-- -------------------------------------------------------------------------- --

--
-- Scripting Values lesen und schreiben.
-- @set sort=true
-- @local
--

Swift.ScriptingValue = {
    SV = {
        Game = "Vanilla",
        Vanilla = {
            Destination = {X = 19, Y= 20},
            Health      = -41,
            Player      = -71,
            Size        = -45,
            Visible     = -50,
            NPC         = 6,
        },
        HistoryEdition = {
            Destination = {X = 17, Y= 18},
            Health      = -38,
            Player      = -68,
            Size        = -42,
            Visible     = -47,
            NPC         = 6,
        }
    }
}

function Swift.ScriptingValue:Initalize()
    if Swift.GameVersion == QSB.GameVersion.HISTORY_EDITION then
        self.SV.Game = "HistoryEdition";
    end
    QSB.ScriptingValue = self.SV[self.SV.Game];
end

function Swift.ScriptingValue:OnSaveGameLoaded()
    -- Porting savegames between game versions
    -- (Not recommended but we try to support it)
    if Swift.GameVersion == QSB.GameVersion.HISTORY_EDITION then
        self.SV.Game = "HistoryEdition";
    end
    QSB.ScriptingValue = self.SV[self.SV.Game];
end

-- -------------------------------------------------------------------------- --
-- Conversion Methods

function Swift.ScriptingValue:BitsInteger(num)
    local t = {};
    while num > 0 do
        rest = math.qmod(num, 2);
        table.insert(t,1,rest);
        num=(num-rest)/2;
    end
    table.remove(t, 1);
    return t;
end

function Swift.ScriptingValue:BitsFraction(num, t)
    for i = 1, 48 do
        num = num * 2;
        if(num >= 1) then
            table.insert(t, 1);
            num = num - 1;
        else
            table.insert(t, 0);
        end
        if(num == 0) then
            return t;
        end
    end
    return t;
end

function Swift.ScriptingValue:IntegerToFloat(num)
    if(num == 0) then
        return 0;
    end
    local sign = 1;
    if (num < 0) then
        num = 2147483648 + num;
        sign = -1;
    end
    local frac = math.qmod(num, 8388608);
    local headPart = (num-frac)/8388608;
    local expNoSign = math.qmod(headPart, 256);
    local exp = expNoSign-127;
    local fraction = 1;
    local fp = 0.5;
    local check = 4194304;
    for i = 23, 0, -1 do
        if (frac - check) > 0 then
            fraction = fraction + fp;
            frac = frac - check;
        end
        check = check / 2;
        fp = fp / 2;
    end
    return fraction * math.pow(2, exp) * sign;
end

function Swift.ScriptingValue:FloatToInteger(fval)
    if(fval == 0) then
        return 0;
    end
    local signed = false;
    if (fval < 0) then
        signed = true;
        fval = fval * -1;
    end
    local outval = 0;
    local bits;
    local exp = 0;
    if fval >= 1 then
        local intPart = math.floor(fval);
        local fracPart = fval - intPart;
        bits = self:BitsInteger(intPart);
        exp = #bits;
        self:BitsFraction(fracPart, bits);
    else
        bits = {};
        self:BitsFraction(fval, bits);
        while(bits[1] == 0) do
            exp = exp - 1;
            table.remove(bits, 1);
        end
        exp = exp - 1;
        table.remove(bits, 1);
    end
    local bitVal = 4194304;
    local start = 1;
    for bpos = start, 23 do
        local bit = bits[bpos];
        if(not bit) then
            break;
        end
        if(bit == 1) then
            outval = outval + bitVal;
        end
        bitVal = bitVal / 2;
    end
    outval = outval + (exp+127)*8388608;
    if(signed) then
        outval = outval - 2147483648;
    end
    return outval;
end

-- -------------------------------------------------------------------------- --
-- API

---
-- Liste der unterstützten Scripting Values.
--
-- <ul>
-- <li><b>QSB.ScriptingValue.Destination.X</b><br>
-- Gibt die Z-Koordinate des Bewegungsziels als Float zurück.</li>
-- <li><b>QSB.ScriptingValue.Destination.Y</b><br>
-- Gibt die Y-Koordinate des Bewegungsziels als Float zurück.</li>
-- <li><b>QSB.ScriptingValue.Health</b><br>
-- Setzt die Gesundheit eines Entity ohne Folgeaktionen zu triggern.</li>
-- <li><b>QSB.ScriptingValue.Player</b><br>
-- Setzt den Besitzer des Entity ohne Plausibelitätsprüfungen.</li>
-- <li><b>QSB.ScriptingValue.Size</b><br>
-- Setzt den Größenfaktor eines Entities als Float.</li>
-- <li><b>QSB.ScriptingValue.Visible</b><br>
-- Sichtbarkeit eines Entities abfragen (801280 == sichtbar)</li>
-- <li><b>QSB.ScriptingValue.NPC</b><br>
-- NPC-Flag eines Siedlers setzen (0 = inaktiv, 1 - 4 = aktiv)</li>
-- </ul>
-- @within ScriptingValue
--
QSB.ScriptingValue = {};

---
-- Gibt den Wert auf dem übergebenen Index für das Entity zurück.
--
-- @param[type=number] _Entity Entity
-- @param[type=number] _SV     Typ der Scripting Value
-- @return[type=number] Ermittelter Wert
-- @within ScriptingValue
--
-- @usage
-- local PlayerID = API.GetInteger("HansWurst", QSB.ScriptingValue.Player);
--
function API.GetInteger(_Entity, _SV)
    local ID = GetID(_Entity);
    if not IsExisting(ID) then
        return;
    end
    return Logic.GetEntityScriptingValue(ID, _SV);
end

---
-- Gibt den Wert auf dem übergebenen Index für das Entity zurück.
--
-- @param[type=number] _Entity Entity
-- @param[type=number] _SV     Typ der Scripting Value
-- @return[type=number] Ermittelter Wert
-- @within ScriptingValue
--
-- @usage
-- local Size = API.GetFloat("HansWurst", QSB.ScriptingValue.Size);
--
function API.GetFloat(_Entity, _SV)
    local ID = GetID(_Entity);
    if not IsExisting(ID) then
        return;
    end
    local Value = Logic.GetEntityScriptingValue(ID, _SV);
    return API.ConvertIntegerToFloat(Value);
end

---
-- Setzt den Wert auf dem übergebenen Index für das Entity.
-- 
-- @param[type=number] _Entity Entity
-- @param[type=number] _SV     Typ der Scripting Value
-- @param[type=number] _Value  Zu setzender Wert
-- @within ScriptingValue
--
-- @usage
-- API.SetInteger("HansWurst", QSB.ScriptingValue.Player, 2);
--
function API.SetInteger(_Entity, _SV, _Value)
    local ID = GetID(_Entity);
    if GUI or not IsExisting(ID) then
        return;
    end
    Logic.SetEntityScriptingValue(ID, _SV, _Value);
end

---
-- Setzt den Wert auf dem übergebenen Index für das Entity.
--
-- @param[type=number] _Entity Entity
-- @param[type=number] _SV     Typ der Scripting Value
-- @param[type=number] _Value  Zu setzender Wert
-- @within ScriptingValue
--
-- @usage
-- API.SetFloat("HansWurst", QSB.ScriptingValue.Size, 1.5);
--
function API.SetFloat(_Entity, _SV, _Value)
    local ID = GetID(_Entity);
    if GUI or not IsExisting(ID) then
        return;
    end
    Logic.SetEntityScriptingValue(ID, _SV, API.ConvertFloatToInteger(_Value));
end

---
-- Konvertirert den Wert in eine Ganzzahl.
--
-- @param[type=number] _Value Gleitkommazahl
-- @return[type=number] Konvertierte Ganzzahl
-- @within ScriptingValue
--
-- @usage
-- local Converted = API.ConvertIntegerToFloat(Value)
--
function API.ConvertIntegerToFloat(_Value)
    return Swift.ScriptingValue:IntegerToFloat(_Value);
end

---
-- Konvertirert den Wert in eine Gleitkommazahl.
--
-- @param[type=number] _Value Gleitkommazahl
-- @return[type=number] Konvertierte Ganzzahl
-- @within ScriptingValue
--
-- @usage
-- local Converted = API.ConvertFloatToInteger(Value)
--
function API.ConvertFloatToInteger(_Value)
    return Swift.ScriptingValue:FloatToInteger(_Value);
end
