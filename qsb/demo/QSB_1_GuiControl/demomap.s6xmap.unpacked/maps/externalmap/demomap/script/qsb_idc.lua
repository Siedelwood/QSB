--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

API = {};
SCP = {Core = {}};

QSB = {};
QSB.Version = "3.0.0 (BETA 2.0.0)";

-- Its not vanity, its a placeholder. The QSB table is not supposed to hold
-- objects anymore. Only constants are allowed. So we need another table.
TWA = TWA or {};

---
-- Stellt wichtige Kernfunktionen bereit.
--
-- <h5>Behobene Fehler</h5>
--
-- Die QSB kommt mit einigen Bugfixes mit, die Fehler im Spiel beheben.
--
-- <ul>
-- <li>NPC-Lagerhäuser können jetzt Salz und Farbe einlagern.</li>
-- <li>Die NPC-Kasernen von Mitteleuropa respawnen jetzt Soldaten.</li>
-- <li>Werden Waren im Zuge eines Quests gesandt, wird bei den Zielgebäuden von
-- der Position des Eingangs ausgegangen anstatt von der Gebäudemitte. Dadurch
-- schlagen Lieferungen bei bestimmten Lagerhäusern nicht mehr fehl.</li>
-- <li>Bei interaktiven Objekten können jetzt auch nur zwei Rohstoffe anstatt
-- von Gold und einem Rohstoff als Kosten benutzt werden.</li>
-- <li>Spezielle Script Entities werden bei Goal_DestroyAllPlayerUnids nicht
-- mehr fälschlich mitgezählt.</li>
-- </ul>
--
-- <h5>Platzhalter</h5>
--
-- <u>Mehrsprachige Texte:</u><br>
-- Anstatt eines Strings wird ein Table mit dem gleichen Text in verschiedenen
-- Sprachen angegeben. Der richtige Text wird anhand der eingestellten Sprache
-- gewählt. Wenn nichts vorgegeben wird, ist die Systemsprache voreingestellt.
-- Als Standard für nichtdeutsche Sprachen wird Englisch verwendet, wenn für
-- die Sprache selbst kein Text vorhanden ist. Es muss also immer wenigstens
-- English (en) und Deutsch (de) vorhanden sein. <br>
-- Einige Features lokalisieren Texte automatisch. <br>
-- (Siehe dazu: <a href="#API.Localize">API.Localize</a>)
--
-- <u>Platzhalter in Texten:</u><br>
-- In Texten können vordefinierte Farben, Namen für Entity-Typen und benannte
-- Entities, sowie Inhalte von Variablen ersetzt werden. Dies wird von einigen
-- QSB-Features automatisch vorgenommen. Es kann Mittels API-Funktion auch
-- manuell angestoßen werden. <br>
-- (Siehe dazu: <a href="#API.ConvertPlaceholders">API.ConvertPlaceholders</a>)
--
-- <h5>Scripting Values</h5>
-- Bei den Scripting Values handelt es sich um einige Werte, die direkt im
-- Arbeitsspeicher manipuliert werden können und Auswirkungen auf Entities
-- haben.<br>
-- (Siehe dazu: <a href="#ScriptingValue">QSB.ScriptingValue</a>)
--
-- <h5>Entwicklungsmodus</h5>
--
-- Die QSB kann verschiedene Optionen zum schnelleren Testen und finden von
-- fehlern aktivieren. <br>
-- (Siehe dazu: <a href="#API.ActivateDebugMode">API.ActivateDebugMode</a>)
--
-- <b>Befehle:</b><br>
-- <i>Diese Befehle können über die Konsole (SHIFT + ^) eingegeben werden, wenn
-- der Debug Mode aktiviert ist.</i><br>
-- <table border="1">
-- <tr>
-- <td><b>Befehl</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>restartmap</td>
-- <td>Map sofort neu starten</td>
-- </tr>
-- <tr>
-- <td>&gt; Befehl</td>
-- <td>Einen Lua Befehl im globalen Skript ausführen.
-- (Die Zeichen " ' { } können nicht verwendet werden)</td>
-- </tr>
-- <tr>
-- <td>&gt;&gt; Befehl</td>
-- <td>Einen Lua Befehl im lokalen Skript ausführen.
-- (Die Zeichen " ' { } können nicht verwendet werden)</td>
-- </tr>
-- <tr>
-- <td>&lt; Pfad</td>
-- <td>Lua-Datei zur Laufzeit ins globale Skript laden.
-- (Es muss / anstatt \ verwendet werden)</td>
-- </tr>
-- <tr>
-- <td>&lt;&lt; Pfad</td>
-- <td>Lua-Datei zur Laufzeit ins lokale Skript laden.
-- (Es muss / anstatt \ verwendet werden)</td>
-- </tr>
-- </table>
--
-- <b>Cheats:</b><br>
-- <i>Bei aktivierten Debug Mode können diese Cheat Codes verwendet werden.</i><br>
-- <table border="1">
-- <tr>
-- <td><b>Cheat</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>SHIFT + ^</td>
-- <td>Konsole öffnen</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + ALT + R</td>
-- <td>Map sofort neu starten.</td>
-- </tr>
-- <td>CTRL + C</td>
-- <td>Zeitanzeige an/aus</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + A</td>
-- <td>Clutter (Gräser) anzeigen (an/aus)</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + C</td>
-- <td>Grasobjekte anzeigen (an/aus)</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + E</td>
-- <td>Laubbäume anzeigen (an/aus)</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + F</td>
-- <td>FoW anzeigen (an/aus) <i>Gebiete werden dauerhaft erkundet!</i></td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + G</td>
-- <td>GUI anzeigen (an/aus)</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + H</td>
-- <td>Steine und Tannen anzeigen (an/aus)</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + R</td>
-- <td>Straßen anzeigen (an/aus)</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + S</td>
-- <td>Schatten anzeigen (an/aus)</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + T</td>
-- <td>Boden anzeigen (an/aus)</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + U</td>
-- <td>FoW anzeigen (an/aus)</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + W</td>
-- <td>Wasser anzeigen (an/aus)</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + X</td>
-- <td>Render Mode des Wassers umschalten (Einfach und komplex)</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + Y</td>
-- <td>Himmel anzeigen (an/aus)</td>
-- </tr>
-- <tr>
-- <td>ALT + F10</td>
-- <td>Selektiertes Gebäude anzünden</td>
-- </tr>
-- <tr>
-- <td>ALT + F11</td>
-- <td>Selektierte Einheit verwunden</td>
-- </tr>
-- <tr>
-- <td>ALT + F12</td>
-- <td>Alle Rechte freigeben / wieder sperren</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + 1</td>
-- <td>FPS-Anzeige</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 4</td>
-- <td>Bogenschützen unter der Maus spawnen</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 5</td>
-- <td>Schwertkämpfer unter der Maus spawnen</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 6</td>
-- <td>Katapultkarren unter der Maus spawnen</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 7</td>
-- <td>Ramme unter der Maus spawnen</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 8</td>
-- <td>Belagerungsturm unter der Maus spawnen</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 9</td>
-- <td>Katapult unter der Maus spawnen</td>
-- </tr>
-- <tr>
-- <td>(Num) +</td>
-- <td>Spiel beschleunigen</td>
-- </tr>
-- <tr>
-- <td>(Num) -</td>
-- <td>Spiel verlangsamen</td>
-- </tr>
-- <tr>
-- <td>(Num) *</td>
-- <td>Geschwindigkeit zurücksetzen</td>
-- </tr>
-- <tr>
-- <td>CTRL + F1</td>
-- <td>+ 50 Gold</td>
-- </tr>
-- <tr>
-- <td>CTRL + F2</td>
-- <td>+ 10 Holz</td>
-- </tr>
-- <tr>
-- <td>CTRL + F3</td>
-- <td>+ 10 Stein</td>
-- </tr>
-- <tr>
-- <td>CTRL + F4</td>
-- <td>+ 10 Getreide</td>
-- </tr>
-- <tr>
-- <td>CTRL + F5</td>
-- <td>+ 10 Milch</td>
-- </tr>
-- <tr>
-- <td>CTRL + F6</td>
-- <td>+ 10 Kräuter</td>
-- </tr>
-- <tr>
-- <td>CTRL + F7</td>
-- <td>+ 10 Wolle</td>
-- </tr>
-- <tr>
-- <td>CTRL + F8</td>
-- <td>+ 10 auf alle Waren</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F1</td>
-- <td>+ 10 Honig</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F2</td>
-- <td>+ 10 Eisen</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F3</td>
-- <td>+ 10 Fisch</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F4</td>
-- <td>+ 10 Wild</td>
-- </tr>
-- <tr>
-- <td>ALT + F5</td>
-- <td>Bedürfnis nach Nahrung in Gebäude aktivieren</td>
-- </tr>
-- <tr>
-- <td>ALT + F6</td>
-- <td>Bedürfnis nach Kleidung in Gebäude aktivieren</td>
-- </tr>
-- <tr>
-- <td>ALT + F7</td>
-- <td>Bedürfnis nach Hygiene in Gebäude aktivieren</td>
-- </tr>
-- <tr>
-- <td>ALT + F8</td>
-- <td>Bedürfnis nach Unterhaltung in Gebäude aktivieren</td>
-- </tr>
-- <tr>
-- <td>CTRL + F9</td>
-- <td>Nahrung für selektiertes Gebäude erhöhen</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F9</td>
-- <td>Nahrung für selektiertes Gebäude verringern</td>
-- </tr>
-- <tr>
-- <td>CTRL + F10</td>
-- <td>Kleidung für selektiertes Gebäude erhöhen</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F10</td>
-- <td>Kleidung für selektiertes Gebäude verringern</td>
-- </tr>
-- <tr>
-- <td>CTRL + F11</td>
-- <td>Hygiene für selektiertes Gebäude erhöhen</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F11</td>
-- <td>Hygiene für selektiertes Gebäude verringern</td>
-- </tr>
-- <tr>
-- <td>CTRL + F12</td>
-- <td>Unterhaltung für selektiertes Gebäude erhöhen</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F12</td>
-- <td>Unterhaltung für selektiertes Gebäude verringern</td>
-- </tr>
-- <tr>
-- <td>ALT + CTRL + F10</td>
-- <td>Einnahmen des selektierten Gebäudes erhöhen</td>
-- </tr>
-- <tr>
-- <td>ALT + (Num) 1</td>
-- <td>Burg selektiert → Gold verringern, Werkstatt selektiert → Ware verringern</td>
-- </tr>
-- <tr>
-- <td>ALT + (Num) 2</td>
-- <td>Burg selektiert → Gold erhöhen, Werkstatt selektiert → Ware erhöhen</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 1</td>
-- <td>Kontrolle über Spieler 1</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 2</td>
-- <td>Kontrolle über Spieler 2</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 3</td>
-- <td>Kontrolle über Spieler 3</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 4</td>
-- <td>Kontrolle über Spieler 4</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 5</td>
-- <td>Kontrolle über Spieler 5</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 6</td>
-- <td>Kontrolle über Spieler 6</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 7</td>
-- <td>Kontrolle über Spieler 7</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 8</td>
-- <td>Kontrolle über Spieler 8</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 0</td>
-- <td>Kamera durchschalten</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 1</td>
-- <td>Kamerasprünge im RTS-Mode</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + V</td>
-- <td>Territorien anzeigen</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + B</td>
-- <td>Blocking anzeigen</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + N</td>
-- <td>Gitter verstecken</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + F9</td>
-- <td>DEBUG-Ausgabe einschalten</td>
-- </tr>
-- <tr>
-- <td>ALT + F9</td>
-- <td>Zufälligen Arbeiter verheiraten</td>
-- </tr>
-- </table>
--
-- @set sort=true
-- @within Beschreibung
--

ParameterType = ParameterType or {};
g_QuestBehaviorVersion = 1;
g_QuestBehaviorTypes = {};

g_GameExtraNo = 0;
if Framework then
    g_GameExtraNo = Framework.GetGameExtraNo();
elseif MapEditor then
    g_GameExtraNo = MapEditor.GetGameExtraNo();
end

---
-- Events, um auf Ereignisse zu reagieren.
--
-- <h5>Was sind Script Events</h5>
--
-- Um dem Mapper das (z.T. fehlerbehaftete) Überschreiben von Game Callbacks
-- oder anlegen von (echten) Triggern zu ersparen, wurden die Script Events
-- eingeführt. Sie vereinheitlichen alle diese Operationen. Ein Event kann
-- von einem Modul oder in den Skripten des Anwenders über einen Event Listener
-- oder ein spezielles Game Callback gefangen werden.
--
-- Ein Event zu fangen bedeutet auf ein eingetretenes Ereignis - z.B. Wenn ein
-- Spielstand geladen wurde - zu reagieren. Events werden immer sowohl im
-- globalen als auch lokalen Skript ausgelöst, wenn ein entsprechendes Ereignis
-- aufgetreten ist, anstatt vieler Callbacks, die auf eine spezifische Umgebung
-- beschränkt sind.
--
-- Module bringen manchmal Events mit. Jedes Modul, welches ein neues Event
-- einführt, wird es in seiner API-Beschreibung aufgführen.
--
-- <u>Script Events, die von der QSB direkt bereitgestellt werden:</u>
--
-- @field ChatOpened       Das Chatfenster wird angezeigt (Parameter: PlayerID)
-- @field ChatClosed       Die Chateingabe wird bestätigt (Parameter: Text, PlayerID)
-- @field LanguageSet      Die Sprache wurde geändert (Parameter: OldLanguage, NewLanguage)
-- @field QuestFailure     Ein Quest schlug fehl (Parameter: QuestID)
-- @field QuestInterrupt   Ein Quest wurde unterbrochen (Parameter: QuestID)
-- @field QuestReset       Ein Quest wurde zurückgesetzt (Parameter: QuestID)
-- @field QuestSuccess     Ein Quest wurde erfolgreich abgeschlossen (Parameter: QuestID)
-- @field QuestTrigger     Ein Quest wurde aktiviert (Parameter: QuestID)
-- @field LoadscreenClosed Der Ladebildschirm wurde beendet.
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Konstanten der Script Environments
-- @field GLOBAL Die globale Skriptumgebung
-- @field LOCAL  Die lokale Skriptumgebung
-- @within Konstanten
--
QSB.Environment = {
    GLOBAL = 1,
    LOCAL  = 2,
}

---
-- Konstanten der Spielversionen
-- @field ORIGINAL        Das Originalspiel
-- @field HISTORY_EDITION Die History Edition
-- @within Konstanten
--
QSB.GameVersion = {
    ORIGINAL        = 1,
    HISTORY_EDITION = 2,
}

---
-- Konstanten der Spielvarianten
-- @field VANILLA   Das unmodifizierte Spiel
-- @field COMMUNITY Der Community Patch
-- @within Konstanten
--
QSB.GameVariant = {
    VANILLA   = 1,
    COMMUNITY = 2,
}

-- -------------------------------------------------------------------------- --

Swift = {
    ModuleRegister = {},
    BehaviorRegister = {},
};

function Swift:LoadKernel()
    self.Environment = (GUI and QSB.Environment.LOCAL) or QSB.Environment.GLOBAL;
    self.GameVersion = (Network.IsNATReady and QSB.GameVersion.HISTORY_EDITION) or QSB.GameVersion.ORIGINAL;
    self.GameVariant = (Entities.U_PolarBear and QSB.GameVariant.COMMUNITY) or QSB.GameVariant.VANILLA;

    self.LuaBase:Initalize();
    self.Logging:Initalize();
    self.Job:Initalize();
    self.Event:Initalize();
    self.Save:Initalize();
    self.Chat:Initalize();
    self.Text:Initalize();
    self.Bugfix:Initalize();
    self.ScriptingValue:Initalize();
    self.Utils:Initalize();
    self.Quest:Initalize();
    self.Debug:Initalize();
    self.Behavior:Initalize();

    self:SetupSaveGameHandler();
    self:SetupEscapeHandler();
    self:SetupLoadscreenHandler();
    self:SetupQsbLoadedHandler();
    self:SetupRandomSeedHandler();

    self:LoadExternFiles();
    self:LoadBehaviors();
end

-- -------------------------------------------------------------------------- --
-- File Loading

function Swift:LoadExternFiles()
    if Mission_LoadFiles then
        local FilesList = Mission_LoadFiles();
        for i= 1, #FilesList, 1 do
            if type(FilesList[i]) == "function" then
                FilesList[i]();
            else
                Script.Load(FilesList[i]);
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Multiplayer

function Swift:SetupRandomSeedHandler()
    if self.Environment == QSB.Environment.GLOBAL then
        Swift.Event:CreateScriptCommand("Cmd_ProclaimateRandomSeed", function(_Seed)
            if Swift.MP_Seed_Set then
                return;
            end
            Swift.MP_Seed_Set = true;
            math.randomseed(_Seed);
            local void = math.random(1, 100);
            Logic.ExecuteInLuaLocalState(string.format(
                [[math.randomseed(%d); math.random(1, 100);]],
                _Seed
            ));
            info("Created seed: " .._Seed);
        end);
    end
end

function Swift:CreateRandomSeed()
    for PlayerID = 1, 8 do
        -- Find first human player to generate random seed
        if Logic.PlayerGetIsHumanFlag(PlayerID) and Logic.PlayerGetGameState(PlayerID) ~= 0 then
            -- If the player ID of the local client matches the ID of the first
            -- human player create the seed and broadcast it to all players
            if GUI.GetPlayerID() == PlayerID then
                local Seed = self:BuildRandomSeed(PlayerID);
                if Framework.IsNetworkGame() then
                    Swift.Event:DispatchScriptCommand(QSB.ScriptCommands.ProclaimateRandomSeed, 0, Seed);
                else
                    math.randomseed(Seed);
                    math.random(1, 100);
                    GUI.SendScriptCommand(string.format(
                        [[math.randomseed(%d); math.random(1, 100);]],
                        Seed
                    ));
                end
            end
            break;
        end
    end
end

function Swift:BuildRandomSeed(_PlayerID)
    local PlayerName = Logic.GetPlayerName(_PlayerID);
    local MapName = Framework.GetCurrentMapName();
    local MapType = Framework.GetCurrentMapTypeAndCampaignName();
    local SeedString = Framework.GetMapGUID(MapName, MapType);
    local DateText = Framework.GetSystemTimeDateString();
    SeedString = SeedString .. PlayerName .. " " .. DateText;
    local Seed = 0;
    for s in SeedString:gmatch(".") do
        Seed = Seed + ((tonumber(s) ~= nil and tonumber(s)) or s:byte());
    end
    return Seed;
end

-- -------------------------------------------------------------------------- --
-- Save Game

function Swift:SetupQsbLoadedHandler()
    if self.Environment == QSB.Environment.GLOBAL then
        Swift.Event:CreateScriptCommand("Cmd_GlobalQsbLoaded", function()
            if Mission_MP_OnQsbLoaded and not Swift.MP_FMA_Loaded and Framework.IsNetworkGame() then
                Logic.ExecuteInLuaLocalState([[
                    if Mission_MP_LocalOnQsbLoaded then
                        Mission_MP_LocalOnQsbLoaded();
                    end
                ]]);
                Swift.MP_FMA_Loaded = true;
                Mission_MP_OnQsbLoaded();
            end
        end);
    end
end

function Swift:SetupSaveGameHandler()
    QSB.ScriptEvents.SaveGameLoaded = self.Event:CreateScriptEvent("Event_SaveGameLoaded");

    if self.Environment == QSB.Environment.GLOBAL then
        Mission_OnSaveGameLoaded_Orig_Swift = Mission_OnSaveGameLoaded;
        Mission_OnSaveGameLoaded = function()
            Mission_OnSaveGameLoaded_Orig_Swift();
            Swift:OnSaveGameLoaded();
        end
    end
end

function Swift:OnSaveGameLoaded()
    -- Trigger in local script
    if self.Environment == QSB.Environment.GLOBAL then
        Logic.ExecuteInLuaLocalState("Swift:OnSaveGameLoaded()");
    end
    -- Call shared
    self.LuaBase:OnSaveGameLoaded();
    self.Logging:OnSaveGameLoaded();
    self.Job:OnSaveGameLoaded();
    self.Event:OnSaveGameLoaded();
    self.Save:OnSaveGameLoaded();
    self.Chat:OnSaveGameLoaded();
    self.Text:OnSaveGameLoaded();
    self.Bugfix:OnSaveGameLoaded();
    self.ScriptingValue:OnSaveGameLoaded();
    self.Utils:OnSaveGameLoaded();
    self.Quest:OnSaveGameLoaded();
    self.Debug:OnSaveGameLoaded();
    self.Behavior:OnSaveGameLoaded();
    -- Call local
    if self.Environment == QSB.Environment.LOCAL then
        self:SetEscapeKeyTrigger();
        self:CreateRandomSeed();
    end
    -- Send event
    self.Event:DispatchScriptEvent(QSB.ScriptEvents.SaveGameLoaded);
end

-- -------------------------------------------------------------------------- --
-- Module Registration

function Swift:LoadModules()
    for i= 1, #self.ModuleRegister, 1 do
        if self.Environment == QSB.Environment.GLOBAL then
            self.ModuleRegister[i].Local = nil;
            if self.ModuleRegister[i].Global.OnGameStart then
                self.ModuleRegister[i].Global:OnGameStart();
            end
        end
        if self.Environment == QSB.Environment.LOCAL then
            self.ModuleRegister[i].Global = nil;
            if self.ModuleRegister[i].Local.OnGameStart then
                self.ModuleRegister[i].Local:OnGameStart();
            end
        end
    end
end

function Swift:RegisterModule(_Module)
    if (type(_Module) ~= "table") then
        assert(false, "Modules must be tables!");
        return;
    end
    if _Module.Properties == nil or _Module.Properties.Name == nil then
        assert(false, "Expected name for Module!");
        return;
    end
    table.insert(self.ModuleRegister, _Module);
end

function Swift:IsModuleRegistered(_Name)
    for k, v in pairs(self.ModuleRegister) do
        return v.Properties and v.Properties.Name == _Name;
    end
end

-- -------------------------------------------------------------------------- --
-- Behavior Registration

function Swift:LoadBehaviors()
    for i= 1, #self.BehaviorRegister, 1 do
        local Behavior = self.BehaviorRegister[i];

        if not _G["B_" .. Behavior.Name].new then
            _G["B_" .. Behavior.Name].new = function(self, ...)
                local arg = {...};
                local behavior = table.copy(self);
                -- Raw parameters
                behavior.i47ya_6aghw_frxil = {};
                -- Overhead parameters
                behavior.v12ya_gg56h_al125 = {};
                for i= 1, #arg, 1 do
                    table.insert(behavior.v12ya_gg56h_al125, arg[i]);
                    if self.Parameter and self.Parameter[i] ~= nil then
                        behavior:AddParameter(i-1, arg[i]);
                    else
                        table.insert(behavior.i47ya_6aghw_frxil, arg[i]);
                    end
                end
                return behavior;
            end
        end
    end
end

function Swift:RegisterBehavior(_Behavior)
    if self.Environment == QSB.Environment.LOCAL then
        return;
    end
    if type(_Behavior) ~= "table" or _Behavior.Name == nil then
        assert(false, "Behavior is invalid!");
        return;
    end
    if _Behavior.RequiresExtraNo and _Behavior.RequiresExtraNo > g_GameExtraNo then
        return;
    end
    if not _G["B_" .. _Behavior.Name] then
        error(string.format("Behavior %s does not exist!", _Behavior.Name));
        return;
    end

    for i= 1, #g_QuestBehaviorTypes, 1 do
        if g_QuestBehaviorTypes[i].Name == _Behavior.Name then
            return;
        end
    end
    table.insert(g_QuestBehaviorTypes, _Behavior);
    table.insert(self.BehaviorRegister, _Behavior);
end

-- -------------------------------------------------------------------------- --
-- Escape Capture

function Swift:SetupEscapeHandler()
    QSB.ScriptEvents.EscapePressed = self.Event:CreateScriptEvent("Event_EscapePressed");
    if self.Environment == QSB.Environment.LOCAL then
        self:SetEscapeKeyTrigger();
    end
end

function Swift:SetEscapeKeyTrigger()
    Input.KeyBindDown(Keys.Escape, "Swift:OnPlayerPressedEscape()", 30, false);
end

function Swift:OnPlayerPressedEscape()
    -- Global
    Swift.Event:DispatchScriptCommand(
        QSB.ScriptCommands.SendScriptEvent,
        0,
        "EscapePressed",
        GUI.GetPlayerID()
    );
    -- Local
    Swift.Event:DispatchScriptCommand(QSB.ScriptEvents.EscapePressed, 0, GUI.GetPlayerID());
end

-- -------------------------------------------------------------------------- --
-- Loadscreen

function Swift:SetupLoadscreenHandler()
    -- Send the event as command to the global script
    QSB.ScriptEvents.LoadscreenClosed = self.Event:CreateScriptEvent("Event_LoadscreenClosed");
    if self.Environment == QSB.Environment.GLOBAL then
        self.Event:CreateScriptCommand(
            "Cmd_RegisterLoadscreenHidden",
            function()
                API.SendScriptEvent(QSB.ScriptEvents.LoadscreenClosed);
                Logic.ExecuteInLuaLocalState([[
                    API.SendScriptEvent(QSB.ScriptEvents.LoadscreenClosed);
                    XGUIEng.PopPage();
                ]]);
            end
        );
        return;
    end

    -- Job for when the button can't be clicked
    -- (When the map is restarted. This should only happen in debug.)
    self.LoadscreenWatchJobID = self.Job:CreateEventJob(
        Events.LOGIC_EVENT_EVERY_TURN,
        function()
            if XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 0 then
                Swift.Event:DispatchScriptCommand(
                    QSB.ScriptCommands.RegisterLoadscreenHidden,
                    GUI.GetPlayerID()
                );
                return true;
            end
        end
    );

    -- Overwrite the loadscreen button
    HideLoadScreen_Orig_Swift = HideLoadScreen;
    HideLoadScreen = function()
        HideLoadScreen_Orig_Swift();
        XGUIEng.PushPage("/LoadScreen/LoadScreen", true);
        XGUIEng.ShowWidget("/LoadScreen/LoadScreen/ButtonStart", 0);
        EndJob(self.LoadscreenWatchJobID);
        Swift.Event:DispatchScriptCommand(
            QSB.ScriptCommands.RegisterLoadscreenHidden,
            GUI.GetPlayerID()
        );
    end
end

-- -------------------------------------------------------------------------- --
-- API

---
-- Installiert Swift.
--
-- @within Base
-- @local
--
function API.Install()
    Swift:LoadKernel();
    Swift:LoadModules();
    collectgarbage("collect");
end

---
-- Gibt die Version des Spiels zurück.
--
-- <b>Hinweis</b>: Unter der Version wird verstanden, ob das Originalspiel
-- oder die History Edition gespielt wird. Zwischen den einzelnen Patches
-- des Originalspiels oder der History Edition wird nicht unterschieden. Es
-- wird die aktuellste Version vorausgesetzt.
--
-- @return[type=boolean] Spiel ist History Edition
-- @within System
-- @see QSB.GameVersion
--
function API.GetGameVersion()
    return Swift.GameVersion;
end

---
-- Gibt die Variante des Spiels zurück.
--
-- <b>Hinweis</b>: Unter der Variante wird verstanden, ob das unveränderte
-- Spiel oder der Community Patch gespielt wird.
--
-- @return[type=boolean] Spiel ist History Edition
-- @within System
-- @see QSB.GameVariant
--
function API.GetGameVariant()
    return Swift.GameVariant;
end

---
-- Gibt die Skriptumgebung zurück.
--
-- <b>Hinweis</b>: Unter dem Environment wird verstanden, ob es sich um das
-- globale oder das lokale Skript handelt.
--
-- @return[type=boolean] Spiel ist History Edition
-- @within System
-- @see QSB.Environment
--
function API.GetScriptEnvironment()
    return Swift.Environment;
end

---
-- Prüft, ob das laufende Spiel eine Multiplayerpartie in der History Edition
-- ist.
--
-- <b>Hinweis</b>: Es ist unmöglich, dass Original und History Edition in einer
-- Partie aufeinander treffen, da die alten Server längst abgeschaltet und die
-- Option zum LAN-Spiel in der HE nicht verfügbar ist.
--
-- @return[type=boolean] Spiel ist History Edition
-- @within System
--
function API.IsHistoryEditionNetworkGame()
    return API.GetGameVersion() == QSB.GameVersion.HISTORY_EDITION and Framework.IsNetworkGame();
end

---
-- Gibt den Slot zurück, den der Spieler einnimmt. Hat der Spieler keinen
-- Slot okkupiert oder ist nicht menschlich, wird -1 zurückgegeben.
--
-- <h5>Multiplayer</h5>
-- Nur für Multiplayer ausgelegt! Nicht im Singleplayer nutzen!
--
-- @return[type=number] ID des Player
-- @return[type=number] Slot ID des Player
-- @within Multiplayer
--
function API.GetPlayerSlotID(_PlayerID)
    for i= 1, 8 do
        if Network.IsNetworkSlotIDUsed(i) then
            local CurrentPlayerID = Logic.GetSlotPlayerID(i);
            if  Logic.PlayerGetIsHumanFlag(CurrentPlayerID)
            and CurrentPlayerID == _PlayerID then
                return i;
            end
        end
    end
    return -1;
end

---
-- Gibt den Spieler zurück, welcher den Slot okkupiert. Hat der Slot keinen
-- Spieler oder ist der Spieler nicht menschlich, wird -1 zurückgegeben.
--
-- <h5>Multiplayer</h5>
-- Nur für Multiplayer ausgelegt! Nicht im Singleplayer nutzen!
--
-- @return[type=number] Slot ID des Player
-- @return[type=number] ID des Player
-- @within Multiplayer
--
function API.GetSlotPlayerID(_SlotID)
    if Network.IsNetworkSlotIDUsed(_SlotID) then
        local CurrentPlayerID = Logic.GetSlotPlayerID(_SlotID);
        if Logic.PlayerGetIsHumanFlag(CurrentPlayerID)  then
            return CurrentPlayerID;
        end
    end
    return -1;
end

---
-- Gibt eine Liste aller Spieler im Spiel zurück.
--
-- <h5>Multiplayer</h5>
-- Nur für Multiplayer ausgelegt! Nicht im Singleplayer nutzen!
--
-- @return[type=table] Liste der aktiven Spieler
-- @within Multiplayer
--
function API.GetActivePlayers()
    local PlayerList = {};
    for i= 1, 8 do
        if Network.IsNetworkSlotIDUsed(i) then
            local PlayerID = Logic.GetSlotPlayerID(i);
            if Logic.PlayerGetIsHumanFlag(PlayerID) and Logic.PlayerGetGameState(PlayerID) ~= 0 then
                table.insert(PlayerList, PlayerID);
            end
        end
    end
    return PlayerList;
end

---
-- Gibt alle Spieler zurück, auf die gerade gewartet wird.
--
-- <h5>Multiplayer</h5>
-- Nur für Multiplayer ausgelegt! Nicht im Singleplayer nutzen!
--
-- @return[type=table] Liste der aktiven Spieler
-- @within Multiplayer
--
function API.GetDelayedPlayers()
    local PlayerList = {};
    for k, v in pairs(API.GetActivePlayers()) do
        if Network.IsWaitingForNetworkSlotID(API.GetPlayerSlotID(v)) then
            table.insert(PlayerList, v);
        end
    end
    return PlayerList;
end

---
-- Gibt zurück, ob die Sitzung geladen wurde.
--
-- <h5>Multiplayer</h5>
-- Nur für Multiplayer ausgelegt! Nicht im Singleplayer nutzen!
--
-- @return[type=boolean] Sitzung ist geladen
-- @within Multiplayer
--
function API.IsMultiplayerLoaded()
    return Framework.IsNetworkGame() and  Network.SessionHaveAllPlayersFinishedLoading() == true;
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Erweitert die Lua-Basisfunktionen um weitere Funktionen.
-- @set sort=true
-- @local
--

Swift.LuaBase = {};

QSB.Metatable = {Init = false, Weak = {}, Metas = {}, Key = 0};

function Swift.LuaBase:Initalize()
    self:OverrideTable();
    self:OverrideString();
    self:OverrideMath();
end

function Swift.LuaBase:OnSaveGameLoaded()
    self:OverrideTable();
    self:OverrideString();
    self:OverrideMath();
end

function Swift.LuaBase:OverrideTable()
    table.compare = function(t1, t2, fx)
        assert(type(t1) == "table");
        assert(type(t2) == "table");
        fx = fx or function(t1, t2)
            return tostring(t1) < tostring(t2);
        end
        assert(type(fx) == "function");
        return fx(t1, t2);
    end

    table.equals = function(t1, t2)
        assert(type(t1) == "table");
        assert(type(t2) == "table");
        for k, v in pairs(t1) do
            if type(v) == "table" then
                if not t2[k] or not table.equals(t2[k], v) then
                    return false;
                end
            elseif type(v) ~= "thread" and type(v) ~= "userdata" then
                if not t2[k] or t2[k] ~= v then
                    return false;
                end
            end
        end
        return true;
    end

    table.contains = function (t, e)
        assert(type(t) == "table");
        for k, v in pairs(t) do
            if v == e then
                return true;
            end
        end
        return false;
    end

    table.length = function(t)
        local c = 0;
        for k, v in pairs(t) do
            if tonumber(k) then
                c = c +1;
            end
        end
        return c;
    end

    table.size = function(t)
        local c = 0;
        for k, v in pairs(t) do
            -- Ignore n if set
            if k ~= "n" or (k == "n" and type(v) ~= "number") then
                c = c +1;
            end
        end
        return c;
    end

    table.isEmpty = function(t)
        return table.size(t) == 0;
    end

    table.copy = function (t1, t2)
        t2 = t2 or {};
        assert(type(t1) == "table");
        assert(type(t2) == "table");
        return Swift.LuaBase:CopyTable(t1, t2);
    end

    table.invert = function (t1)
        assert(type(t1) == "table");
        local t2 = {};
        for i= table.length(t1), 1, -1 do
            table.insert(t2, t1[i]);
        end
        return t2;
    end

    table.push = function (t, e)
        assert(type(t) == "table");
        table.insert(t, 1, e);
    end

    table.pop = function (t)
        assert(type(t) == "table");
        return table.remove(t, 1);
    end

    table.tostring = function(t)
        return Swift.LuaBase:ConvertTableToString(t);
    end

    -- FIXME: Does not work?
    table.insertAll = function(t, ...)
        for i= 1, #arg do
            if not table.contains(t, arg[i]) then
                table.insert(t, arg[i]);
            end
        end
        return t;
    end

    -- FIXME: Does not work?
    table.removeAll = function(t, ...)
        for i= 1, #arg do
            for k, v in pairs(t) do
                if type(v) == "table" and type(arg[i]) then
                    if table.equals(v, arg[i]) then
                        t[k] = nil;
                    end
                else
                    if v == arg[i] then
                        t[k] = nil;
                    end
                end
            end
        end
        -- Set n as table remove would do
        t.n = table.length(t);
        return t;
    end

    table.setMetatable = function(t, meta)
        assert(type(t) == "table");
        assert(type(meta) == "table" or meta == nil);

        local oldmeta = meta;
        meta = {};
        for k,v in pairs(oldmeta) do
            meta[k] = v;
        end
        oldmeta = getmetatable(t);
        setmetatable(t, meta);
        local k = 0;
        if oldmeta and oldmeta.KeySave and t == QSB.Metatable.Weak[oldmeta.KeySave] then
            k = oldmeta.KeySave;
            if meta == nil then
                QSB.Metatable.Weak[k] = nil;
                QSB.Metatablele.Metas[k] = nil;
                return;
            end
        else
            k = QSB.Metatable.Key + 1;
            QSB.Metatable.Key = k;
        end
        QSB.Metatable.Weak[k] = t;
        QSB.Metatable.Metas[k] = meta;
        meta.KeySave = k;
    end

    table.restoreMetatables = function()
        for k, tab in pairs(QSB.Metatable.Weak) do
            setmetatable(tab, QSB.Metatable.Metas[k]);
        end
        setmetatable(QSB.Metatable.Weak, {__mode = "v"});
        setmetatable(QSB.Metatable.Metas, {__mode = "v"});
    end
    table.restoreMetatables();
end

function Swift.LuaBase:OverrideString()
    string.contains = function (self, s)
        return self:find(s) ~= nil;
    end

    string.indexOf = function (self, s)
        return self:find(s);
    end

    string.slice = function(self, _sep)
        _sep = _sep or "%s";
        if self then
            local t = {};
            for str in self:gmatch("([^".._sep.."]+)") do
                table.insert(t, str);
            end
            return t;
        end
    end

    string.join = function(self, ...)
        local s = "";
        local parts = {self, unpack(arg)};
        for i= 1, #parts do
            if type("part") == "table" then
                s = s .. string.join(unpack(parts[i]));
            else
                s = s .. tostring(parts[i]);
            end
        end
        return s;
    end

    string.replace = function(self, p, r)
        return self:gsub(p, r, 1);
    end

    string.replaceAll = function(self, p, r)
        return self:gsub(p, r);
    end
end

function Swift.LuaBase:OverrideMath()
    math.lerp = function(s, c, e)
        local f = (c - s) / e;
        return (f > 1 and 1) or f;
    end

    math.qmod = function(a, b)
        return a - math.floor(a/b)*b;
    end
end

function Swift.LuaBase:ConvertTableToString(_Table)
    assert(type(_Table) == "table");
    local String = "{";
    for k, v in pairs(_Table) do
        local key;
        if (tonumber(k)) then
            key = ""..k;
        else
            key = "\""..k.."\"";
        end
        if type(v) == "table" then
            String = String .. "[" .. key .. "] = " .. self:ConvertTableToString(v) .. ", ";
        elseif type(v) == "number" then
            String = String .. "[" .. key .. "] = " .. v .. ", ";
        elseif type(v) == "string" then
            String = String .. "[" .. key .. "] = \"" .. v .. "\", ";
        elseif type(v) == "boolean" or type(v) == "nil" then
            String = String .. "[" .. key .. "] = " .. tostring(v) .. ", ";
        else
            String = String .. "[" .. key .. "] = \"" .. tostring(v) .. "\", ";
        end
    end
    String = String .. "}";
    return String;
end

function Swift.LuaBase:CopyTable(_Table1, _Table2)
    _Table1 = _Table1 or {};
    _Table2 = _Table2 or {};
    for k, v in pairs(_Table1) do
        if "table" == type(v) then
            _Table2[k] = _Table2[k] or {};
            for kk, vv in pairs(self:CopyTable(v, _Table2[k])) do
                _Table2[k][kk] = _Table2[k][kk] or vv;
            end
        else
            _Table2[k] = v;
        end
    end
    return _Table2;
end

function Swift.LuaBase:ToBoolean(_Input)
    if type(_Input) == "boolean" then
        return _Input;
    end
    if _Input == 1 or string.find(string.lower(tostring(_Input)), "^[1tjy\\+].*$") then
        return true;
    end
    return false;
end

-- -------------------------------------------------------------------------- --
-- API

---
-- Wandelt underschiedliche Darstellungen einer Boolean in eine echte um.
--
-- Jeder String, der mit j, t, y oder + beginnt, wird als true interpretiert.
-- Alles andere als false.
--
-- Ist die Eingabe bereits ein Boolean wird es direkt zurückgegeben.
--
-- @param _Value Wahrheitswert
-- @return[type=boolean] Wahrheitswert
-- @within Base
-- @local
--
-- @usage local Bool = API.ToBoolean("+")  --> Bool = true
-- local Bool = API.ToBoolean("1")  --> Bool = true
-- local Bool = API.ToBoolean(1)  --> Bool = true
-- local Bool = API.ToBoolean("no") --> Bool = false
--
function API.ToBoolean(_Value)
    return Swift.LuaBase:ToBoolean(_Value);
end

---
-- Schreibt ein genaues Abbild der Table ins Log. Funktionen, Threads und
-- Metatables werden als Adresse geschrieben.
--
-- @param[type=table]  _Table Tabelle, die gedumpt wird
-- @param[type=string] _Name Optionaler Name im Log
-- @within Base
-- @local
-- @usage
-- Table = {1, 2, 3, {a = true}}
-- API.DumpTable(Table)
--
function API.DumpTable(_Table, _Name)
    local Start = "{";
    if _Name then
        Start = _Name.. " = \n" ..Start;
    end
    Framework.WriteToLog(Start);

    for k, v in pairs(_Table) do
        if type(v) == "table" then
            Framework.WriteToLog("[" ..k.. "] = ");
            API.DumpTable(v);
        elseif type(v) == "string" then
            Framework.WriteToLog("[" ..k.. "] = \"" ..v.. "\"");
        else
            Framework.WriteToLog("[" ..k.. "] = " ..tostring(v));
        end
    end
    Framework.WriteToLog("}");
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Interne Funktionalität zum Schreiben von Ausgaben ins Log.
--
-- @set sort=true
-- @local
--

Swift.Logging = {
    FileLogLevel = 3,
    LogLevel = 2,
};

QSB.LogLevel = {
    ALL     = 4;
    INFO    = 3;
    WARNING = 2;
    ERROR   = 1;
    OFF     = 0;
}

function Swift.Logging:Initalize()
end

function Swift.Logging:OnSaveGameLoaded()
end

function Swift.Logging:Log(_Text, _Level, _Verbose)
    if self.FileLogLevel >= _Level then
        local Level = _Text:sub(1, _Text:find(":"));
        local Text = _Text:sub(_Text:find(":")+1);
        Text = string.format(
            " (%s) %s%s",
            (Swift.Environment == QSB.Environment.LOCAL and "local") or "global",
            Framework.GetSystemTimeDateString(),
            Text
        )
        Framework.WriteToLog(Level .. Text);
    end
    if _Verbose then
        if Swift.Environment == QSB.Environment.GLOBAL then
            if self.LogLevel >= _Level then
                Logic.ExecuteInLuaLocalState(string.format(
                    [[GUI.AddStaticNote("%s")]],
                    _Text
                ));
            end
            return;
        end
        if self.LogLevel >= _Level then
            GUI.AddStaticNote(_Text);
        end
    end
end

function Swift.Logging:SetLogLevel(_ScreenLogLevel, _FileLogLevel)
    if Swift.Environment == QSB.Environment.GLOBAL then
        Logic.ExecuteInLuaLocalState(string.format(
            [[Swift.Logging.FileLogLevel = %d]],
            (_FileLogLevel or 0)
        ));
        Logic.ExecuteInLuaLocalState(string.format(
            [[Swift.Logging.LogLevel = %d]],
            (_ScreenLogLevel or 0)
        ));
        self.FileLogLevel = (_FileLogLevel or 0);
        self.LogLevel = (_ScreenLogLevel or 0);
    end
end

function debug(_Text, _Silent)
    Swift.Logging:Log("DEBUG: " .._Text, QSB.LogLevel.ALL, not _Silent);
end
function info(_Text, _Silent)
    Swift.Logging:Log("INFO: " .._Text, QSB.LogLevel.INFO, not _Silent);
end
function warn(_Text, _Silent)
    Swift.Logging:Log("WARNING: " .._Text, QSB.LogLevel.WARNING, not _Silent);
end
function error(_Text, _Silent)
    Swift.Logging:Log("ERROR: " .._Text, QSB.LogLevel.ERROR, not _Silent);
end

-- -------------------------------------------------------------------------- --
-- API

---
-- Setzt, ab wann Log-Nachrichten geschrieben werden.
--
-- Es wird zwischen der Ausgabe am Bildschirm und dem Wegschreiben ins Log
-- unterschieden. Die Anzeige am Bildschirm kann strenger eingestellt sein,
-- als das Speichern in der Log-Datei.
--
-- Mögliche Level:
-- <table border=1>
-- <tr>
-- <td><b>Name</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>QSB.LogLevel.ALL</td>
-- <td>Alle Stufen ausgeben (Debug, Info, Warning, Error)</td>
-- </tr>
-- <tr>
-- <td>QSB.LogLevel.INFO</td>
-- <td>Erst ab Stufe Info ausgeben (Info, Warning, Error)</td>
-- </tr>
-- <tr>
-- <td>QSB.LogLevel.WARNING</td>
-- <td>Erst ab Stufe Warning ausgeben (Warning, Error)</td>
-- </tr>
-- <tr>
-- <td>QSB.LogLevel.ERROR</td>
-- <td>Erst ab Stufe Error ausgeben (Error)</td>
-- </tr>
-- <tr>
-- <td>QSB.LogLevel.OFF</td>
-- <td>Keine Meldungen ausgeben</td>
-- </tr>
-- </table>
--
-- @param[type=number] _ScreenLogLevel Level für Bildschirmausgabe
-- @param[type=number] _FileLogLevel   Level für Dateiausgaabe
-- @within Base
-- @local
--
-- @usage
-- API.SetLogLevel(QSB.LogLevel.ERROR, QSB.LogLevel.WARNING);
--
function API.SetLogLevel(_ScreenLogLevel, _FileLogLevel)
    Swift.Logging:SetLogLevel(_ScreenLogLevel, _FileLogLevel);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Kommunikation von Komponenten über Events aus dem Skript.
--
-- @set sort=true
-- @local
--

Swift.Event = {
    ScriptEventRegister   = {};
    ScriptEventListener   = {};
    ScriptCommandRegister = {};
};

QSB.ScriptCommandSequence = 2;
QSB.ScriptCommands = {};
QSB.ScriptEvents = {};

function Swift.Event:Initalize()
    self:OverrideSoldierPayment();
    if Swift.Environment == QSB.Environment.GLOBAL then
        self:CreateScriptCommand("Cmd_SendScriptEvent", function(_Event, ...)
            assert(QSB.ScriptEvents[_Event] ~= nil);
            API.SendScriptEvent(QSB.ScriptEvents[_Event], unpack(arg));
        end);
    end
end

function Swift.Event:OnSaveGameLoaded()
end

-- -------------------------------------------------------------------------- --
-- Script Commands

function Swift.Event:OverrideSoldierPayment()
    GameCallback_SetSoldierPaymentLevel_Orig_Swift = GameCallback_SetSoldierPaymentLevel;
    GameCallback_SetSoldierPaymentLevel = function(_PlayerID, _Level)
        if _Level <= 2 then
            return GameCallback_SetSoldierPaymentLevel_Orig_Swift(_PlayerID, _Level);
        end
        Swift.Event:ProcessScriptCommand(_PlayerID, _Level);
    end
end

function Swift.Event:CreateScriptCommand(_Name, _Function)
    if Swift.Environment == QSB.Environment.LOCAL then
        return 0;
    end
    QSB.ScriptCommandSequence = QSB.ScriptCommandSequence +1;
    local ID = QSB.ScriptCommandSequence;
    local Name = _Name;
    if string.find(_Name, "^Cmd_") then
        Name = string.sub(_Name, 5);
    end
    self.ScriptCommandRegister[ID] = {Name, _Function};
    Logic.ExecuteInLuaLocalState(string.format(
        [[
            local ID = %d
            local Name = "%s"
            Swift.Event.ScriptCommandRegister[ID] = Name
            QSB.ScriptCommands[Name] = ID
        ]],
        ID,
        Name
    ));
    QSB.ScriptCommands[Name] = ID;
    return ID;
end

function Swift.Event:DispatchScriptCommand(_ID, ...)
    if Swift.Environment == QSB.Environment.GLOBAL then
        return;
    end
    assert(_ID ~= nil);
    if self.ScriptCommandRegister[_ID] then
        local PlayerID = GUI.GetPlayerID();
        local NamePlayerID = PlayerID +4;
        local PlayerName = Logic.GetPlayerName(NamePlayerID);
        local Parameters = self:EncodeScriptCommandParameters(unpack(arg));

        if Framework.IsNetworkGame() and Swift.GameVersion == QSB.GameVersion.HISTORY_EDITION then
            GUI.SetPlayerName(NamePlayerID, Parameters);
            GUI.SetSoldierPaymentLevel(_ID);
        else
            GUI.SendScriptCommand(string.format(
                [[Swift.Event:ProcessScriptCommand(%d, %d, "%s")]],
                arg[1],
                _ID,
                Parameters
            ));
        end
        debug(string.format(
            "Dispatching script command %s to global.",
            self.ScriptCommandRegister[_ID]
        ), true);

        if Framework.IsNetworkGame() and Swift.GameVersion == QSB.GameVersion.HISTORY_EDITION then
            GUI.SetPlayerName(NamePlayerID, PlayerName);
            GUI.SetSoldierPaymentLevel(PlayerSoldierPaymentLevel[PlayerID]);
        end
    end
end

function Swift.Event:ProcessScriptCommand(_PlayerID, _ID, _ParameterString)
    if not self.ScriptCommandRegister[_ID] then
        return;
    end
    local PlayerName = _ParameterString;
    if Framework.IsNetworkGame() and Swift.GameVersion == QSB.GameVersion.HISTORY_EDITION then
        PlayerName = Logic.GetPlayerName(_PlayerID +4);
    end
    local Parameters = self:DecodeScriptCommandParameters(PlayerName);
    local PlayerID = table.remove(Parameters, 1);
    if PlayerID ~= 0 and PlayerID ~= _PlayerID then
        return;
    end
    debug(string.format(
        "Processing script command %s in global.",
        self.ScriptCommandRegister[_ID][1]
    ), true);
    self.ScriptCommandRegister[_ID][2](unpack(Parameters));
end

function Swift.Event:EncodeScriptCommandParameters(...)
    local Query = "";
    for i= 1, #arg do
        local Parameter = arg[i];
        if type(Parameter) == "string" then
            Parameter = string.replaceAll(Parameter, '#', "<<<HT>>>");
            Parameter = string.replaceAll(Parameter, '"', "<<<QT>>>");
            if Parameter:len() == 0 then
                Parameter = "<<<ES>>>";
            end
        elseif type(Parameter) == "table" then
            Parameter = "{" ..table.concat(Parameter, ",") .."}";
        end
        if string.len(Query) > 0 then
            Query = Query .. "#";
        end
        Query = Query .. tostring(Parameter);
    end
    return Query;
end

function Swift.Event:DecodeScriptCommandParameters(_Query)
    local Parameters = {};
    for k, v in pairs(string.slice(_Query, "#")) do
        local Value = v;
        Value = string.replaceAll(Value, "<<<HT>>>", '#');
        Value = string.replaceAll(Value, "<<<QT>>>", '"');
        Value = string.replaceAll(Value, "<<<ES>>>", '');
        if Value == nil then
            Value = nil;
        elseif Value == "true" or Value == "false" then
            Value = Value == "true";
        elseif string.indexOf(Value, "{") == 1 then
            local ValueTable = string.slice(string.sub(Value, 2, string.len(Value)-1), ",");
            Value = {};
            for i= 1, #ValueTable do
                Value[i] = (tonumber(ValueTable[i]) ~= nil and tonumber(ValueTable[i]) or ValueTable);
            end
        elseif tonumber(Value) ~= nil then
            Value = tonumber(Value);
        end
        table.insert(Parameters, Value);
    end
    return Parameters;
end

-- -------------------------------------------------------------------------- --
-- Script Events

function Swift.Event:CreateScriptEvent(_Name)
    for i= 1, #self.ScriptEventRegister, 1 do
        if self.ScriptEventRegister[i] == _Name then
            return 0;
        end
    end
    local ID = #self.ScriptEventRegister+1;
    debug(string.format("Create script event %s", _Name), true);
    self.ScriptEventRegister[ID] = _Name;
    return ID;
end

function Swift.Event:DispatchScriptEvent(_ID, ...)
    if not self.ScriptEventRegister[_ID] then
        return;
    end
    -- Dispatch module events
    for i= 1, #Swift.ModuleRegister, 1 do
        local Env = (Swift.Environment == QSB.Environment.GLOBAL and "Global") or "Local";
        if Swift.ModuleRegister[i][Env] and Swift.ModuleRegister[i][Env].OnEvent then
            Swift.ModuleRegister[i][Env]:OnEvent(_ID, unpack(arg));
        end
    end
    -- Call event game callback
    if GameCallback_QSB_OnEventReceived then
        GameCallback_QSB_OnEventReceived(_ID, unpack(arg));
    end
    -- Call event listeners
    if self.ScriptEventListener[_ID] then
        for k, v in pairs(self.ScriptEventListener[_ID]) do
            if tonumber(k) then
                v(unpack(arg));
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- API

function API.RegisterScriptCommand(_Name, _Function)
    return Swift.Event:CreateScriptCommand(_Name, _Function);
end

function API.BroadcastScriptCommand(_NameOrID, ...)
    local ID = _NameOrID;
    if type(ID) == "string" then
        for i= 1, #Swift.Event.ScriptCommandRegister, 1 do
            if Swift.Event.ScriptCommandRegister[i][1] == _NameOrID then
                ID = i;
            end
        end
    end
    assert(type(ID) == "number");
    if not GUI then
        return;
    end
    Swift.Event:DispatchScriptCommand(ID, 0, unpack(arg));
end

-- Does this function makes any sense? Calling the synchronization but only for
-- one player seems to be stupid...
function API.SendScriptCommand(_NameOrID, ...)
    local ID = _NameOrID;
    if type(ID) == "string" then
        for i= 1, #Swift.Event.ScriptCommandRegister, 1 do
            if Swift.Event.ScriptCommandRegister[i][1] == _NameOrID then
                ID = i;
            end
        end
    end
    assert(type(ID) == "number");
    if not GUI then
        return;
    end
    Swift.Event:DispatchScriptCommand(ID, GUI.GetPlayerID(), unpack(arg));
end

---
-- Legt ein neues Script Event an.
--
-- @param[type=string]   _Name     Identifier des Event
-- @return[type=number] ID des neuen Script Event
-- @within Event
-- @local
--
-- @usage
-- local EventID = API.RegisterScriptEvent("MyNewEvent");
--
function API.RegisterScriptEvent(_Name)
    return Swift.Event:CreateScriptEvent(_Name);
end

---
-- Sendet das Script Event mit der übergebenen ID und überträgt optional
-- Parameter.
--
-- <h5>Multiplayer</h5>
-- Im Multiplayer kann diese Funktion nicht benutzt werden, um Script Events
-- synchron oder asynchron aus dem lokalen im globalen Skript auszuführen.
--
-- @param[type=number] _EventID ID des Event
-- @param              ... Optionale Parameter (nil, string, number, boolean, (array) table)
-- @within Event
-- @local
--
-- @usage
-- API.SendScriptEvent(SomeEventID, Param1, Param2, ...);
--
function API.SendScriptEvent(_EventID, ...)
    Swift.Event:DispatchScriptEvent(_EventID, unpack(arg));
end

---
-- Triggerd ein Script Event im globalen Skript aus dem lokalen Skript.
--
-- Das Event wird synchron für alle Spieler gesendet.
--
-- @param[type=number] _EventName Name des Event
-- @param              ... Optionale Parameter (nil, string, number, boolean, (array) table)
-- @within Event
-- @local
--
-- @usage
-- API.SendScriptEventToGlobal("SomeEventName", Param1, Param2, ...);
--
function API.BroadcastScriptEventToGlobal(_EventName, ...)
    if not GUI then
        return;
    end
    Swift.Event:DispatchScriptCommand(
        QSB.ScriptCommands.SendScriptEvent,
        0,
        _EventName,
        unpack(arg)
    );
end

---
-- Triggerd ein Script Event im globalen Skript aus dem lokalen Skript.
--
-- Das Event wird asynchron für den kontrollierenden Spieler gesendet.
--
-- @param[type=number] _EventName Name des Event
-- @param              ... Optionale Parameter (nil, string, number, boolean, (array) table)
-- @within Event
-- @local
--
-- @usage
-- API.SendScriptEventToGlobal("SomeEventName", Param1, Param2, ...);
--
function API.SendScriptEventToGlobal(_EventName, ...)
    if not GUI then
        return;
    end
    Swift.Event:DispatchScriptCommand(
        QSB.ScriptCommands.SendScriptEvent,
        GUI.GetPlayerID(),
        _EventName,
        unpack(arg)
    );
end

---
-- Erstellt einen neuen Listener für das Event.
--
-- An den Listener werden die gleichen Parameter übergeben, die für das Event
-- auch bei GameCallback_QSB_OnEventReceived übergeben werden.
--
-- <b>Hinweis</b>: Event Listener für ein spezifisches Event werden nach
-- GameCallback_QSB_OnEventReceived aufgerufen.
--
-- @param[type=number]   _EventID  ID des Event
-- @param[type=function] _Function Listener Funktion
-- @return[type=number] ID des Listener
-- @within Event
-- @see API.RemoveScriptEventListener
--
-- @usage
-- local ListenerID = API.AddScriptEventListener(QSB.ScriptEvents.SaveGameLoaded, function()
--     Logic.DEBUG_AddNote("A save has been loaded!");
-- end);
--
function API.AddScriptEventListener(_EventID, _Function)
    if not Swift.Event.ScriptEventListener[_EventID] then
        Swift.Event.ScriptEventListener[_EventID] = {
            IDSequence = 0;
        }
    end
    local Data = Swift.Event.ScriptEventListener[_EventID];
    assert(type(_Function) == "function");
    Swift.Event.ScriptEventListener[_EventID].IDSequence = Data.IDSequence +1;
    Swift.Event.ScriptEventListener[_EventID][Data.IDSequence] = _Function;
    return Data.IDSequence;
end

---
-- Entfernt einen Listener von dem Event.
--
-- @param[type=number] _EventID ID des Event
-- @param[type=number] _ID      ID des Listener
-- @within Event
-- @see API.AddScriptEventListener
--
function API.RemoveScriptEventListener(_EventID, _ID)
    if Swift.Event.ScriptEventListener[_EventID] then
        Swift.Event.ScriptEventListener[_EventID][_ID] = nil;
    end
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Bietet erweiterte Möglichkeiten mit Jobs erweitern.
-- @set sort=true
-- @local
--

Swift.Job = {
    EventJobMappingID = 0;
    EventJobMapping = {},
    EventJobs = {},

    SecondsSinceGameStart = 0;
    LastTimeStamp = 0;
};

function Swift.Job:Initalize()
    self:StartJobs();
end

function Swift.Job:OnSaveGameLoaded()
end

function Swift.Job:StartJobs()
    -- Update Real time variable
    self:CreateEventJob(
        Events.LOGIC_EVENT_EVERY_TURN,
        function()
            Swift.Job:RealtimeController();
        end
    )
end

function Swift.Job:CreateEventJob(_Type, _Function, ...)
    self.EventJobMappingID = self.EventJobMappingID +1;
    local ID = Trigger.RequestTrigger(
        _Type,
        "",
        "QSB_EventJob_EventJobExecutor",
        1,
        {},
        {self.EventJobMappingID}
    );
    self.EventJobs[ID] = {ID, true, _Function, arg};
    self.EventJobMapping[self.EventJobMappingID] = ID;
    return ID;
end

function Swift.Job:EventJobExecutor(_MappingID)
    local ID = self.EventJobMapping[_MappingID];
    if ID and self.EventJobs[ID] and self.EventJobs[ID][2] then
        local Parameter = self.EventJobs[ID][4];
        if self.EventJobs[ID][3](unpack(Parameter)) then
            self.EventJobs[ID][2] = false;
        end
    end
end

function Swift.Job:RealtimeController()
    if not self.LastTimeStamp then
        self.LastTimeStamp = math.floor(Framework.TimeGetTime());
    end
    local CurrentTimeStamp = math.floor(Framework.TimeGetTime());

    if self.LastTimeStamp ~= CurrentTimeStamp then
        self.LastTimeStamp = CurrentTimeStamp;
        self.SecondsSinceGameStart = self.SecondsSinceGameStart +1;
    end
end

-- -------------------------------------------------------------------------- --
-- Helper Jobs

function QSB_EventJob_EventJobExecutor(_MappingID)
    Swift.Job:EventJobExecutor(_MappingID);
end

-- -------------------------------------------------------------------------- --
-- API

---
-- Gibt die real vergangene Zeit seit dem Spielstart in Sekunden zurück.
-- @return[type=number] Vergangene reale Zeit
-- @within Job
--
-- @usage
-- local RealTime = API.RealTimeGetSecondsPassedSinceGameStart();
--
function API.RealTimeGetSecondsPassedSinceGameStart()
    return Swift.Job.SecondsSinceGameStart;
end

---
-- Erzeugt einen neuen Event-Job.
--
-- <b>Hinweis</b>: Nur wenn ein Event Job mit dieser Funktion gestartet wird,
-- können ResumeJob und YieldJob auf den Job angewendet werden.
--
-- <b>Hinweis</b>: Events.LOGIC_EVENT_ENTITY_CREATED funktioniert nicht!
--
-- <b>Hinweis</b>: Wird ein Table als Argument an den Job übergeben, wird eine
-- Kopie angelegt um Speicherprobleme zu verhindern. Es handelt sich also um
-- eine neue Table und keine Referenz!
--
-- @param[type=number]   _EventType Event-Typ
-- @param _Function      Funktion (Funktionsreferenz oder String)
-- @param ...            Optionale Argumente des Job
-- @return[type=number] ID des Jobs
-- @within Job
--
-- @usage
-- API.StartJobByEventType(
--     Events.LOGIC_EVENT_EVERY_SECOND,
--     FunctionRefToCall
-- );
--
function API.StartJobByEventType(_EventType, _Function, ...)
    local Function = _G[_Function] or _Function;
    if type(Function) ~= "function" then
        error("API.StartJobByEventType: Can not find function!");
        return;
    end
    return Swift.Job:CreateEventJob(_EventType, _Function, unpack(arg));
end

---
-- Führt eine Funktion ein mal pro Sekunde aus. Die weiteren Argumente werden an
-- die Funktion übergeben.
--
-- Die Funktion kann als Referenz, Inline oder als String übergeben werden.
--
-- @param _Function Funktion (Funktionsreferenz oder String)
-- @param ...       Liste von Argumenten
-- @return[type=number] Job ID
-- @within Job
--
-- @usage
-- -- Führt eine Funktion nach 15 Sekunden aus.
-- API.StartJob(function(_Time, _EntityType)
--     if Logic.GetTime() > _Time + 15 then
--         MachWas(_EntityType);
--         return true;
--     end
-- end, Logic.GetTime(), Entities.U_KnightHealing)
--
-- -- Startet einen Job
-- StartSimpleJob("MeinJob");
--
function API.StartJob(_Function, ...)
    local Function = _G[_Function] or _Function;
    if type(Function) ~= "function" then
        error("API.StartJob: _Function must be a function!");
        return;
    end
    return API.StartJobByEventType(Events.LOGIC_EVENT_EVERY_SECOND, Function, unpack(arg));
end
StartSimpleJob = API.StartJob;
StartSimpleJobEx = API.StartJob;

---
-- Führt eine Funktion ein mal pro Turn aus. Ein Turn entspricht einer 1/10
-- Sekunde in der Spielzeit. Die weiteren Argumente werden an die Funktion
-- übergeben.
--
-- Die Funktion kann als Referenz, Inline oder als String übergeben werden.
--
-- @param _Function Funktion (Funktionsreferenz oder String)
-- @param ...       Liste von Argumenten
-- @return[type=number] Job ID
-- @within Job
-- @see API.StartJob
--
function API.StartHiResJob(_Function, ...)
    local Function = _G[_Function] or _Function;
    if type(Function) ~= "function" then
        error("API.StartHiResJob: _Function must be a function!");
        return;
    end
    return API.StartJobByEventType(Events.LOGIC_EVENT_EVERY_TURN, Function, unpack(arg));
end
StartSimpleHiResJob = API.StartHiResJob;
StartSimpleHiResJobEx = API.StartHiResJob;

---
-- Beendet den Job mit der übergebenen ID endgültig.
--
-- @param[type=number] _JobID ID des Jobs
-- @within Job
--
-- @usage
-- API.EndJob(AnyJobID);
--
function API.EndJob(_JobID)
    if Swift.Job.EventJobs[_JobID] then
        Trigger.UnrequestTrigger(Swift.Job.EventJobs[_JobID][1]);
        Swift.Job.EventJobs[_JobID] = nil;
        return;
    end
    EndJob(_JobID);
end

---
-- Gibt zurück, ob der Job mit der übergebenen ID aktiv ist.
--
-- @param[type=number] _JobID ID des Jobs
-- @return[type=boolean] Job ist aktiv
-- @within Job
--
-- @usage
-- if API.JobIsRunning(AnyJobID) then
--     -- Mach was
-- end;
--
function API.JobIsRunning(_JobID)
    if Swift.Job.EventJobs[_JobID] then
        return Swift.Job.EventJobs[_JobID][2] == true;
    end
    return JobIsRunning(_JobID);
end

---
-- Aktiviert einen pausierten Job.
--
-- @param[type=number] _JobID ID des Jobs
-- @within Job
--
-- @usage
-- API.ResumeJob(AnyJobID);
--
function API.ResumeJob(_JobID)
    if Swift.Job.EventJobs[_JobID] then
        if Swift.Job.EventJobs[_JobID][2] ~= true then
            Swift.Job.EventJobs[_JobID][2] = true;
        end
        return;
    end
    error("API.ResumeJob: Job " ..tostring(_JobID).. " can not be resumed!");
end

---
-- Pausiert einen aktivien Job.
--
-- @param[type=number] _JobID ID des Jobs
-- @within Job
--
-- @usage
-- API.YieldJob(AnyJobID);
--
function API.YieldJob(_JobID)
    if Swift.Job.EventJobs[_JobID] then
        if Swift.Job.EventJobs[_JobID][2] == true then
            Swift.Job.EventJobs[_JobID][2] = false;
        end
        return;
    end
    error("API.YieldJob: Job " ..tostring(_JobID).. " can not be paused!");
end

---
-- Wartet die angebene Zeit in Sekunden und führt anschließend die Funktion aus.
--
-- Die Funktion kann als Referenz, Inline oder als String übergeben werden.
--
-- <b>Achtung</b>: Die Ausführung erfolgt asynchron. Das bedeutet, dass das
-- Skript weiterläuft.
--
-- @param[type=number] _Waittime   Wartezeit in Sekunden
-- @param[type=function] _Function Callback-Funktion
-- @param ... Liste der Argumente
-- @return[type=number] ID der Verzögerung
-- @within Job
--
-- @usage
-- API.StartDelay(
--     30,
--     function()
--         Logic.DEBUG_AddNote("Zeit abgelaufen!");
--     end
-- )
--
function API.StartDelay(_Waittime, _Function, ...)
    local Function = _G[_Function] or _Function;
    if type(Function) ~= "function" then
        error("API.StartDelay: _Function must be a function!");
        return;
    end
    return API.StartJob(
        function(_StartTime, _Delay, _Callback, _Arguments)
            if _StartTime + _Delay <= Logic.GetTime() then
                _Callback(unpack(_Arguments or {}));
                return true;
            end
        end,
        Logic.GetTime(),
        _Waittime,
        _Function,
        {...}
    );
end

---
-- Wartet die angebene Zeit in Turns und führt anschließend die Funktion aus.
--
-- Die Funktion kann als Referenz, Inline oder als String übergeben werden.
--
-- <b>Achtung</b>: Die Ausführung erfolgt asynchron. Das bedeutet, dass das
-- Skript weiterläuft.
--
-- @param[type=number] _Waittime   Wartezeit in Turns
-- @param[type=function] _Function Callback-Funktion
-- @param ... Liste der Argumente
-- @return[type=number] ID der Verzögerung
-- @within Job
--
-- @usage
-- API.StartHiResDelay(
--     30,
--     function()
--         Logic.DEBUG_AddNote("Zeit abgelaufen!");
--     end
-- )
--
function API.StartHiResDelay(_Waittime, _Function, ...)
    local Function = _G[_Function] or _Function;
    if type(Function) ~= "function" then
        error("API.StartHiResDelay: _Function must be a function!");
        return;
    end
    return API.StartHiResJob(
        function(_StartTime, _Delay, _Callback, _Arguments)
            if _StartTime + _Delay <= Logic.GetCurrentTurn() then
                _Callback(unpack(_Arguments or {}));
                return true;
            end
        end,
        Logic.GetTime(),
        _Waittime,
        _Function,
        {...}
    );
end

---
-- Wartet die angebene Zeit in realen Sekunden und führt anschließend die
-- Funktion aus.
--
-- Die Funktion kann als Referenz, Inline oder als String übergeben werden.
--
-- <b>Achtung</b>: Die Ausführung erfolgt asynchron. Das bedeutet, dass das
-- Skript weiterläuft.
--
-- @param[type=number] _Waittime   Wartezeit in realen Sekunden
-- @param[type=function] _Function Callback-Funktion
-- @param ... Liste der Argumente
-- @return[type=number] ID der Verzögerung
-- @within Job
--
-- @usage
-- API.StartRealTimeDelay(
--     30,
--     function()
--         Logic.DEBUG_AddNote("Zeit abgelaufen!");
--     end
-- )
--
function API.StartRealTimeDelay(_Waittime, _Function, ...)
    local Function = _G[_Function] or _Function;
    if type(Function) ~= "function" then
        error("API.StartRealTimeDelay: _Function must be a function!");
        return;
    end
    return API.StartHiResJob(
        function(_StartTime, _Delay, _Callback, _Arguments)
            if (Swift.Job.SecondsSinceGameStart >= _StartTime + _Delay) then
                _Callback(unpack(_Arguments or {}));
                return true;
            end
        end,
        Swift.Job.SecondsSinceGameStart,
        _Waittime,
        _Function,
        {...}
    );
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Speichern und Laden von Spielständen kontrollieren.
-- @set sort=true
-- @local
--

Swift.Save = {
    HistoryEditionQuickSave = false,
    SavingDisabled = false,
    LoadingDisabled = false,
};

function Swift.Save:Initalize()
    self:SetupQuicksaveKeyCallback();
    self:SetupQuicksaveKeyTrigger();
end

function Swift.Save:OnSaveGameLoaded()
    self:SetupQuicksaveKeyTrigger();
    self:UpdateLoadButtons();
    self:UpdateSaveButtons();
end

-- -------------------------------------------------------------------------- --
-- HE Quicksave

function Swift.Save:SetupQuicksaveKeyTrigger()
    if Swift.Environment == QSB.Environment.LOCAL then
        Swift.Job:CreateEventJob(
            Events.LOGIC_EVENT_EVERY_TURN,
            function()
                Input.KeyBindDown(
                    Keys.ModifierControl + Keys.S,
                    "KeyBindings_SaveGame(true)",
                    2,
                    false
                );
                return true;
            end
        );
    end
end

function Swift.Save:SetupQuicksaveKeyCallback()
    if Swift.Environment == QSB.Environment.LOCAL then
        KeyBindings_SaveGame_Orig_Swift = KeyBindings_SaveGame;
        KeyBindings_SaveGame = function(...)
            -- No quicksave if saving disabled
            if Swift.Save.SavingDisabled then
                return;
            end
            -- No quicksave if forced by History Edition
            if not Swift.Save.HistoryEditionQuickSave and not arg[1] then
                return;
            end
            -- Do quicksave
            KeyBindings_SaveGame_Orig_Swift();
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Disable Save

function Swift.Save:DisableSaving(_Flag)
    self.SavingDisabled = _Flag == true;
    if Swift.Environment == QSB.Environment.GLOBAL then
        Logic.ExecuteInLuaLocalState(string.format(
            [[Swift.Save:DisableSaving(%s)]],
            tostring(_Flag)
        ))
    else
        self:UpdateSaveButtons();
    end
end

function Swift.Save:UpdateSaveButtons()
    if Swift.Environment == QSB.Environment.LOCAL then
        local VisibleFlag = (self.SavingDisabled and 0) or 1;
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", VisibleFlag);
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame", VisibleFlag);
    end
end

-- -------------------------------------------------------------------------- --
-- Disable Load

function Swift.Save:DisableLoading(_Flag)
    self.LoadingDisabled = _Flag == true;
    if Swift.Environment == QSB.Environment.GLOBAL then
        Logic.ExecuteInLuaLocalState(string.format(
            [[Swift.Save:DisableLoading(%s)]],
            tostring(_Flag)
        ))
    else
        self:UpdateLoadButtons();
    end
end

function Swift.Save:UpdateLoadButtons()
    if Swift.Environment == QSB.Environment.LOCAL then
        local VisibleFlag = (self.LoadingDisabled and 0) or 1;
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/LoadGame", VisibleFlag);
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickLoad", VisibleFlag);
    end
end

-- -------------------------------------------------------------------------- --
-- API

---
-- Deaktiviert das automatische Speichern der History Edition.
-- @param[type=boolean] _Flag Auto-Speichern ist deaktiviert
-- @within Spielstand
--
function API.DisableAutoSave(_Flag)
    if Swift.Environment == QSB.Environment.GLOBAL then
        Swift.Save.HistoryEditionQuickSave = _Flag == true;
        Logic.ExecuteInLuaLocalState(string.format(
            [[Swift.Save.HistoryEditionQuickSave = %s]],
            tostring(_Flag == true)
        ))
    end
end

---
-- Deaktiviert das Speichern des Spiels.
-- @param[type=boolean] _Flag Speichern ist deaktiviert
-- @within Spielstand
--
function API.DisableSaving(_Flag)
    Swift.Save:DisableSaving(_Flag);
end

---
-- Deaktiviert das Laden von Spielständen.
-- @param[type=boolean] _Flag Laden ist deaktiviert
-- @within Spielstand
--
function API.DisableLoading(_Flag)
    Swift.Save:DisableLoading(_Flag);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Steuerung des Chat als Eingabefenster.
-- @set sort=true
-- @local
--

Swift.Chat = {
    DebugInput = {};
};

function Swift.Chat:Initalize()
    QSB.ScriptEvents.ChatOpened = Swift.Event:CreateScriptEvent("Event_ChatOpened");
    QSB.ScriptEvents.ChatClosed = Swift.Event:CreateScriptEvent("Event_ChatClosed");
    for i= 1, 8 do
        self.DebugInput[i] = {};
    end
end

function Swift.Chat:OnSaveGameLoaded()
end

function Swift.Chat:ShowTextInput(_PlayerID, _AllowDebug)
    if  Swift.GameVersion == QSB.GameVersion.HISTORY_EDITION
    and Framework.IsNetworkGame() then
        return;
    end
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[Swift.Chat:ShowTextInput(%d, %s)]],
            _PlayerID,
            tostring(_AllowDebug == true)
        ))
        return;
    end
    _PlayerID = _PlayerID or GUI.GetPlayerID();
    self:PrepareInputVariable(_PlayerID);
    self:ShowInputBox(_PlayerID, _AllowDebug == true);
end

function Swift.Chat:ShowInputBox(_PlayerID, _Debug)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.DebugInput[_PlayerID] = _Debug == true;

    Swift.Job:CreateEventJob(
        Events.LOGIC_EVENT_EVERY_TURN,
        function()
            -- Open chat
            Input.ChatMode();
            XGUIEng.SetText("/InGame/Root/Normal/ChatInput/ChatInput", "");
            XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput", 1);
            XGUIEng.SetFocus("/InGame/Root/Normal/ChatInput/ChatInput");
            -- Send event to global script
            Swift.Event:DispatchScriptCommand(
                QSB.ScriptCommands.SendScriptEvent,
                GUI.GetPlayerID(),
                "ChatOpened",
                _PlayerID
            );
            -- Send event to local script
            Swift.Event:DispatchScriptEvent(
                QSB.ScriptEvents.ChatOpened,
                _PlayerID
            );
            -- Slow down game time. We can not set the game time to 0 because
            -- then Logic.ExecuteInLuaLocalState and GUI.SendScriptCommand do
            -- not work anymore.
            if not Framework.IsNetworkGame() then
                Game.GameTimeSetFactor(GUI.GetPlayerID(), 0.0000001);
            end
            return true;
        end
    )
end

function Swift.Chat:PrepareInputVariable(_PlayerID)
    if Swift.Environment == QSB.Environment.GLOBAL then
        return;
    end

    GUI_Chat.Abort_Orig_Swift = GUI_Chat.Abort_Orig_Swift or GUI_Chat.Abort;
    GUI_Chat.Confirm_Orig_Swift = GUI_Chat.Confirm_Orig_Swift or GUI_Chat.Confirm;

    GUI_Chat.Confirm = function()
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput", 0);
        local ChatMessage = XGUIEng.GetText("/InGame/Root/Normal/ChatInput/ChatInput");
        local IsDebug = Swift.Chat.DebugInput[_PlayerID];
        Swift.ChatBoxInput = ChatMessage;
        Swift.Chat:SendInputToGlobalScript(ChatMessage, IsDebug);
        g_Chat.JustClosed = 1;
        if not Framework.IsNetworkGame() then
            Game.GameTimeSetFactor(_PlayerID, 1);
        end
        Input.GameMode();
        if  ChatMessage:len() > 0
        and Framework.IsNetworkGame()
        and not IsDebug then
            GUI.SendChatMessage(
                ChatMessage,
                _PlayerID,
                g_Chat.CurrentMessageType,
                g_Chat.CurrentWhisperTarget
            );
        end
    end

    if not Framework.IsNetworkGame() then
        GUI_Chat.Abort = function()
        end
    end
end

function Swift.Chat:SendInputToGlobalScript(_Text, _Debug)
    _Text = (_Text == nil and "") or _Text;
    local PlayerID = GUI.GetPlayerID();
    -- Send chat input to global script
    Swift.Event:DispatchScriptCommand(
        QSB.ScriptCommands.SendScriptEvent,
        0,
        "ChatClosed",
        (_Text or "<<<ES>>>"),
        GUI.GetPlayerID(),
        _Debug == true
    );
    -- Send chat input to local script
    Swift.Event:DispatchScriptEvent(
        QSB.ScriptEvents.ChatClosed,
        (_Text or "<<<ES>>>"),
        GUI.GetPlayerID(),
        _Debug == true
    );
    -- Reset debug flag
    self.DebugInput[PlayerID] = false;
end

-- -------------------------------------------------------------------------- --
-- API

---
-- Offnet das Chatfenster für eine Eingabe.
--
-- <b>Hinweis</b>: Im Multiplayer kann der Chat nicht über Skript gesteuert
-- werden.
-- 
-- @param[type=number]  _PlayerID   Spieler für den der Chat geöffnet wird
-- @param[type=boolean] _AllowDebug Debug Eingaben werden bearbeitet
-- @within System
--
function API.ShowTextInput(_PlayerID, _AllowDebug)
    Swift.Chat:ShowTextInput(_PlayerID, _AllowDebug);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Multilinguale Texte und Platzhalterersetzung in Texten.
-- @set sort=true
-- @local
--

Swift.Text = {
    Languages = {
        {"de", "Deutsch", "en"},
        {"en", "English", "en"},
        {"fr", "Français", "en"},
    },

    Colors = {
        red     = "{@color:255,80,80,255}",
        blue    = "{@color:104,104,232,255}",
        yellow  = "{@color:255,255,80,255}",
        green   = "{@color:80,180,0,255}",
        white   = "{@color:255,255,255,255}",
        black   = "{@color:0,0,0,255}",
        grey    = "{@color:140,140,140,255}",
        azure   = "{@color:0,160,190,255}",
        orange  = "{@color:255,176,30,255}",
        amber   = "{@color:224,197,117,255}",
        violet  = "{@color:180,100,190,255}",
        pink    = "{@color:255,170,200,255}",
        scarlet = "{@color:190,0,0,255}",
        magenta = "{@color:190,0,89,255}",
        olive   = "{@color:74,120,0,255}",
        sky     = "{@color:145,170,210,255}",
        tooltip = "{@color:51,51,120,255}",
        lucid   = "{@color:0,0,0,0}",
        none    = "{@color:none}"
    },

    Placeholders = {
        Names = {},
        EntityTypes = {},
    },
}

QSB.Language = "de";

function Swift.Text:Initalize()
    QSB.ScriptEvents.LanguageSet = Swift.Event:CreateScriptEvent("Event_LanguageSet");
    self:DetectLanguage();
end

function Swift.Text:OnSaveGameLoaded()
end

-- -------------------------------------------------------------------------- --
-- Language

function Swift.Text:DetectLanguage()
    local DefaultLanguage = Network.GetDesiredLanguage();
    if DefaultLanguage ~= "de" and DefaultLanguage ~= "fr" then
        DefaultLanguage = "en";
    end
    QSB.Language = DefaultLanguage;
end

function Swift.Text:OnLanguageChanged(_PlayerID, _GUI_PlayerID, _Language)
    self:ChangeSystemLanguage(_PlayerID, _Language, _GUI_PlayerID);
end

function Swift.Text:ChangeSystemLanguage(_PlayerID, _Language, _GUI_PlayerID)
    local OldLanguage = QSB.Language;
    local NewLanguage = _Language;
    if _GUI_PlayerID == nil or _GUI_PlayerID == _PlayerID then
        QSB.Language = _Language;
    end

    Swift.Event:DispatchScriptEvent(QSB.ScriptEvents.LanguageSet, OldLanguage, NewLanguage);
    Logic.ExecuteInLuaLocalState(string.format(
        [[
            local OldLanguage = "%s"
            local NewLanguage = "%s"
            if GUI.GetPlayerID() == %d then
                QSB.Language = NewLanguage
            end
            Swift.Event:DispatchScriptEvent(QSB.ScriptEvents.LanguageSet, OldLanguage, NewLanguage)
        ]],
        OldLanguage,
        NewLanguage,
        _PlayerID
    ));
end

function Swift.Text:Localize(_Text)
    local LocalizedText;
    if type(_Text) == "table" then
        LocalizedText = {};
        if _Text.en == nil and _Text[QSB.Language] == nil then
            for k,v in pairs(_Text) do
                if type(v) == "table" then
                    LocalizedText[k] = self:Localize(v);
                end
            end
        else
            if _Text[QSB.Language] then
                LocalizedText = _Text[QSB.Language];
            else
                for k, v in pairs(self.Languages) do
                    if v[1] == QSB.Language and v[3] ~= nil then
                        LocalizedText = _Text[v[3]];
                        break;
                    end
                end
            end
            if type(LocalizedText) == "table" then
                LocalizedText = "ERROR_NO_TEXT";
            end
        end
    else
        LocalizedText = tostring(_Text);
    end
    return LocalizedText;
end

-- -------------------------------------------------------------------------- --
-- Placeholder

function Swift.Text:ConvertPlaceholders(_Text)
    local s1, e1, s2, e2;
    while true do
        local Before, Placeholder, After, Replacement, s1, e1, s2, e2;
        if _Text:find("{n:") then
            Before, Placeholder, After, s1, e1, s2, e2 = self:SplicePlaceholderText(_Text, "{n:");
            Replacement = self.Placeholders.Names[Placeholder];
            _Text = Before .. self:Localize(Replacement or ("n:" ..tostring(Placeholder).. ": not found")) .. After;
        elseif _Text:find("{t:") then
            Before, Placeholder, After, s1, e1, s2, e2 = self:SplicePlaceholderText(_Text, "{t:");
            Replacement = self.Placeholders.EntityTypes[Placeholder];
            _Text = Before .. self:Localize(Replacement or ("n:" ..tostring(Placeholder).. ": not found")) .. After;
        elseif _Text:find("{v:") then
            Before, Placeholder, After, s1, e1, s2, e2 = self:SplicePlaceholderText(_Text, "{v:");
            Replacement = self:ReplaceValuePlaceholder(Placeholder);
            _Text = Before .. self:Localize(Replacement or ("v:" ..tostring(Placeholder).. ": not found")) .. After;
        end
        if s1 == nil or e1 == nil or s2 == nil or e2 == nil then
            break;
        end
    end
    _Text = self:ReplaceColorPlaceholders(_Text);
    return _Text;
end

function Swift.Text:SplicePlaceholderText(_Text, _Start)
    local s1, e1 = _Text:find(_Start);
    local s2, e2 = _Text:find("}", e1);

    local Before      = _Text:sub(1, s1-1);
    local Placeholder = _Text:sub(e1+1, s2-1);
    local After       = _Text:sub(e2+1);
    return Before, Placeholder, After, s1, e1, s2, e2;
end

function Swift.Text:ReplaceColorPlaceholders(_Text)
    for k, v in pairs(self.Colors) do
        _Text = _Text:gsub("{" ..k.. "}", v);
    end
    return _Text;
end

function Swift.Text:ReplaceValuePlaceholder(_Text)
    local Ref = _G;
    local Slice = string.slice(_Text, "%.");
    for i= 1, #Slice do
        local KeyOrIndex = Slice[i];
        local Index = tonumber(KeyOrIndex);
        if Index ~= nil then
            KeyOrIndex = Index;
        end
        if not Ref[KeyOrIndex] then
            return nil;
        end
        Ref = Ref[KeyOrIndex];
    end
    return Ref;
end

-- Slices a string of commands into multiple strings by resolving %% and % as
-- command delimiters.
-- * && separates entries from another and makes them different inputs
-- * & copys parameters for all commands chained with it
--
-- Example:
-- foo & bar 1 2 3 && muh 4
--
-- Result:
-- foo 1 2 3
-- bar 1 2 3
-- muh 4
function Swift.Text:CommandTokenizer(_Input)
    local Commands = {};
    if _Input == nil then
        return Commands;
    end
    local DAmberCommands = {_Input};
    local AmberCommands = {};

    -- parse && delimiter
    local s, e = string.find(_Input, "%s+&&%s+");
    if s then
        DAmberCommands = {};
        while (s) do
            local tmp = string.sub(_Input, 1, s-1);
            table.insert(DAmberCommands, tmp);
            _Input = string.sub(_Input, e+1);
            s, e = string.find(_Input, "%s+&&%s+");
        end
        if string.len(_Input) > 0 then 
            table.insert(DAmberCommands, _Input);
        end
    end

    -- parse & delimiter
    for i= 1, #DAmberCommands, 1 do
        local s, e = string.find(DAmberCommands[i], "%s+&%s+");
        if s then
            local LastCommand = "";
            while (s) do
                local tmp = string.sub(DAmberCommands[i], 1, s-1);
                table.insert(AmberCommands, LastCommand .. tmp);
                if string.find(tmp, " ") then
                    LastCommand = string.sub(tmp, 1, string.find(tmp, " ")-1) .. " ";
                end
                DAmberCommands[i] = string.sub(DAmberCommands[i], e+1);
                s, e = string.find(DAmberCommands[i], "%s+&%s+");
            end
            if string.len(DAmberCommands[i]) > 0 then 
                table.insert(AmberCommands, LastCommand .. DAmberCommands[i]);
            end
        else
            table.insert(AmberCommands, DAmberCommands[i]);
        end
    end

    -- parse spaces
    for i= 1, #AmberCommands, 1 do
        local CommandLine = {};
        local s, e = string.find(AmberCommands[i], "%s+");
        if s then
            while (s) do
                local tmp = string.sub(AmberCommands[i], 1, s-1);
                table.insert(CommandLine, tmp);
                AmberCommands[i] = string.sub(AmberCommands[i], e+1);
                s, e = string.find(AmberCommands[i], "%s+");
            end
            table.insert(CommandLine, AmberCommands[i]);
        else
            table.insert(CommandLine, AmberCommands[i]);
        end
        table.insert(Commands, CommandLine);
    end

    return Commands;
end

-- -------------------------------------------------------------------------- --
-- API

---
-- Ermittelt den lokalisierten Text anhand der eingestellten Sprache der QSB.
--
-- Wird ein normaler String übergeben, wird dieser sofort zurückgegeben.
-- Bei einem Table mit einem passenden Sprach-Key (de, en, fr, ...) wird die
-- entsprechende Sprache zurückgegeben. Sollte ein Nested Table übergeben
-- werden, werden alle Texte innerhalb des Tables rekursiv übersetzt als Table
-- zurückgegeben. Alle anderen Werte sind nicht in der Rückgabe enthalten.
--
-- @param[type=table] _Text Table mit Übersetzungen
-- @return Übersetzten Text oder Table mit Texten
-- @within Text
--
-- @usage
-- -- Beispiel #1: Table lokalisieren
-- local Text = API.Localize({de = "Deutsch", en = "English"});
-- -- Rückgabe: "Deutsch"
--
-- @usage
-- -- Beispiel #2: Mehrstufige (Nested) Tables
-- -- (Nested Tables sind in dem Fall mit Vorsicht zu genießen!)
-- API.Localize{{de = "Deutsch", en = "English"}, {{1,2,3,4, de = "A", en = "B"}}}
-- -- Rückgabe: {"Deutsch", {"A"}}
--
function API.Localize(_Text)
    return Swift.Text:Localize(_Text);
end

---
-- Schreibt eine Nachricht in das Debug Window. Der Text erscheint links am
-- Bildschirm und ist nicht statisch.
-- 
-- <i>Platzhalter werden automatisch im aufrufenden Environment ersetzt.</i><br>
-- <i>Multilinguale Texte werden automatisch im aufrufenden Environment übersetzt.</i>
--
-- <b>Hinweis:</b> Texte werden automatisch lokalisiert und Platzhalter ersetzt.
--
-- @param[type=string] _Text Anzeigetext
-- @within Text
--
-- @usage
-- API.Note("Das ist eine flüchtige Information!");
--
function API.Note(_Text)
    _Text = Swift.Text:ConvertPlaceholders(Swift.Text:Localize(_Text));
    if not GUI then
        Logic.DEBUG_AddNote(_Text);
        return;
    end
    GUI.AddNote(_Text);
end

---
-- Schreibt eine Nachricht in das Debug Window. Der Text erscheint links am
-- Bildschirm und verbleibt dauerhaft am Bildschirm.
-- 
-- <i>Platzhalter werden automatisch im aufrufenden Environment ersetzt.</i><br>
-- <i>Multilinguale Texte werden automatisch im aufrufenden Environment übersetzt.</i>
--
-- <b>Hinweis:</b> Texte werden automatisch lokalisiert und Platzhalter ersetzt.
--
-- @param[type=string] _Text Anzeigetext
-- @within Text
--
-- @usage
-- API.StaticNote("Das ist eine dauerhafte Information!");
--
function API.StaticNote(_Text)
    _Text = Swift.Text:ConvertPlaceholders(Swift.Text:Localize(_Text));
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[GUI.AddStaticNote("%s")]],
            _Text
        ));
        return;
    end
    GUI.AddStaticNote(_Text);
end

---
-- Schreibt eine Nachricht unten in das Nachrichtenfenster. Die Nachricht
-- verschwindet nach einigen Sekunden.
-- 
-- <i>Platzhalter werden automatisch im aufrufenden Environment ersetzt.</i><br>
-- <i>Multilinguale Texte werden automatisch im aufrufenden Environment übersetzt.</i>
--
-- <b>Hinweis:</b> Texte werden automatisch lokalisiert und Platzhalter ersetzt.
--
-- @param[type=string] _Text  Anzeigetext
-- @param[type=string] _Sound (Optional) Soundeffekt der Nachricht
-- @within Text
--
-- @usage
-- -- Beispiel #1: Einfache Nachricht
-- API.Message("Das ist eine Nachricht!");
--
-- @usage
-- -- Beispiel #2: Nachricht und Ton
-- API.Message("Das ist eine WERTVOLLE Nachricht!", "ui/menu_left_gold_pay");
--
function API.Message(_Text, _Sound)
    _Text = Swift.Text:ConvertPlaceholders(Swift.Text:Localize(_Text));
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.Message("%s", %s)]],
            _Text,
            _Sound
        ));
        return;
    end
    _Text = Swift.Text:ConvertPlaceholders(API.Localize(_Text));
    if _Sound then
        _Sound = _Sound:gsub("/", "\\");
    end
    Message(_Text, _Sound);
end

---
-- Löscht alle Nachrichten im Debug Window.
--
-- @within Text
--
-- @usage
-- API.ClearNotes();
--
function API.ClearNotes()
    if not GUI then
        Logic.ExecuteInLuaLocalState([[API.ClearNotes()]]);
        return;
    end
    GUI.ClearNotes();
end

---
-- Ersetzt alle Platzhalter im Text oder in der Table.
--
-- Mögliche Platzhalter:
-- <ul>
-- <li>{n:xyz} - Ersetzt einen Skriptnamen mit dem zuvor gesetzten Wert.</li>
-- <li>{t:xyz} - Ersetzt einen Typen mit dem zuvor gesetzten Wert.</li>
-- <li>{v:xyz} - Ersetzt mit dem Inhalt der angegebenen Variable. Der Wert muss
-- in der Umgebung vorhanden sein, in der er ersetzt wird.</li>
-- </ul>
--
-- Außerdem werden einige Standardfarben ersetzt.
-- <pre>{COLOR}</pre>
-- Ersetze {COLOR} in deinen Texten mit einer der gelisteten Farben.
--
-- <table border="1">
-- <tr><th><b>Platzhalter</b></th><th><b>Farbe</b></th><th><b>RGBA</b></th></tr>
--
-- <tr><td>red</td>     <td>Rot</td>           <td>255,80,80,255</td></tr>
-- <tr><td>blue</td>    <td>Blau</td>          <td>104,104,232,255</td></tr>
-- <tr><td>yellow</td>  <td>Gelp</td>          <td>255,255,80,255</td></tr>
-- <tr><td>green</td>   <td>Grün</td>          <td>80,180,0,255</td></tr>
-- <tr><td>white</td>   <td>Weiß</td>          <td>255,255,255,255</td></tr>
-- <tr><td>black</td>   <td>Schwarz</td>       <td>0,0,0,255</td></tr>
-- <tr><td>grey</td>    <td>Grau</td>          <td>140,140,140,255</td></tr>
-- <tr><td>azure</td>   <td>Azurblau</td>      <td>255,176,30,255</td></tr>
-- <tr><td>orange</td>  <td>Orange</td>        <td>255,176,30,255</td></tr>
-- <tr><td>amber</td>   <td>Bernstein</td>     <td>224,197,117,255</td></tr>
-- <tr><td>violet</td>  <td>Violett</td>       <td>180,100,190,255</td></tr>
-- <tr><td>pink</td>    <td>Rosa</td>          <td>255,170,200,255</td></tr>
-- <tr><td>scarlet</td> <td>Scharlachrot</td>  <td>190,0,0,255</td></tr>
-- <tr><td>magenta</td> <td>Magenta</td>       <td>190,0,89,255</td></tr>
-- <tr><td>olive</td>   <td>Olivgrün</td>      <td>74,120,0,255</td></tr>
-- <tr><td>sky</td>     <td>Himmelsblau</td>   <td>145,170,210,255</td></tr>
-- <tr><td>tooltip</td> <td>Tooltip-Blau</td>  <td>51,51,120,255</td></tr>
-- <tr><td>lucid</td>   <td>Transparent</td>   <td>0,0,0,0</td></tr>
-- <tr><td>none</td>    <td>Standardfarbe</td> <td>(Abhängig vom Widget)</td></tr>
-- </table>
--
-- @param[type=string] _Message Text
-- @return Ersetzter Text
-- @within Text
--
-- @usage
-- -- Beispiel #1: Vordefinierte Farbe austauschen
-- local Replaced = API.ConvertPlaceholders("{scarlet}Dieser Text ist jetzt rot!");
--
-- @usage
-- -- Beispiel #2: Skriptnamen austauschen
-- local Replaced = API.ConvertPlaceholders("{n:placeholder2} wurde ersetzt!");
--
-- @usage
-- -- Beispiel #3: Typen austauschen
-- local Replaced = API.ConvertPlaceholders("{t:U_KnightHealing} wurde ersetzt!");
--
-- @usage
-- -- Beispiel #4: Variable austauschen
-- local Replaced = API.ConvertPlaceholders("{v:MyVariable.1.MyValue} wurde ersetzt!");
--
function API.ConvertPlaceholders(_Message)
    if type(_Message) == "table" then
        for k, v in pairs(_Message) do
            _Message[k] = Swift.Text:ConvertPlaceholders(v);
        end
        return API.Localize(_Message);
    elseif type(_Message) == "string" then
        return Swift.Text:ConvertPlaceholders(_Message);
    else
        return _Message;
    end
end

---
-- Fügt einen Platzhalter für den angegebenen Namen hinzu.
--
-- Innerhalb des Textes wird der Plathalter wie folgt geschrieben:
-- <pre>{n:SOME_NAME}</pre>
-- SOME_NAME muss mit dem Namen ersetzt werden.
--
-- @param[type=string] _Name        Name, der ersetzt werden soll
-- @param[type=string] _Replacement Wert, der ersetzt wird
-- @within Text
--
-- @usage
-- API.AddNamePlaceholder("Scriptname", "Horst");
-- API.AddNamePlaceholder("Scriptname", {de = "Kuchen", en = "Cake"});
--
function API.AddNamePlaceholder(_Name, _Replacement)
    if type(_Replacement) == "function" or type(_Replacement) == "thread" then
        error("API.AddNamePlaceholder: Only strings, numbers, or tables are allowed!");
        return;
    end
    Swift.Text.Placeholders.Names[_Name] = _Replacement;
end

---
-- Fügt einen Platzhalter für einen Entity-Typ hinzu.
--
-- Innerhalb des Textes wird der Plathalter wie folgt geschrieben:
-- <pre>{t:ENTITY_TYP}</pre>
-- ENTITY_TYP muss mit einem Entity-Typ ersetzt werden. Der Typ wird ohne
-- Entities. davor geschrieben.
--
-- @param[type=string] _Type        Typname, der ersetzt werden soll
-- @param[type=string] _Replacement Wert, der ersetzt wird
-- @within Text
--
-- @usage
-- API.AddNamePlaceholder("U_KnightHealing", "Arroganze Ziege");
-- API.AddNamePlaceholder("B_Castle_SE", {de = "Festung des Bösen", en = "Fortress of Evil"});
--
function API.AddEntityTypePlaceholder(_Type, _Replacement)
    if Entities[_Type] == nil then
        error("API.AddEntityTypePlaceholder: EntityType does not exist!");
        return;
    end
    Swift.Text.Placeholders.EntityTypes[_Type] = _Replacement;
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Es werden einige Fehler im Spiel behoben.
--
-- @set sort=true
-- @local
--

Swift.Bugfix = {};

function Swift.Bugfix:Initalize()
    if Swift.Environment == QSB.Environment.GLOBAL then
        self:FixResourceSlotsInStorehouses();
        self:OverrideConstructionCompleteCallback();
        self:OverrideIsMerchantArrived();
        self:OverrideIsObjectiveCompleted();
    end
    if Swift.Environment == QSB.Environment.LOCAL then
        self:FixInteractiveObjectClicked();
    end
end

function Swift.Bugfix:OnSaveGameLoaded()
end

-- -------------------------------------------------------------------------- --
-- Luxury for NPCs

function Swift.Bugfix:FixResourceSlotsInStorehouses()
    for i= 1, 8 do
        local StoreHouseID = Logic.GetStoreHouse(i);
        if StoreHouseID ~= 0 then
            Logic.AddGoodToStock(StoreHouseID, Goods.G_Salt, 0, true, true);
            Logic.AddGoodToStock(StoreHouseID, Goods.G_Dye, 0, true, true);
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Respawning for ME barracks

function Swift.Bugfix:OverrideConstructionCompleteCallback()
    GameCallback_OnBuildingConstructionComplete_Orig_QSB_Core = GameCallback_OnBuildingConstructionComplete;
    GameCallback_OnBuildingConstructionComplete = function(_PlayerID, _EntityID)
        GameCallback_OnBuildingConstructionComplete_Orig_QSB_Core(_PlayerID, _EntityID);
        local EntityType = Logic.GetEntityType(_EntityID);
        if EntityType == Entities.B_NPC_Barracks_ME then
            Logic.RespawnResourceSetMaxSpawn(_EntityID, 0.01);
            Logic.RespawnResourceSetMinSpawn(_EntityID, 0.01);
        end
    end

    for k, v in pairs(Logic.GetEntitiesOfType(Entities.B_NPC_Barracks_ME)) do
        Logic.RespawnResourceSetMaxSpawn(v, 0.01);
        Logic.RespawnResourceSetMinSpawn(v, 0.01);
    end
end

-- -------------------------------------------------------------------------- --
-- Delivery checkpoint

function Swift.Bugfix:OverrideIsMerchantArrived()
    function QuestTemplate:IsMerchantArrived(objective)
        if objective.Data[3] ~= nil then
            if objective.Data[3] == 1 then
                if objective.Data[5].ID ~= nil then
                    objective.Data[3] = objective.Data[5].ID;
                    DeleteQuestMerchantWithID(objective.Data[3]);
                    if MapCallback_DeliverCartSpawned then
                        MapCallback_DeliverCartSpawned(self, objective.Data[3], objective.Data[1]);
                    end
                end
            elseif Logic.IsEntityDestroyed(objective.Data[3]) then
                DeleteQuestMerchantWithID(objective.Data[3]);
                objective.Data[3] = nil;
                objective.Data[5].ID = nil;
            else
                local Target = objective.Data[6] and objective.Data[6] or self.SendingPlayer;
                local StorehouseID = Logic.GetStoreHouse(Target);
                local MarketplaceID = Logic.GetStoreHouse(Target);
                local HeadquartersID = Logic.GetStoreHouse(Target);
                local HasArrived = nil;

                if StorehouseID > 0 then
                    local x,y = Logic.GetBuildingApproachPosition(StorehouseID);
                    HasArrived = API.GetDistance(objective.Data[3], {X= x, Y= y}) < 1000;
                end
                if MarketplaceID > 0 then
                    local x,y = Logic.GetBuildingApproachPosition(MarketplaceID);
                    HasArrived = HasArrived or API.GetDistance(objective.Data[3], {X= x, Y= y}) < 1000;
                end
                if HeadquartersID > 0 then
                    local x,y = Logic.GetBuildingApproachPosition(HeadquartersID);
                    HasArrived = HasArrived or API.GetDistance(objective.Data[3], {X= x, Y= y}) < 1000;
                end
                return HasArrived;
            end
        end
        return false;
    end
end

-- -------------------------------------------------------------------------- --
-- IO costs

function Swift.Bugfix:FixInteractiveObjectClicked()
    GUI_Interaction.InteractiveObjectClicked = function()
        local ButtonNumber = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));
        local ObjectID = g_Interaction.ActiveObjectsOnScreen[ButtonNumber];
        if ObjectID == nil or not Logic.InteractiveObjectGetAvailability(ObjectID) then
            return;
        end
        local PlayerID = GUI.GetPlayerID();
        local Costs = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};
        local CanNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_Resources");

        -- Check activation costs
        local Affordable = true;
        if Affordable and Costs ~= nil and Costs[1] ~= nil then
            if Costs[1] == Goods.G_Gold then
                CanNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_G_Gold");
            end
            if Costs[1] ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(Costs[1]) ~= GoodCategories.GC_Resource then
                error("Only resources can be used as costs for objects!");
                Affordable = false;
            end
            Affordable = Affordable and GetPlayerGoodsInSettlement(Costs[1], PlayerID, false) >= Costs[2];
        end
        if Affordable and Costs ~= nil and Costs[3] ~= nil then
            if Costs[3] == Goods.G_Gold then
                CanNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_G_Gold");
            end
            if Costs[3] ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(Costs[3]) ~= GoodCategories.GC_Resource then
                error("Only resources can be used as costs for objects!");
                Affordable = false;
            end
            Affordable = Affordable and GetPlayerGoodsInSettlement(Costs[3], PlayerID, false) >= Costs[4];
        end
        if not Affordable then
            Message(CanNotBuyString);
            return;
        end

        -- Check click override
        if not GUI_Interaction.InteractionClickOverride
        or not GUI_Interaction.InteractionClickOverride(ObjectID) then
            Sound.FXPlay2DSound( "ui\\menu_click");
        end
        -- Check feedback speech override
        if not GUI_Interaction.InteractionSpeechFeedbackOverride
        or not GUI_Interaction.InteractionSpeechFeedbackOverride(ObjectID) then
            GUI_FeedbackSpeech.Add("SpeechOnly_CartsSent", g_FeedbackSpeech.Categories.CartsUnderway, nil, nil);
        end
        -- Check action override and perform action
        if not Mission_Callback_OverrideObjectInteraction
        or not Mission_Callback_OverrideObjectInteraction(ObjectID, PlayerID, Costs) then
            GUI.ExecuteObjectInteraction(ObjectID, PlayerID);
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Destroy all units

function Swift.Bugfix:OverrideIsObjectiveCompleted()
    QuestTemplate.IsObjectiveCompleted_Orig_QSB_Kernel = QuestTemplate.IsObjectiveCompleted;
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        local objectiveType = objective.Type;
        if objective.Completed ~= nil then
            return objective.Completed;
        end
        local data = objective.Data;

        -- Solves the problem that special entities and construction sites
        -- let the script beleave that the player is still alive.
        if objectiveType == Objective.DestroyAllPlayerUnits then
            local PlayerEntities = GetPlayerEntities(data, 0);
            local IllegalEntities = {};

            for i= #PlayerEntities, 1, -1 do
                local Type = Logic.GetEntityType(PlayerEntities[i]);
                if Logic.IsEntityInCategory(PlayerEntities[i], EntityCategories.AttackableBuilding) == 0 or Logic.IsEntityInCategory(PlayerEntities[i], EntityCategories.Wall) == 0 then
                    if Logic.IsConstructionComplete(PlayerEntities[i]) == 0 then
                        table.insert(IllegalEntities, PlayerEntities[i]);
                    end
                end
                local IndestructableEntities = {Entities.XD_ScriptEntity, Entities.S_AIHomePosition, Entities.S_AIAreaDefinition};
                if table.contains(IndestructableEntities, Type) then
                    table.insert(IllegalEntities, PlayerEntities[i]);
                end
            end

            if #PlayerEntities == 0 or #PlayerEntities - #IllegalEntities == 0 then
                objective.Completed = true;
            end
        elseif objectiveType == Objective.Distance then
            objective.Completed = Swift.Behavior:IsQuestPositionReached(self, objective);
        else
            return self:IsObjectiveCompleted_Orig_QSB_Kernel(objective);
        end
    end
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Eine Sammlung von nützlichen Hilfsfunktionen.
-- @set sort=true
-- @local
--

Swift.Utils = {}

QSB.RefillAmounts = {};
QSB.CustomVariable = {};

function Swift.Utils:Initalize()
    QSB.ScriptEvents.CustomValueChanged = Swift.Event:CreateScriptEvent("Event_CustomValueChanged");
    if Swift.Environment == QSB.Environment.GLOBAL then
        self:OverwriteGeologistRefill();
    end
end

function Swift.Utils:OnSaveGameLoaded()
end

function Swift.Utils:OverwriteGeologistRefill()
    if Framework.GetGameExtraNo() >= 1 then
        GameCallback_OnGeologistRefill_Orig_QSB_Kernel = GameCallback_OnGeologistRefill;
        GameCallback_OnGeologistRefill = function(_PlayerID, _TargetID, _GeologistID)
            GameCallback_OnGeologistRefill_Orig_QSB_Kernel(_PlayerID, _TargetID, _GeologistID);
            if QSB.RefillAmounts[_TargetID] then
                local RefillAmount = QSB.RefillAmounts[_TargetID];
                local RefillRandom = RefillAmount + math.random(1, math.floor((RefillAmount * 0.2) + 0.5));
                Logic.SetResourceDoodadGoodAmount(_TargetID, RefillRandom);
                if RefillRandom > 0 then
                    if Logic.GetResourceDoodadGoodType(_TargetID) == Goods.G_Iron then
                        Logic.SetModel(_TargetID, Models.Doodads_D_SE_ResourceIron);
                    else
                        Logic.SetModel(_TargetID, Models.R_ResorceStone_Scaffold);
                    end
                end
            end
        end
    end
end

function Swift.Utils:TriggerEntityKilledCallbacks(_Entity, _Attacker)
    local DefenderID = GetID(_Entity);
    local AttackerID = GetID(_Attacker or 0);
    if AttackerID == 0 or DefenderID == 0 or Logic.GetEntityHealth(DefenderID) > 0 then
        return;
    end
    local x, y, z     = Logic.EntityGetPos(DefenderID);
    local DefPlayerID = Logic.EntityGetPlayer(DefenderID);
    local DefType     = Logic.GetEntityType(DefenderID);
    local AttPlayerID = Logic.EntityGetPlayer(AttackerID);
    local AttType     = Logic.GetEntityType(AttackerID);

    GameCallback_EntityKilled(DefenderID, DefPlayerID, AttackerID, AttPlayerID, DefType, AttType);
    Logic.ExecuteInLuaLocalState(string.format(
        "GameCallback_Feedback_EntityKilled(%d, %d, %d, %d,%d, %d, %f, %f)",
        DefenderID, DefPlayerID, AttackerID, AttPlayerID, DefType, AttType, x, y
    ));
end

function Swift.Utils:GetCustomVariable(_Name)
    return QSB.CustomVariable[_Name];
end

function Swift.Utils:SetCustomVariable(_Name, _Value)
    Swift.Utils:UpdateCustomVariable(_Name, _Value);
    local Value = tostring(_Value);
    if type(_Value) ~= "number" then
        Value = [["]] ..Value.. [["]];
    end
    if GUI then
        Swift.Event:DispatchScriptCommand(QSB.ScriptCommands.UpdateCustomVariable, 0, _Name, Value);
    else
        Logic.ExecuteInLuaLocalState(string.format(
            [[Swift.Utils:UpdateCustomVariable("%s", %s)]],
            _Name,
            Value
        ));
    end
end

function Swift.Utils:UpdateCustomVariable(_Name, _Value)
    if QSB.CustomVariable[_Name] then
        local Old = QSB.CustomVariable[_Name];
        QSB.CustomVariable[_Name] = _Value;
        Swift.Event:DispatchScriptEvent(
            QSB.ScriptEvents.CustomValueChanged,
            _Name,
            Old,
            _Value
        );
    else
        QSB.CustomVariable[_Name] = _Value;
        Swift.Event:DispatchScriptEvent(
            QSB.ScriptEvents.CustomValueChanged,
            _Name,
            nil,
            _Value
        );
    end
end

---
-- Speichert den Wert der Custom Variable im globalen und lokalen Skript.
--
-- Des weiteren wird in beiden Umgebungen ein Event ausgelöst, wenn der Wert
-- gesetzt wird. Das Event bekommt den Namen der Variable, den alten Wert und
-- den neuen Wert übergeben.
--
-- @param[type=boolean] _Name  Name der Custom Variable
-- @param               _Value Neuer Wert
-- @within System
-- @local
--
-- @usage
-- local Value = API.ObtainCustomVariable("MyVariable", 0);
--
function API.SaveCustomVariable(_Name, _Value)
    Swift.Utils:SetCustomVariable(_Name, _Value);
end

---
-- Gibt den aktuellen Wert der Custom Variable zurück oder den Default-Wert.
-- @param[type=boolean] _Name    Name der Custom Variable
-- @param               _Default (Optional) Defaultwert falls leer
-- @return Wert
-- @within System
-- @local
--
-- @usage
-- local Value = API.ObtainCustomVariable("MyVariable", 0);
--
function API.ObtainCustomVariable(_Name, _Default)
    local Value = QSB.CustomVariable[_Name];
    if not Value and _Default then
        Value = _Default;
    end
    return Value;
end

-- -------------------------------------------------------------------------- --
-- Entity

---
-- Ersetzt ein Entity mit einem neuen eines anderen Typs. Skriptname,
-- Rotation, Position und Besitzer werden übernommen.
--
-- Für Siedler wird automatisch die Tasklist TL_NPC_IDLE gesetzt, damit
-- sie nicht versteinert in der Landschaft rumstehen.
--
-- <b>Hinweis</b>: Die Entity-ID ändert sich und beim Ersetzen von
-- Spezialgebäuden kann eine Niederlage erfolgen.
--
-- @param _Entity      Entity (Skriptname oder ID)
-- @param[type=number] _Type     Neuer Typ
-- @param[type=number] _NewOwner (optional) Neuer Besitzer
-- @return[type=number] Entity-ID des Entity
-- @within Entity
-- @usage
-- API.ReplaceEntity("Stein", Entities.XD_ScriptEntity)
--
function API.ReplaceEntity(_Entity, _Type, _NewOwner)
    local ID1 = GetID(_Entity);
    if ID1 == 0 then
        return;
    end
    local pos = GetPosition(ID1);
    local player = _NewOwner or Logic.EntityGetPlayer(ID1);
    local orientation = Logic.GetEntityOrientation(ID1);
    local name = Logic.GetEntityName(ID1);
    DestroyEntity(ID1);
    local ID2 = Logic.CreateEntity(_Type, pos.X, pos.Y, orientation, player);
    Logic.SetEntityName(ID2, name);
    if Logic.IsSettler(ID2) == 1 then
        Logic.SetTaskList(ID2, TaskLists.TL_NPC_IDLE);
    end
    return ID2;
end
ReplaceEntity = API.ReplaceEntity;

---
-- Setzt das Entity oder das Battalion verwundbar oder unverwundbar.
--
-- @param               _Entity Entity (Scriptname oder ID)
-- @param[type=boolean] _Flag Verwundbar
-- @within Entity
-- @local
--
function API.SetEntityVulnerableFlag(_Entity, _Flag)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    local VulnerabilityFlag = (_Flag and 1) or 0;
    if EntityID > 0 then
        local SoldierTable = {Logic.GetSoldiersAttachedToLeader(EntityID)};
        if SoldierTable[1] and SoldierTable[1] > 0 then
            for i= 2, SoldierTable[1]+1 do
                Logic.SetEntityInvulnerabilityFlag(SoldierTable[i], VulnerabilityFlag);
            end
        end
        Logic.SetEntityInvulnerabilityFlag(EntityID, VulnerabilityFlag);
    end
end

MakeVulnerable = function(_Entity)
    API.SetEntityVulnerableFlag(_Entity, false);
end
MakeInvulnerable = function(_Entity)
    API.SetEntityVulnerableFlag(_Entity, true);
end

---
-- Sendet einen Handelskarren zu dem Spieler. Startet der Karren von einem
-- Gebäude, wird immer die Position des Eingangs genommen.
--
-- @param _Position                        Position (Skriptname oder Entity-ID)
-- @param[type=number] _PlayerID           Zielspieler
-- @param[type=number] _GoodType           Warentyp
-- @param[type=number] _Amount             Warenmenge
-- @param[type=number] _CartOverlay        (optional) Overlay für Goldkarren
-- @param[type=boolean] _IgnoreReservation (optional) Marktplatzreservation ignorieren
-- @param[type=boolean] _Overtake          (optional) Mit Position austauschen
-- @return[type=number] Entity-ID des erzeugten Wagens
-- @within System
-- @usage
-- -- API-Call
-- API.SendCart(Logic.GetStoreHouse(1), 2, Goods.G_Grain, 45)
--
function API.SendCart(_Position, _PlayerID, _GoodType, _Amount, _CartOverlay, _IgnoreReservation, _Overtake)
    local OriginalID = GetID(_Position);
    if not IsExisting(OriginalID) then
        return;
    end
    local ID;
    local x,y,z = Logic.EntityGetPos(OriginalID);
    local ResourceCategory = Logic.GetGoodCategoryForGoodType(_GoodType);
    local Orientation = Logic.GetEntityOrientation(OriginalID);
    local ScriptName = Logic.GetEntityName(OriginalID);
    if Logic.IsBuilding(OriginalID) == 1 then
        x,y = Logic.GetBuildingApproachPosition(OriginalID);
        Orientation = Logic.GetEntityOrientation(OriginalID)-90;
    end

    -- Macht Waren lagerbar im Lagerhaus
    if ResourceCategory == GoodCategories.GC_Resource or _GoodType == Goods.G_None then
        local TypeName = Logic.GetGoodTypeName(_GoodType);
        local SHID = Logic.GetStoreHouse(_PlayerID);
        local HQID = Logic.GetHeadquarters(_PlayerID);
        if SHID ~= 0 and Logic.GetIndexOnInStockByGoodType(SHID, _GoodType) == -1 then
            if _GoodType ~= Goods.G_Gold or (_GoodType == Goods.G_Gold and HQID == 0) then
                info(
                    "API.SendCart: creating stock for " ..TypeName.. " in" ..
                    "storehouse of player " .._PlayerID.. "."
                );
                Logic.AddGoodToStock(SHID, _GoodType, 0, true, true);
            end
        end
    end

    info("API.SendCart: Creating cart ("..
        tostring(_Position) ..","..
        tostring(_PlayerID) ..","..
        Logic.GetGoodTypeName(_GoodType) ..","..
        tostring(_Amount) ..","..
        tostring(_CartOverlay) ..","..
        tostring(_IgnoreReservation) ..
    ")");

    if ResourceCategory == GoodCategories.GC_Resource then
        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_ResourceMerchant, x, y, Orientation, _PlayerID);
    elseif _GoodType == Goods.G_Medicine then
        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Medicus, x, y, Orientation,_PlayerID);
    elseif _GoodType == Goods.G_Gold or _GoodType == Goods.G_None or _GoodType == Goods.G_Information then
        if _CartOverlay then
            ID = Logic.CreateEntityOnUnblockedLand(_CartOverlay, x, y, Orientation, _PlayerID);
        else
            ID = Logic.CreateEntityOnUnblockedLand(Entities.U_GoldCart, x, y, Orientation, _PlayerID);
        end
    else
        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Marketer, x, y, Orientation, _PlayerID);
    end
    info("API.SendCart: Executing hire merchant...");
    Logic.HireMerchant(ID, _PlayerID, _GoodType, _Amount, _PlayerID, _IgnoreReservation);
    if _Overtake and Logic.IsBuilding(OriginalID) == 0 then
        info("API.SendCart: Cart replaced original.");
        Logic.SetEntityName(ID, ScriptName);
        DestroyEntity(OriginalID);
    end
    info("API.SendCart: Cart has been send successfully.");
    return ID
end

---
-- Gibt die relative Gesundheit des Entity zurück.
--
-- <b>Hinweis</b>: Der Wert wird als Prozentwert zurückgegeben. Das bedeutet,
-- der Wert liegt zwischen 0 und 100.
--
-- @param _Entity Entity (Scriptname oder ID)
-- @return[type=number] Aktuelle Gesundheit
-- @within Entity
--
function API.GetEntityHealth(_Entity)
    local EntityID = GetID(_Entity);
    if IsExisting(EntityID) then
        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);
        local Health    = Logic.GetEntityHealth(EntityID);
        return (Health/MaxHealth) * 100;
    end
    error("API.GetEntityHealth: _Entity (" ..tostring(_Entity).. ") does not exist!");
    return 0;
end

---
-- Setzt die Gesundheit des Entity. Optional kann die Gesundheit relativ zur
-- maximalen Gesundheit geändert werden.
--
-- @param               _Entity   Entity (Scriptname oder ID)
-- @param[type=number]  _Health   Neue aktuelle Gesundheit
-- @param[type=boolean] _Relative (Optional) Relativ zur maximalen Gesundheit
-- @within Entity
--
function API.ChangeEntityHealth(_Entity, _Health, _Relative)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID > 0 then
        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);
        if type(_Health) ~= "number" or _Health < 0 then
            error("API.ChangeEntityHealth: _Health " ..tostring(_Health).. "must be 0 or greater!");
            return
        end
        _Health = (_Health > MaxHealth and MaxHealth) or _Health;
        if Logic.IsLeader(EntityID) == 1 then
            local SoldierTable = {Logic.GetSoldiersAttachedToLeader(EntityID)};
            for i= 2, SoldierTable[1]+1 do
                API.ChangeEntityHealth(SoldierTable[i], _Health, _Relative);
            end
        else
            local OldHealth = Logic.GetEntityHealth(EntityID);
            local NewHealth = _Health;
            if _Relative then
                _Health = (_Health < 0 and 0) or _Health;
                _Health = (_Health > 100 and 100) or _Health;
                NewHealth = math.ceil((MaxHealth) * (_Health/100));
            end
            if NewHealth > OldHealth then
                Logic.HealEntity(EntityID, NewHealth - OldHealth);
            elseif NewHealth < OldHealth then
                Logic.HurtEntity(EntityID, OldHealth - NewHealth);
            end
        end
        return;
    end
    error("API.ChangeEntityHealth: _Entity (" ..tostring(_Entity).. ") does not exist!");
end

---
-- Setzt die Menge an Rohstoffen und die durchschnittliche Auffüllmenge
-- in einer Mine.
--
-- @param              _Entity       Rohstoffvorkommen (Skriptname oder ID)
-- @param[type=number] _StartAmount  Menge an Rohstoffen
-- @param[type=number] _RefillAmount Minimale Nachfüllmenge (> 0)
-- @within Entity
--
-- @usage
-- API.SetResourceAmount("mine1", 250, 150);
--
function API.SetResourceAmount(_Entity, _StartAmount, _RefillAmount)
    if GUI or not IsExisting(_Entity) then
        return;
    end
    assert(type(_StartAmount) == "number");
    assert(type(_RefillAmount) == "number");

    local EntityID = GetID(_Entity);
    if not IsExisting(EntityID) or Logic.GetResourceDoodadGoodType(EntityID) == 0 then
        return;
    end
    if Logic.GetResourceDoodadGoodAmount(EntityID) == 0 then
        EntityID = API.ReplaceEntity(EntityID, Logic.GetEntityType(EntityID));
    end
    Logic.SetResourceDoodadGoodAmount(EntityID, _StartAmount);
    if _RefillAmount then
        QSB.RefillAmounts[EntityID] = _RefillAmount;
    end
end

---
-- Gibt dem Entity einen eindeutigen Skriptnamen und gibt ihn zurück.
-- Hat das Entity einen Namen, bleibt dieser unverändert und wird
-- zurückgegeben.
-- @param[type=number] _EntityID Entity ID
-- @return[type=string] Skriptname
-- @within System
--
function API.CreateEntityName(_EntityID)
    if type(_EntityID) == "string" then
        return _EntityID;
    else
        assert(type(_EntityID) == "number");
        local name = Logic.GetEntityName(_EntityID);
        if (type(name) ~= "string" or name == "" ) then
            QSB.GiveEntityNameCounter = (QSB.GiveEntityNameCounter or 0)+ 1;
            name = "AutomaticScriptName_"..QSB.GiveEntityNameCounter;
            Logic.SetEntityName(_EntityID, name);
        end
        return name;
    end
end

-- Mögliche (zufällige) Siedler, getrennt in männlich und weiblich.
QSB.PossibleSettlerTypes = {
    Male = {
        Entities.U_BannerMaker,
        Entities.U_Baker,
        Entities.U_Barkeeper,
        Entities.U_Blacksmith,
        Entities.U_Butcher,
        Entities.U_BowArmourer,
        Entities.U_BowMaker,
        Entities.U_CandleMaker,
        Entities.U_Carpenter,
        Entities.U_DairyWorker,
        Entities.U_Pharmacist,
        Entities.U_Tanner,
        Entities.U_SmokeHouseWorker,
        Entities.U_Soapmaker,
        Entities.U_SwordSmith,
        Entities.U_Weaver,
    },
    Female = {
        Entities.U_BathWorker,
        Entities.U_SpouseS01,
        Entities.U_SpouseS02,
        Entities.U_SpouseS03,
        Entities.U_SpouseF01,
        Entities.U_SpouseF02,
        Entities.U_SpouseF03,
    }
}

---
-- Wählt aus einer festen Liste von Typen einen zufälligen Siedler-Typ aus.
-- Es werden nur Stadtsiedler zurückgegeben. Sie können männlich oder
-- weiblich sein.
--
-- @return[type=number] Zufälliger Typ
-- @within Entity
-- @local
--
function API.GetRandomSettlerType()
    local Gender = (math.random(1, 2) == 1 and "Male") or "Female";
    local Type   = math.random(1, #QSB.PossibleSettlerTypes[Gender]);
    return QSB.PossibleSettlerTypes[Gender][Type];
end

---
-- Wählt aus einer Liste von Typen einen zufälligen männlichen Siedler aus. Es
-- werden nur Stadtsiedler zurückgegeben.
--
-- @return[type=number] Zufälliger Typ
-- @within Entity
-- @local
--
function API.GetRandomMaleSettlerType()
    local Type = math.random(1, #QSB.PossibleSettlerTypes.Male);
    return QSB.PossibleSettlerTypes.Male[Type];
end

---
-- Wählt aus einer Liste von Typen einen zufälligen weiblichen Siedler aus. Es
-- werden nur Stadtsiedler zurückgegeben.
--
-- @return[type=number] Zufälliger Typ
-- @within Entity
-- @local
--
function API.GetRandomFemaleSettlerType()
    local Type = math.random(1, #QSB.PossibleSettlerTypes.Female);
    return QSB.PossibleSettlerTypes.Female[Type];
end

---
-- Gibt das Entity aus der Liste zurück, welches dem Ziel am nähsten ist.
--
-- @param             _Target Entity oder Position
-- @param[type=table] _List   Liste von Entities oder Positionen
-- @return Nähste Entity oder Position
-- @within Position
-- @usage
-- local Clostest = API.GetClosestToTarget("HQ1", {"Marcus", "Alandra", "Hakim"});
--
function API.GetClosestToTarget(_Target, _List)
    local ClosestToTarget = 0;
    local ClosestToTargetDistance = Logic.WorldGetSize();
    for i= 1, #_List, 1 do
        local DistanceBetween = API.GetDistance(_List[i], _Target);
        if DistanceBetween < ClosestToTargetDistance then
            ClosestToTargetDistance = DistanceBetween;
            ClosestToTarget = _List[i];
        end
    end
    return ClosestToTarget;
end

---
-- Lokalisiert ein Entity auf der Map. Es können sowohl Skriptnamen als auch
-- IDs verwendet werden. Wenn das Entity nicht gefunden wird, wird eine
-- Tabelle mit XYZ = 0 zurückgegeben.
--
-- @param _Entity Entity (Skriptname oder ID)
-- @return[type=table] Positionstabelle {X= x, Y= y, Z= z}
-- @within Position
-- @usage
-- local Position = API.GetPosition("Hans");
--
function API.GetPosition(_Entity)
    if _Entity == nil then
        return {X= 0, Y= 0, Z= 0};
    end
    if (type(_Entity) == "table") then
        return _Entity;
    end
    if (not IsExisting(_Entity)) then
        warn("API.GetPosition: Entity (" ..tostring(_Entity).. ") does not exist!");
        return {X= 0, Y= 0, Z= 0};
    end
    local x, y, z = Logic.EntityGetPos(GetID(_Entity));
    return {X= x, Y= y, Z= y};
end
API.LocateEntity = API.GetPosition;
GetPosition = API.GetPosition;

---
-- Setzt ein Entity auf eine neue Position
--
-- @param _Entity Entity (Skriptname oder ID)
-- @param _Target Ziel (Skriptname, ID oder Position)
-- @within Position
-- @usage
-- API.SetPosition("Hans", "Horst");
--
function API.SetPosition(_Entity, _Target)
    local ID = GetID(_Entity);
    if not ID then
        return;
    end

    local Target;
    if type(_Target) ~= "table" then
        local ID2 = GetID(_Target);
        local x,y,z = Logic.EntityGetPos(ID2);
        Target = {X= x, Y= y};
    else
        Target = _Target;
    end

    if Logic.IsLeader(ID) == 1 then
        local Soldiers = {Logic.GetSoldiersAttachedToLeader(ID)};
        for i= 2, Soldiers[1]+1 do
            Logic.DEBUG_SetSettlerPosition(Soldiers[i], Target.X, Target.Y);
        end
    end
    Logic.DEBUG_SetSettlerPosition(ID, Target.X, Target.Y);
end
API.RelocateEntity = API.SetPosition;
SetPosition = API.SetPosition;

---
-- Prüft, ob eine Positionstabelle eine gültige Position enthält.
--
-- Eine Position ist Ungültig, wenn sie sich nicht auf der Welt befindet.
-- Das ist der Fall bei negativen Werten oder Werten, welche die Größe
-- der Welt übersteigen.
--
-- @param[type=table] _pos Positionstable {X= x, Y= y}
-- @return[type=boolean] Position ist valide
-- @within Position
--
function API.IsValidPosition(_pos)
    if type(_pos) == "table" then
        if (_pos.X ~= nil and type(_pos.X) == "number") and (_pos.Y ~= nil and type(_pos.Y) == "number") then
            local world = {Logic.WorldGetSize()};
            if _pos.Z and _pos.Z < 0 then
                return false;
            end
            if _pos.X < world[1] and _pos.X > 0 and _pos.Y < world[2] and _pos.Y > 0 then
                return true;
            end
        end
    end
    return false;
end

-- -------------------------------------------------------------------------- --
-- Math

---
-- Bestimmt die Distanz zwischen zwei Punkten. Es können Entity-IDs,
-- Skriptnamen oder Positionstables angegeben werden.
--
-- Wenn die Distanz nicht bestimmt werden kann, wird -1 zurückgegeben.
--
-- @param _pos1 Erste Vergleichsposition (Skriptname, ID oder Positions-Table)
-- @param _pos2 Zweite Vergleichsposition (Skriptname, ID oder Positions-Table)
-- @return[type=number] Entfernung zwischen den Punkten
-- @within Math
-- @usage
-- local Distance = API.GetDistance("HQ1", Logic.GetKnightID(1))
--
function API.GetDistance( _pos1, _pos2 )
    if (type(_pos1) == "string") or (type(_pos1) == "number") then
        _pos1 = API.GetPosition(_pos1);
    end
    if (type(_pos2) == "string") or (type(_pos2) == "number") then
        _pos2 = API.GetPosition(_pos2);
    end
    if type(_pos1) ~= "table" or type(_pos2) ~= "table" then
        warn("API.GetDistance: Distance could not be calculated!");
        return -1;
    end
    local xDistance = (_pos1.X - _pos2.X);
    local yDistance = (_pos1.Y - _pos2.Y);
    return math.sqrt((xDistance^2) + (yDistance^2));
end
GetDistance = API.GetDistance;

---
-- Rotiert ein Entity, sodass es zum Ziel schaut.
--
-- @param _Entity      Entity (Skriptname oder ID)
-- @param _Target      Ziel (Skriptname, ID oder Position)
-- @param[type=number] _Offset Winkel Offset
-- @within Math
-- @usage
-- API.LookAt("Hakim", "Alandra")
--
function API.LookAt(_Entity, _Target, _Offset)
    _Offset = _Offset or 0;
    local ID1 = GetID(_Entity);
    if ID1 == 0 then
        return;
    end
    local x1,y1,z1 = Logic.EntityGetPos(ID1);
    local ID2;
    local x2, y2, z2;
    if type(_Target) == "table" then
        x2 = _Target.X;
        y2 = _Target.Y;
        z2 = _Target.Z;
    else
        ID2 = GetID(_Target);
        if ID2 == 0 then
            return;
        end
        x2,y2,z2 = Logic.EntityGetPos(ID2);
    end

    if not API.IsValidPosition({X= x1, Y= y1, Z= z1}) then
        return;
    end
    if not API.IsValidPosition({X= x2, Y= y2, Z= z2}) then
        return;
    end
    Angle = math.deg(math.atan2((y2 - y1), (x2 - x1))) + _Offset;
    if Angle < 0 then
        Angle = Angle + 360;
    end

    if Logic.IsLeader(ID1) == 1 then
        local Soldiers = {Logic.GetSoldiersAttachedToLeader(ID1)};
        for i= 2, Soldiers[1]+1 do
            Logic.SetOrientation(Soldiers[i], Angle);
        end
    end
    Logic.SetOrientation(ID1, Angle);
end
LookAt = API.LookAt;

---
-- Bestimmt den Winkel zwischen zwei Punkten. Es können Entity-IDs,
-- Skriptnamen oder Positionstables angegeben werden.
--
-- @param _Pos1 Erste Vergleichsposition (Skriptname, ID oder Positions-Table)
-- @param _Pos2 Zweite Vergleichsposition (Skriptname, ID oder Positions-Table)
-- @return[type=number] Winkel zwischen den Punkten
-- @within Math
-- @usage
-- local Angle = API.GetAngleBetween("HQ1", Logic.GetKnightID(1))
--
function API.GetAngleBetween(_Pos1, _Pos2)
	local delta_X = 0;
	local delta_Y = 0;
	local alpha   = 0;
	if type (_Pos1) == "string" or type (_Pos1) == "number" then
		_Pos1 = API.GetPosition(GetID(_Pos1));
	end
	if type (_Pos2) == "string" or type (_Pos2) == "number" then
		_Pos2 = API.GetPosition(GetID(_Pos2));
	end
	delta_X = _Pos1.X - _Pos2.X;
	delta_Y = _Pos1.Y - _Pos2.Y;
	if delta_X == 0 and delta_Y == 0 then
		return 0;
	end
	alpha = math.deg(math.asin(math.abs(delta_X)/(math.sqrt((delta_X ^ 2)+delta_Y ^ 2))));
	if delta_X >= 0 and delta_Y > 0 then
		alpha = 270 - alpha ;
	elseif delta_X < 0 and delta_Y > 0 then
		alpha = 270 + alpha;
	elseif delta_X < 0 and delta_Y <= 0 then
		alpha = 90  - alpha;
	elseif delta_X >= 0 and delta_Y <= 0 then
		alpha = 90  + alpha;
	end
	return alpha;
end

---
-- Bestimmt die Durchschnittsposition mehrerer Entities.
--
-- @param ... Positionen mit Komma getrennt
-- @return[type=table] Durchschnittsposition aller Positionen
-- @within Math
-- @usage
-- local Center = API.GetGeometricFocus("Hakim", "Marcus", "Alandra");
--
function API.GetGeometricFocus(...)
    local PositionData = {X= 0, Y= 0, Z= 0};
    local ValidEntryCount = 0;
    for i= 1, #arg do
        local Position = API.GetPosition(arg[i]);
        if API.IsValidPosition(Position) then
            PositionData.X = PositionData.X + Position.X;
            PositionData.Y = PositionData.Y + Position.Y;
            PositionData.Z = PositionData.Z + (Position.Z or 0);
            ValidEntryCount = ValidEntryCount +1;
        end
    end
    return {
        X= PositionData.X * (1/ValidEntryCount);
        Y= PositionData.Y * (1/ValidEntryCount);
        Z= PositionData.Z * (1/ValidEntryCount);
    }
end

---
-- Gib eine Position auf einer Linie im relativen Abstand zur ersten Position
-- zurück.
--
-- @param               _Pos1       Erste Position
-- @param               _Pos2       Zweite Position
-- @param[type=number]  _Percentage Entfernung zu Erster Position
-- @return[type=table] Position auf Linie
-- @within Math
-- @usage
-- local Position = API.GetLinePosition("HQ1", "HQ2", 0.75);
--
function API.GetLinePosition(_Pos1, _Pos2, _Percentage)
    if _Percentage > 1 then
        _Percentage = _Percentage / 100;
    end

    if not API.IsValidPosition(_Pos1) and not IsExisting(_Pos1) then
        error("API.GetLinePosition: _Pos1 does not exist or is invalid position!");
        return;
    end
    local Pos1 = _Pos1;
    if type(Pos1) ~= "table" then
        Pos1 = API.GetPosition(Pos1);
    end

    if not API.IsValidPosition(_Pos2) and not IsExisting(_Pos2) then
        error("API.GetLinePosition: _Pos1 does not exist or is invalid position!");
        return;
    end
    local Pos2 = _Pos2;
    if type(Pos2) ~= "table" then
        Pos2 = API.GetPosition(Pos2);
    end

	local dx = Pos2.X - Pos1.X;
	local dy = Pos2.Y - Pos1.Y;
    return {X= Pos1.X+(dx*_Percentage), Y= Pos1.Y+(dy*_Percentage)};
end

---
-- Gib Positionen im gleichen Abstand auf der Linie zurück.
--
-- @param               _Pos1    Erste Position
-- @param               _Pos2    Zweite Position
-- @param[type=number]  _Periode Anzahl an Positionen
-- @return[type=table] Positionen auf Linie
-- @within Math
-- @usage
-- local PositionList = API.GetLinePositions("HQ1", "HQ2", 6);
--
function API.GetLinePositions(_Pos1, _Pos2, _Periode)
    local PositionList = {};
    for i= 0, 100, (1/_Periode)*100 do
        local Section = API.GetLinePosition(_Pos1, _Pos2, i);
        table.insert(PositionList, Section);
    end
    return PositionList;
end

---
-- Gibt eine Position auf einer Kreisbahn um einen Punkt zurück.
--
-- @param               _Target          Entity oder Position
-- @param[type=number]  _Distance        Entfernung um das Zentrum
-- @param[type=number]  _Angle           Winkel auf dem Kreis
-- @return[type=table] Position auf Kreisbahn
-- @within Math
-- @usage
-- local Position = API.GetCirclePosition("HQ1", 3000, -45);
--
function API.GetCirclePosition(_Target, _Distance, _Angle)
    if not API.IsValidPosition(_Target) and not IsExisting(_Target) then
        error("API.GetCirclePosition: _Target does not exist or is invalid position!");
        return;
    end

    local Position = _Target;
    local Orientation = 0+ (_Angle or 0);
    if type(_Target) ~= "table" then
        local EntityID = GetID(_Target);
        Orientation = Logic.GetEntityOrientation(EntityID)+(_Angle or 0);
        Position = API.GetPosition(EntityID);
    end

    local Result = {
        X= Position.X+_Distance * math.cos(math.rad(Orientation)),
        Y= Position.Y+_Distance * math.sin(math.rad(Orientation)),
        Z= Position.Z
    };
    return Result;
end
API.GetRelatiePos = API.GetCirclePosition;

---
-- Gibt Positionen im gleichen Abstand auf der Kreisbahn zurück.
--
-- @param               _Target          Entity oder Position
-- @param[type=number]  _Distance        Entfernung um das Zentrum
-- @param[type=number]  _Periode         Anzahl an Positionen
-- @param[type=number]  _Offset          Start Offset
-- @return[type=table] Positionend auf Kreisbahn
-- @within Math
-- @usage
-- local PositionList = API.GetCirclePositions("Position", 3000, 6, 45);
--
function API.GetCirclePositions(_Target, _Distance, _Periode, _Offset)
    local Periode = math.floor((360 / _Periode) + 0.5);
    local PositionList = {};
    for i= (Periode + _Offset), (360 + _Offset) do
        local Section = API.GetCirclePosition(_Target, _Distance, i);
        table.insert(PositionList, Section);
    end
    return PositionList;
end

-- -------------------------------------------------------------------------- --
-- Group

---
-- Gibt den Leader des Soldaten zurück.
--
-- @param _Entity Entity (Skriptname oder ID)
-- @return[type=number] Menge an Soldaten
-- @within Entity
--
function API.GetGroupLeader(_Entity)
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.GetGroupLeader: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return 0;
    end
    if Logic.IsEntityInCategory(EntityID, EntityCategories.Soldier) == 0 then
        return 0;
    end
    return Logic.SoldierGetLeaderEntityID(EntityID);
end

---
-- Heilt das Entity um die angegebene Menge an Gesundheit.
--
-- @param               _Entity   Entity (Scriptname oder ID)
-- @param[type=number]  _Amount   Geheilte Gesundheit
-- @within Entity
--
function API.GroupHeal(_Entity, _Amount)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID == 0 or Logic.IsLeader(EntityID) == 1 then
        error("API.GroupHeal: _Entity (" ..tostring(_Entity).. ") must be an existing leader!");
        return;
    end
    if type(_Amount) ~= "number" or _Amount < 0 then
        error("API.GroupHeal: _Amount (" ..tostring(_Amount).. ") must greatier than 0!");
        return;
    end
    API.ChangeEntityHealth(EntityID, Logic.GetEntityHealth(EntityID) + _Amount);
end

---
-- Verwundet ein Entity oder ein Battallion um die angegebene
-- Menge an Schaden. Bei einem Battalion wird der Schaden solange
-- auf Soldaten aufgeteilt, bis er komplett verrechnet wurde.
--
-- @param               _Entity   Entity (Scriptname oder ID)
-- @param[type=number] _Damage   Schaden
-- @param[type=string] _Attacker Angreifer
-- @within Entity
--
function API.GroupHurt(_Entity, _Damage, _Attacker)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.GroupHurt: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    if Logic.IsEntityInCategory(EntityID, EntityCategories.Soldier) == 1 then
        API.GroupHurt(API.GetGroupLeader(EntityID), _Damage);
        return;
    end

    local EntityToHurt = EntityID;
    local IsLeader = Logic.IsLeader(EntityToHurt) == 1;
    if IsLeader then
        local SoldierTable = {Logic.GetSoldiersAttachedToLeader(EntityID)};
        if SoldierTable[1] > 0 then
            EntityToHurt = SoldierTable[2];
        end
    end
    if type(_Damage) ~= "number" or _Damage < 0 then
        error("API.GroupHurt: _Damage (" ..tostring(_Damage).. ") must be greater than 0!");
        return;
    end

    if EntityToHurt then
        local Health = Logic.GetEntityHealth(EntityToHurt);
        if Health <= _Damage then
            _Damage = _Damage - Health;
            Logic.HurtEntity(EntityToHurt, Health);
            Swift.Utils:TriggerEntityKilledCallbacks(EntityToHurt, _Attacker);
            if IsLeader and _Damage > 0 then
                API.GroupHurt(EntityToHurt, _Damage);
            end
        else
            Logic.HurtEntity(EntityToHurt, _Damage);
            Swift.Utils:TriggerEntityKilledCallbacks(EntityToHurt, _Attacker);
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Object

---
-- Aktiviert ein Interaktives Objekt.
--
-- @param[type=string] _ScriptName Skriptname des Objektes
-- @param[type=number] _State      State des Objektes
-- @within Entity
--
function API.InteractiveObjectActivate(_ScriptName, _State)
    _State = _State or 0;
    if GUI or not IsExisting(_ScriptName) then
        return;
    end
    for i= 1, 8 do
        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, _State);
    end
end
InteractiveObjectActivate = API.InteractiveObjectActivate;

---
-- Deaktiviert ein interaktives Objekt.
--
-- @param[type=string] _ScriptName Scriptname des Objektes
-- @within Entity
--
function API.InteractiveObjectDeactivate(_ScriptName)
    if GUI or not IsExisting(_ScriptName) then
        return;
    end
    for i= 1, 8 do
        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, 2);
    end
end
InteractiveObjectDeactivate = API.InteractiveObjectDeactivate;

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Grundlegende Steuerung von Quests mittels Funktionen und Events.
-- @set sort=true
-- @local
--

Swift.Quest = {}

function Swift.Quest:Initalize()
    QSB.ScriptEvents.QuestFailure = Swift.Event:CreateScriptEvent("Event_QuestFailure");
    QSB.ScriptEvents.QuestInterrupt = Swift.Event:CreateScriptEvent("Event_QuestInterrupt");
    QSB.ScriptEvents.QuestReset = Swift.Event:CreateScriptEvent("Event_QuestReset");
    QSB.ScriptEvents.QuestSuccess = Swift.Event:CreateScriptEvent("Event_QuestSuccess");
    QSB.ScriptEvents.QuestTrigger = Swift.Event:CreateScriptEvent("Event_QuestTrigger");

    if Swift.Environment == QSB.Environment.GLOBAL then
        self:OverrideQuestSystemGlobal();
    end
end

function Swift.Quest:OnSaveGameLoaded()
end

function Swift.Quest:OverrideQuestSystemGlobal()
    QuestTemplate.Trigger_Orig_QSB_Core = QuestTemplate.Trigger
    QuestTemplate.Trigger = function(_quest)
        QuestTemplate.Trigger_Orig_QSB_Core(_quest);
        for i=1,_quest.Objectives[0] do
            if _quest.Objectives[i].Type == Objective.Custom2 and _quest.Objectives[i].Data[1].SetDescriptionOverwrite then
                local Desc = _quest.Objectives[i].Data[1]:SetDescriptionOverwrite(_quest);
                Swift.Quest:ChangeCustomQuestCaptionText(Desc, _quest);
                break;
            end
        end
        Swift.Quest:SendQuestStateEvent(_quest.Identifier, "QuestTrigger");
    end

    QuestTemplate.Interrupt_Orig_QSB_Core = QuestTemplate.Interrupt;
    QuestTemplate.Interrupt = function(_Quest)
        _Quest:Interrupt_Orig_QSB_Core();

        for i=1, _Quest.Objectives[0] do
            if _Quest.Objectives[i].Type == Objective.Custom2 and _Quest.Objectives[i].Data[1].Interrupt then
                _Quest.Objectives[i].Data[1]:Interrupt(_Quest, i);
            end
        end
        for i=1, _Quest.Triggers[0] do
            if _Quest.Triggers[i].Type == Triggers.Custom2 and _Quest.Triggers[i].Data[1].Interrupt then
                _Quest.Triggers[i].Data[1]:Interrupt(_Quest, i);
            end
        end

        Swift.Quest:SendQuestStateEvent(_Quest.Identifier, "QuestInterrupt");
    end

    QuestTemplate.Fail_Orig_QSB_Core = QuestTemplate.Fail;
    QuestTemplate.Fail = function(_Quest)
        _Quest:Fail_Orig_QSB_Core();
        Swift.Quest:SendQuestStateEvent(_Quest.Identifier, "QuestFailure");
    end

    QuestTemplate.Success_Orig_QSB_Core = QuestTemplate.Success;
    QuestTemplate.Success = function(_Quest)
        _Quest:Success_Orig_QSB_Core();
        Swift.Quest:SendQuestStateEvent(_Quest.Identifier, "QuestSuccess");
    end
end

function Swift.Quest:SendQuestStateEvent(_QuestName, _StateName)
    local QuestID = API.GetQuestID(_QuestName);
    if Quests[QuestID] then
        Swift.Event:DispatchScriptEvent(QSB.ScriptEvents[_StateName], QuestID);
        Logic.ExecuteInLuaLocalState(string.format(
            [[Swift.Event:DispatchScriptEvent(QSB.ScriptEvents["%s"], %d)]],
            _StateName,
            QuestID
        ));
    end
end

function Swift.Quest:ChangeCustomQuestCaptionText(_Text, _Quest)
    if _Quest and _Quest.Visible then
        _Quest.QuestDescription = _Text;
        Logic.ExecuteInLuaLocalState([[
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives/Custom/BGDeco",0)
            local identifier = "]].._Quest.Identifier..[["
            for i=1, Quests[0] do
                if Quests[i].Identifier == identifier then
                    local text = Quests[i].QuestDescription
                    XGUIEng.SetText("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives/Custom/Text", "]].._Text..[[")
                    break
                end
            end
        ]]);
    end
end

-- -------------------------------------------------------------------------- --
-- API

---
-- Gibt die ID des Quests mit dem angegebenen Namen zurück. Existiert der
-- Quest nicht, wird nil zurückgegeben.
--
-- @param[type=string] _Name Name des Quest
-- @return[type=number] ID des Quest
-- @within Quest
--
function API.GetQuestID(_Name)
    if type(_Name) == "number" then
        return _Name;
    end
    for k, v in pairs(Quests) do
        if v and k > 0 then
            if v.Identifier == _Name then
                return k;
            end
        end
    end
end
GetQuestID = API.GetQuestID;

---
-- Prüft, ob zu der angegebenen ID ein Quest existiert. Wird ein Questname
-- angegeben wird dessen Quest-ID ermittelt und geprüft.
--
-- @param[type=number] _QuestID ID oder Name des Quest
-- @return[type=boolean] Quest existiert
-- @within Quest
--
function API.IsValidQuest(_QuestID)
    return Quests[_QuestID] ~= nil or Quests[API.GetQuestID(_QuestID)] ~= nil;
end
IsValidQuest = API.IsValidQuest;

---
-- Prüft den angegebenen Questnamen auf verbotene Zeichen.
--
-- @param[type=number] _Name Name des Quest
-- @return[type=boolean] Name ist gültig
-- @within Quest
--
function API.IsValidQuestName(_Name)
    return string.find(_Name, "^[A-Za-z0-9_ @ÄÖÜäöüß]+$") ~= nil;
end
IsValidQuestName = API.IsValidQuestName;

---
-- Lässt den Quest fehlschlagen.
--
-- Der Status wird auf Over und das Resultat auf Failure gesetzt.
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _NoMessage Meldung nicht anzeigen
-- @within Quest
--
function API.FailQuest(_QuestName, _NoMessage)
    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    if Quest then
        if not _NoMessage then
            Logic.DEBUG_AddNote("fail quest " .._QuestName);
        end
        Quest:RemoveQuestMarkers();
        Quest:Fail();
        -- Note: Event is send in QuestTemplate:Fail()!
    end
end

---
-- Startet den Quest neu.
--
-- Der Quest muss beendet sein um ihn wieder neu zu starten. Wird ein Quest
-- neu gestartet, müssen auch alle Trigger wieder neu ausgelöst werden, außer
-- der Quest wird manuell getriggert.
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _NoMessage Meldung nicht anzeigen
-- @within Quest
--
function API.RestartQuest(_QuestName, _NoMessage)
    -- All changes on default behavior must be considered in this function.
    -- When a default behavior is changed in a module this function must be
    -- changed as well.

    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    if Quest then
        if not _NoMessage then
            Logic.DEBUG_AddNote("restart quest " .._QuestName);
        end

        if Quest.Objectives then
            local questObjectives = Quest.Objectives;
            for i = 1, questObjectives[0] do
                local objective = questObjectives[i];
                objective.Completed = nil
                local objectiveType = objective.Type;

                if objectiveType == Objective.Deliver then
                    local data = objective.Data;
                    data[3] = nil;
                    data[4] = nil;
                    data[5] = nil;
                    data[9] = nil;

                elseif g_GameExtraNo and g_GameExtraNo >= 1 and objectiveType == Objective.Refill then
                    objective.Data[2] = nil;

                elseif objectiveType == Objective.Protect or objectiveType == Objective.Object then
                    local data = objective.Data;
                    for j=1, data[0], 1 do
                        data[-j] = nil;
                    end

                elseif objectiveType == Objective.DestroyEntities and objective.Data[1] == 2 and objective.DestroyTypeAmount then
                    objective.Data[3] = objective.DestroyTypeAmount;
                elseif objectiveType == Objective.DestroyEntities and objective.Data[1] == 3 then
                    objective.Data[4] = nil;
                    objective.Data[5] = nil;

                elseif objectiveType == Objective.Distance then
                    if objective.Data[1] == -65565 then
                        objective.Data[4].NpcInstance = nil;
                    end

                elseif objectiveType == Objective.Custom2 and objective.Data[1].Reset then
                    objective.Data[1]:Reset(Quest, i);
                end
            end
        end

        local function resetCustom(_type, _customType)
            local Quest = Quest;
            local behaviors = Quest[_type];
            if behaviors then
                for i = 1, behaviors[0] do
                    local behavior = behaviors[i];
                    if behavior.Type == _customType then
                        local behaviorDef = behavior.Data[1];
                        if behaviorDef and behaviorDef.Reset then
                            behaviorDef:Reset(Quest, i);
                        end
                    end
                end
            end
        end

        resetCustom("Triggers", Triggers.Custom2);
        resetCustom("Rewards", Reward.Custom);
        resetCustom("Reprisals", Reprisal.Custom);

        Quest.Result = nil;
        local OldQuestState = Quest.State;
        Quest.State = QuestState.NotTriggered;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..Quest.Index..")");
        if OldQuestState == QuestState.Over then
            Quest.Job = Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", "Quest_Loop", 1, 0, {Quest.QueueID});
        end
        -- Note: Send the event
        Swift.Event:DispatchScriptEvent(QSB.ScriptEvents.QuestReset, QuestID);
        Logic.ExecuteInLuaLocalState(string.format(
            "Swift.Event:DispatchScriptEvent(QSB.ScriptEvents.QuestReset, %d)",
            QuestID
        ));
        return QuestID, Quest;
    end
end

---
-- Startet den Quest sofort, sofern er existiert.
--
-- Dabei ist es unerheblich, ob die Bedingungen zum Start erfüllt sind.
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _NoMessage Meldung nicht anzeigen
-- @within Quest
--
function API.StartQuest(_QuestName, _NoMessage)
    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    if Quest then
        if not _NoMessage then
            Logic.DEBUG_AddNote("start quest " .._QuestName);
        end
        Quest:SetMsgKeyOverride();
        Quest:SetIconOverride();
        Quest:Trigger();
        -- Note: Event is send in QuestTemplate:Trigger()!
    end
end

---
-- Unterbricht den Quest.
--
-- Der Status wird auf Over und das Resultat auf Interrupt gesetzt. Sind Marker
-- gesetzt, werden diese entfernt.
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _NoMessage Meldung nicht anzeigen
-- @within Quest
--
function API.StopQuest(_QuestName, _NoMessage)
    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    if Quest then
        if not _NoMessage then
            Logic.DEBUG_AddNote("interrupt quest " .._QuestName);
        end
        Quest:RemoveQuestMarkers();
        Quest:Interrupt(-1);
        -- Note: Event is send in QuestTemplate:Interrupt()!
    end
end

---
-- Gewinnt den Quest.
--
-- Der Status wird auf Over und das Resultat auf Success gesetzt.
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _NoMessage Meldung nicht anzeigen
-- @within Quest
--
function API.WinQuest(_QuestName, _NoMessage)
    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    if Quest then
        if not _NoMessage then
            Logic.DEBUG_AddNote("win quest " .._QuestName);
        end
        Quest:RemoveQuestMarkers();
        Quest:Success();
        -- Note: Event is send in QuestTemplate:Success()!
    end
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Stellt Cheats und Befehle für einfacheres Testen bereit.
--
-- @set sort=true
-- @within Beschreibung
-- @local
--

Swift.Debug = {
    CheckAtRun           = false;
    TraceQuests          = false;
    DevelopingCheats     = false;
    DevelopingShell      = false;
};

function Swift.Debug:Initalize()
    QSB.ScriptEvents.DebugChatConfirmed = Swift.Event:CreateScriptEvent("Event_DebugChatConfirmed");
    QSB.ScriptEvents.DebugConfigChanged = Swift.Event:CreateScriptEvent("Event_DebugConfigChanged");

    if Swift.Environment == QSB.Environment.LOCAL then
        self:InitalizeQsbDebugHotkeys();

        API.AddScriptEventListener(
            QSB.ScriptEvents.ChatClosed,
            function(...)
                Swift.Debug:ProcessDebugInput(unpack(arg));
            end
        );
    end
end

function Swift.Debug:OnSaveGameLoaded()
    if Swift.Environment == QSB.Environment.LOCAL then
        self:InitalizeDebugWidgets();
        self:InitalizeQsbDebugHotkeys();
    end
end

function Swift.Debug:ActivateDebugMode(_CheckAtRun, _TraceQuests, _DevelopingCheats, _DevelopingShell)
    if Swift.Environment == QSB.Environment.LOCAL then
        return;
    end

    self.CheckAtRun       = _CheckAtRun == true;
    self.TraceQuests      = _TraceQuests == true;
    self.DevelopingCheats = _DevelopingCheats == true;
    self.DevelopingShell  = _DevelopingShell == true;

    Swift.Event:DispatchScriptEvent(
        QSB.ScriptEvents.DebugModeStatusChanged,
        self.CheckAtRun,
        self.TraceQuests,
        self.DevelopingCheats,
        self.DevelopingShell
    );

    Logic.ExecuteInLuaLocalState(string.format(
        [[
            Swift.Debug.CheckAtRun       = %s;
            Swift.Debug.TraceQuests      = %s;
            Swift.Debug.DevelopingCheats = %s;
            Swift.Debug.DevelopingShell  = %s;

            Swift.Event:DispatchScriptEvent(
                QSB.ScriptEvents.DebugModeStatusChanged,
                Swift.Debug.CheckAtRun,
                Swift.Debug.TraceQuests,
                Swift.Debug.DevelopingCheats,
                Swift.Debug.DevelopingShell
            );
            Swift.Debug:InitalizeDebugWidgets();
        ]],
        tostring(self.CheckAtRun),
        tostring(self.TraceQuests),
        tostring(self.DevelopingCheats),
        tostring(self.DevelopingShell)
    ));
end

function Swift.Debug:InitalizeDebugWidgets()
    if Network.IsNATReady ~= nil and Framework.IsNetworkGame() then
        return;
    end
    if self.DevelopingCheats then
        KeyBindings_EnableDebugMode(1);
        KeyBindings_EnableDebugMode(2);
        KeyBindings_EnableDebugMode(3);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock", 1);
        self.GameClock = true;
    else
        KeyBindings_EnableDebugMode(0);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock", 0);
        self.GameClock = false;
    end
end

function Swift.Debug:InitalizeQsbDebugHotkeys()
    if Framework.IsNetworkGame() then
        return;
    end
    -- Restart map
    Input.KeyBindDown(
        Keys.ModifierControl + Keys.ModifierShift + Keys.ModifierAlt + Keys.R,
        "Swift.Debug:ProcessDebugShortcut('RestartMap')",
        30,
        false
    );
    -- Open chat
    Input.KeyBindDown(
        Keys.ModifierShift + Keys.OemPipe,
        "Swift.Debug:ProcessDebugShortcut('Terminal')",
        30,
        false
    );
end

function Swift.Debug:ProcessDebugShortcut(_Type, _Params)
    if self.DevelopingCheats then
        if _Type == "RestartMap" then
            Framework.RestartMap();
        elseif _Type == "Terminal" then
            API.ShowTextInput(GUI.GetPlayerID(), true);
        end
    end
end

function Swift.Debug:ProcessDebugInput(_Input, _PlayerID, _DebugAllowed)
    if _DebugAllowed then
        if _Input:lower():find("^restartmap") then
            self:ProcessDebugShortcut("RestartMap");
        elseif _Input:lower():find("^clear") then
            GUI.ClearNotes();
        elseif _Input:lower():find("^version") then
            local Slices = _Input:slice(" ");
            if Slices[2] then
                for i= 1, #Swift.ModuleRegister do
                    if Swift.ModuleRegister[i].Properties.Name ==  Slices[2] then
                        GUI.AddStaticNote("Version: " ..Swift.ModuleRegister[i].Properties.Version);
                    end
                end
                return;
            end
            GUI.AddStaticNote("Version: " ..QSB.Version);
        elseif _Input:find("^> ") then
            GUI.SendScriptCommand(_Input:sub(3), true);
        elseif _Input:find("^>> ") then
            GUI.SendScriptCommand(string.format(
                "Logic.ExecuteInLuaLocalState(\"%s\")",
                _Input:sub(4)
            ), true);
        elseif _Input:find("^< ") then
            GUI.SendScriptCommand(string.format(
                [[Script.Load("%s")]],
                _Input:sub(3)
            ));
        elseif _Input:find("^<< ") then
            Script.Load(_Input:sub(4));
        end
    end
end

-- -------------------------------------------------------------------------- --
-- API

---
-- Aktiviert oder deaktiviert Optionen des Debug Mode.
--
-- <b>Hinweis:</b> Du kannst alle Optionen unbegrenzt oft beliebig ein-
-- und ausschalten.
--
-- <ul>
-- <li><u>Prüfung zum Spielbeginn</u>: <br>
-- Quests werden auf konsistenz geprüft, bevor sie starten. </li>
-- <li><u>Questverfolgung</u>: <br>
-- Jede Statusänderung an einem Quest löst eine Nachricht auf dem Bildschirm
-- aus, die die Änderung wiedergibt. </li>
-- <li><u>Eintwickler Cheaks</u>: <br>
-- Aktivier die Entwickler Cheats. </li>
-- <li><u>Debug Chat-Eingabe</u>: <br>
-- Die Chat-Eingabe kann zur Eingabe von Befehlen genutzt werden. </li>
-- </ul>
--
-- @param[type=boolean] _CheckAtRun       Custom Behavior prüfen an/aus
-- @param[type=boolean] _TraceQuests      Quest Trace an/aus
-- @param[type=boolean] _DevelopingCheats Cheats an/aus
-- @param[type=boolean] _DevelopingShell  Eingabeaufforderung an/aus
-- @within System
--
function API.ActivateDebugMode(_CheckAtRun, _TraceQuests, _DevelopingCheats, _DevelopingShell)
    Swift.Debug:ActivateDebugMode(_CheckAtRun, _TraceQuests, _DevelopingCheats, _DevelopingShell);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Scripting Values lesen und schreiben.
-- @set sort=true
-- @local
--

Swift.ScriptingValue = {
    SV = {
        Game = "Vanilla",
        Vanilla = {
            Destination = {X = 19, Y= 20},
            Health      = -41,
            Player      = -71,
            Size        = -45,
            Visible     = -50,
            NPC         = 6,
        },
        HistoryEdition = {
            Destination = {X = 17, Y= 18},
            Health      = -38,
            Player      = -68,
            Size        = -42,
            Visible     = -47,
            NPC         = 6,
        }
    }
}

function Swift.ScriptingValue:Initalize()
    if Swift.GameVersion == QSB.GameVersion.HISTORY_EDITION then
        self.SV.Game = "HistoryEdition";
    end
    QSB.ScriptingValue = self.SV[self.SV.Game];
end

function Swift.ScriptingValue:OnSaveGameLoaded()
    -- Porting savegames between game versions
    -- (Not recommended but we try to support it)
    if Swift.GameVersion == QSB.GameVersion.HISTORY_EDITION then
        self.SV.Game = "HistoryEdition";
    end
    QSB.ScriptingValue = self.SV[self.SV.Game];
end

-- -------------------------------------------------------------------------- --
-- Conversion Methods

function Swift.ScriptingValue:BitsInteger(num)
    local t = {};
    while num > 0 do
        rest = math.qmod(num, 2);
        table.insert(t,1,rest);
        num=(num-rest)/2;
    end
    table.remove(t, 1);
    return t;
end

function Swift.ScriptingValue:BitsFraction(num, t)
    for i = 1, 48 do
        num = num * 2;
        if(num >= 1) then
            table.insert(t, 1);
            num = num - 1;
        else
            table.insert(t, 0);
        end
        if(num == 0) then
            return t;
        end
    end
    return t;
end

function Swift.ScriptingValue:IntegerToFloat(num)
    if(num == 0) then
        return 0;
    end
    local sign = 1;
    if (num < 0) then
        num = 2147483648 + num;
        sign = -1;
    end
    local frac = math.qmod(num, 8388608);
    local headPart = (num-frac)/8388608;
    local expNoSign = math.qmod(headPart, 256);
    local exp = expNoSign-127;
    local fraction = 1;
    local fp = 0.5;
    local check = 4194304;
    for i = 23, 0, -1 do
        if (frac - check) > 0 then
            fraction = fraction + fp;
            frac = frac - check;
        end
        check = check / 2;
        fp = fp / 2;
    end
    return fraction * math.pow(2, exp) * sign;
end

function Swift.ScriptingValue:FloatToInteger(fval)
    if(fval == 0) then
        return 0;
    end
    local signed = false;
    if (fval < 0) then
        signed = true;
        fval = fval * -1;
    end
    local outval = 0;
    local bits;
    local exp = 0;
    if fval >= 1 then
        local intPart = math.floor(fval);
        local fracPart = fval - intPart;
        bits = self:BitsInteger(intPart);
        exp = #bits;
        self:BitsFraction(fracPart, bits);
    else
        bits = {};
        self:BitsFraction(fval, bits);
        while(bits[1] == 0) do
            exp = exp - 1;
            table.remove(bits, 1);
        end
        exp = exp - 1;
        table.remove(bits, 1);
    end
    local bitVal = 4194304;
    local start = 1;
    for bpos = start, 23 do
        local bit = bits[bpos];
        if(not bit) then
            break;
        end
        if(bit == 1) then
            outval = outval + bitVal;
        end
        bitVal = bitVal / 2;
    end
    outval = outval + (exp+127)*8388608;
    if(signed) then
        outval = outval - 2147483648;
    end
    return outval;
end

-- -------------------------------------------------------------------------- --
-- API

---
-- Liste der unterstützten Scripting Values.
--
-- <ul>
-- <li><b>QSB.ScriptingValue.Destination.X</b><br>
-- Gibt die Z-Koordinate des Bewegungsziels als Float zurück.</li>
-- <li><b>QSB.ScriptingValue.Destination.Y</b><br>
-- Gibt die Y-Koordinate des Bewegungsziels als Float zurück.</li>
-- <li><b>QSB.ScriptingValue.Health</b><br>
-- Setzt die Gesundheit eines Entity ohne Folgeaktionen zu triggern.</li>
-- <li><b>QSB.ScriptingValue.Player</b><br>
-- Setzt den Besitzer des Entity ohne Plausibelitätsprüfungen.</li>
-- <li><b>QSB.ScriptingValue.Size</b><br>
-- Setzt den Größenfaktor eines Entities als Float.</li>
-- <li><b>QSB.ScriptingValue.Visible</b><br>
-- Sichtbarkeit eines Entities abfragen (801280 == sichtbar)</li>
-- <li><b>QSB.ScriptingValue.NPC</b><br>
-- NPC-Flag eines Siedlers setzen (0 = inaktiv, 1 - 4 = aktiv)</li>
-- </ul>
-- @within ScriptingValue
--
QSB.ScriptingValue = {};

---
-- Gibt den Wert auf dem übergebenen Index für das Entity zurück.
--
-- @param[type=number] _Entity Entity
-- @param[type=number] _SV     Typ der Scripting Value
-- @return[type=number] Ermittelter Wert
-- @within ScriptingValue
--
-- @usage
-- local PlayerID = API.GetInteger("HansWurst", QSB.ScriptingValue.Player);
--
function API.GetInteger(_Entity, _SV)
    local ID = GetID(_Entity);
    if not IsExisting(ID) then
        return;
    end
    return Logic.GetEntityScriptingValue(ID, _SV);
end

---
-- Gibt den Wert auf dem übergebenen Index für das Entity zurück.
--
-- @param[type=number] _Entity Entity
-- @param[type=number] _SV     Typ der Scripting Value
-- @return[type=number] Ermittelter Wert
-- @within ScriptingValue
--
-- @usage
-- local Size = API.GetFloat("HansWurst", QSB.ScriptingValue.Size);
--
function API.GetFloat(_Entity, _SV)
    local ID = GetID(_Entity);
    if not IsExisting(ID) then
        return;
    end
    local Value = Logic.GetEntityScriptingValue(ID, _SV);
    return API.ConvertIntegerToFloat(Value);
end

---
-- Setzt den Wert auf dem übergebenen Index für das Entity.
-- 
-- @param[type=number] _Entity Entity
-- @param[type=number] _SV     Typ der Scripting Value
-- @param[type=number] _Value  Zu setzender Wert
-- @within ScriptingValue
--
-- @usage
-- API.SetInteger("HansWurst", QSB.ScriptingValue.Player, 2);
--
function API.SetInteger(_Entity, _SV, _Value)
    local ID = GetID(_Entity);
    if GUI or not IsExisting(ID) then
        return;
    end
    Logic.SetEntityScriptingValue(ID, _SV, _Value);
end

---
-- Setzt den Wert auf dem übergebenen Index für das Entity.
--
-- @param[type=number] _Entity Entity
-- @param[type=number] _SV     Typ der Scripting Value
-- @param[type=number] _Value  Zu setzender Wert
-- @within ScriptingValue
--
-- @usage
-- API.SetFloat("HansWurst", QSB.ScriptingValue.Size, 1.5);
--
function API.SetFloat(_Entity, _SV, _Value)
    local ID = GetID(_Entity);
    if GUI or not IsExisting(ID) then
        return;
    end
    Logic.SetEntityScriptingValue(ID, _SV, API.ConvertFloatToInteger(_Value));
end

---
-- Konvertirert den Wert in eine Ganzzahl.
--
-- @param[type=number] _Value Gleitkommazahl
-- @return[type=number] Konvertierte Ganzzahl
-- @within ScriptingValue
--
-- @usage
-- local Converted = API.ConvertIntegerToFloat(Value)
--
function API.ConvertIntegerToFloat(_Value)
    return Swift.ScriptingValue:IntegerToFloat(_Value);
end

---
-- Konvertirert den Wert in eine Gleitkommazahl.
--
-- @param[type=number] _Value Gleitkommazahl
-- @return[type=number] Konvertierte Ganzzahl
-- @within ScriptingValue
--
-- @usage
-- local Converted = API.ConvertFloatToInteger(Value)
--
function API.ConvertFloatToInteger(_Value)
    return Swift.ScriptingValue:FloatToInteger(_Value);
end
--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Eine Sammlung von vielen Behavior.
-- @set sort=true
-- @local
--

Swift.Behavior = {
    QuestCounter = 0,
    Text = {
        ActivateBuff = {
            Pattern = {
                de = "BONUS AKTIVIEREN{cr}{cr}%s",
                en = "ACTIVATE BUFF{cr}{cr}%s",
                fr = "ACTIVER BONUS{cr}{cr}%s",
            },
            BuffsVanilla = {
                ["Buff_Spice"]                  = {de = "Salz", en = "Salt", fr = "Sel"},
                ["Buff_Colour"]                 = {de = "Farben", en = "Color", fr = "Couleurs"},
                ["Buff_Entertainers"]           = {de = "Entertainer", en = "Entertainer", fr = "Artistes"},
                ["Buff_FoodDiversity"]          = {de = "Vielfältige Nahrung", en = "Food diversity", fr = "Diversité alimentaire"},
                ["Buff_ClothesDiversity"]       = {de = "Vielfältige Kleidung", en = "Clothes diversity", fr = "Diversité vestimentaire"},
                ["Buff_HygieneDiversity"]       = {de = "Vielfältige Reinigung", en = "Hygiene diversity", fr = "Diversité hygiénique"},
                ["Buff_EntertainmentDiversity"] = {de = "Vielfältige Unterhaltung", en = "Entertainment diversity", fr = "Diversité des dievertissements"},
                ["Buff_Sermon"]                 = {de = "Predigt", en = "Sermon", fr = "Sermon"},
                ["Buff_Festival"]               = {de = "Fest", en = "Festival", fr = "Festival"},
                ["Buff_ExtraPayment"]           = {de = "Sonderzahlung", en = "Extra payment", fr = "Paiement supplémentaire"},
                ["Buff_HighTaxes"]              = {de = "Hohe Steuern", en = "High taxes", fr = "Hautes taxes"},
                ["Buff_NoPayment"]              = {de = "Kein Sold", en = "No payment", fr = "Aucun paiement"},
                ["Buff_NoTaxes"]                = {de = "Keine Steuern", en = "No taxes", fr = "Aucune taxes"},
            },
            BuffsEx1 = {
                ["Buff_Gems"]              = {de = "Edelsteine", en = "Gems", fr = "Gemmes"},
                ["Buff_MusicalInstrument"] = {de = "Musikinstrumente", en = "Musical instruments", fr = "Instruments musicaux"},
                ["Buff_Olibanum"]          = {de = "Weihrauch", en = "Olibanum", fr = "Encens"},
            }
        },
        SoldierCount = {
            Pattern = {
                de = "SOLDATENANZAHL {cr}Partei: %s{cr}{cr}%s %d",
                en = "SOLDIER COUNT {cr}Faction: %s{cr}{cr}%s %d",
                fr = "NOMBRE DE SOLDATS {cr}Faction: %s{cr}{cr}%s %d",
            },
            Relation = {
                ["true"]  = {de = "Weniger als ", en = "Less than ", fr = "Moins de"},
                ["false"] = {de = "Mindestens ", en = "At least ", fr = "Au moins"},
            }
        },
        Festivals = {
            Pattern = {
                de = "FESTE FEIERN {cr}{cr}Partei: %s{cr}{cr}Anzahl: %d",
                en = "HOLD PARTIES {cr}{cr}Faction: %s{cr}{cr}Amount: %d",
                fr = "FESTIVITÉS {cr}{cr}Faction: %s{cr}{cr}Nombre : %d",
            },
        }
    }
}

-- FIXME: Remove
QSB.DestroyedSoldiers = {};
QSB.EffectNameToID = {};
QSB.InitalizedObjekts = {};

function Swift.Behavior:Initalize()
    if Swift.Environment == QSB.Environment.GLOBAL then
        self:OverrideQuestMarkers();
    end
    if Swift.Environment == QSB.Environment.LOCAL then
        self:OverrideDisplayQuestObjective();
    end
end

function Swift.Behavior:OnSaveGameLoaded()
end

function Swift.Behavior:OverrideQuestMarkers()
    QuestTemplate.RemoveQuestMarkers = function(self)
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[4] then
                    DestroyQuestMarker(self.Objectives[i].Data[2]);
                end
            end
        end
    end
    QuestTemplate.ShowQuestMarkers = function(self)
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[4] then
                    ShowQuestMarker(self.Objectives[i].Data[2]);
                end
            end
        end
    end

    function ShowQuestMarker(_Entity)
        local eID = GetID(_Entity);
        local x,y = Logic.GetEntityPosition(eID);
        local Marker = EGL_Effects.E_Questmarker_low;
        if Logic.IsBuilding(eID) == 1 then
            Marker = EGL_Effects.E_Questmarker;
        end
        DestroyQuestMarker(_Entity);
        Questmarkers[eID] = Logic.CreateEffect(Marker, x, y, 0);
    end
    function DestroyQuestMarker(_Entity)
        local eID = GetID(_Entity);
        if Questmarkers[eID] ~= nil then
            Logic.DestroyEffect(Questmarkers[eID]);
            Questmarkers[eID] = nil;
        end
    end
end

function Swift.Behavior:OverrideDisplayQuestObjective()
    GUI_Interaction.DisplayQuestObjective_Orig_QSB_Kernel = GUI_Interaction.DisplayQuestObjective
    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)
        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        if QuestType == Objective.Distance then
            if Quest.Objectives[1].Data[1] == -65566 then
                Quest.Objectives[1].Data[1] = Logic.GetKnightID(Quest.ReceivingPlayer);
            end
        end
        GUI_Interaction.DisplayQuestObjective_Orig_QSB_Kernel(_QuestIndex, _MessageKey);
    end
end

function Swift.Behavior:IsQuestPositionReached(_Quest, _Objective)
    local IDdata2 = GetID(_Objective.Data[1]);
    if IDdata2 == -65566 then
        _Objective.Data[1] = Logic.GetKnightID(_Quest.ReceivingPlayer);
        IDdata2 = _Objective.Data[1];
    end
    local IDdata3 = GetID(_Objective.Data[2]);
    _Objective.Data[3] = _Objective.Data[3] or 2500;
    if not (Logic.IsEntityDestroyed(IDdata2) or Logic.IsEntityDestroyed(IDdata3)) then
        if Logic.GetDistanceBetweenEntities(IDdata2,IDdata3) <= _Objective.Data[3] then
            DestroyQuestMarker(IDdata3);
            return true;
        end
    else
        DestroyQuestMarker(IDdata3);
        return false;
    end
end

-- -------------------------------------------------------------------------- --
-- DEBUG

---
-- Aktiviert den Debug.
--
-- @param[type=boolean] _CheckAtRun Prüfe Quests zur Laufzeit
-- @param[type=boolean] _TraceQuests Aktiviert Questverfolgung
-- @param[type=boolean] _DevelopingCheats Aktiviert Cheats
-- @param[type=boolean] _DevelopingShell Aktiviert Eingabe
--
-- @within Reward
-- @see API.ActivateDebugMode
--
function Reward_DEBUG(...)
    return B_Reward_DEBUG:new(...);
end

B_Reward_DEBUG = {
    Name = "Reward_DEBUG",
    Description = {
        en = "Reward: Start the debug mode. See documentation for more information.",
        de = "Lohn: Startet den Debug-Modus. Für mehr Informationen siehe Dokumentation.",
        fr = "Récompense: Démarre le mode de débug. Pour plus d'informations, voir la documentation.",
    },
    Parameter = {
        { ParameterType.Custom,     en = "Check quest while runtime",   de = "Quests zur Laufzeit prüfen",  fr = "Vérifier les quêtes au cours de l'exécution" },
        { ParameterType.Custom,     en = "Use quest trace",             de = "Questverfolgung",             fr = "Suivi de quête" },
        { ParameterType.Custom,     en = "Activate developing cheats",  de = "Cheats aktivieren",           fr = "Activer les cheats" },
        { ParameterType.Custom,     en = "Activate developing shell",   de = "Eingabe aktivieren",          fr = "Activer la saisie" },
    },
}

function B_Reward_DEBUG:GetRewardTable(_Quest)
    return { Reward.Custom, {self, self.CustomFunction} }
end

function B_Reward_DEBUG:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.CheckWhileRuntime = API.ToBoolean(_Parameter);
    elseif (_Index == 1) then
        self.UseQuestTrace = API.ToBoolean(_Parameter);
    elseif (_Index == 2) then
        self.DevelopingCheats = API.ToBoolean(_Parameter);
    elseif (_Index == 3) then
        self.DevelopingShell = API.ToBoolean(_Parameter);
    end
end

function B_Reward_DEBUG:CustomFunction(_Quest)
    API.ActivateDebugMode(self.CheckWhileRuntime, self.UseQuestTrace, self.DevelopingCheats, self.DevelopingShell);
end

function B_Reward_DEBUG:GetCustomData(_Index)
    return {"true","false"};
end

Swift:RegisterBehavior(B_Reward_DEBUG);

-- -------------------------------------------------------------------------- --
-- GOALS

---
-- Ein Interaktives Objekt muss benutzt werden.
--
-- @param _ScriptName Skriptname des interaktiven Objektes
--
-- @within Goal
--
function Goal_ActivateObject(...)
    return B_Goal_ActivateObject:new(...);
end

B_Goal_ActivateObject = {
    Name = "Goal_ActivateObject",
    Description = {
        en = "Goal: Activate an interactive object",
        de = "Ziel: Aktiviere ein interaktives Objekt",
        fr = "Objectif: activer un objet interactif",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Object name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Goal_ActivateObject:GetGoalTable()
    return {Objective.Object, { self.ScriptName } }
end

function B_Goal_ActivateObject:AddParameter(_Index, _Parameter)
   if _Index == 0 then
        self.ScriptName = _Parameter
   end
end

function B_Goal_ActivateObject:GetMsgKey()
    return "Quest_Object_Activate"
end

Swift:RegisterBehavior(B_Goal_ActivateObject);

-- -------------------------------------------------------------------------- --

---
-- Einem Spieler müssen Rohstoffe oder Waren gesendet werden.
--
-- In der Regel wird zum Auftraggeber gesendet. Es ist aber möglich auch zu
-- einem anderen Zielspieler schicken zu lassen. Wird ein Wagen gefangen
-- genommen, dann muss erneut geschickt werden. Optional kann dem Spieler
-- auch erlaubt werden, den Karren zurückzuerobern.
--
-- @param _GoodType      Typ der Ware
-- @param _GoodAmount    Menga der Ware
-- @param _OtherTarget   Anderes Ziel als Auftraggeber
-- @param _IgnoreCapture Wagen kann zurückerobert werden
--
-- @within Goal
--
function Goal_Deliver(...)
    return B_Goal_Deliver:new(...)
end

B_Goal_Deliver = {
    Name = "Goal_Deliver",
    Description = {
        en = "Goal: Deliver goods to quest giver or to another player.",
        de = "Ziel: Liefere Waren zum Auftraggeber oder zu einem anderen Spieler.",
        fr = "Objectif: livrer des marchandises au mandant ou à un autre joueur.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Type of good", de = "Ressourcentyp", fr = "Type de ressources" },
        { ParameterType.Number, en = "Amount of good", de = "Ressourcenmenge", fr = "Quantité de ressources" },
        { ParameterType.Custom, en = "To different player", de = "Anderer Empfänger", fr = "Autre bénéficiaire" },
        { ParameterType.Custom, en = "Ignore capture", de = "Abfangen ignorieren", fr = "Ignorer une interception" },
    },
}

function B_Goal_Deliver:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Deliver, GoodType, self.GoodAmount, self.OverrideTarget, self.IgnoreCapture }
end

function B_Goal_Deliver:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    elseif (_Index == 2) then
        self.OverrideTarget = tonumber(_Parameter)
    elseif (_Index == 3) then
        self.IgnoreCapture = API.ToBoolean(_Parameter)
    end
end

function B_Goal_Deliver:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        table.insert( Data, "-" )
        for i = 1, 8 do
            table.insert( Data, i )
        end
    elseif _Index == 3 then
        table.insert( Data, "true" )
        table.insert( Data, "false" )
    else
        assert( false )
    end
    return Data
end

function B_Goal_Deliver:GetMsgKey()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    local GC = Logic.GetGoodCategoryForGoodType( GoodType )

    local tMapping = {
        [GoodCategories.GC_Clothes] = "Quest_Deliver_GC_Clothes",
        [GoodCategories.GC_Entertainment] = "Quest_Deliver_GC_Entertainment",
        [GoodCategories.GC_Food] = "Quest_Deliver_GC_Food",
        [GoodCategories.GC_Gold] = "Quest_Deliver_GC_Gold",
        [GoodCategories.GC_Hygiene] = "Quest_Deliver_GC_Hygiene",
        [GoodCategories.GC_Medicine] = "Quest_Deliver_GC_Medicine",
        [GoodCategories.GC_Water] = "Quest_Deliver_GC_Water",
        [GoodCategories.GC_Weapon] = "Quest_Deliver_GC_Weapon",
        [GoodCategories.GC_Resource] = "Quest_Deliver_Resources",
    }

    if GC then
        local Key = tMapping[GC]
        if Key then
            return Key
        end
    end
    return "Quest_Deliver_Goods"
end

Swift:RegisterBehavior(B_Goal_Deliver);

-- -------------------------------------------------------------------------- --

---
-- Es muss ein bestimmter Diplomatiestatus zu einer anderen Patei erreicht
-- werden. Der Status kann eine Verbesserung oder eine Verschlechterung zum
-- aktuellen Status sein.
--
-- Die Relation kann entweder auf kleiner oder gleich (<=), größer oder gleich
-- (>=), oder exakte Gleichheit (==) eingestellt werden. Exakte GLeichheit ist
-- wegen der Gefahr eines Soft Locks mit Vorsicht zu genießen.
--
-- @param _PlayerID Partei, die Entdeckt werden muss
-- @param _Relation Größer-Kleiner-Relation
-- @param _State    Diplomatiestatus
--
-- @within Goal
--
function Goal_Diplomacy(...)
    return B_Goal_Diplomacy:new(...);
end

B_Goal_Diplomacy = {
    Name = "Goal_Diplomacy",
    Description = {
        en = "Goal: A diplomatic state must b reached. Can be lower than current state or higher.",
        de = "Ziel: Die Beziehungen zu einem Spieler müssen entweder verbessert oder verschlechtert werden.",
        fr = "Objectif: les relations avec un joueur doivent être soit améliorées, soit détériorées.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Party", de = "Partei", fr = "Faction" },
        { ParameterType.Custom,   en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Custom,   en = "Diplomacy state", de = "Diplomatische Beziehung", fr = "Relations diplomatiques" },
    },
    DiploNameMap = {
        [DiplomacyStates.Allied]             = {de = "Verbündeter",    en = "Allied",               fr = "Allié"},
        [DiplomacyStates.TradeContact]       = {de = "Handelspartner", en = "Trade Contact",        fr = "Partenaire commercial"},
        [DiplomacyStates.EstablishedContact] = {de = "Bekannt",        en = "Established Contact",  fr = "Contact établi"},
        [DiplomacyStates.Undecided]          = {de = "Unbekannt",      en = "Undecided",            fr = "Inconnu"},
        [DiplomacyStates.Enemy]              = {de = "Feind",          en = "Enemy",                fr = "Ennemi"},
    },
    TextPattern = {
        de = "DIPLOMATIESTATUS ERREICHEN {cr}{cr}Status: %s{cr}Zur Partei: %s",
        en = "DIPLOMATIC STATE {cr}{cr}State: %s{cr}To player: %s",
        fr = "ATTEINDRE LE STATUT DE DIPLOMATIQUE {cr}{cr}Statut : %s{cr}Avec la faction : %s",
    },
}

function B_Goal_Diplomacy:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_Diplomacy:ChangeCaption(_Quest)
    local PlayerName = GetPlayerName(self.PlayerID) or "";
    local Text = string.format(
        Swift:Localize(self.TextPattern),
        Swift:Localize(self.DiploNameMap[self.DiplState]),
        PlayerName
    );
    Swift.Quest:ChangeCustomQuestCaptionText(Text, _Quest);
end

function B_Goal_Diplomacy:CustomFunction(_Quest)
    self:ChangeCaption(_Quest);
    if self.Relation == "<=" then
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) <= self.DiplState then
            return true;
        end
    elseif self.Relation == ">=" then
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) >= self.DiplState then
            return true;
        end
    else
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) == self.DiplState then
            return true;
        end
    end
end

function B_Goal_Diplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Relation = _Parameter;
    elseif (_Index == 2) then
        self.DiplState = DiplomacyStates[_Parameter];
    end
end

function B_Goal_Diplomacy:GetIcon()
    return {6, 3};
end

function B_Goal_Diplomacy:GetCustomData(_Index)
    if _Index == 1 then
        return {">=", "<=", "=="};
    elseif _Index == 2 then
        return {"Allied", "TradeContact", "EstablishedContact", "Undecided", "Enemy"};
    end
end

Swift:RegisterBehavior(B_Goal_Diplomacy);

-- -------------------------------------------------------------------------- --

---
-- Das Heimatterritorium des Spielers muss entdeckt werden.
--
-- Das Heimatterritorium ist immer das, wo sich Burg oder Lagerhaus der
-- zu entdeckenden Partei befinden.
--
-- @param _PlayerID ID der zu entdeckenden Partei
--
-- @within Goal
--
function Goal_DiscoverPlayer(...)
    return B_Goal_DiscoverPlayer:new(...);
end

B_Goal_DiscoverPlayer = {
    Name = "Goal_DiscoverPlayer",
    Description = {
        en = "Goal: Discover the home territory of another player.",
        de = "Ziel: Entdecke das Heimatterritorium eines Spielers.",
        fr = "Objectif: Découvrir le territoire d'origine d'un joueur.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_DiscoverPlayer:GetGoalTable()
    return {Objective.Discover, 2, { self.PlayerID } }
end

function B_Goal_DiscoverPlayer:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_DiscoverPlayer:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_Discover",
        [PlayerCategories.City] = "Quest_Discover_City",
        [PlayerCategories.Cloister] = "Quest_Discover_Cloister",
        [PlayerCategories.Harbour] = "Quest_Discover",
        [PlayerCategories.Village] = "Quest_Discover_Village",
    }
    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_Discover"
end

Swift:RegisterBehavior(B_Goal_DiscoverPlayer);

-- -------------------------------------------------------------------------- --

---
-- Ein Territorium muss erstmalig vom Auftragnehmer betreten werden.
--
-- Wenn ein Spieler zuvor mit seinen Einheiten auf dem Territorium war, ist
-- es bereits entdeckt und das Ziel sofort erfüllt.
--
-- @param _Territory Name oder ID des Territorium
--
-- @within Goal
--
function Goal_DiscoverTerritory(...)
    return B_Goal_DiscoverTerritory:new(...);
end

B_Goal_DiscoverTerritory = {
    Name = "Goal_DiscoverTerritory",
    Description = {
        en = "Goal: Discover a territory",
        de = "Ziel: Entdecke ein Territorium",
        fr = "Objectif : Découvrir un territoire",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", fr = "Territoire" },
    },
}

function B_Goal_DiscoverTerritory:GetGoalTable()
    return { Objective.Discover, 1, { self.TerritoryID  } }
end

function B_Goal_DiscoverTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
        assert( self.TerritoryID > 0 )
    end
end

function B_Goal_DiscoverTerritory:GetMsgKey()
    return "Quest_Discover_Territory"
end

Swift:RegisterBehavior(B_Goal_DiscoverTerritory);

-- -------------------------------------------------------------------------- --

---
-- Eine andere Partei muss besiegt werden.
--
-- Die Partei gilt als besiegt, wenn ein Hauptgebäude (Burg, Kirche, Lager)
-- zerstört wurde.
-- 
-- <b>Achtung:</b> Bei Banditen ist dieses Behavior wenig sinnvoll, da sie
-- nicht durch zerstörung ihres Hauptzeltes vernichtet werden. Hier bietet
-- sich Goal_DestroyAllPlayerUnits an.
--
-- @param _PlayerID ID des Spielers
--
-- @within Goal
--
function Goal_DestroyPlayer(...)
    return B_Goal_DestroyPlayer:new(...);
end

B_Goal_DestroyPlayer = {
    Name = "Goal_DestroyPlayer",
    Description = {
        en = "Goal: Destroy a player (destroy a main building)",
        de = "Ziel: Zerstöre einen Spieler (ein Hauptgebäude muss zerstört werden).",
        fr = "Objectif : Détruire un joueur (un bâtiment principal doit être détruit).",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_DestroyPlayer:GetGoalTable()
    assert( self.PlayerID <= 8 and self.PlayerID >= 1, "Error in " .. self.Name .. ": GetGoalTable: PlayerID is invalid")
    return { Objective.DestroyPlayers, self.PlayerID }
end

function B_Goal_DestroyPlayer:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_DestroyPlayer:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",
        [PlayerCategories.City] = "Quest_DestroyPlayers_City",
        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",
        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",
        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",
    }

    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_DestroyEntities_Building"
end

Swift:RegisterBehavior(B_Goal_DestroyPlayer)

-- -------------------------------------------------------------------------- --

---
-- Es sollen Informationen aus der Burg gestohlen werden.
--
-- Der Spieler muss einen Dieb entsenden um Informationen aus der Burg zu
-- stehlen. 
--
-- <b>Achtung:</b> Das ist nur bei Feinden möglich!
--
-- @param _PlayerID ID der Partei
--
-- @within Goal
--
function Goal_StealInformation(...)
    return B_Goal_StealInformation:new(...);
end

B_Goal_StealInformation = {
    Name = "Goal_StealInformation",
    Description = {
        en = "Goal: Steal information from another players castle",
        de = "Ziel: Stehle Informationen aus der Burg eines Spielers",
        fr = "Objectif : voler des informations du château d'un joueur",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_StealInformation:GetGoalTable()

    local Target = Logic.GetHeadquarters(self.PlayerID)
    if not Target or Target == 0 then
        Target = Logic.GetStoreHouse(self.PlayerID)
    end
    assert( Target and Target ~= 0 )
    return {Objective.Steal, 1, { Target } }

end

function B_Goal_StealInformation:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end

end

function B_Goal_StealInformation:GetMsgKey()
    return "Quest_Steal_Info"

end

Swift:RegisterBehavior(B_Goal_StealInformation);

-- -------------------------------------------------------------------------- --

---
-- Alle Einheiten des Spielers müssen zerstört werden.
--
-- <b>Achtung</b>: Bei normalen Parteien, welche ein Dorf oder eine Stadt
-- besitzen, ist Goal_DestroyPlayer besser geeignet!
--
-- @param _PlayerID ID des Spielers
--
-- @within Goal
--
function Goal_DestroyAllPlayerUnits(...)
    return B_Goal_DestroyAllPlayerUnits:new(...);
end

B_Goal_DestroyAllPlayerUnits = {
    Name = "Goal_DestroyAllPlayerUnits",
    Description = {
        en = "Goal: Destroy all units owned by player (be careful with script entities)",
        de = "Ziel: Zerstöre alle Einheiten eines Spielers (vorsicht mit Script-Entities)",
        fr = "Objectif: Détruire toutes les unités d'un joueur (attention aux entités de script)",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_DestroyAllPlayerUnits:GetGoalTable()
    return { Objective.DestroyAllPlayerUnits, self.PlayerID }
end

function B_Goal_DestroyAllPlayerUnits:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_DestroyAllPlayerUnits:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",
        [PlayerCategories.City] = "Quest_DestroyPlayers_City",
        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",
        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",
        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",
    }

    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_DestroyEntities"
end

Swift:RegisterBehavior(B_Goal_DestroyAllPlayerUnits);

-- -------------------------------------------------------------------------- --

---
-- Ein benanntes Entity muss zerstört werden.
--
-- Ein Entity gilt als zerstört, wenn es nicht mehr existiert oder während
-- der Laufzeit des Quests seine Entity-ID oder den Besitzer verändert.
--
-- <b>Achtung</b>: Helden können nicht direkt zerstört werden. Bei ihnen
-- genügt es, wenn sie sich "in die Burg zurückziehen".
--
-- @param _ScriptName Skriptname des Ziels
--
-- @within Goal
--
function Goal_DestroyScriptEntity(...)
    return B_Goal_DestroyScriptEntity:new(...);
end

B_Goal_DestroyScriptEntity = {
    Name = "Goal_DestroyScriptEntity",
    Description = {
        en = "Goal: Destroy an entity",
        de = "Ziel: Zerstöre eine Entität",
        fr = "Objectif : Détruire une entité",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Goal_DestroyScriptEntity:GetGoalTable()
    return {Objective.DestroyEntities, 1, { self.ScriptName } }
end

function B_Goal_DestroyScriptEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Goal_DestroyScriptEntity:GetMsgKey()
    if Logic.IsEntityAlive(self.ScriptName) then
        local ID = GetID(self.ScriptName)
        if ID and ID ~= 0 then
            ID = Logic.GetEntityType( ID )
            if ID and ID ~= 0 then
                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
                    return "Quest_DestroyEntities_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then
                    return "Quest_DestroyEntities_Predators"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
                    return "Quest_Destroy_Leader"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1
                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1
                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then

                    return "Quest_DestroyEntities_Unit"
                end
            end
        end
    end
    return "Quest_DestroyEntities"
end

Swift:RegisterBehavior(B_Goal_DestroyScriptEntity);

-- -------------------------------------------------------------------------- --

---
-- Eine Menge an Entities eines Typs müssen zerstört werden.
--
-- <b>Achtung</b>: Wenn Raubtiere zerstört werden sollen, muss Spieler 0
-- als Besitzer angegeben werden.
--
-- @param _EntityType Typ des Entity
-- @param _Amount     Menge an Entities des Typs
-- @param _PlayerID   Besitzer des Entity
--
-- @within Goal
--
function Goal_DestroyType(...)
    return B_Goal_DestroyType:new(...);
end

B_Goal_DestroyType = {
    Name = "Goal_DestroyType",
    Description = {
        en = "Goal: Destroy entity types",
        de = "Ziel: Zerstöre Entitätstypen",
        fr = "Objectif: Détruire les types d'entités",
    },
    Parameter = {
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung", fr = "Désignation du type" },
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr = "Quantité" },
        { ParameterType.Custom, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_DestroyType:GetGoalTable()
    return {Objective.DestroyEntities, 2, Entities[self.EntityName], self.Amount, self.PlayerID }
end

function B_Goal_DestroyType:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
        self.DestroyTypeAmount = self.Amount
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_DestroyType:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Entities ) do
            if string.find( k, "^[ABU]_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        for i = 0, 8 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function B_Goal_DestroyType:GetMsgKey()
    local ID = self.EntityName
    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
        return "Quest_DestroyEntities_Building"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then
        return "Quest_DestroyEntities_Predators"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
        return "Quest_Destroy_Leader"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then

        return "Quest_DestroyEntities_Unit"
    end
    return "Quest_DestroyEntities"
end

Swift:RegisterBehavior(B_Goal_DestroyType);

-- -------------------------------------------------------------------------- --

---
-- Eine Entfernung zwischen zwei Entities muss erreicht werden.
--
-- Je nach angegebener Relation muss die Entfernung unter- oder überschritten
-- werden, um den Quest zu gewinnen.
--
-- @param _ScriptName1  Erstes Entity
-- @param _ScriptName2  Zweites Entity
-- @param _Relation     Relation
-- @param _Distance     Entfernung
--
-- @within Goal
--
function Goal_EntityDistance(...)
    return B_Goal_EntityDistance:new(...);
end

B_Goal_EntityDistance = {
    Name = "Goal_EntityDistance",
    Description = {
        en = "Goal: Distance between two entities",
        de = "Ziel: Zwei Entities sollen zueinander eine Entfernung über- oder unterschreiten.",
        fr = "Objectif: deux entités doivent se trouver à une distance supérieure ou inférieure l'une de l'autre.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1", fr = "Entité 1" },
        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2", fr = "Entité 2" },
        { ParameterType.Custom, en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Number, en = "Distance", de = "Entfernung", fr = "Distance" },
    },
}

function B_Goal_EntityDistance:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_EntityDistance:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity1 = _Parameter
    elseif (_Index == 1) then
        self.Entity2 = _Parameter
    elseif (_Index == 2) then
        self.bRelSmallerThan = _Parameter == "<"
    elseif (_Index == 3) then
        self.Distance = _Parameter * 1
    end
end

function B_Goal_EntityDistance:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.Entity1 ) or Logic.IsEntityDestroyed( self.Entity2 ) then
        return false
    end
    local ID1 = GetID( self.Entity1 )
    local ID2 = GetID( self.Entity2 )
    local InRange = Logic.CheckEntitiesDistance( ID1, ID2, self.Distance )
    if ( self.bRelSmallerThan and InRange ) or ( not self.bRelSmallerThan and not InRange ) then
        return true
    end
end

function B_Goal_EntityDistance:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        table.insert( Data, ">" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

function B_Goal_EntityDistance:Debug(_Quest)
    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then
        error(_Quest.Identifier.. ": " ..self.Name..": At least 1 of the entities for distance check don't exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Goal_EntityDistance);

-- -------------------------------------------------------------------------- --

---
-- Der Primary Knight des angegebenen Spielers muss sich dem Ziel nähern.
--
-- Die Distanz, die unterschritten werden muss, kann frei bestimmt werden.
-- Wird die Distanz 0 belassen, wird sie automatisch 2500.
--
-- @param _ScriptName Skriptname des Ziels
-- @param _Disctande  (optional) Entfernung zum Ziel
--
-- @within Goal
--
function Goal_KnightDistance(...)
    return B_Goal_KnightDistance:new(...);
end

B_Goal_KnightDistance = {
    Name = "Goal_KnightDistance",
    Description = {
        en = "Goal: Bring the knight close to a given entity. If the distance is left at 0 it will automatically set to 2500.",
        de = "Ziel: Bringe den Ritter nah an eine bestimmte Entität. Wird die Entfernung 0 gelassen, ist sie automatisch 2500.",
        fr = "Objectif : Rapproche le chevalier d'une entité donnée. Si la distance est laissée à 0, elle est automatiquement de 2500.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target", de = "Ziel", fr = "Cible" },
        { ParameterType.Number, en = "Distance", de = "Entfernung", fr = "Distance" },
    },
}

function B_Goal_KnightDistance:GetGoalTable()
    return {Objective.Distance, -65566, self.Target, self.Distance, true}
end

function B_Goal_KnightDistance:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Target = _Parameter;
    elseif (_Index == 1) then
        if _Parameter == nil or _Parameter == "" then
            _Parameter = 0;
        end
        self.Distance = _Parameter * 1;
        if self.Distance == 0 then
            self.Distance = 2500;
        end
    end
end

Swift:RegisterBehavior(B_Goal_KnightDistance);

---
-- Eine bestimmte Anzahl an Einheiten einer Kategorie muss sich auf dem
-- Territorium befinden.
--
-- Es kann entweder gefordert werden, weniger als die angegebene Menge auf
-- dem Territorium zu haben (z.B. "<"" 1 für 0) oder mindestens so
-- viele Entities (z.B. ">=" 5 für mindestens 5).
--
-- @param _Territory  TerritoryID oder TerritoryName
-- @param _PlayerID   PlayerID der Einheiten
-- @param _Category   Kategorie der Einheiten
-- @param _Relation   Mengenrelation (< oder >=)
-- @param _Amount     Menge an Einheiten
--
-- @within Goal
--
function Goal_UnitsOnTerritory(...)
    return B_Goal_UnitsOnTerritory:new(...);
end

B_Goal_UnitsOnTerritory = {
    Name = "Goal_UnitsOnTerritory",
    Description = {
        en = "Goal: Place a certain amount of units on a territory",
        de = "Ziel: Platziere eine bestimmte Anzahl Einheiten auf einem Gebiet",
        fr = "Objectif: placer un certain nombre d'unités sur un territoire",
    },
    Parameter = {
        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium", fr = "Territoire" },
        { ParameterType.Custom,  en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Custom,  en = "Category", de = "Kategorie", fr = "Catégorie" },
        { ParameterType.Custom,  en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Number,  en = "Number of units", de = "Anzahl Einheiten", fr = "Quantité d'unitées" },
    },
}

function B_Goal_UnitsOnTerritory:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_UnitsOnTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if self.TerritoryID == nil then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    elseif (_Index == 1) then
        self.PlayerID = tonumber(_Parameter) * 1
    elseif (_Index == 2) then
        self.Category = _Parameter
    elseif (_Index == 3) then
        self.bRelSmallerThan = (tostring(_Parameter) == "true" or tostring(_Parameter) == "<")
    elseif (_Index == 4) then
        self.NumberOfUnits = _Parameter * 1
    end
end

function B_Goal_UnitsOnTerritory:CustomFunction(_Quest)
    local PlayerEntities = self:GetEntities(self.TerritoryID, self.PlayerID, EntityCategories[self.Category]);
    if self.bRelSmallerThan == false and #PlayerEntities >= self.NumberOfUnits then
        return true;
    elseif self.bRelSmallerThan == true and #PlayerEntities < self.NumberOfUnits then
        return true;
    end
end

function B_Goal_UnitsOnTerritory:GetEntities(_TerritoryID, _PlayerID, _Category)
    local PlayerEntities = {};
    local Units = {};
    if (_PlayerID == -1) then
        for i=0,8 do
            local NumLast = 0;
            repeat
                Units = {Logic.GetEntitiesOfCategoryInTerritory(_TerritoryID, i, _PlayerID, NumLast)};
                PlayerEntities = Array_Append(PlayerEntities, Units);
                NumLast = NumLast + #Units;
            until #Units == 0;
        end
    else
        local NumLast = 0;
        repeat
            Units = { Logic.GetEntitiesOfCategoryInTerritory(_TerritoryID, _PlayerID, _Category, NumLast)};
            PlayerEntities = Array_Append(PlayerEntities, Units);
            NumLast = NumLast + #Units;
        until #Units == 0;
    end
    return PlayerEntities;
end

function B_Goal_UnitsOnTerritory:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, -1 )
        for i = 1, 8 do
            table.insert( Data, i )
        end
    elseif _Index == 2 then
        for k, v in pairs( EntityCategories ) do
            if not string.find( k, "^G_" ) and k ~= "SheepPasture" then
                table.insert( Data, k )
            end
        end
        table.sort( Data );
    elseif _Index == 3 then
        table.insert( Data, ">=" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

function B_Goal_UnitsOnTerritory:Debug(_Quest)
    local territories = {Logic.GetTerritories()}
    if tonumber(self.TerritoryID) == nil or self.TerritoryID < 0 or not table.contains(territories, self.TerritoryID) then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid territoryID!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 0 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    elseif not EntityCategories[self.Category] then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid entity category!");
        return true;
    elseif tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits < 0 then
        error(_Quest.Identifier.. ": " ..self.Name..": amount is negative or nil!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Goal_UnitsOnTerritory);

-- -------------------------------------------------------------------------- --

---
-- Der angegebene Spieler muss einen Buff aktivieren.
--
-- <u>Buffs "Aufstieg eines Königreich"</u>
-- <li>Buff_Spice: Salz</li>
-- <li>Buff_Colour: Farben</li>
-- <li>Buff_Entertainers: Entertainer anheuern</li>
-- <li>Buff_FoodDiversity: Vielfältige Nahrung</li>
-- <li>Buff_ClothesDiversity: Vielfältige Kleidung</li>
-- <li>Buff_HygieneDiversity: Vielfältige Hygiene</li>
-- <li>Buff_EntertainmentDiversity: Vielfältige Unterhaltung</li>
-- <li>Buff_Sermon: Predigt halten</li>
-- <li>Buff_Festival: Fest veranstalten</li>
-- <li>Buff_ExtraPayment: Bonussold auszahlen</li>
-- <li>Buff_HighTaxes: Hohe Steuern verlangen</li>
-- <li>Buff_NoPayment: Sold streichen</li>
-- <li>Buff_NoTaxes: Keine Steuern verlangen</li>
-- <br/>
-- <u>Buffs "Reich des Ostens"</u>
-- <li>Buff_Gems: Edelsteine</li>
-- <li>Buff_MusicalInstrument: Musikinstrumente</li>
-- <li>Buff_Olibanum: Weihrauch</li>
--
-- @param _PlayerID Spieler, der den Buff aktivieren muss
-- @param _Buff     Buff, der aktiviert werden soll
--
-- @within Goal
--
function Goal_ActivateBuff(...)
    return B_Goal_ActivateBuff:new(...);
end

B_Goal_ActivateBuff = {
    Name = "Goal_ActivateBuff",
    Description = {
        en = "Goal: Activate a buff",
        de = "Ziel: Aktiviere einen Buff",
        fr = "Objectif: Activer un bonus",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Custom, en = "Buff", de = "Buff", fr = "Bonus" },
    },
}

function B_Goal_ActivateBuff:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_ActivateBuff:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.BuffName = _Parameter
        self.Buff = Buffs[_Parameter]
    end
end

function B_Goal_ActivateBuff:CustomFunction(_Quest)
   if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local tMapping = Swift.LuaBase:CopyTable(Swift.Behavior.Text.ActivateBuff.BuffsVanilla);
        if g_GameExtraNo >= 1 then
            tMapping = Swift.LuaBase:CopyTable(Swift.Behavior.Text.ActivateBuff.BuffsEx1, tMapping);
        end
        Swift.Quest:ChangeCustomQuestCaptionText(
            string.format(
                Swift:Localize(Swift.Behavior.Text.ActivateBuff.Pattern),
                Swift:Localize(tMapping[self.BuffName])
            ),
            _Quest
        );
    end

    local Buff = Logic.GetBuff( self.PlayerID, self.Buff )
    if Buff and Buff ~= 0 then
        return true
    end
end

function B_Goal_ActivateBuff:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        Data = {
            "Buff_Spice",
            "Buff_Colour",
            "Buff_Entertainers",
            "Buff_FoodDiversity",
            "Buff_ClothesDiversity",
            "Buff_HygieneDiversity",
            "Buff_EntertainmentDiversity",
            "Buff_Sermon",
            "Buff_Festival",
            "Buff_ExtraPayment",
            "Buff_HighTaxes",
            "Buff_NoPayment",
            "Buff_NoTaxes"
        }

        if g_GameExtraNo >= 1 then
            table.insert(Data, "Buff_Gems")
            table.insert(Data, "Buff_MusicalInstrument")
            table.insert(Data, "Buff_Olibanum")
        end

        table.sort( Data )
    else
        assert( false )
    end
    return Data
end

function B_Goal_ActivateBuff:GetIcon()
    local tMapping = {
        [Buffs.Buff_Spice]                  = "Goods.G_Salt",
        [Buffs.Buff_Colour]                 = "Goods.G_Dye",
        [Buffs.Buff_Entertainers]           = "Entities.U_Entertainer_NA_FireEater", --{5, 12},
        [Buffs.Buff_FoodDiversity]          = "Needs.Nutrition", --{1, 1},
        [Buffs.Buff_ClothesDiversity]       = "Needs.Clothes", --{1, 2},
        [Buffs.Buff_HygieneDiversity]       = "Needs.Hygiene", --{16, 1},
        [Buffs.Buff_EntertainmentDiversity] = "Needs.Entertainment", --{1, 4},
        [Buffs.Buff_Sermon]                 = "Technologies.R_Sermon", --{4, 14},
        [Buffs.Buff_Festival]               = "Technologies.R_Festival", --{4, 15},
        [Buffs.Buff_ExtraPayment]           = {1,8},
        [Buffs.Buff_HighTaxes]              = {1,6},
        [Buffs.Buff_NoPayment]              = {1,8},
        [Buffs.Buff_NoTaxes]                = {1,6},
    }
    if g_GameExtraNo and g_GameExtraNo >= 1 then
        tMapping[Buffs.Buff_Gems] = "Goods.G_Gems"
        tMapping[Buffs.Buff_MusicalInstrument] = "Goods.G_MusicalInstrument"
        tMapping[Buffs.Buff_Olibanum] = "Goods.G_Olibanum"
    end
    return tMapping[self.Buff]
end

function B_Goal_ActivateBuff:Debug(_Quest)
    if not self.Buff then
        error(_Quest.Identifier.. ": " ..self.Name..": buff '" ..self.BuffName.. "' does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Goal_ActivateBuff);

-- -------------------------------------------------------------------------- --

---
-- Zwei Punkte auf der Spielwelt müssen mit einer Straße verbunden werden.
--
-- @param _Position1 Erster Endpunkt der Straße
-- @param _Position2 Zweiter Endpunkt der Straße
-- @param _OnlyRoads Keine Wege akzeptieren
--
-- @within Goal
--
function Goal_BuildRoad(...)
    return B_Goal_BuildRoad:new(...)
end

B_Goal_BuildRoad = {
    Name = "Goal_BuildRoad",
    Description = {
        en = "Goal: Connect two points with a street or a road",
        de = "Ziel: Verbinde zwei Punkte mit einer Strasse oder einem Weg.",
        fr = "Objectif: Relier deux points par une route ou un chemin.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity 1",       de = "Entity 1",     fr = "Entité 1" },
        { ParameterType.ScriptName, en = "Entity 2",       de = "Entity 2",     fr = "Entité 2" },
        { ParameterType.Custom,     en = "Only roads",     de = "Nur Strassen", fr = "Que des Routes" },
    },
}

function B_Goal_BuildRoad:GetGoalTable()
    -- {BehaviorType, {EntityID1, EntityID2, BeSmalerThan, Length, RoadsOnly}}
    -- -> Length wird nicht mehr benutzt. Sorgte für Promleme im Spiel
    return { Objective.BuildRoad, { GetID( self.Entity1 ), GetID( self.Entity2 ), false, 0, self.bRoadsOnly } }
end

function B_Goal_BuildRoad:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity1 = _Parameter
    elseif (_Index == 1) then
        self.Entity2 = _Parameter
    elseif (_Index == 2) then
        self.bRoadsOnly = API.ToBoolean(_Parameter)
    end
end

function B_Goal_BuildRoad:GetCustomData( _Index )
    local Data
    if _Index == 2 then
        Data = {"true","false"}
    end
    return Data
end

function B_Goal_BuildRoad:Debug(_Quest)
    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then
        error(_Quest.Identifier.. ": " ..self.Name..": first or second entity does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Goal_BuildRoad);

-- -------------------------------------------------------------------------- --


---
-- Eine Mauer muss gebaut werden um die Bewegung eines Spielers einzuschränken.
-- 
-- Einschränken bedeutet, dass sich der angegebene Spieler nicht von Punkt A
-- nach Punkt B bewegen kann, weil eine Mauer im Weg ist. Die Punkte sind
-- frei wählbar. In den meisten Fällen reicht es, Marktplätze anzugeben.
--
-- Beispiel: Spieler 3 ist der Feind von Spieler 1, aber Bekannt mit Spieler 2.
-- Wenn er sich nicht mehr zwischen den Marktplätzen von Spieler 1 und 2
-- bewegen kann, weil eine Mauer dazwischen ist, ist das Ziel erreicht.
--
-- <b>Achtung:</b> Bei Monsun kann dieses Ziel fälschlicher Weise als erfüllt
-- gewertet werden, wenn der Weg durch Wasser blockiert wird!
--
-- @param _PlayerID  PlayerID, die blockiert wird
-- @param _Position1 Erste Position
-- @param _Position2 Zweite Position
--
-- @within Goal
--
function Goal_BuildWall(...)
    return B_Goal_BuildWall:new(...)
end

B_Goal_BuildWall = {
    Name = "Goal_BuildWall",
    Description = {
        en = "Goal: Build a wall between 2 positions bo stop the movement of an (hostile) player.",
        de = "Ziel: Baue eine Mauer zwischen 2 Punkten, die die Bewegung eines (feindlichen) Spielers zwischen den Punkten verhindert.",
        fr = "Objectif: Construire un mur entre 2 points qui empêche le déplacement d'un joueur (ennemi) entre les points.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Enemy", de = "Feind", fr = "Ennemi" },
        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1", fr = "Entité 1" },
        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2", fr = "Entité 2" },
    },
}

function B_Goal_BuildWall:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_BuildWall:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.EntityName1 = _Parameter
    elseif (_Index == 2) then
        self.EntityName2 = _Parameter
    end
end

function B_Goal_BuildWall:CustomFunction(_Quest)
    local eID1 = GetID(self.EntityName1)
    local eID2 = GetID(self.EntityName2)

    if not IsExisting(eID1) then
        return false
    end
    if not IsExisting(eID2) then
        return false
    end
    local x,y,z = Logic.EntityGetPos(eID1)
    if Logic.IsBuilding(eID1) == 1 then
        x,y = Logic.GetBuildingApproachPosition(eID1)
    end
    local Sector1 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)
    local x,y,z = Logic.EntityGetPos(eID2)
    if Logic.IsBuilding(eID2) == 1 then
        x,y = Logic.GetBuildingApproachPosition(eID2)
    end
    local Sector2 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)
    if Sector1 ~= Sector2 then
        return true
    end
    return nil
end

function B_Goal_BuildWall:GetMsgKey()
    return "Quest_Create_Wall"
end

function B_Goal_BuildWall:GetIcon()
    return {3,9}
end

function B_Goal_BuildWall:Debug(_Quest)
    if not IsExisting(self.EntityName1) or not IsExisting(self.EntityName2) then
        error(_Quest.Identifier.. ": " ..self.Name..": first or second entity does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end

    if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) > -1 and not self.WarningPrinted then
        warn(_Quest.Identifier.. ": " ..self.Name..": player %d is neighter enemy or unknown to quest receiver!");
        self.WarningPrinted = true;
    end
    return false;
end

Swift:RegisterBehavior(B_Goal_BuildWall);

-- -------------------------------------------------------------------------- --

---
-- Ein bestimmtes Territorium muss vom Auftragnehmer eingenommen werden.
--
-- @param _Territory Territorium-ID oder Territoriumname
--
-- @within Goal
--
function Goal_Claim(...)
    return B_Goal_Claim:new(...)
end

B_Goal_Claim = {
    Name = "Goal_Claim",
    Description = {
        en = "Goal: Claim a territory",
        de = "Ziel: Erobere ein Territorium",
        fr = "Objectif: Conquérir un territoire",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", fr = "Territoire" },
    },
}

function B_Goal_Claim:GetGoalTable()
    return { Objective.Claim, 1, self.TerritoryID }
end

function B_Goal_Claim:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    end
end

function B_Goal_Claim:GetMsgKey()
    return "Quest_Claim_Territory"
end

Swift:RegisterBehavior(B_Goal_Claim);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Menge an Territorien besitzen.
-- Das Heimatterritorium des Spielers wird mitgezählt!
--
-- @param _Amount Anzahl Territorien
--
-- @within Goal
--
function Goal_ClaimXTerritories(...)
    return B_Goal_ClaimXTerritories:new(...)
end

B_Goal_ClaimXTerritories = {
    Name = "Goal_ClaimXTerritories",
    Description = {
        en = "Goal: Claim the given number of territories, all player territories are counted",
        de = "Ziel: Erobere die angegebene Anzahl Territorien, alle spielereigenen Territorien werden gezählt",
        fr = "Objectif: conquérir le nombre de territoires indiqué, tous les territoires des joueurs sont comptabilisés.",
    },
    Parameter = {
        { ParameterType.Number, en = "Territories" , de = "Territorien", fr = "Territoire" }
    },
}

function B_Goal_ClaimXTerritories:GetGoalTable()
    return { Objective.Claim, 2, self.TerritoriesToClaim }
end

function B_Goal_ClaimXTerritories:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoriesToClaim = _Parameter * 1
    end
end

function B_Goal_ClaimXTerritories:GetMsgKey()
    return "Quest_Claim_Territory"
end

Swift:RegisterBehavior(B_Goal_ClaimXTerritories);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss auf dem Territorium einen Entitytyp erstellen.
--
-- Dieses Behavior eignet sich für Aufgaben vom Schlag "Baue X Getreidefarmen
-- Auf Territorium >".
--
-- @param _Type      Typ des Entity
-- @param _Amount    Menge an Entities
-- @param _Territory Territorium
--
-- @within Goal
--
function Goal_Create(...)
    return B_Goal_Create:new(...);
end

B_Goal_Create = {
    Name = "Goal_Create",
    Description = {
        en = "Goal: Create Buildings/Units on a specified territory",
        de = "Ziel: Erstelle Einheiten/Gebäude auf einem bestimmten Territorium.",
        fr = "Objectif: créer des unités/bâtiments sur un territoire donné.",
    },
    Parameter = {
        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung", fr = "Désignation du type" },
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr = "Quantité" },
        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium", fr = "Territoire" },
    },
}

function B_Goal_Create:GetGoalTable()
    return { Objective.Create, assert( Entities[self.EntityName] ), self.Amount, self.TerritoryID }
end

function B_Goal_Create:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    elseif (_Index == 2) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    end
end

function B_Goal_Create:GetMsgKey()
    return Logic.IsEntityTypeInCategory( Entities[self.EntityName], EntityCategories.AttackableBuilding ) == 1 and "Quest_Create_Building" or "Quest_Create_Unit"
end

Swift:RegisterBehavior(B_Goal_Create);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Menge von Rohstoffen produzieren.
--
-- @param _Type   Typ des Rohstoffs
-- @param _Amount Menge an Rohstoffen
--
-- @within Goal
--
function Goal_Produce(...)
    return B_Goal_Produce:new(...);
end

B_Goal_Produce = {
    Name = "Goal_Produce",
    Description = {
        en = "Goal: Produce an amount of goods",
        de = "Ziel: Produziere eine Anzahl einer bestimmten Ware.",
        fr = "Objectif: produire un certain nombre d'une marchandise donnée."
    },
    Parameter = {
        { ParameterType.RawGoods, en = "Type of good", de = "Ressourcentyp", fr = "Type de ressources" },
        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Ressource", fr = "Quantité de ressources" },
    },
}

function B_Goal_Produce:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Produce, GoodType, self.GoodAmount }
end

function B_Goal_Produce:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    end
end

function B_Goal_Produce:GetMsgKey()
    return "Quest_Produce"
end

Swift:RegisterBehavior(B_Goal_Produce);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss eine bestimmte Menge einer Ware erreichen.
--
-- @param _Type     Typ der Ware
-- @param _Amount   Menge an Waren
-- @param _Relation Mengenrelation
--
-- @within Goal
--
function Goal_GoodAmount(...)
    return B_Goal_GoodAmount:new(...);
end

B_Goal_GoodAmount = {
    Name = "Goal_GoodAmount",
    Description = {
        en = "Goal: Obtain an amount of goods - either by trading or producing them",
        de = "Ziel: Beschaffe eine Anzahl Waren - entweder durch Handel oder durch eigene Produktion.",
        fr = "Objectif: Se procurer un certain nombre de marchandises - soit par le commerce, soit par sa propre production."
    },
    Parameter = {
        { ParameterType.Custom, en = "Type of good", de = "Warentyp", fr = "TYpe de marchandises" },
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr = "Quantité" },
        { ParameterType.Custom, en = "Relation", de = "Relation", fr = "Relation" },
    },
}

function B_Goal_GoodAmount:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Produce, GoodType, self.GoodAmount, self.bRelSmallerThan }
end

function B_Goal_GoodAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    elseif  (_Index == 2) then
        self.bRelSmallerThan = _Parameter == "<" or tostring(_Parameter) == "true"
    end
end

function B_Goal_GoodAmount:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        table.insert( Data, ">=" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

Swift:RegisterBehavior(B_Goal_GoodAmount);

-- -------------------------------------------------------------------------- --

---
-- Die Siedler des Spielers dürfen nicht aufgrund des Bedürfnisses streiken.
--
-- <u>Bedürfnisse</u>
-- <ul>
-- <li>Clothes: Kleidung</li>
-- <li>Entertainment: Unterhaltung</li>
-- <li>Nutrition: Nahrung</li>
-- <li>Hygiene: Hygiene</li>
-- <li>Medicine: Medizin</li>
-- </ul>
--
-- @param _PlayerID ID des Spielers
-- @param _Need     Bedürfnis
--
-- @within Goal
--
function Goal_SatisfyNeed(...)
    return B_Goal_SatisfyNeed:new(...);
end

B_Goal_SatisfyNeed = {
    Name = "Goal_SatisfyNeed",
    Description = {
        en = "Goal: Satisfy a need",
        de = "Ziel: Erfuelle ein Beduerfnis",
        fr = "Objectif: Répondre à un besoin",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Need, en = "Need", de = "Beduerfnis", fr = "Besoin" },
    },
}

function B_Goal_SatisfyNeed:GetGoalTable()
    return { Objective.SatisfyNeed, Needs[self.Need], self.PlayerID }

end

function B_Goal_SatisfyNeed:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Need = _Parameter
    end

end

function B_Goal_SatisfyNeed:GetMsgKey()
    local tMapping = {
        [Needs.Clothes] = "Quest_SatisfyNeed_Clothes",
        [Needs.Entertainment] = "Quest_SatisfyNeed_Entertainment",
        [Needs.Nutrition] = "Quest_SatisfyNeed_Food",
        [Needs.Hygiene] = "Quest_SatisfyNeed_Hygiene",
        [Needs.Medicine] = "Quest_SatisfyNeed_Medicine",
    }

    local Key = tMapping[Needs[self.Need]]
    if Key then
        return Key
    end

    -- No default message
end

Swift:RegisterBehavior(B_Goal_SatisfyNeed);

-- -------------------------------------------------------------------------- --

---
-- Der angegebene Spieler muss eine Menge an Siedlern in der Stadt haben.
--
-- @param _Amount   Menge an Siedlern
-- @param _PlayerID ID des Spielers (Default: 1)
--
-- @within Goal
--
function Goal_SettlersNumber(...)
    return B_Goal_SettlersNumber:new(...);
end

B_Goal_SettlersNumber = {
    Name = "Goal_SettlersNumber",
    Description = {
        en = "Goal: Get a given amount of settlers",
        de = "Ziel: Erreiche eine bestimmte Anzahl Siedler.",
        fr = "Objectif: atteindre un certain nombre de Settlers.",
    },
    Parameter = {
        { ParameterType.Number,   en = "Amount", de = "Anzahl", fr = "Quantité" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_SettlersNumber:GetGoalTable()
    return {Objective.SettlersNumber, self.PlayerID or 1, self.SettlersAmount };
end

function B_Goal_SettlersNumber:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SettlersAmount = _Parameter * 1;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    end
end

function B_Goal_SettlersNumber:GetMsgKey()
    return "Quest_NumberSettlers";
end

Swift:RegisterBehavior(B_Goal_SettlersNumber);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Menge von Ehefrauen in der Stadt haben.
--
-- @param _Amount Menge an Ehefrauen
--
-- @within Goal
--
function Goal_Spouses(...)
    return B_Goal_Spouses:new(...);
end

B_Goal_Spouses = {
    Name = "Goal_Spouses",
    Description = {
        en = "Goal: Get a given amount of spouses",
        de = "Ziel: Erreiche eine bestimmte Ehefrauenanzahl",
        fr = "Objectif: Atteindre un certain nombre d'épouses",
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr = "Quantité" },
    },
}

function B_Goal_Spouses:GetGoalTable()
    return {Objective.Spouses, self.SpousesAmount }
end

function B_Goal_Spouses:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SpousesAmount = _Parameter * 1
    end
end

function B_Goal_Spouses:GetMsgKey()
    return "Quest_NumberSpouses"
end

Swift:RegisterBehavior(B_Goal_Spouses);

-- -------------------------------------------------------------------------- --

---
-- Ein Spieler muss eine Menge an Soldaten haben.
--
-- <u>Relationen</u>
-- <ul>
-- <li>>= - Anzahl als Mindestmenge</li>
-- <li>< - Weniger als Anzahl</li>
-- </ul>
--
-- Dieses Behavior kann verwendet werden um die Menge an feindlichen
-- Soldaten zu zählen oder die Menge an Soldaten des Spielers.
--
-- @param _PlayerID ID des Spielers
-- @param _Relation Mengenrelation
-- @param _Amount   Menge an Soldaten
--
-- @within Goal
--
function Goal_SoldierCount(...)
    return B_Goal_SoldierCount:new(...);
end

B_Goal_SoldierCount = {
    Name = "Goal_SoldierCount",
    Description = {
        en = "Goal: Create a specified number of soldiers",
        de = "Ziel: Erreiche eine Anzahl grösser oder kleiner der angegebenen Menge Soldaten.",
        fr = "Objectif: Atteindre un nombre de soldats supérieur ou inférieur à la quantité indiquée.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Custom, en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten", fr = "Nombre de soldats" },
    },
}

function B_Goal_SoldierCount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_SoldierCount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.bRelSmallerThan = tostring(_Parameter) == "true" or tostring(_Parameter) == "<"
    elseif (_Index == 2) then
        self.NumberOfUnits = _Parameter * 1
    end
end

function B_Goal_SoldierCount:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local Relation = tostring(self.bRelSmallerThan);
        local PlayerName = GetPlayerName(self.PlayerID) or "";
        Swift.Quest:ChangeCustomQuestCaptionText(
            string.format(
                Swift:Localize(Swift.Behavior.Text.SoldierCount.Pattern),
                PlayerName,
                Swift:Localize(Swift.Behavior.Text.SoldierCount.Relation[Relation]),
                self.NumberOfUnits
            ),
            _Quest
        );
    end

    local NumSoldiers = Logic.GetCurrentSoldierCount( self.PlayerID )
    if ( self.bRelSmallerThan and NumSoldiers < self.NumberOfUnits ) then
        return true
    elseif ( not self.bRelSmallerThan and NumSoldiers >= self.NumberOfUnits ) then
        return true
    end
    return nil
end

function B_Goal_SoldierCount:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then

        table.insert( Data, ">=" )
        table.insert( Data, "<" )

    else
        assert( false )
    end
    return Data
end

function B_Goal_SoldierCount:GetIcon()
    return {7,11}
end

function B_Goal_SoldierCount:GetMsgKey()
    return "Quest_Create_Unit"
end

function B_Goal_SoldierCount:Debug(_Quest)
    if tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits < 0 then
        error(_Quest.Identifier.. ": " ..self.Name..": amount can not be below 0!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Goal_SoldierCount);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss wenigstens einen bestimmten Titel erreichen.
--
-- Folgende Titel können verwendet werden:
-- <table border="1">
-- <tr>
-- <td><b>Titel</b></td>
-- <td><b>Übersetzung</b></td>
-- </tr>
-- <tr>
-- <td>Knight</td>
-- <td>Ritter</td>
-- </tr>
-- <tr>
-- <td>Mayor</td>
-- <td>Landvogt</td>
-- </tr>
-- <tr>
-- <td>Baron</td>
-- <td>Baron</td>
-- </tr>
-- <tr>
-- <td>Earl</td>
-- <td>Graf</td>
-- </tr>
-- <tr>
-- <td>Marquees</td>
-- <td>Marktgraf</td>
-- </tr>
-- <tr>
-- <td>Duke</td>
-- <td>Herzog</td>
-- </tr>
-- </tr>
-- <tr>
-- <td>Archduke</td>
-- <td>Erzherzog</td>
-- </tr>
-- <table>
--
-- @param _Title Titel, der erreicht werden muss
--
-- @within Goal
--
function Goal_KnightTitle(...)
    return B_Goal_KnightTitle:new(...);
end

B_Goal_KnightTitle = {
    Name = "Goal_KnightTitle",
    Description = {
        en = "Goal: Reach a specified knight title",
        de = "Ziel: Erreiche einen vorgegebenen Titel",
        fr = "Objectif: atteindre un titre donné",
    },
    Parameter = {
        { ParameterType.Custom, en = "Knight title", de = "Titel", fr = "Titre" },
    },
}

function B_Goal_KnightTitle:GetGoalTable()
    return {Objective.KnightTitle, assert( KnightTitles[self.KnightTitle] ) }
end

function B_Goal_KnightTitle:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.KnightTitle = _Parameter
    end
end

function B_Goal_KnightTitle:GetMsgKey()
    return "Quest_KnightTitle"
end

function B_Goal_KnightTitle:GetCustomData( _Index )
    return {"Knight", "Mayor", "Baron", "Earl", "Marquees", "Duke", "Archduke"}
end

Swift:RegisterBehavior(B_Goal_KnightTitle);

-- -------------------------------------------------------------------------- --

---
-- Der angegebene Spieler muss mindestens die Menge an Festen feiern.
--
-- Ein Fest wird gewertet, sobald die Metfässer auf dem Markt erscheinen. Diese
-- Metfässer erscheinen im normalen Spielverlauf nur durch ein Fest!
--
-- <b>Achtung</b>: Wenn ein Spieler aus einem anderen Grund Metfässer besitzt,
-- wird dieses Behavior nicht mehr richtig funktionieren!
--
-- @param _PlayerID ID des Spielers
-- @param _Amount   Menge an Festen
--
-- @within Goal
--
function Goal_Festivals(...)
    return B_Goal_Festivals:new(...);
end

B_Goal_Festivals = {
    Name = "Goal_Festivals",
    Description = {
        en = "Goal: The player has to start the given number of festivals.",
        de = "Ziel: Der Spieler muss eine gewisse Anzahl Feste gestartet haben.",
        fr = "Objectif: Le joueur doit avoir lancé un certain nombre de festivités."
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Number, en = "Number of festivals", de = "Anzahl Feste", fr = "Nombre de festivités" }
    }
};

function B_Goal_Festivals:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} };
end

function B_Goal_Festivals:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.PlayerID = tonumber(_Parameter);
    else
        assert(_Index == 1, "Error in " .. self.Name .. ": AddParameter: Index is invalid.");
        self.NeededFestivals = tonumber(_Parameter);
    end
end

function B_Goal_Festivals:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local PlayerName = GetPlayerName(self.PlayerID) or "";
        Swift.Quest:ChangeCustomQuestCaptionText(
            string.format(
                Swift:Localize(Swift.Behavior.Text.Festivals.Pattern),
                PlayerName, self.NeededFestivals
            ), 
            _Quest
        );
    end

    if Logic.GetStoreHouse( self.PlayerID ) == 0  then
        return false
    end
    local tablesOnFestival = {Logic.GetPlayerEntities(self.PlayerID, Entities.B_TableBeer, 5,0)}
    local amount = 0
    for k=2, #tablesOnFestival do
        local tableID = tablesOnFestival[k]
        if Logic.GetIndexOnOutStockByGoodType(tableID, Goods.G_Beer) ~= -1 then
            local goodAmountOnMarketplace = Logic.GetAmountOnOutStockByGoodType(tableID, Goods.G_Beer)
            amount = amount + goodAmountOnMarketplace
        end
    end
    if not self.FestivalStarted and amount > 0 then
        self.FestivalStarted = true
        self.FestivalCounter = (self.FestivalCounter and self.FestivalCounter + 1) or 1
        if self.FestivalCounter >= self.NeededFestivals then
            self.FestivalCounter = nil
            return true
        end
    elseif amount == 0 then
        self.FestivalStarted = false
    end
end

function B_Goal_Festivals:Debug(_Quest)
    if Logic.GetStoreHouse( self.PlayerID ) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.PlayerID .. " is dead :-(")
        return true
    elseif GetPlayerCategoryType(self.PlayerID) ~= PlayerCategories.City then
        error(_Quest.Identifier.. ": " ..self.Name .. ":  Player "..  self.PlayerID .. " is no city")
        return true
    elseif self.NeededFestivals < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Festivals is negative")
        return true
    end
    return false
end

function B_Goal_Festivals:Reset()
    self.FestivalCounter = nil
    self.FestivalStarted = nil
end

function B_Goal_Festivals:GetIcon()
    return {4,15}
end

Swift:RegisterBehavior(B_Goal_Festivals)

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Einheit gefangen nehmen.
--
-- @param _ScriptName Ziel
--
-- @within Goal
--
function Goal_Capture(...)
    return B_Goal_Capture:new(...)
end

B_Goal_Capture = {
    Name = "Goal_Capture",
    Description = {
        en = "Goal: Capture a cart.",
        de = "Ziel: Ein Karren muss erobert werden.",
        fr = "Objectif: un chariot doit être conquis.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Goal_Capture:GetGoalTable()
    return { Objective.Capture, 1, { self.ScriptName } }
end

function B_Goal_Capture:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Goal_Capture:GetMsgKey()
   local ID = GetID(self.ScriptName)
   if Logic.IsEntityAlive(ID) then
        ID = Logic.GetEntityType( ID )
        if ID and ID ~= 0 then
            if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
                return "Quest_Capture_Cart"

            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then
                return "Quest_Capture_SiegeEngine"

            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1
                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1
                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then

                return "Quest_Capture_VIPOfPlayer"

            end
        end
    end
end

Swift:RegisterBehavior(B_Goal_Capture);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Menge von Einheiten eines Typs von einem
-- Spieler gefangen nehmen.
--
-- @param _Typ      Typ, der gefangen werden soll
-- @param _Amount   Menge an Einheiten
-- @param _PlayerID Besitzer der Einheiten
--
-- @within Goal
--
function Goal_CaptureType(...)
    return B_Goal_CaptureType:new(...)
end

B_Goal_CaptureType = {
    Name = "Goal_CaptureType",
    Description = {
        en = "Goal: Capture specified entity types",
        de = "Ziel: Nimm bestimmte Entitätstypen gefangen",
        fr = "Objectif: capturer certains types d'entités",
    },
    Parameter = {
        { ParameterType.Custom,     en = "Type name",   de = "Typbezeichnung",  fr = "Désignation du type" },
        { ParameterType.Number,     en = "Amount",      de = "Anzahl",          fr = "Quantité" },
        { ParameterType.PlayerID,   en = "Player",      de = "Spieler",         fr = "Joueur" },
    },
}

function B_Goal_CaptureType:GetGoalTable()
    return { Objective.Capture, 2, Entities[self.EntityName], self.Amount, self.PlayerID }
end

function B_Goal_CaptureType:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_CaptureType:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Entities ) do
            if string.find( k, "^U_.+Cart" ) or Logic.IsEntityTypeInCategory( v, EntityCategories.AttackableMerchant ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        for i = 0, 8 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function B_Goal_CaptureType:GetMsgKey()

    local ID = self.EntityName
    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
        return "Quest_Capture_Cart"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then
        return "Quest_Capture_SiegeEngine"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then

        return "Quest_Capture_VIPOfPlayer"
    end
end

Swift:RegisterBehavior(B_Goal_CaptureType);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss das angegebene Entity beschützen.
--
-- Wird ein Wagen zerstört oder in das Lagerhaus / die Burg eines Feindes
-- gebracht, schlägt das Ziel fehl.
--
-- @param _ScriptName Zu beschützendes Entity
--
-- @within Goal
--
function Goal_Protect(...)
    return B_Goal_Protect:new(...)
end

B_Goal_Protect = {
    Name = "Goal_Protect",
    Description = {
        en = "Goal: Protect an entity (entity needs a script name",
        de = "Ziel: Beschütze eine Entität (Entität benötigt einen Skriptnamen)",
        fr = "Objectif : Protéger une entité (l'entité nécessite un nom de script)"
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Goal_Protect:GetGoalTable()
    return {Objective.Protect, { self.ScriptName }}
end

function B_Goal_Protect:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Goal_Protect:GetMsgKey()
    if Logic.IsEntityAlive(self.ScriptName) then
        local ID = GetID(self.ScriptName)
        if ID and ID ~= 0 then
            ID = Logic.GetEntityType( ID )
            if ID and ID ~= 0 then
                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
                    return "Quest_Protect_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SpecialBuilding ) == 1 then
                    local tMapping = {
                        [PlayerCategories.City]        = "Quest_Protect_City",
                        [PlayerCategories.Cloister]    = "Quest_Protect_Cloister",
                        [PlayerCategories.Village]    = "Quest_Protect_Village",
                    }
                    local PlayerCategory = GetPlayerCategoryType( Logic.EntityGetPlayer(GetID(self.ScriptName)) )
                    if PlayerCategory then
                        local Key = tMapping[PlayerCategory]
                        if Key then
                            return Key
                        end
                    end
                    return "Quest_Protect_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
                    return "Quest_Protect_Knight"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
                    return "Quest_Protect_Cart"
                end
            end
        end
    end
    return "Quest_Protect"
end

Swift:RegisterBehavior(B_Goal_Protect);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Mine mit einem Geologen wieder auffüllen.
--
-- <b>Achtung</b>: Dieses Behavior ist nur in "Reich des Ostens" verfügbar.
--
-- @param _ScriptName Skriptname der Mine
--
-- @within Goal
--
function Goal_Refill(...)
    return B_Goal_Refill:new(...)
end

B_Goal_Refill = {
    Name = "Goal_Refill",
    Description = {
        en = "Goal: Refill an object using a geologist",
        de = "Ziel: Eine Mine soll durch einen Geologen wieder aufgefuellt werden.",
        fr = "Objectif: Une mine doit être réalimentée par un géologue.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
   RequiresExtraNo = 1,
}

function B_Goal_Refill:GetGoalTable()
    return { Objective.Refill, { GetID(self.ScriptName) } }
end

function B_Goal_Refill:GetIcon()
    return {8,1,1}
end

function B_Goal_Refill:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

if g_GameExtraNo > 0 then
    Swift:RegisterBehavior(B_Goal_Refill);
end

-- -------------------------------------------------------------------------- --

---
-- Eine bestimmte Menge an Rohstoffen in einer Mine muss erreicht werden.
--
-- Dieses Behavior eignet sich besonders für den Einsatz als versteckter
-- Quest um eine Reaktion auszulösen, wenn z.B. eine Mine leer ist.
--
-- <u>Relationen</u>
-- <ul>
-- <li>> - Mehr als Anzahl</li>
-- <li>< - Weniger als Anzahl</li>
-- </ul>
--
-- @param _ScriptName Skriptname der Mine
-- @param _Relation   Mengenrelation
-- @param _Amount     Menge an Rohstoffen
--
-- @within Goal
--
function Goal_ResourceAmount(...)
    return B_Goal_ResourceAmount:new(...)
end

B_Goal_ResourceAmount = {
    Name = "Goal_ResourceAmount",
    Description = {
        en = "Goal: Reach a specified amount of resources in a doodad",
        de = "Ziel: In einer Mine soll weniger oder mehr als eine angegebene Anzahl an Rohstoffen sein.",
        fr = "Objectif: Dans une mine, il doit y avoir moins ou plus de matières premières qu'un nombre indiqué.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
        { ParameterType.Custom, en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Number, en = "Amount", de = "Menge", fr = "Quantité" },
    },
}

function B_Goal_ResourceAmount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_ResourceAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.bRelSmallerThan = _Parameter == "<"
    elseif (_Index == 2) then
        self.Amount = _Parameter * 1
    end
end

function B_Goal_ResourceAmount:CustomFunction(_Quest)
    local ID = GetID(self.ScriptName)
    if ID and ID ~= 0 and Logic.GetResourceDoodadGoodType(ID) ~= 0 then
        local HaveAmount = Logic.GetResourceDoodadGoodAmount(ID)
        if ( self.bRelSmallerThan and HaveAmount < self.Amount ) or ( not self.bRelSmallerThan and HaveAmount >= self.Amount ) then
            return true
        end
    end
    return nil
end

function B_Goal_ResourceAmount:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, ">=" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

function B_Goal_ResourceAmount:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        error(_Quest.Identifier.. ": " ..self.Name..": entity '" ..self.ScriptName.. "' does not exist!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name..": error at amount! (nil or below 0)");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Goal_ResourceAmount);

-- -------------------------------------------------------------------------- --

---
-- Der Quest schlägt sofort fehl.
--
-- @within Goal
--
function Goal_InstantFailure()
    return B_Goal_InstantFailure:new()
end

B_Goal_InstantFailure = {
    Name = "Goal_InstantFailure",
    Description = {
        en = "Goal: Instant failure, the goal returns false.",
        de = "Ziel: Direkter Misserfolg, das Goal sendet false.",
        fr = "Objectif: échec direct, le goal envoie false.",
    },
}

function B_Goal_InstantFailure:GetGoalTable()
    return {Objective.DummyFail};
end

Swift:RegisterBehavior(B_Goal_InstantFailure);

-- -------------------------------------------------------------------------- --

---
-- Der Quest wird sofort erfüllt.
--
-- @within Goal
--
function Goal_InstantSuccess()
    return B_Goal_InstantSuccess:new()
end

B_Goal_InstantSuccess = {
    Name = "Goal_InstantSuccess",
    Description = {
        en = "Goal: Instant success, the goal returns true.",
        de = "Ziel: Direkter Erfolg, das Goal sendet true.",
        fr = "Objectif: succès direct, le goal envoie false."
    },
}

function B_Goal_InstantSuccess:GetGoalTable()
    return {Objective.Dummy};
end

Swift:RegisterBehavior(B_Goal_InstantSuccess);

-- -------------------------------------------------------------------------- --

---
-- Der Zustand des Quests ändert sich niemals
--
-- Wenn ein Zeitlimit auf dem Quest liegt, wird dieses Behavior nicht
-- fehlschlagen sondern automatisch erfüllt.
--
-- @within Goal
--
function Goal_NoChange()
    return B_Goal_NoChange:new()
end

B_Goal_NoChange = {
    Name = "Goal_NoChange",
    Description = {
        en = "Goal: The quest state doesn't change. Use reward functions of other quests to change the state of this quest.",
        de = "Ziel: Der Questzustand wird nicht verändert. Ein Reward einer anderen Quest sollte den Zustand dieser Quest verändern.",
        fr = "Objectif: L'état de la quête n'est pas modifié. Une récompense d'une autre quête doit modifier l'état de cette quête.",
    },
}

function B_Goal_NoChange:GetGoalTable()
    return { Objective.NoChange }
end

Swift:RegisterBehavior(B_Goal_NoChange);

-- -------------------------------------------------------------------------- --

---
-- Führt eine Funktion im Skript als Goal aus.
--
-- Die Funktion muss entweder true, false oder nichts zurückgeben.
-- <ul>
-- <li>true: Erfolgreich abgeschlossen</li>
-- <li>false: Fehlschlag</li>
-- <li>nichts: Zustand unbestimmt</li>
-- </ul>
--
-- Anstelle eines Strings kann beim Einsatz im Skript eine Funktionsreferenz
-- übergeben werden. In diesem Fall werden alle weiteren Parameter direkt an
-- die Funktion weitergereicht.
--
-- @param _FunctionName Name der Funktion
--
-- @within Goal
--
function Goal_MapScriptFunction(...)
    return B_Goal_MapScriptFunction:new(...);
end

B_Goal_MapScriptFunction = {
    Name = "Goal_MapScriptFunction",
    Description = {
        en = "Goal: Calls a function within the global map script. Return 'true' means success, 'false' means failure and 'nil' doesn't change anything.",
        de = "Ziel: Ruft eine Funktion im globalen Skript auf, die einen Wahrheitswert zurueckgibt. Rueckgabe 'true' gilt als erfuellt, 'false' als gescheitert und 'nil' ändert nichts.",
        fr = "Objectif: Appelle une fonction dans le script global qui renvoie une valeur de vérité. Le retour 'true' est considéré comme rempli, 'false' comme échoué et 'nil' ne change rien.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname", fr = "Nom de la fonction" },
    },
}

function B_Goal_MapScriptFunction:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_MapScriptFunction:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.FuncName = _Parameter
    end
end

function B_Goal_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        return self.FuncName(unpack(self.i47ya_6aghw_frxil));
    end
    return _G[self.FuncName](self, _Quest);
end

function B_Goal_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        error(_Quest.Identifier.. ": " ..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) ~= "function" and not _G[self.FuncName] then
        error(_Quest.Identifier.. ": " ..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Goal_MapScriptFunction);

-- -------------------------------------------------------------------------- --

---
-- Eine benutzerdefinierte Variable muss einen bestimmten Wert haben.
--
-- Custom Variables können ausschließlich Zahlen enthalten. Bevor eine
-- Variable in einem Goal abgefragt werden kann, muss sie zuvor mit
-- Reprisal_CustomVariables oder Reward_CutsomVariables initialisiert
-- worden sein.
--
-- <p>Vergleichsoperatoren</p>
-- <ul>
-- <li>== - Werte müssen gleich sein</li>
-- <li>~= - Werte müssen ungleich sein</li>
-- <li>> - Variablenwert größer Vergleichswert</li>
-- <li>>= - Variablenwert größer oder gleich Vergleichswert</li>
-- <li>< - Variablenwert kleiner Vergleichswert</li>
-- <li><= - Variablenwert kleiner oder gleich Vergleichswert</li>
-- </ul>
--
-- @param _Name     Name der Variable
-- @param _Relation Vergleichsoperator
-- @param _Value    Wert oder andere Custom Variable mit wert.
--
-- @within Goal
--
function Goal_CustomVariables(...)
    return B_Goal_CustomVariables:new(...);
end

B_Goal_CustomVariables = {
    Name = "Goal_CustomVariables",
    Description = {
        en = "Goal: A customised variable has to assume a certain value.",
        de = "Ziel: Eine benutzerdefinierte Variable muss einen bestimmten Wert annehmen.",
        fr = "Objectif: une variable définie par l'utilisateur doit prendre une certaine valeur.",
    },
    Parameter = {
        { ParameterType.Default, en = "Name of Variable", de = "Variablenname", fr = "Nom de la variable" },
        { ParameterType.Custom,  en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Default, en = "Value or variable", de = "Wert oder Variable", fr = "Valeur ou variable" }
    }
};

function B_Goal_CustomVariables:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} };
end

function B_Goal_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Relation = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        self.Value = (value == nil and tostring(_Parameter)) or value;
    end
end

function B_Goal_CustomVariables:CustomFunction()
    local Value1 = API.ObtainCustomVariable("BehaviorVariable_" ..self.VariableName, 0);
    local Value2 = self.Value;
    if type(self.Value) == "string" then
        Value2 = API.ObtainCustomVariable("BehaviorVariable_" ..self.Value, 0);
    end

    if self.Relation == "==" then
        if Value1 == Value2 then
            return true;
        end
    elseif self.Relation == "~=" then
        if Value1 == Value2 then
            return true;
        end
    elseif self.Relation == "<" then
        if Value1 < Value2 then
            return true;
        end
    elseif self.Relation == "<=" then
        if Value1 <= Value2 then
            return true;
        end
    elseif self.Relation == ">=" then
        if Value1 >= Value2 then
            return true;
        end
    else
        if Value1 > Value2 then
            return true;
        end
    end
    return nil;
end

function B_Goal_CustomVariables:GetCustomData( _Index )
    return {"==", "~=", "<=", "<", ">", ">="};
end

function B_Goal_CustomVariables:Debug(_Quest)
    local relations = {"==", "~=", "<=", "<", ">", ">="}
    local results    = {true, false, nil}

    if not API.ObtainCustomVariable("BehaviorVariable_" ..self.VariableName) then
        warn(_Quest.Identifier.. ": " ..self.Name..": variable '"..self.VariableName.."' do not exist!");
    end
    if not table.contains(relations, self.Relation) then
        error(_Quest.Identifier.. ": " ..self.Name..": '"..self.Relation.."' is an invalid relation!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Goal_CustomVariables)

-- -------------------------------------------------------------------------- --

---
-- Der Spieler kann durch regelmäßiges Begleichen eines Tributes bessere
-- Diplomatie zu einem Spieler erreichen.
--
-- Die Zeit zum Bezahlen des Tributes muss immer kleiner sein als die
-- Wiederholungsperiode.
--
-- <b>Hinweis</b>: Je mehr Zeit sich der Spieler lässt um den Tribut zu
-- begleichen, desto mehr wird sich der Start der nächsten Periode verzögern.
--
-- @param _GoldAmount Menge an Gold
-- @param _Periode    Zahlungsperiode in Sekunden
-- @param _Time       Zeitbegrenzung in Sekunden
-- @param _StartMsg   Vorschlagnachricht
-- @param _SuccessMsg Erfolgsnachricht
-- @param _FailureMsg Fehlschlagnachricht
-- @param _Restart    Nach nichtbezahlen neu starten
--
-- @within Goal
--
function Goal_TributeDiplomacy(...)
    return B_Goal_TributeDiplomacy:new(...);
end

B_Goal_TributeDiplomacy = {
    Name = "Goal_TributeDiplomacy",
    Description = {
        en = "Goal: AI requests periodical tribute for better Diplomacy",
        de = "Ziel: Die KI fordert einen regelmässigen Tribut fuer bessere Diplomatie. Der Questgeber ist der fordernde Spieler.",
        fr = "Objectif: L'IA demande un tribut régulier pour une meilleure diplomatie. Le donneur de quête est le joueur qui exige."
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Menge", fr = "Quantité", },
        { ParameterType.Number, en = "Time till next peyment in seconds", de = "Zeit bis zur Forderung in Sekunden", fr = "Temps jusqu'à la demande en secondes", },
        { ParameterType.Number, en = "Time to pay tribute in seconds", de = "Zeit bis zur Zahlung in Sekunden", fr = "Délai avant paiement en secondes", },
        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", fr = "Message de début de quête de tribut", },
        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", fr = "Message de réussite de la quête de tribut", },
        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", fr = "Message de défaite de la quête de tribut", },
        { ParameterType.Custom, en = "Restart if failed to pay", de = "Nicht-bezahlen beendet die Quest", fr = "Ne pas payer met fin à la quête", },
    },
}

function B_Goal_TributeDiplomacy:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} };
end

function B_Goal_TributeDiplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 1) then
        self.PeriodLength = _Parameter * 1;
    elseif (_Index == 2) then
        self.TributTime = _Parameter * 1;
    elseif (_Index == 3) then
        self.StartMsg = _Parameter;
    elseif (_Index == 4) then
        self.SuccessMsg = _Parameter;
    elseif (_Index == 5) then
        self.FailureMsg = _Parameter;
    elseif (_Index == 6) then
        self.RestartAtFailure = API.ToBoolean(_Parameter);
    end
end

function B_Goal_TributeDiplomacy:GetTributeQuest(_Quest)
    if not self.InternTributeQuest then
        local Language = QSB.Language;
        local StartMsg = self.StartMsg;
        if type(StartMsg) == "table" then
            StartMsg = StartMsg[Language];
        end
        local SuccessMsg = self.SuccessMsg;
        if type(SuccessMsg) == "table" then
            SuccessMsg = SuccessMsg[Language];
        end
        local FailureMsg = self.FailureMsg;
        if type(FailureMsg) == "table" then
            FailureMsg = FailureMsg[Language];
        end

        Swift.Behavior.QuestCounter = Swift.Behavior.QuestCounter+1;

        local QuestID, Quest = QuestTemplate:New (
            _Quest.Identifier.."_TributeDiplomacyQuest_" ..Swift.Behavior.QuestCounter,
            _Quest.SendingPlayer,
            _Quest.ReceivingPlayer,
            {{ Objective.Deliver, {Goods.G_Gold, self.Amount}}},
            {{ Triggers.Time, 0 }},
            self.TributTime, nil, nil, nil, nil, true, true, nil,
            StartMsg,
            SuccessMsg,
            FailureMsg
        );
        self.InternTributeQuest = Quest;
    end
end

function B_Goal_TributeDiplomacy:CheckTributeQuest(_Quest)
    if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Over and not self.RestartQuest then
        if self.InternTributeQuest.Result ~= QuestResult.Success then
            SetDiplomacyState( _Quest.ReceivingPlayer, _Quest.SendingPlayer, DiplomacyStates.Enemy);
            if not self.RestartAtFailure then
                return false;
            end
        else
            SetDiplomacyState(_Quest.ReceivingPlayer, _Quest.SendingPlayer, DiplomacyStates.TradeContact);
        end
        self.RestartQuest = true;
        self.Time = Logic.GetTime();
    end
end

function B_Goal_TributeDiplomacy:CheckTributePlayer(_Quest)
    local storeHouse = Logic.GetStoreHouse(_Quest.SendingPlayer);
    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then
        if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        return true;
    end
end

function B_Goal_TributeDiplomacy:TributQuestRestarter(_Quest)
    if self.InternTributeQuest and self.Time and self.RestartQuest and ((Logic.GetTime() - self.Time) >= self.PeriodLength) then
        self.InternTributeQuest.Objectives[1].Completed = nil;
        self.InternTributeQuest.Objectives[1].Data[3] = nil;
        self.InternTributeQuest.Objectives[1].Data[4] = nil;
        self.InternTributeQuest.Objectives[1].Data[5] = nil;
        self.InternTributeQuest.Result = nil;
        self.InternTributeQuest.State = QuestState.NotTriggered;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")");
        StartSimpleJobEx(_G[QuestTemplate.Loop], self.InternTributeQuest.QueueID);
        self.RestartQuest = nil;
    end
end

function B_Goal_TributeDiplomacy:CustomFunction(_Quest)
    -- Tribut Quest erzeugen
    self:GetTributeQuest(_Quest);
    -- Status des Tributes prüfen.
    if self:CheckTributeQuest(_Quest) == false then
        return false;
    end
    -- Status des fordernden Spielers prüfen.
    if self:CheckTributePlayer(_Quest) == true then
        return true;
    end
    -- Quest neu starten, falls nötig.
    self:TributQuestRestarter(_Quest);
end

function B_Goal_TributeDiplomacy:Debug(_Quest)
    if self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Amount is negative!");
        return true;
    end
    if self.PeriodLength < self.TributTime then
        error(_Quest.Identifier.. ": " ..self.Name .. ": TributTime too long!");
        return true;
    end
end

function B_Goal_TributeDiplomacy:Reset(_Quest)
    self.Time = nil;
    self.InternTributeQuest = nil;
    self.RestartQuest = nil;
end

function B_Goal_TributeDiplomacy:Interrupt(_Quest)
    if self.InternTributeQuest ~= nil then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
    end
end

function B_Goal_TributeDiplomacy:GetCustomData(_Index)
    if (_Index == 6) then
        return {"true", "false"};
    end
end

Swift:RegisterBehavior(B_Goal_TributeDiplomacy);

-- -------------------------------------------------------------------------- --

---
-- Erlaubt es dem Spieler ein Territorium zu "mieten".
--
-- Zerstört der Spieler den Außenposten, schlägt der Quest fehl und das
-- Territorium wird an den Vermieter übergeben. Wenn der Spieler die Pacht
-- nicht bezahlt, geht der Besitz an den Vermieter über.
--
-- Die Zeit zum Bezahlen des Tributes muss immer kleiner sein als die
-- Wiederholungsperiode.
--
-- <b>Hinweis</b>: Je mehr Zeit sich der Spieler lässt um den Tribut zu
-- begleichen, desto mehr wird sich der Start der nächsten Periode verzögern.
--
-- @param _Territory  Name des Territorium
-- @param _PlayerID   PlayerID des Zahlungsanforderer
-- @param _Cost       Menge an Gold
-- @param _Periode    Zahlungsperiode in Sekunden
-- @param _Time       Zeitbegrenzung in Sekunden
-- @param _StartMsg   Vorschlagnachricht
-- @param _SuccessMsg Erfolgsnachricht
-- @param _FailMsg    Fehlschlagnachricht
-- @param _HowOften   Anzahl an Zahlungen (0 = endlos)
-- @param _OtherOwner Eroberung durch Dritte beendet Quest
-- @param _Abort      Nach nichtbezahlen abbrechen
--
-- @within Goal
--
function Goal_TributeClaim(...)
    return B_Goal_TributeClaim:new(...);
end

B_Goal_TributeClaim = {
    Name = "Goal_TributeClaim",
    Description = {
        en = "Goal: AI requests periodical tribute for a specified territory. The quest sender is the demanding player.",
        de = "Ziel: Die KI fordert einen regelmässigen Tribut fuer ein Territorium. Der Questgeber ist der fordernde Spieler.",
        fr = "Objectif: L'IA demande un tribut régulier pour un territoire. Le donneur de quête est le joueur qui exige.",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", fr = "Territoire", },
        { ParameterType.PlayerID, en = "PlayerID", de = "PlayerID", fr = "PlayerID", },
        { ParameterType.Number, en = "Amount", de = "Menge", fr = "Quantité", },
        { ParameterType.Number, en = "Length of Period in seconds", de = "Sekunden bis zur nächsten Forderung", fr = "secondes jusqu'à la prochaine demande", },
        { ParameterType.Number, en = "Time to pay Tribut in seconds", de = "Zeit bis zur Zahlung in Sekunden", fr = "Délai avant paiement en secondes", },
        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", fr = "Message de début de quête de tribut", },
        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", fr = "Message de réussite de la quête de tribut", },
        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", fr = "Message de défaite de la quête de tribut", },
        { ParameterType.Number, en = "How often to pay (0 = forerver)", de = "Anzahl der Tributquests (0 = unendlich)", fr = "Nombre de quêtes de tribut (0 = infini)", },
        { ParameterType.Custom, en = "Other Owner cancels the Quest", de = "Anderer Spieler kann Quest beenden", fr = "Un autre joueur peut terminer une quête", },
        { ParameterType.Custom, en = "About if a rate is not payed", de = "Nicht-bezahlen beendet die Quest", fr = "Ne pas payer met fin à la quête", },
    },
}

function B_Goal_TributeClaim:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} };
end

function B_Goal_TributeClaim:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        if type(_Parameter) == "string" then
            _Parameter = GetTerritoryIDByName(_Parameter);
        end
        self.TerritoryID = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 3) then
        self.PeriodLength = _Parameter * 1;
    elseif (_Index == 4) then
        self.TributTime = _Parameter * 1;
    elseif (_Index == 5) then
        self.StartMsg = _Parameter;
    elseif (_Index == 6) then
        self.SuccessMsg = _Parameter;
    elseif (_Index == 7) then
        self.FailureMsg = _Parameter;
    elseif (_Index == 8) then
        self.HowOften = _Parameter * 1;
    elseif (_Index == 9) then
        self.OtherOwnerCancels = API.ToBoolean(_Parameter);
    elseif (_Index == 10) then
        self.DontPayCancels = API.ToBoolean(_Parameter);
    end
end

function B_Goal_TributeClaim:CureOutpost(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if IsExisting(Outpost) and API.GetEntityHealth(Outpost) < 25 and Logic.IsBuildingBeingKnockedDown(Outpost) == false then
        while (Logic.GetEntityHealth(Outpost) < Logic.GetEntityMaxHealth(Outpost) * 0.6) do
            Logic.HealEntity(Outpost, 1);
        end
    end
end

function B_Goal_TributeClaim:RestartTributeQuest(_Quest)
    if self.InternTributeQuest then
        self.InternTributeQuest.Objectives[1].Completed = nil;
        self.InternTributeQuest.Objectives[1].Data[3] = nil;
        self.InternTributeQuest.Objectives[1].Data[4] = nil;
        self.InternTributeQuest.Objectives[1].Data[5] = nil;
        self.InternTributeQuest.Result = nil;
        self.InternTributeQuest.State = QuestState.NotTriggered;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")");
        StartSimpleJobEx(_G[QuestTemplate.Loop], self.InternTributeQuest.QueueID);
    end
end

function B_Goal_TributeClaim:CreateTributeQuest(_Quest)
    if not self.InternTributeQuest then
        local Language = QSB.Language;
        local StartMsg = self.StartMsg;
        if type(StartMsg) == "table" then
            StartMsg = StartMsg[Language];
        end
        local SuccessMsg = self.SuccessMsg;
        if type(SuccessMsg) == "table" then
            SuccessMsg = SuccessMsg[Language];
        end
        local FailureMsg = self.FailureMsg;
        if type(FailureMsg) == "table" then
            FailureMsg = FailureMsg[Language];
        end

        Swift.Behavior.QuestCounter = Swift.Behavior.QuestCounter+1;

        local OnFinished = function()
            self.Time = Logic.GetTime();
        end
        local QuestID, Quest = QuestTemplate:New(
            _Quest.Identifier.."_TributeClaimQuest" ..Swift.Behavior.QuestCounter,
            self.PlayerID,
            _Quest.ReceivingPlayer,
            {{ Objective.Deliver, {Goods.G_Gold, self.Amount}}},
            {{ Triggers.Time, 0 }},
            self.TributTime, nil, nil, OnFinished, nil, true, true, nil,
            StartMsg,
            SuccessMsg,
            FailureMsg
        );
        self.InternTributeQuest = Quest;
    end
end

function B_Goal_TributeClaim:OnTributeFailed(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if IsExisting(Outpost) then
        Logic.ChangeEntityPlayerID(Outpost, self.PlayerID);
    end
    Logic.SetTerritoryPlayerID(self.TerritoryID, self.PlayerID);
    self.InternTributeQuest.State = false;
    self.Time = nil;

    if self.DontPayCancels then
        _Quest:Interrupt();
    end
end

function B_Goal_TributeClaim:OnTributePaid(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if self.InternTributeQuest.Result == QuestResult.Success then
        if Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then
            if IsExisting(Outpost) then
                Logic.ChangeEntityPlayerID(Outpost, _Quest.ReceivingPlayer);
            end
            Logic.SetTerritoryPlayerID(self.TerritoryID, _Quest.ReceivingPlayer);
        end
    end
    if self.Time and Logic.GetTime() >= self.Time + self.PeriodLength then
        if self.HowOften and self.HowOften ~= 0 then
            self.TributeCounter = (self.TributeCounter or 0) +1;
            if self.TributeCounter >= self.HowOften then
                return false;
            end
        end
        self:RestartTributeQuest();
        self.Time = nil;
    end
end

function B_Goal_TributeClaim:CustomFunction(_Quest)
    self:CreateTributeQuest(_Quest);
    self:CureOutpost(_Quest);

    if Logic.GetTerritoryPlayerID(self.TerritoryID) == _Quest.ReceivingPlayer
    or Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then
        if self.OtherOwner then
            self:RestartTributeQuest();
            self.OtherOwner = nil;
        end

        -- Quest abgeschlossen
        if self.InternTributeQuest.State == QuestState.Over then
            if self.InternTributeQuest.Result == QuestResult.Failure then
                self:OnTributeFailed(_Quest);
            else
                self:OnTributePaid(_Quest);
            end

        elseif self.InternTributeQuest.State == false then
            if self.Time and Logic.GetTime() >= self.Time + self.PeriodLength then
                self:RestartTributeQuest(_Quest);
            end
        end

    -- Keiner besitzt das Territorium -> Abbruch
    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) == 0 and self.InternTributeQuest then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end

    -- Anderer Besitzer -> Abbruch
    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) ~= self.PlayerID then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        if self.OtherOwnerCancels then
            _Quest:Interrupt();
        end
        self.OtherOwner = true;
    end

    --Fordernder Spieler existiert nicht -> Abbruch
    local storeHouse = Logic.GetStoreHouse(self.PlayerID);
    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then
        if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        return true;
    end
end

function B_Goal_TributeClaim:Debug(_Quest)
    if self.TerritoryID == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Unknown Territory");
        return true;
    end
    if not self.Quest and Logic.GetStoreHouse(self.PlayerID) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(");
        return true;
    end
    if self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Amount is negative");
        return true;
    end
    if self.PeriodLength < self.TributTime or self.PeriodLength < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Period Length is wrong");
        return true;
    end
    if self.HowOften < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": HowOften is negative");
        return true;
    end
end

function B_Goal_TributeClaim:Reset(_Quest)
    self.InternTributeQuest = nil;
    self.Time = nil;
    self.OtherOwner = nil;
end

function B_Goal_TributeClaim:Interrupt(_Quest)
    if type(self.InternTributeQuest) == "table" then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
    end
end

function B_Goal_TributeClaim:GetCustomData(_Index)
    if (_Index == 9) or (_Index == 10) then
        return {"false", "true"};
    end
end

Swift:RegisterBehavior(B_Goal_TributeClaim);

-- -------------------------------------------------------------------------- --
-- REPRISALS

---
-- Deaktiviert ein interaktives Objekt.
--
-- @param _ScriptName Skriptname des interaktiven Objektes
--
-- @within Reprisal
--
function Reprisal_ObjectDeactivate(...)
    return B_Reprisal_InteractiveObjectDeactivate:new(...);
end

B_Reprisal_InteractiveObjectDeactivate = {
    Name = "Reprisal_InteractiveObjectDeactivate",
    Description = {
        en = "Reprisal: Deactivates an interactive object",
        de = "Vergeltung: Deaktiviert ein interaktives Objekt",
        fr = "Rétribution: désactive un objet interactif",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object", de = "Interaktives Objekt", fr = "Object interactif" },
    },
}

function B_Reprisal_InteractiveObjectDeactivate:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_InteractiveObjectDeactivate:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.ScriptName = _Parameter
    end

end

function B_Reprisal_InteractiveObjectDeactivate:CustomFunction(_Quest)
    InteractiveObjectDeactivate(self.ScriptName);
end

function B_Reprisal_InteractiveObjectDeactivate:Debug(_Quest)
    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then
        warn(_Quest.Identifier.. ": " ..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");
        self.WarningPrinted = true;
    end
    local eID = GetID(self.ScriptName);
    if QSB.InitalizedObjekts[eID] and QSB.InitalizedObjekts[eID] == _Quest.Identifier then
        error(_Quest.Identifier.. ": " ..self.Name..": you can not deactivate in the same quest the object is initalized!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_InteractiveObjectDeactivate);

-- -------------------------------------------------------------------------- --

---
-- Aktiviert ein interaktives Objekt.
--
-- Der Status bestimmt, wie das Objekt aktiviert wird.
-- <ul>
-- <li>0: Kann nur mit Helden aktiviert werden</li>
-- <li>1: Kann immer aktiviert werden</li>
-- <li>2: Kann niemals aktiviert werden</li>
-- </ul>
--
-- @param _ScriptName Skriptname des interaktiven Objektes
-- @param _State      Status des Objektes
--
-- @within Reprisal
--
function Reprisal_ObjectActivate(...)
    return B_Reprisal_InteractiveObjectActivate:new(...);
end

B_Reprisal_InteractiveObjectActivate = {
    Name = "Reprisal_InteractiveObjectActivate",
    Description = {
        en = "Reprisal: Activates an interactive object",
        de = "Vergeltung: Aktiviert ein interaktives Objekt",
        fr = "Retribution : active un objet interactif",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object",  de = "Interaktives Objekt", fr = "Object interactif" },
        { ParameterType.Custom,     en = "Availability",        de = "Nutzbarkeit",         fr = "Utilisabilité" },
    },
}

function B_Reprisal_InteractiveObjectActivate:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_InteractiveObjectActivate:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        local parameter = 0
        if _Parameter == "Always" or 1 then
            parameter = 1
        end
        self.UsingState = parameter * 1
    end
end

function B_Reprisal_InteractiveObjectActivate:CustomFunction(_Quest)
    InteractiveObjectActivate(self.ScriptName, self.UsingState);
end

function B_Reprisal_InteractiveObjectActivate:GetCustomData( _Index )
    if _Index == 1 then
        return {"Knight only", "Always"}
    end
end

function B_Reprisal_InteractiveObjectActivate:Debug(_Quest)
    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then
        warn(_Quest.Identifier.. ": " ..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");
        self.WarningPrinted = true;
    end
    local eID = GetID(self.ScriptName);
    if QSB.InitalizedObjekts[eID] and QSB.InitalizedObjekts[eID] == _Quest.Identifier then
        error(_Quest.Identifier.. ": " ..self.Name..": you can not activate in the same quest the object is initalized!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_InteractiveObjectActivate);

-- -------------------------------------------------------------------------- --

---
-- Der diplomatische Status zwischen Sender und Empfänger verschlechtert sich
-- um eine Stufe.
--
-- @within Reprisal
--
function Reprisal_DiplomacyDecrease()
    return B_Reprisal_SlightlyDiplomacyDecrease:new();
end

B_Reprisal_SlightlyDiplomacyDecrease = {
    Name = "Reprisal_SlightlyDiplomacyDecrease",
    Description = {
        en = "Reprisal: Diplomacy decreases slightly to another player.",
        de = "Vergeltung: Der Diplomatiestatus zum Auftraggeber wird um eine Stufe verringert.",
        fr = "Rétribution: le statut diplomatique avec le mandant est réduit d'un niveau.",
    },
}

function B_Reprisal_SlightlyDiplomacyDecrease:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_SlightlyDiplomacyDecrease:CustomFunction(_Quest)
    local Sender = _Quest.SendingPlayer;
    local Receiver = _Quest.ReceivingPlayer;
    local State = GetDiplomacyState(Receiver, Sender);
    if State > -2 then
        SetDiplomacyState(Receiver, Sender, State-1);
    end
end

function B_Reprisal_SlightlyDiplomacyDecrease:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

Swift:RegisterBehavior(B_Reprisal_SlightlyDiplomacyDecrease);

-- -------------------------------------------------------------------------- --

---
-- Änder den Diplomatiestatus zwischen zwei Spielern.
--
-- @param _Party1   ID der ersten Partei
-- @param _Party2   ID der zweiten Partei
-- @param _State    Neuer Diplomatiestatus
--
-- @within Reprisal
--
function Reprisal_Diplomacy(...)
    return B_Reprisal_Diplomacy:new(...);
end

B_Reprisal_Diplomacy = {
    Name = "Reprisal_Diplomacy",
    Description = {
        en = "Reprisal: Sets Diplomacy state of two Players to a stated value.",
        de = "Vergeltung: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.",
        fr = "Rétribution: Définit le statut diplomatique de deux joueurs sur la valeur indiquée.",
    },
    Parameter = {
        { ParameterType.PlayerID,         en = "PlayerID 1", de = "Spieler 1", fr = "Joueur 1" },
        { ParameterType.PlayerID,         en = "PlayerID 2", de = "Spieler 2", fr = "Joueur 2" },
        { ParameterType.DiplomacyState,   en = "Relation",   de = "Beziehung", fr = "Relation diplomatique" },
    },
}

function B_Reprisal_Diplomacy:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_Diplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID1 = _Parameter * 1
    elseif (_Index == 1) then
        self.PlayerID2 = _Parameter * 1
    elseif (_Index == 2) then
        self.Relation = DiplomacyStates[_Parameter]
    end
end

function B_Reprisal_Diplomacy:CustomFunction(_Quest)
    SetDiplomacyState(self.PlayerID1, self.PlayerID2, self.Relation);
end

function B_Reprisal_Diplomacy:Debug(_Quest)
    if not tonumber(self.PlayerID1) or self.PlayerID1 < 1 or self.PlayerID1 > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": PlayerID 1 is invalid!");
        return true;
    elseif not tonumber(self.PlayerID2) or self.PlayerID2 < 1 or self.PlayerID2 > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": PlayerID 2 is invalid!");
        return true;
    elseif not tonumber(self.Relation) or self.Relation < -2 or self.Relation > 2 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": '"..self.Relation.."' is a invalid diplomacy state!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_Diplomacy);

-- -------------------------------------------------------------------------- --

---
-- Ein benanntes Entity wird entfernt.
--
-- <b>Hinweis</b>: Das Entity wird durch ein XD_ScriptEntity ersetzt. Es
-- behält Name, Besitzer und Ausrichtung.
--
-- @param _ScriptName Skriptname des Entity
--
-- @within Reprisal
--
function Reprisal_DestroyEntity(...)
    return B_Reprisal_DestroyEntity:new(...);
end

B_Reprisal_DestroyEntity = {
    Name = "Reprisal_DestroyEntity",
    Description = {
        en = "Reprisal: Replaces an entity with an invisible script entity, which retains the entities name.",
        de = "Vergeltung: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.",
        fr = "Rétribution: remplace une entité par une entité de script invisible qui prend son nom.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity", de = "Entity", fr = "Entité" },
    },
}

function B_Reprisal_DestroyEntity:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_DestroyEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Reprisal_DestroyEntity:CustomFunction(_Quest)
    ReplaceEntity(self.ScriptName, Entities.XD_ScriptEntity);
end

function B_Reprisal_DestroyEntity:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        warn(_Quest.Identifier .. ": " ..self.Name..": '" ..self.ScriptName.. "' is already destroyed!");
        self.WarningPrinted = true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_DestroyEntity);

-- -------------------------------------------------------------------------- --

---
-- Zerstört einen über ein Behavior erzeugten Effekt.
--
-- @param _EffectName Name des Effekts
--
-- @within Reprisal
--
function Reprisal_DestroyEffect(...)
    return B_Reprisal_DestroyEffect:new(...);
end

B_Reprisal_DestroyEffect = {
    Name = "Reprisal_DestroyEffect",
    Description = {
        en = "Reprisal: Destroys an effect",
        de = "Vergeltung: Zerstört einen Effekt",
        fr = "Rétribution: détruit un effet",
    },
    Parameter = {
        { ParameterType.Default, en = "Effect name", de = "Effektname", fr = "Nom de l'effet" },
    }
}

function B_Reprisal_DestroyEffect:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.EffectName = _Parameter;
    end
end

function B_Reprisal_DestroyEffect:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } };
end

function B_Reprisal_DestroyEffect:CustomFunction(_Quest)
    if not QSB.EffectNameToID[self.EffectName] or not Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then
        return;
    end
    Logic.DestroyEffect(QSB.EffectNameToID[self.EffectName]);
end

function B_Reprisal_DestroyEffect:Debug(_Quest)
    if not QSB.EffectNameToID[self.EffectName] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Effect " .. self.EffectName .. " never created")
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_DestroyEffect);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler verliert das Spiel.
--
-- @within Reprisal
--
function Reprisal_Defeat()
    return B_Reprisal_Defeat:new()
end

B_Reprisal_Defeat = {
    Name = "Reprisal_Defeat",
    Description = {
        en = "Reprisal: The player loses the game.",
        de = "Vergeltung: Der Spieler verliert das Spiel.",
        fr = "Rétribution: le joueur perd la partie.",
    },
}

function B_Reprisal_Defeat:GetReprisalTable()
    return {Reprisal.Defeat};
end

Swift:RegisterBehavior(B_Reprisal_Defeat);

-- -------------------------------------------------------------------------- --

---
-- Zeigt die Niederlagedekoration am Quest an.
--
-- Es handelt sich dabei um reine Optik! Der Spieler wird nicht verlieren.
--
-- @within Reprisal
--
function Reprisal_FakeDefeat()
    return B_Reprisal_FakeDefeat:new();
end

B_Reprisal_FakeDefeat = {
    Name = "Reprisal_FakeDefeat",
    Description = {
        en = "Reprisal: Displays a defeat icon for a quest",
        de = "Vergeltung: Zeigt ein Niederlage Icon fuer eine Quest an",
        fr = "Rétribution: affiche une icône de défaite pour une quête",
    },
}

function B_Reprisal_FakeDefeat:GetReprisalTable()
    return { Reprisal.FakeDefeat }
end

Swift:RegisterBehavior(B_Reprisal_FakeDefeat);

-- -------------------------------------------------------------------------- --

---
-- Ein Entity wird durch ein neues anderen Typs ersetzt.
--
-- Das neue Entity übernimmt Skriptname, Besitzer  und Ausrichtung des 
-- alten Entity.
--
-- @param _Entity Skriptname oder ID des Entity
-- @param _Type   Neuer Typ des Entity
-- @param _Owner  Besitzer des Entity
--
-- @within Reprisal
--
function Reprisal_ReplaceEntity(...)
    return B_Reprisal_ReplaceEntity:new(...);
end

B_Reprisal_ReplaceEntity = {
    Name = "Reprisal_ReplaceEntity",
    Description = {
        en = "Reprisal: Replaces an entity with a new one of a different type. The playerID can be changed too.",
        de = "Vergeltung: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.",
        fr = "Rétribution: remplace une entité par une nouvelle entité d'un autre type. Il est également possible de changer l'appartenance d'un joueur.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target", de = "Ziel", fr = "Cible" },
        { ParameterType.Custom, en = "New Type", de = "Neuer Typ", fr = "Nouveau type" },
        { ParameterType.Custom, en = "New playerID", de = "Neue Spieler ID", fr = "Nouvelle ID de joueur" },
    },
}

function B_Reprisal_ReplaceEntity:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_ReplaceEntity:AddParameter(_Index, _Parameter)
   if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.NewType = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = tonumber(_Parameter);
    end
end

function B_Reprisal_ReplaceEntity:CustomFunction(_Quest)
    local eID = GetID(self.ScriptName);
    local pID = self.PlayerID;
    if pID == Logic.EntityGetPlayer(eID) then
        pID = nil;
    end
    ReplaceEntity(self.ScriptName, Entities[self.NewType], pID);
end

function B_Reprisal_ReplaceEntity:GetCustomData(_Index)
    local Data = {}
    if _Index == 1 then
        for k, v in pairs( Entities ) do
            local name = {"^M_","^XS_","^X_","^XT_","^Z_", "^XB_"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        Data = {"-","0","1","2","3","4","5","6","7","8",}
    end
    return Data
end

function B_Reprisal_ReplaceEntity:Debug(_Quest)
    if not Entities[self.NewType] then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid entity type!");
        return true;
    elseif self.PlayerID ~= nil and (self.PlayerID < 1 or self.PlayerID > 8) then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end

    if not IsExisting(self.ScriptName) then
        self.WarningPrinted = true;
        warn(_Quest.Identifier.. ": " ..self.Name..": '" ..self.ScriptName.. "' does not exist!");
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_ReplaceEntity);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest neu.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestRestart(...)
    return B_Reprisal_QuestRestart:new(...)
end

B_Reprisal_QuestRestart = {
    Name = "Reprisal_QuestRestart",
    Description = {
        en = "Reprisal: Restarts a (completed) quest so it can be triggered and completed again",
        de = "Vergeltung: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann",
        fr = "Rétribution : relance une quête (terminée) pour qu'elle puisse être redéclenchée et terminée à nouveau",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
    },
}

function B_Reprisal_QuestRestart:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_QuestRestart:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Reprisal_QuestRestart:CustomFunction(_Quest)
    API.RestartQuest(self.QuestName, true);
end

function B_Reprisal_QuestRestart:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_QuestRestart);

-- -------------------------------------------------------------------------- --

---
-- Lässt einen Quest fehlschlagen.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestFailure(...)
    return B_Reprisal_QuestFailure:new(...)
end

B_Reprisal_QuestFailure = {
    Name = "Reprisal_QuestFailure",
    Description = {
        en = "Reprisal: Lets another active quest fail",
        de = "Vergeltung: Lässt eine andere aktive Quest fehlschlagen",
        fr = "Rétribution: fait échouer une autre quête active",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
    },
}

function B_Reprisal_QuestFailure:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_QuestFailure:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Reprisal_QuestFailure:CustomFunction(_Quest)
    API.FailQuest(self.QuestName, true);
end

function B_Reprisal_QuestFailure:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid quest!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_QuestFailure);

-- -------------------------------------------------------------------------- --

---
-- Wertet einen Quest als erfolgreich.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestSuccess(...)
    return B_Reprisal_QuestSuccess:new(...)
end

B_Reprisal_QuestSuccess = {
    Name = "Reprisal_QuestSuccess",
    Description = {
        en = "Reprisal: Completes another active quest successfully",
        de = "Vergeltung: Beendet eine andere aktive Quest erfolgreich",
        fr = "Rétribution: Réussir une autre quête active",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
    },
}

function B_Reprisal_QuestSuccess:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_QuestSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Reprisal_QuestSuccess:CustomFunction(_Quest)
    API.WinQuest(self.QuestName, true);
end

function B_Reprisal_QuestSuccess:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_QuestSuccess);

-- -------------------------------------------------------------------------- --

---
-- Triggert einen Quest.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestActivate(...)
    return B_Reprisal_QuestActivate:new(...)
end

B_Reprisal_QuestActivate = {
    Name = "Reprisal_QuestActivate",
    Description = {
        en = "Reprisal: Activates another quest that is not triggered yet.",
        de = "Vergeltung: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.",
        fr = "Rétribution: Active une autre quête qui n'a pas encore été déclenchée.",
    },
    Parameter = {
        {ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête", },
    },
}

function B_Reprisal_QuestActivate:GetReprisalTable()
    return {Reprisal.Custom, {self, self.CustomFunction} }
end

function B_Reprisal_QuestActivate:AddParameter(_Index, _Parameter)
    if (_Index==0) then
        self.QuestName = _Parameter
    else
        assert(false, "Error in " .. self.Name .. ": AddParameter: Index is invalid")
    end
end

function B_Reprisal_QuestActivate:CustomFunction(_Quest)
    API.StartQuest(self.QuestName, true);
end

function B_Reprisal_QuestActivate:Debug(_Quest)
    if not IsValidQuest(self.QuestName) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Quest: "..  self.QuestName .. " does not exist");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_QuestActivate)

-- -------------------------------------------------------------------------- --

---
-- Unterbricht einen Quest.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestInterrupt(...)
    return B_Reprisal_QuestInterrupt:new(...)
end

B_Reprisal_QuestInterrupt = {
    Name = "Reprisal_QuestInterrupt",
    Description = {
        en = "Reprisal: Interrupts another active quest without success or failure",
        de = "Vergeltung: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg",
        fr = "Rétribution : termine une autre quête active sans succès ni échec",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
    },
}

function B_Reprisal_QuestInterrupt:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_QuestInterrupt:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Reprisal_QuestInterrupt:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then

        local QuestID = GetQuestID(self.QuestName)
        local Quest = Quests[QuestID]
        if Quest.State == QuestState.Active then
            API.StopQuest(self.QuestName, true);
        end
    end
end

function B_Reprisal_QuestInterrupt:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_QuestInterrupt);

-- -------------------------------------------------------------------------- --

---
-- Unterbricht einen Quest, selbst wenn dieser noch nicht ausgelöst wurde.
--
-- @param _QuestName   Name des Quest
-- @param _EndetQuests Bereits beendete unterbrechen
--
-- @within Reprisal
--
function Reprisal_QuestForceInterrupt(...)
    return B_Reprisal_QuestForceInterrupt:new(...)
end

B_Reprisal_QuestForceInterrupt = {
    Name = "Reprisal_QuestForceInterrupt",
    Description = {
        en = "Reprisal: Interrupts another quest (even when it isn't active yet) without success or failure",
        de = "Vergeltung: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg",
        fr = "Rétribution: Termine une autre quête, même si elle n'est pas encore active, sans succès ni échec.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
        { ParameterType.Custom, en = "Ended quests", de = "Beendete Quests", fr = "Quêtes terminées" },
    },
}

function B_Reprisal_QuestForceInterrupt:GetReprisalTable()

    return { Reprisal.Custom,{self, self.CustomFunction} }

end

function B_Reprisal_QuestForceInterrupt:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.InterruptEnded = API.ToBoolean(_Parameter)
    end

end

function B_Reprisal_QuestForceInterrupt:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end
function B_Reprisal_QuestForceInterrupt:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then

        local QuestID = GetQuestID(self.QuestName)
        local Quest = Quests[QuestID]
        if self.InterruptEnded or Quest.State ~= QuestState.Over then
            Quest:Interrupt()
        end
    end
end

function B_Reprisal_QuestForceInterrupt:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_QuestForceInterrupt);

-- -------------------------------------------------------------------------- --

---
-- Ändert den Wert einer benutzerdefinierten Variable.
--
-- Benutzerdefinierte Variablen können ausschließlich Zahlen sein. Nutze
-- dieses Behavior bevor die Variable in einem Goal oder Trigger abgefragt
-- wird, um sie zu initialisieren!
--
-- <p>Operatoren</p>
-- <ul>
-- <li>= - Variablenwert wird auf den Wert gesetzt</li>
-- <li>- - Variablenwert mit Wert Subtrahieren</li>
-- <li>+ - Variablenwert mit Wert addieren</li>
-- <li>* - Variablenwert mit Wert multiplizieren</li>
-- <li>/ - Variablenwert mit Wert dividieren</li>
-- <li>^ - Variablenwert mit Wert potenzieren</li>
-- </ul>
--
-- @param _Name     Name der Variable
-- @param _Operator Rechen- oder Zuweisungsoperator
-- @param _Value    Wert oder andere Custom Variable
--
-- @within Reprisal
--
function Reprisal_CustomVariables(...)
    return B_Reprisal_CustomVariables:new(...);
end

B_Reprisal_CustomVariables = {
    Name = "Reprisal_CustomVariables",
    Description = {
        en = "Reprisal: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.",
        de = "Vergeltung: Führt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.",
        fr = "Rétribution: effectue une opération mathématique sur la variable. L'autre opérateur peut être un nombre ou une variable personnalisée.",
    },
    Parameter = {
        { ParameterType.Default, en = "Name of variable", de = "Variablenname", fr = "Nom de la variable" },
        { ParameterType.Custom,  en = "Operator", de = "Operator", fr = "Operateur" },
        { ParameterType.Default,  en = "Value or variable", de = "Wert oder Variable", fr = "Valeur ou variable" }
    }
};

function B_Reprisal_CustomVariables:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} };
end

function B_Reprisal_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Operator = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        self.Value = (value == nil and tostring(_Parameter)) or value;
    end
end

function B_Reprisal_CustomVariables:CustomFunction()
    local Value1 = API.ObtainCustomVariable("BehaviorVariable_" ..self.VariableName, 0);
    local Value2 = self.Value;
    if type(self.Value) == "string" then
        Value2 = API.ObtainCustomVariable("BehaviorVariable_" ..self.Value, 0);
    end

    if self.Operator == "=" then
        Value1 = Value2;
    elseif self.Operator == "+" then
        Value1 = Value1 + Value2;
    elseif self.Operator == "-" then
        Value1 = Value1 - Value2;
    elseif self.Operator == "*" then
        Value1 = Value1 * Value2;
    elseif self.Operator == "/" then
        Value1 = Value1 / Value2;
    elseif self.Operator == "^" then
        Value1 = Value1 % Value2;
    end
    API.SaveCustomVariable("BehaviorVariable_"..self.VariableName, Value1);
end

function B_Reprisal_CustomVariables:GetCustomData( _Index )
    return {"=", "+", "-", "*", "/", "^"};
end

function B_Reprisal_CustomVariables:Debug(_Quest)
    local operators = {"=", "+", "-", "*", "/", "^"};
    if not table.contains(operators, self.Operator) then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid operator!");
        return true;
    elseif self.VariableName == "" then
        error(_Quest.Identifier.. ": " ..self.Name..": missing name for variable!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_CustomVariables)

-- -------------------------------------------------------------------------- --

---
-- Führt eine Funktion im Skript als Reprisal aus.
--
-- Wird ein Funktionsname als String übergeben, wird die Funktion mit den
-- Daten des Behavors und des zugehörigen Quest aufgerufen (Standard).
--
-- Wird eine Funktionsreferenz angegeben, wird die Funktion zusammen mit allen
-- optionalen Parametern aufgerufen, als sei es ein gewöhnlicher Aufruf im
-- Skript.
-- <pre> Reprisal_MapScriptFunction(ReplaceEntity, "block", Entities.XD_ScriptEntity);
-- -- entspricht: ReplaceEntity("block", Entities.XD_ScriptEntity);</pre>
-- <b>Achtung:</b> Nicht über den Assistenten verfügbar!
--
-- @param _Function Name der Funktion oder Funktionsreferenz
--
-- @within Reprisal
--
function Reprisal_MapScriptFunction(...)
    return B_Reprisal_MapScriptFunction:new(...);
end

B_Reprisal_MapScriptFunction = {
    Name = "Reprisal_MapScriptFunction",
    Description = {
        en = "Reprisal: Calls a function within the global map script if the quest has failed.",
        de = "Vergeltung: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.",
        fr = "Rétribution: lance une fonction dans le script global de la carte en cas d'échec de la quête.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname", fr = "Nom de la fonction" },
    },
}

function B_Reprisal_MapScriptFunction:GetReprisalTable()
    return {Reprisal.Custom, {self, self.CustomFunction}};
end

function B_Reprisal_MapScriptFunction:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.FuncName = _Parameter;
    end
end

function B_Reprisal_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        self.FuncName(unpack(self.i47ya_6aghw_frxil));
        return;
    end
    _G[self.FuncName](self, _Quest);
end

function B_Reprisal_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        error(_Quest.Identifier.. ": " ..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) ~= "function" and not _G[self.FuncName] then
        error(_Quest.Identifier.. ": " ..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_MapScriptFunction);

-- -------------------------------------------------------------------------- --

---
-- Erlaubt oder verbietet einem Spieler ein Recht.
--
-- @param _PlayerID   ID des Spielers
-- @param _Lock       Sperren/Entsperren
-- @param _Technology Name des Rechts
--
-- @within Reprisal
--
function Reprisal_Technology(...)
    return B_Reprisal_Technology:new(...);
end

B_Reprisal_Technology = {
    Name = "Reprisal_Technology",
    Description = {
        en = "Reprisal: Locks or unlocks a technology for the given player",
        de = "Vergeltung: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player",
        fr = "Rétribution: bloque ou autorise une technologie pour le joueur spécifié",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "PlayerID", de = "SpielerID", fr = "PlayerID" },
        { ParameterType.Custom,   en = "Un / Lock", de = "Sperren/Erlauben", fr = "Bloquer/Autoriser" },
        { ParameterType.Custom,   en = "Technology", de = "Technologie"; fr = "Technologie" },
    },
}

function B_Reprisal_Technology:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} }
end

function B_Reprisal_Technology:AddParameter(_Index, _Parameter)
    if (_Index ==0) then
        self.PlayerID = _Parameter*1
    elseif (_Index == 1) then
        self.LockType = _Parameter == "Lock"
    elseif (_Index == 2) then
        self.Technology = _Parameter
    end
end

function B_Reprisal_Technology:CustomFunction(_Quest)
    if self.PlayerID
    and Logic.GetStoreHouse(self.PlayerID) ~= 0
    and Technologies[self.Technology]
    then
        if self.LockType  then
            LockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])
        else
            UnLockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])
        end
    else
        return false
    end
end

function B_Reprisal_Technology:GetCustomData(_Index)
    local Data = {}
    if (_Index == 1) then
        Data[1] = "Lock"
        Data[2] = "UnLock"
    elseif (_Index == 2) then
        for k, v in pairs( Technologies ) do
            table.insert( Data, k )
        end
    end
    return Data
end

function B_Reprisal_Technology:Debug(_Quest)
    if not Technologies[self.Technology] then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid technology type!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_Technology);

-- -------------------------------------------------------------------------- --
-- REWARDS

---
-- Erlaubt oder verbietet einem Spieler ein Recht.
--
-- @param _PlayerID   ID des Spielers
-- @param _Lock       Sperren/Entsperren
-- @param _Technology Name des Rechts
--
-- @within Reprisal
--
function Reprisal_Technology(...)
    return B_Reprisal_Technology:new(...);
end

B_Reprisal_Technology = {
    Name = "Reprisal_Technology",
    Description = {
        en = "Reprisal: Locks or unlocks a technology for the given player",
        de = "Vergeltung: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player",
        fr = "Rétribution: bloque ou autorise une technologie pour le joueur spécifié",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "PlayerID",   de = "SpielerID",          fr = "PlayerID", },
        { ParameterType.Custom,   en = "Un / Lock",  de = "Sperren/Erlauben",   fr = "Bloquer/Autoriser", },
        { ParameterType.Custom,   en = "Technology", de = "Technologie",        fr = "Technologie" },
    },
}

function B_Reprisal_Technology:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} }
end

function B_Reprisal_Technology:AddParameter(_Index, _Parameter)
    if (_Index ==0) then
        self.PlayerID = _Parameter*1
    elseif (_Index == 1) then
        self.LockType = _Parameter == "Lock"
    elseif (_Index == 2) then
        self.Technology = _Parameter
    end
end

function B_Reprisal_Technology:CustomFunction(_Quest)
    if self.PlayerID
    and Logic.GetStoreHouse(self.PlayerID) ~= 0
    and Technologies[self.Technology]
    then
        if self.LockType  then
            LockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])
        else
            UnLockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])
        end
    else
        return false
    end
end

function B_Reprisal_Technology:GetCustomData(_Index)
    local Data = {}
    if (_Index == 1) then
        Data[1] = "Lock"
        Data[2] = "UnLock"
    elseif (_Index == 2) then
        for k, v in pairs( Technologies ) do
            table.insert( Data, k )
        end
    end
    return Data
end

function B_Reprisal_Technology:Debug(_Quest)
    if not Technologies[self.Technology] then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid technology type!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_Technology);

-- -------------------------------------------------------------------------- --
-- Rewards                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Deaktiviert ein interaktives Objekt
--
-- @param _ScriptName Skriptname des interaktiven Objektes
--
-- @within Reward
--
function Reward_ObjectDeactivate(...)
    return B_Reward_InteractiveObjectDeactivate:new(...);
end

B_Reward_InteractiveObjectDeactivate = Swift.LuaBase:CopyTable(B_Reprisal_InteractiveObjectDeactivate);
B_Reward_InteractiveObjectDeactivate.Name             = "Reward_InteractiveObjectDeactivate";
B_Reward_InteractiveObjectDeactivate.Description.en   = "Reward: Deactivates an interactive object";
B_Reward_InteractiveObjectDeactivate.Description.de   = "Lohn: Deaktiviert ein interaktives Objekt";
B_Reward_InteractiveObjectDeactivate.Description.fr   = "Récompense: Désactive un objet interactif";
B_Reward_InteractiveObjectDeactivate.GetReprisalTable = nil;

B_Reward_InteractiveObjectDeactivate.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_InteractiveObjectDeactivate);

-- -------------------------------------------------------------------------- --

---
-- Aktiviert ein interaktives Objekt.
--
-- Der Status bestimmt, wie das objekt aktiviert wird.
-- <ul>
-- <li>0: Kann nur mit Helden aktiviert werden</li>
-- <li>1: Kann immer aktiviert werden</li>
-- <li>2: Kann niemals aktiviert werden</li>
-- </ul>
--
-- @param _ScriptName Skriptname des interaktiven Objektes
-- @param _State Status des Objektes
--
-- @within Reward
--
function Reward_ObjectActivate(...)
    return B_Reward_InteractiveObjectActivate:new(...);
end

B_Reward_InteractiveObjectActivate = Swift.LuaBase:CopyTable(B_Reprisal_InteractiveObjectActivate);
B_Reward_InteractiveObjectActivate.Name             = "Reward_InteractiveObjectActivate";
B_Reward_InteractiveObjectActivate.Description.en   = "Reward: Activates an interactive object";
B_Reward_InteractiveObjectActivate.Description.de   = "Lohn: Aktiviert ein interaktives Objekt";
B_Reward_InteractiveObjectActivate.Description.fr   = "Récompense: Active un objet interactif";
B_Reward_InteractiveObjectActivate.GetReprisalTable = nil;

B_Reward_InteractiveObjectActivate.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} };
end

Swift:RegisterBehavior(B_Reward_InteractiveObjectActivate);

-- -------------------------------------------------------------------------- --

---
-- Initialisiert ein interaktives Objekt.
--
-- Interaktive Objekte können Kosten und Belohnungen enthalten, müssen sie
-- jedoch nicht. Ist eine Wartezeit angegeben, kann das Objekt erst nach
-- Ablauf eines Cooldowns benutzt werden.
--
-- @param _ScriptName Skriptname des interaktiven Objektes
-- @param _Distance   Entfernung zur Aktivierung
-- @param _Time       Wartezeit bis zur Aktivierung
-- @param _RType1     Warentyp der Belohnung
-- @param _RAmount    Menge der Belohnung
-- @param _CType1     Typ der 1. Ware
-- @param _CAmount1   Menge der 1. Ware
-- @param _CType2     Typ der 2. Ware
-- @param _CAmount2   Menge der 2. Ware
-- @param _Status     Aktivierung (0: Held, 1: immer, 2: niemals)
--
-- @within Reward
--
function Reward_ObjectInit(...)
    return B_Reward_ObjectInit:new(...);
end

B_Reward_ObjectInit = {
    Name = "Reward_ObjectInit",
    Description = {
        en = "Reward: Setup an interactive object with costs and rewards.",
        de = "Lohn: Initialisiert ein interaktives Objekt mit seinen Kosten und Schätzen.",
        fr = "Récompense: Initialise un objet interactif avec ses coûts et ses trésors.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object", de = "Interaktives Objekt",  fr = "Obejct interactif" },
        { ParameterType.Number,     en = "Distance to use",    de = "Nutzungsentfernung",   fr = "Distance d'utilisation" },
        { ParameterType.Number,     en = "Waittime",           de = "Wartezeit",            fr = "Temps d'attente" },
        { ParameterType.Custom,     en = "Reward good",        de = "Belohnungsware",       fr = "Produits de récompense" },
        { ParameterType.Number,     en = "Reward amount",      de = "Anzahl",               fr = "Quantité" },
        { ParameterType.Custom,     en = "Cost good 1",        de = "Kostenware 1",         fr = "Marchandise de coût 1" },
        { ParameterType.Number,     en = "Cost amount 1",      de = "Anzahl 1",             fr = "Quantité 1" },
        { ParameterType.Custom,     en = "Cost good 2",        de = "Kostenware 2",         fr = "Marchandise de coût 2" },
        { ParameterType.Number,     en = "Cost amount 2",      de = "Anzahl 2",             fr = "Quantité 2" },
        { ParameterType.Custom,     en = "Availability",       de = "Verfügbarkeit",        fr = "Disponibilité" },
    },
}

function B_Reward_ObjectInit:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_ObjectInit:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.Distance = _Parameter * 1
    elseif (_Index == 2) then
        self.Waittime = _Parameter * 1
    elseif (_Index == 3) then
        self.RewardType = _Parameter
    elseif (_Index == 4) then
        self.RewardAmount = _Parameter * 1
    elseif (_Index == 5) then
        self.FirstCostType = _Parameter
    elseif (_Index == 6) then
        self.FirstCostAmount = _Parameter * 1
    elseif (_Index == 7) then
        self.SecondCostType = _Parameter
    elseif (_Index == 8) then
        self.SecondCostAmount = _Parameter * 1
    elseif (_Index == 9) then
        local parameter = nil
        if _Parameter == "Always" or _Parameter == 1 then
            parameter = 1
        elseif _Parameter == "Never" or _Parameter == 2 then
            parameter = 2
        elseif _Parameter == "Knight only" or _Parameter == 0 then
            parameter = 0
        end
        self.UsingState = parameter
    end
end

function B_Reward_ObjectInit:CustomFunction(_Quest)
    local eID = GetID(self.ScriptName);
    if eID == 0 then
        return;
    end
    QSB.InitalizedObjekts[eID] = _Quest.Identifier;

    Logic.InteractiveObjectClearCosts(eID);
    Logic.InteractiveObjectClearRewards(eID);

    Logic.InteractiveObjectSetInteractionDistance(eID, self.Distance);
    Logic.InteractiveObjectSetTimeToOpen(eID, self.Waittime);

    if self.RewardType and self.RewardType ~= "-" then
        Logic.InteractiveObjectAddRewards(eID, Goods[self.RewardType], self.RewardAmount);
    end
    if self.FirstCostType and self.FirstCostType ~= "-" then
        Logic.InteractiveObjectAddCosts(eID, Goods[self.FirstCostType], self.FirstCostAmount);
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        Logic.InteractiveObjectAddCosts(eID, Goods[self.SecondCostType], self.SecondCostAmount);
    end

    Logic.InteractiveObjectSetAvailability(eID,true);
    if self.UsingState then
        for i=1, 8 do
            Logic.InteractiveObjectSetPlayerState(eID,i, self.UsingState);
        end
    end

    Logic.InteractiveObjectSetRewardResourceCartType(eID,Entities.U_ResourceMerchant);
    Logic.InteractiveObjectSetRewardGoldCartType(eID,Entities.U_GoldCart);
    Logic.InteractiveObjectSetCostResourceCartType(eID,Entities.U_ResourceMerchant);
    Logic.InteractiveObjectSetCostGoldCartType(eID, Entities.U_GoldCart);
    RemoveInteractiveObjectFromOpenedList(eID);
    table.insert(HiddenTreasures,eID);
end

function B_Reward_ObjectInit:GetCustomData( _Index )
    if _Index == 3 or _Index == 5 or _Index == 7 then
        local Data = {
            "-",
            "G_Beer",
            "G_Bread",
            "G_Broom",
            "G_Carcass",
            "G_Cheese",
            "G_Clothes",
            "G_Dye",
            "G_Gold",
            "G_Grain",
            "G_Herb",
            "G_Honeycomb",
            "G_Iron",
            "G_Leather",
            "G_Medicine",
            "G_Milk",
            "G_RawFish",
            "G_Salt",
            "G_Sausage",
            "G_SmokedFish",
            "G_Soap",
            "G_Stone",
            "G_Water",
            "G_Wood",
            "G_Wool",
        }

        if g_GameExtraNo >= 1 then
            Data[#Data+1] = "G_Gems"
            Data[#Data+1] = "G_MusicalInstrument"
            Data[#Data+1] = "G_Olibanum"
        end
        return Data
    elseif _Index == 9 then
        return {"-", "Knight only", "Always", "Never",}
    end
end

function B_Reward_ObjectInit:Debug(_Quest)
    if Logic.IsInteractiveObject(GetID(self.ScriptName)) == false then
        error(_Quest.Identifier.. ": " ..self.Name..": '"..self.ScriptName.."' is not a interactive object!");
        return true;
    end
    if self.UsingState ~= 1 and self.Distance < 50 then
        warn(_Quest.Identifier.. ": " ..self.Name..": distance is maybe too short!");
    end
    if self.Waittime < 0 then
        error(_Quest.Identifier.. ": " ..self.Name..": waittime must be equal or greater than 0!");
        return true;
    end
    if self.RewardType and self.RewardType ~= "-" then
        if not Goods[self.RewardType] then
            error(_Quest.Identifier.. ": " ..self.Name..": '"..self.RewardType.."' is invalid good type!");
            return true;
        elseif self.RewardAmount < 1 then
            error(_Quest.Identifier.. ": " ..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    if self.FirstCostType and self.FirstCostType ~= "-" then
        if not Goods[self.FirstCostType] then
            error(_Quest.Identifier.. ": " ..self.Name..": '"..self.FirstCostType.."' is invalid good type!");
            return true;
        elseif self.FirstCostAmount < 1 then
            error(_Quest.Identifier.. ": " ..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        if not Goods[self.SecondCostType] then
            error(_Quest.Identifier.. ": " ..self.Name..": '"..self.SecondCostType.."' is invalid good type!");
            return true;
        elseif self.SecondCostAmount < 1 then
            error(_Quest.Identifier.. ": " ..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_ObjectInit);

-- -------------------------------------------------------------------------- --

---
-- Änder den Diplomatiestatus zwischen zwei Spielern.
--
-- @param _Party1   ID der ersten Partei
-- @param _Party2   ID der zweiten Partei
-- @param _State    Neuer Diplomatiestatus
--
-- @within Reward
--
function Reward_Diplomacy(...)
    return B_Reward_Diplomacy:new(...);
end

B_Reward_Diplomacy = Swift.LuaBase:CopyTable(B_Reprisal_Diplomacy);
B_Reward_Diplomacy.Name             = "Reward_Diplomacy";
B_Reward_Diplomacy.Description.en   = "Reward: Sets Diplomacy state of two Players to a stated value.";
B_Reward_Diplomacy.Description.de   = "Lohn: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.";
B_Reward_Diplomacy.Description.fr   = "Récompense: Définit le statut diplomatique de deux joueurs sur la valeur indiquée.";
B_Reward_Diplomacy.GetReprisalTable = nil;

B_Reward_Diplomacy.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_Diplomacy);

-- -------------------------------------------------------------------------- --

---
-- Verbessert die diplomatischen Beziehungen zwischen Sender und Empfänger
-- um einen Grad.
--
-- @within Reward
--
function Reward_DiplomacyIncrease()
    return B_Reward_SlightlyDiplomacyIncrease:new();
end

B_Reward_SlightlyDiplomacyIncrease = {
    Name = "Reward_SlightlyDiplomacyIncrease",
    Description = {
        en = "Reward: Diplomacy increases slightly to another player",
        de = "Lohn: Verbesserung des Diplomatiestatus zu einem anderen Spieler",
        fr = "Récompense: Amélioration du statut diplomatique avec un autre joueur",
    },
}

function B_Reward_SlightlyDiplomacyIncrease:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_SlightlyDiplomacyIncrease:CustomFunction(_Quest)
    local Sender = _Quest.SendingPlayer;
    local Receiver = _Quest.ReceivingPlayer;
    local State = GetDiplomacyState(Receiver, Sender);
    if State < 2 then
        SetDiplomacyState(Receiver, Sender, State+1);
    end
end

function B_Reward_SlightlyDiplomacyIncrease:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

Swift:RegisterBehavior(B_Reward_SlightlyDiplomacyIncrease);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt Handelsangebote im Lagerhaus des angegebenen Spielers.
--
-- Sollen Angebote gelöscht werden, muss "-" als Ware ausgewählt werden.
--
-- <b>Achtung:</b> Stadtlagerhäuser können keine Söldner anbieten!
--
-- @param _PlayerID Partei, die Anbietet
-- @param _Amount1  Menge des 1. Angebot
-- @param _Type1    Ware oder Typ des 1. Angebot
-- @param _Amount2  Menge des 2. Angebot
-- @param _Type2    Ware oder Typ des 2. Angebot
-- @param _Amount3  Menge des 3. Angebot
-- @param _Type3    Ware oder Typ des 3. Angebot
-- @param _Amount4  Menge des 4. Angebot
-- @param _Type4    Ware oder Typ des 4. Angebot
--
-- @within Reward
--
function Reward_TradeOffers(...)
    return B_Reward_Merchant:new(...);
end

B_Reward_Merchant = {
    Name = "Reward_Merchant",
    Description = {
        en = "Reward: Deletes all existing offers for a merchant and sets new offers, if given",
        de = "Lohn: Löscht alle Angebote eines Händlers und setzt neue, wenn angegeben",
        fr = "Récompense: Supprime toutes les offres d'un commerçant et en place de nouvelles si elles sont indiquées.",
    },
    Parameter = {
        { ParameterType.Custom, en = "PlayerID", de = "PlayerID",  fr = "PlayerID" },
        { ParameterType.Custom, en = "Amount 1", de = "Menge 1",   fr = "Quantité 1" },
        { ParameterType.Custom, en = "Offer 1",  de = "Angebot 1", fr = "Offre 1" },
        { ParameterType.Custom, en = "Amount 2", de = "Menge 2",   fr = "Quantité 2" },
        { ParameterType.Custom, en = "Offer 2",  de = "Angebot 2", fr = "Offre 2" },
        { ParameterType.Custom, en = "Amount 3", de = "Menge 3",   fr = "Quantité 3" },
        { ParameterType.Custom, en = "Offer 3",  de = "Angebot 3", fr = "Offr 3e" },
        { ParameterType.Custom, en = "Amount 4", de = "Menge 4",   fr = "Quantité 4" },
        { ParameterType.Custom, en = "Offer 4",  de = "Angebot 4", fr = "Offre 4" },
    },
}

function B_Reward_Merchant:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_Merchant:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 1) then
        _Parameter = _Parameter or 0;
        self.AmountOffer1 = _Parameter * 1;
    elseif (_Index == 2) then
        self.Offer1 = _Parameter
    elseif (_Index == 3) then
        _Parameter = _Parameter or 0;
        self.AmountOffer2 = _Parameter * 1;
    elseif (_Index == 4) then
        self.Offer2 = _Parameter
    elseif (_Index == 5) then
        _Parameter = _Parameter or 0;
        self.AmountOffer3 = _Parameter * 1;
    elseif (_Index == 6) then
        self.Offer3 = _Parameter
    elseif (_Index == 7) then
        _Parameter = _Parameter or 0;
        self.AmountOffer4 = _Parameter * 1;
    elseif (_Index == 8) then
        self.Offer4 = _Parameter
    end
end

function B_Reward_Merchant:CustomFunction()
    if (self.PlayerID > 1) and (self.PlayerID < 9) then
        local Storehouse = Logic.GetStoreHouse(self.PlayerID)
        Logic.RemoveAllOffers(Storehouse)
        for i =  1,4 do
            if self["Offer"..i] and self["Offer"..i] ~= "-" then
                if Goods[self["Offer"..i]] then
                    AddOffer(Storehouse, self["AmountOffer"..i], Goods[self["Offer"..i]])
                elseif Logic.IsEntityTypeInCategory(Entities[self["Offer"..i]], EntityCategories.Military) == 1 then
                    AddMercenaryOffer(Storehouse, self["AmountOffer"..i], Entities[self["Offer"..i]])
                else
                    AddEntertainerOffer (Storehouse , Entities[self["Offer"..i]])
                end
            end
        end
    end
end

function B_Reward_Merchant:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID ) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(")
        return true
    end
end

function B_Reward_Merchant:GetCustomData(_Index)
    local Players = { 1,2,3,4,5,6,7,8 }
    local Amount = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }
    local Offers = {"-",
                    "G_Beer",
                    "G_Bow",
                    "G_Bread",
                    "G_Broom",
                    "G_Candle",
                    "G_Carcass",
                    "G_Cheese",
                    "G_Clothes",
                    "G_Cow",
                    "G_Grain",
                    "G_Herb",
                    "G_Honeycomb",
                    "G_Iron",
                    "G_Leather",
                    "G_Medicine",
                    "G_Milk",
                    "G_RawFish",
                    "G_Sausage",
                    "G_Sheep",
                    "G_SmokedFish",
                    "G_Soap",
                    "G_Stone",
                    "G_Sword",
                    "G_Wood",
                    "G_Wool",
                    "G_Salt",
                    "G_Dye",
                    "U_AmmunitionCart",
                    "U_BatteringRamCart",
                    "U_CatapultCart",
                    "U_SiegeTowerCart",
                    "U_MilitaryBandit_Melee_ME",
                    "U_MilitaryBandit_Melee_SE",
                    "U_MilitaryBandit_Melee_NA",
                    "U_MilitaryBandit_Melee_NE",
                    "U_MilitaryBandit_Ranged_ME",
                    "U_MilitaryBandit_Ranged_NA",
                    "U_MilitaryBandit_Ranged_NE",
                    "U_MilitaryBandit_Ranged_SE",
                    "U_MilitaryBow_RedPrince",
                    "U_MilitaryBow",
                    "U_MilitarySword_RedPrince",
                    "U_MilitarySword",
                    "U_Entertainer_NA_FireEater",
                    "U_Entertainer_NA_StiltWalker",
                    "U_Entertainer_NE_StrongestMan_Barrel",
                    "U_Entertainer_NE_StrongestMan_Stone",
                    }
    if g_GameExtraNo and g_GameExtraNo >= 1 then
        table.insert(Offers, "G_Gems")
        table.insert(Offers, "G_Olibanum")
        table.insert(Offers, "G_MusicalInstrument")
        table.insert(Offers, "G_MilitaryBandit_Ranged_AS")
        table.insert(Offers, "G_MilitaryBandit_Melee_AS")
        table.insert(Offers, "U_MilitarySword_Khana")
        table.insert(Offers, "U_MilitaryBow_Khana")
    end
    if (_Index == 0) then
        return Players
    elseif (_Index == 1) or (_Index == 3) or (_Index == 5) or (_Index == 7) then
        return Amount
    elseif (_Index == 2) or (_Index == 4) or (_Index == 6) or (_Index == 8) then
        return Offers
    end
end

Swift:RegisterBehavior(B_Reward_Merchant)

-- -------------------------------------------------------------------------- --

---
-- Ein benanntes Entity wird entfernt.
--
-- <b>Hinweis</b>: Das Entity wird durch ein XD_ScriptEntity ersetzt. Es
-- behält Name, Besitzer und Ausrichtung.
--
-- @param _ScriptName Skriptname des Entity
--
-- @within Reward
--
function Reward_DestroyEntity(...)
    return B_Reward_DestroyEntity:new(...);
end

B_Reward_DestroyEntity = Swift.LuaBase:CopyTable(B_Reprisal_DestroyEntity);
B_Reward_DestroyEntity.Name = "Reward_DestroyEntity";
B_Reward_DestroyEntity.Description.en = "Reward: Replaces an entity with an invisible script entity, which retains the entities name.";
B_Reward_DestroyEntity.Description.de = "Lohn: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.";
B_Reward_DestroyEntity.Description.fr = "Récompense: Remplace une entité par une entité de script invisible qui prend le nom.";
B_Reward_DestroyEntity.GetReprisalTable = nil;

B_Reward_DestroyEntity.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_DestroyEntity);

-- -------------------------------------------------------------------------- --

---
-- Zerstört einen über ein Behavior erzeugten Effekt.
--
-- @param _EffectName Name des Effekts
--
-- @within Reward
--
function Reward_DestroyEffect(...)
    return B_Reward_DestroyEffect:new(...);
end

B_Reward_DestroyEffect = Swift.LuaBase:CopyTable(B_Reprisal_DestroyEffect);
B_Reward_DestroyEffect.Name = "Reward_DestroyEffect";
B_Reward_DestroyEffect.Description.en = "Reward: Destroys an effect.";
B_Reward_DestroyEffect.Description.de = "Lohn: Zerstört einen Effekt.";
B_Reward_DestroyEffect.Description.fr = "Récompense: Détruit un effet.";
B_Reward_DestroyEffect.GetReprisalTable = nil;

B_Reward_DestroyEffect.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Swift:RegisterBehavior(B_Reward_DestroyEffect);

-- -------------------------------------------------------------------------- --

---
-- Ersetzt ein Entity mit einem Batallion.
--
-- Ist die Position ein Gebäude, werden die Battalione am Eingang erzeugt und
-- Das Entity wird nicht ersetzt.
--
-- Das erzeugte Battalion kann vor der KI des Besitzers versteckt werden.
--
-- @param _Position    Skriptname des Entity
-- @param _PlayerID    PlayerID des Battalion
-- @param _UnitType    Einheitentyp der Soldaten
-- @param _Orientation Ausrichtung in °
-- @param _Soldiers    Anzahl an Soldaten
-- @param _HideFromAI  Vor KI verstecken
--
-- @within Reward
--
function Reward_CreateBattalion(...)
    return B_Reward_CreateBattalion:new(...);
end

B_Reward_CreateBattalion = {
    Name = "Reward_CreateBattalion",
    Description = {
        en = "Reward: Replaces a script entity with a battalion, which retains the entities name",
        de = "Lohn: Ersetzt eine Script-Entity durch ein Bataillon, welches den Namen der Script-Entity übernimmt",
        fr = "Récompense: Remplace une entité de script par un bataillon qui prend le nom de l'entité de script.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity",               de = "Script Entity",           fr = "Entité de script" },
        { ParameterType.PlayerID,   en = "Player",                      de = "Spieler",                 fr = "Joueur" },
        { ParameterType.Custom,     en = "Type name",                   de = "Typbezeichnung",          fr = "Désignation du type" },
        { ParameterType.Number,     en = "Orientation (in degrees)",    de = "Ausrichtung (in Grad)",   fr = "Orientation (en degrés)" },
        { ParameterType.Number,     en = "Number of soldiers",          de = "Anzahl Soldaten",         fr = "Nombre de Soldats" },
        { ParameterType.Custom,     en = "Hide from AI",                de = "Vor KI verstecken",       fr = "Cacher de l'IA" },
    },
}

function B_Reward_CreateBattalion:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_CreateBattalion:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 4) then
        self.SoldierCount = _Parameter * 1
    elseif (_Index == 5) then
        self.HideFromAI = API.ToBoolean(_Parameter)
    end
end

function B_Reward_CreateBattalion:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, self.SoldierCount )
    local posID = GetID(self.ScriptNameEntity)
    if Logic.IsBuilding(posID) == 0 then
        DestroyEntity(self.ScriptNameEntity)
        Logic.SetEntityName( NewID, self.ScriptNameEntity )
    end
    if self.HideFromAI then
        AICore.HideEntityFromAI( self.PlayerID, NewID, true )
    end
end

function B_Reward_CreateBattalion:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        for k, v in pairs( Entities ) do
            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 5 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_CreateBattalion:Debug(_Quest)
    if not Entities[self.UnitKey] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": playerID is wrong!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        error(_Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": you can not create a empty batallion!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_CreateBattalion);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt eine Menga von Battalionen an der Position.
--
-- Die erzeugten Battalione können vor der KI ihres Besitzers versteckt werden.
--
-- @param _Amount      Anzahl erzeugter Battalione
-- @param _Position    Skriptname des Entity
-- @param _PlayerID    PlayerID des Battalion
-- @param _UnitType    Einheitentyp der Soldaten
-- @param _Orientation Ausrichtung in °
-- @param _Soldiers    Anzahl an Soldaten
-- @param _HideFromAI  Vor KI verstecken
--
-- @within Reward
--
function Reward_CreateSeveralBattalions(...)
    return B_Reward_CreateSeveralBattalions:new(...);
end

B_Reward_CreateSeveralBattalions = {
    Name = "Reward_CreateSeveralBattalions",
    Description = {
        en = "Reward: Creates a given amount of battalions",
        de = "Lohn: Erstellt eine gegebene Anzahl Bataillone",
        fr = "Récompense: Crée un nombre donné de bataillons",
    },
    Parameter = {
        { ParameterType.Number,     en = "Amount",                      de = "Anzahl",                  fr = "Quantité" },
        { ParameterType.ScriptName, en = "Script entity",               de = "Script Entity",           fr = "Quentité de Script" },
        { ParameterType.PlayerID,   en = "Player",                      de = "Spieler",                 fr = "Joueur" },
        { ParameterType.Custom,     en = "Type name",                   de = "Typbezeichnung",          fr = "Désignation de type" },
        { ParameterType.Number,     en = "Orientation (in degrees)",    de = "Ausrichtung (in Grad)",   fr = "Orientation (en degrés)" },
        { ParameterType.Number,     en = "Number of soldiers",          de = "Anzahl Soldaten",         fr = "Nombre de soldats" },
        { ParameterType.Custom,     en = "Hide from AI",                de = "Vor KI verstecken",       fr = "Cacher de l'AI" },
    },
}

function B_Reward_CreateSeveralBattalions:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_CreateSeveralBattalions:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1
    elseif (_Index == 1) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 3) then
        self.UnitKey = _Parameter
    elseif (_Index == 4) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 5) then
        self.SoldierCount = _Parameter * 1
    elseif (_Index == 6) then
        self.HideFromAI = API.ToBoolean(_Parameter)
    end
end

function B_Reward_CreateSeveralBattalions:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local tID = GetID(self.ScriptNameEntity)
    local x,y,z = Logic.EntityGetPos(tID);
    if Logic.IsBuilding(tID) == 1 then
        x,y = Logic.GetBuildingApproachPosition(tID)
    end

    for i=1, self.Amount do
        local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], x, y, self.Orientation, self.PlayerID, self.SoldierCount )
        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )
        if self.HideFromAI then
            AICore.HideEntityFromAI( self.PlayerID, NewID, true )
        end
    end
end

function B_Reward_CreateSeveralBattalions:GetCustomData( _Index )
    local Data = {}
    if _Index == 3 then
        for k, v in pairs( Entities ) do
            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 6 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_CreateSeveralBattalions:Debug(_Quest)
    if not Entities[self.UnitKey] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": playerDI is wrong!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        error(_Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": you can not create a empty batallion!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_CreateSeveralBattalions);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt einen Effekt an der angegebenen Position.
--
-- Der Effekt kann über seinen Namen jeder Zeit gelöscht werden.
--
-- <b>Achtung</b>: Feuereffekte sind bekannt dafür Abstürzue zu verursachen.
-- Vermeide sie entweder ganz oder unterbinde das Speichern, solange ein
-- solcher Effekt aktiv ist!
--
-- @param _EffectName  Einzigartiger Effektname
-- @param _TypeName    Typ des Effekt
-- @param _PlayerID    PlayerID des Effekt
-- @param _Location    Position des Effekt
-- @param _Orientation Ausrichtung in °
--
-- @within Reward
--
function Reward_CreateEffect(...)
    return B_Reward_CreateEffect:new(...);
end

B_Reward_CreateEffect = {
    Name = "Reward_CreateEffect",
    Description = {
        en = "Reward: Creates an effect at a specified position",
        de = "Lohn: Erstellt einen Effekt an der angegebenen Position",
        fr = "Récompense: Crée un effet à la position indiquée",
    },
    Parameter = {
        { ParameterType.Default,    en = "Effect name", de = "Effektname",      fr = "Nom de l'effet" },
        { ParameterType.Custom,     en = "Type name",   de = "Typbezeichnung",  fr = "Designation de type" },
        { ParameterType.PlayerID,   en = "Player",      de = "Spieler",         fr = "Joueur" },
        { ParameterType.ScriptName, en = "Location",    de = "Ort",             fr = "Lieu" },
        { ParameterType.Number,     en = "Orientation (in degrees)(-1: from locating entity)", de = "Ausrichtung (in Grad)(-1: von Positionseinheit)", fr = "Orientation (en degrés)(-1 : de l'unité de position)" },
    }
}

function B_Reward_CreateEffect:AddParameter(_Index, _Parameter)

    if _Index == 0 then
        self.EffectName = _Parameter;
    elseif _Index == 1 then
        self.Type = EGL_Effects[_Parameter];
    elseif _Index == 2 then
        self.PlayerID = _Parameter * 1;
    elseif _Index == 3 then
        self.Location = _Parameter;
    elseif _Index == 4 then
        self.Orientation = _Parameter * 1;
    end

end

function B_Reward_CreateEffect:GetRewardTable()
    return { Reward.Custom, { self, self.CustomFunction } };
end

function B_Reward_CreateEffect:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed(self.Location) then
        return;
    end
    local entity = assert(GetID(self.Location), _Quest.Identifier .. "Error in " .. self.Name .. ": CustomFunction: Entity is invalid");
    if QSB.EffectNameToID[self.EffectName] and Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then
        return;
    end

    local posX, posY = Logic.GetEntityPosition(entity);
    local orientation = tonumber(self.Orientation);
    local effect = Logic.CreateEffectWithOrientation(self.Type, posX, posY, orientation, self.PlayerID);
    if self.EffectName ~= "" then
        QSB.EffectNameToID[self.EffectName] = effect;
    end
end

function B_Reward_CreateEffect:Debug(_Quest)
    if QSB.EffectNameToID[self.EffectName] and Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then
        error(_Quest.Identifier.. ": " ..self.Name..": effect already exists!");
        return true;
    elseif not IsExisting(self.Location) then
        error(_Quest.Identifier.. ": " ..self.Name..": location '" ..self.Location.. "' is missing!");
        return true;
    elseif self.PlayerID and (self.PlayerID < 0 or self.PlayerID > 8) then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid playerID!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid orientation!");
        return true;
    end
end

function B_Reward_CreateEffect:GetCustomData(_Index)
    assert(_Index == 1, "Error in " .. self.Name .. ": GetCustomData: Index is invalid.");
    local types = {};
    for k, v in pairs(EGL_Effects) do
        table.insert(types, k);
    end
    table.sort(types);
    return types;
end

Swift:RegisterBehavior(B_Reward_CreateEffect);

-- -------------------------------------------------------------------------- --

---
-- Ersetzt ein Entity mit dem Skriptnamen durch ein neues Entity.
--
-- Ist die Position ein Gebäude, werden die Entities am Eingang erzeugt und
-- die Position wird nicht ersetzt.
--
-- Das erzeugte Entity kann vor der KI des Besitzers versteckt werden.
--
-- @param _ScriptName  Skriptname des Entity
-- @param _PlayerID    PlayerID des Effekt
-- @param _TypeName    Typname des Entity
-- @param _Orientation Ausrichtung in °
-- @param _HideFromAI  Vor KI verstecken
--
-- @within Reward
--
function Reward_CreateEntity(...)
    return B_Reward_CreateEntity:new(...);
end

B_Reward_CreateEntity = {
    Name = "Reward_CreateEntity",
    Description = {
        en = "Reward: Replaces an entity by a new one of a given type",
        de = "Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs",
        fr = "Récompense: Remplace une entité par une nouvelle entité de type donné",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity",               de = "Script Entity",           fr = "Entité de script" },
        { ParameterType.PlayerID,   en = "Player",                      de = "Spieler",                 fr = "Joueur" },
        { ParameterType.Custom,     en = "Type name",                   de = "Typbezeichnung",          fr = "Désignation de type" },
        { ParameterType.Number,     en = "Orientation (in degrees)",    de = "Ausrichtung (in Grad)",   fr = "Orientation (en degrés)" },
        { ParameterType.Custom,     en = "Hide from AI",                de = "Vor KI verstecken",       fr = "Cacher de l'AI" },
    },
}

function B_Reward_CreateEntity:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_CreateEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 4) then
        self.HideFromAI = API.ToBoolean(_Parameter)
    end
end

function B_Reward_CreateEntity:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID;
    if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then
        NewID     = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )
        local l,s = Logic.GetSoldiersAttachedToLeader(NewID)
        Logic.SetOrientation(s, math.floor(self.Orientation + 0.5))
    else
        NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )
    end
    local posID = GetID(self.ScriptNameEntity)
    if Logic.IsBuilding(posID) == 0 then
        DestroyEntity(self.ScriptNameEntity)
        Logic.SetEntityName( NewID, self.ScriptNameEntity )
    end
    if self.HideFromAI then
        AICore.HideEntityFromAI( self.PlayerID, NewID, true )
    end
end

function B_Reward_CreateEntity:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        for k, v in pairs( Entities ) do
            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )

    elseif _Index == 4 or _Index == 5 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_CreateEntity:Debug(_Quest)
    if not Entities[self.UnitKey] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 0 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": playerID is not valid!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        error(_Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_CreateEntity);

-- -------------------------------------------------------------------------- --

-- Kompatibelität
B_Reward_CreateSettler = Swift.LuaBase:CopyTable(B_Reward_CreateEntity);
B_Reward_CreateSettler.Name = "Reward_CreateSettler";
B_Reward_CreateSettler.Description.en = "Reward: Replaces an entity by a new one of a given type";
B_Reward_CreateSettler.Description.de = "Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs";
B_Reward_CreateSettler.Description.fr = "Récompense: Remplace une entité par une nouvelle entité de type donné";
Swift:RegisterBehavior(B_Reward_CreateSettler);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt mehrere Entities an der angegebenen Position.
--
-- Die erzeugten Entities können vor der KI ihres Besitzers versteckt werden.
--
-- @param _Amount      Anzahl an Entities
-- @param _ScriptName  Skriptname des Entity
-- @param _PlayerID    PlayerID des Effekt
-- @param _TypeName    Einzigartiger Effektname
-- @param _Orientation Ausrichtung in °
-- @param _HideFromAI  Vor KI verstecken
--
-- @within Reward
--
function Reward_CreateSeveralEntities(...)
    return B_Reward_CreateSeveralEntities:new(...);
end

B_Reward_CreateSeveralEntities = {
    Name = "Reward_CreateSeveralEntities",
    Description = {
        en = "Reward: Creating serveral battalions at the position of a entity. They retains the entities name and a _[index] suffix",
        de = "Lohn: Erzeugt mehrere Entities an der Position der Entity. Sie übernimmt den Namen der Script Entity und den Suffix _[index]",
        fr = "Récompense: Crée plusieurs Entities à la position de l'Entity. Elle reprend le nom de l'entité script et le suffixe _[index].",
    },
    Parameter = {
        { ParameterType.Number,     en = "Amount",                      de = "Anzahl",                  fr = "Quantité" },
        { ParameterType.ScriptName, en = "Script entity",               de = "Script Entity",           fr = "Entité de script" },
        { ParameterType.PlayerID,   en = "Player",                      de = "Spieler",                 fr = "Joueur" },
        { ParameterType.Custom,     en = "Type name",                   de = "Typbezeichnung",          fr = "Designation de type" },
        { ParameterType.Number,     en = "Orientation (in degrees)",    de = "Ausrichtung (in Grad)",   fr = "Orientation (en degrés)" },
        { ParameterType.Custom,     en = "Hide from AI",                de = "Vor KI verstecken",       fr = "Cacher de l'AI" },
    },
}

function B_Reward_CreateSeveralEntities:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_CreateSeveralEntities:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1
    elseif (_Index == 1) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 3) then
        self.UnitKey = _Parameter
    elseif (_Index == 4) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 5) then
        self.HideFromAI = API.ToBoolean(_Parameter)
    end
end

function B_Reward_CreateSeveralEntities:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID;
    for i=1, self.Amount do
        if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then
            NewID     = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )
            local l,s = Logic.GetSoldiersAttachedToLeader(NewID)
            Logic.SetOrientation(s, math.floor(self.Orientation + 0.5))
        else
            NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )
        end
        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )
        if self.HideFromAI then
            AICore.HideEntityFromAI( self.PlayerID, NewID, true )
        end
    end
end

function B_Reward_CreateSeveralEntities:GetCustomData( _Index )
    local Data = {}
    if _Index == 3 then
        for k, v in pairs( Entities ) do
            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )

    elseif _Index == 5 or _Index == 6 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data

end

function B_Reward_CreateSeveralEntities:Debug(_Quest)
    if not Entities[self.UnitKey] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        error(_Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_CreateSeveralEntities);

-- -------------------------------------------------------------------------- --

---
-- Bewegt einen Siedler, einen Helden oder ein Battalion zum angegebenen 
-- Zielort.
--
-- @param _Settler     Einheit, die bewegt wird
-- @param _Destination Bewegungsziel
--
-- @within Reward
--
function Reward_MoveSettler(...)
    return B_Reward_MoveSettler:new(...);
end

B_Reward_MoveSettler = {
    Name = "Reward_MoveSettler",
    Description = {
        en = "Reward: Moves a (NPC) settler to a destination. Must not be AI controlled, or it won't move",
        de = "Lohn: Bewegt einen (NPC) Siedler zu einem Zielort. Darf keinem KI Spieler gehören, ansonsten wird sich der Siedler nicht bewegen",
        fr = "Récompense: Déplace un settler (NPC) vers une destination. Ne doit pas appartenir à un joueur IA, sinon le settler ne se déplacera pas.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Settler", de = "Siedler", fr = "Settler" },
        { ParameterType.ScriptName, en = "Destination", de = "Ziel", fr = "Destination" },
    },
}

function B_Reward_MoveSettler:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_MoveSettler:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameUnit = _Parameter
    elseif (_Index == 1) then
        self.ScriptNameDest = _Parameter
    end
end

function B_Reward_MoveSettler:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.ScriptNameUnit ) or Logic.IsEntityDestroyed( self.ScriptNameDest ) then
        return false
    end
    local DestID = GetID( self.ScriptNameDest )
    local DestX, DestY = Logic.GetEntityPosition( DestID )
    if Logic.IsBuilding( DestID ) == 1 then
        DestX, DestY = Logic.GetBuildingApproachPosition( DestID )
    end
    Logic.MoveSettler( GetID( self.ScriptNameUnit ), DestX, DestY )
end

function B_Reward_MoveSettler:Debug(_Quest)
    if not IsExisting(self.ScriptNameUnit) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": mover entity does not exist!");
        return true;
    elseif not IsExisting(self.ScriptNameDest) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": destination does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_MoveSettler);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler gewinnt das Spiel.
--
-- @within Reward
--
function Reward_Victory()
    return B_Reward_Victory:new()
end

B_Reward_Victory = {
    Name = "Reward_Victory",
    Description = {
        en = "Reward: The player wins the game.",
        de = "Lohn: Der Spieler gewinnt das Spiel.",
        fr = "Récompense: Le Joueur gagne la partie.",
    },
}

function B_Reward_Victory:GetRewardTable()
    return {Reward.Victory};
end

Swift:RegisterBehavior(B_Reward_Victory);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler verliert das Spiel.
--
--
-- @within Reward
--
function Reward_Defeat()
    return B_Reward_Defeat:new()
end

B_Reward_Defeat = {
    Name = "Reward_Defeat",
    Description = {
        en = "Reward: The player loses the game.",
        de = "Lohn: Der Spieler verliert das Spiel.",
        fr = "Récompense: le Joueur perd la partie.",
    },
}

function B_Reward_Defeat:GetRewardTable()
    return { Reward.Custom, {self, self.CustomFunction} }
end

function B_Reward_Defeat:CustomFunction(_Quest)
    _Quest:TerminateEventsAndStuff()
    Logic.ExecuteInLuaLocalState("GUI_Window.MissionEndScreenSetVictoryReasonText(".. g_VictoryAndDefeatType.DefeatMissionFailed ..")")
    Defeated(_Quest.ReceivingPlayer)
end

Swift:RegisterBehavior(B_Reward_Defeat);

-- -------------------------------------------------------------------------- --

---
-- Zeigt die Siegdekoration an dem Quest an.
--
-- Dies ist reine Optik! Der Spieler wird dadurch nicht das Spiel gewinnen.
--
-- @within Reward
--
function Reward_FakeVictory()
    return B_Reward_FakeVictory:new();
end

B_Reward_FakeVictory = {
    Name = "Reward_FakeVictory",
    Description = {
        en = "Reward: Display a victory icon for a quest",
        de = "Lohn: Zeigt ein Siegesicon fuer diese Quest",
        fr = "Récompense: Affiche une icône de victoire pour cette quête",
    },
}

function B_Reward_FakeVictory:GetRewardTable()
    return { Reward.FakeVictory }
end

Swift:RegisterBehavior(B_Reward_FakeVictory);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt eine Armee, die das angegebene Territorium angreift.
--
-- Die Armee wird versuchen Gebäude auf dem Territrium zu zerstören.
-- <ul>
-- <li>Außenposten: Die Armee versucht den Außenposten zu zerstören</li>
-- <li>Stadt: Die Armee versucht das Lagerhaus zu zerstören</li>
-- </ul>
--
-- @param _PlayerID   PlayerID der Angreifer
-- @param _SpawnPoint Skriptname des Entstehungspunkt
-- @param _Territory  Zielterritorium
-- @param _Sword      Anzahl Schwertkämpfer (Battalion)
-- @param _Bow        Anzahl Bogenschützen (Battalion)
-- @param _Cata       Anzahl Katapulte
-- @param _Towers     Anzahl Belagerungstürme
-- @param _Rams       Anzahl Rammen
-- @param _Ammo       Anzahl Munitionswagen
-- @param _Type       Typ der Soldaten
-- @param _Reuse      Freie Truppen wiederverwenden
--
-- @within Reward
--
function Reward_AI_SpawnAndAttackTerritory(...)
    return B_Reward_AI_SpawnAndAttackTerritory:new(...);
end

B_Reward_AI_SpawnAndAttackTerritory = {
    Name = "Reward_AI_SpawnAndAttackTerritory",
    Description = {
        en = "Reward: Spawns AI troops and attacks a territory (Hint: Use for hidden quests as a surprise)",
        de = "Lohn: Erstellt KI Truppen und greift ein Territorium an (Tipp: Fuer eine versteckte Quest als Ueberraschung verwenden)",
        fr = "Récompense: Créez des troupes d'IA et attaquez un territoire (astuce : utilisez une surprise pour une quête cachée).",
    },
    Parameter = {
        { ParameterType.PlayerID,       en = "AI Player",       de = "KI Spieler",                  fr = "Joueur AI" },
        { ParameterType.ScriptName,     en = "Spawn point",     de = "Erstellungsort",              fr = "Lieu de création" },
        { ParameterType.TerritoryName,  en = "Territory",       de = "Territorium",                 fr = "Territoire" },
        { ParameterType.Number,         en = "Sword",           de = "Schwert",                     fr = "Épéiste" },
        { ParameterType.Number,         en = "Bow",             de = "Bogen",                       fr = "Archer" },
        { ParameterType.Number,         en = "Catapults",       de = "Katapulte",                   fr = "Catapultes" },
        { ParameterType.Number,         en = "Siege towers",    de = "Belagerungstuerme",           fr = "Tours de siège" },
        { ParameterType.Number,         en = "Rams",            de = "Rammen",                      fr = "Bélier" },
        { ParameterType.Number,         en = "Ammo carts",      de = "Munitionswagen",              fr = "Chariot à munitions" },
        { ParameterType.Custom,         en = "Soldier type",    de = "Soldatentyp",                 fr = "Type de soldat" },
        { ParameterType.Custom,         en = "Reuse troops",    de = "Verwende bestehende Truppen", fr = "Utiliser les troupes existantes" },
    },
}

function B_Reward_AI_SpawnAndAttackTerritory:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_SpawnAndAttackTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    elseif (_Index == 3) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 4) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 5) then
        self.NumCatapults = _Parameter * 1
    elseif (_Index == 6) then
        self.NumSiegeTowers = _Parameter * 1
    elseif (_Index == 7) then
        self.NumRams = _Parameter * 1
    elseif (_Index == 8) then
        self.NumAmmoCarts = _Parameter * 1
    elseif (_Index == 9) then
        if _Parameter == "Normal" or _Parameter == false then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == true then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 10) then
        self.ReuseTroops = API.ToBoolean(_Parameter)
    end
end

function B_Reward_AI_SpawnAndAttackTerritory:GetCustomData( _Index )
    local Data = {}
    if _Index == 9 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo >= 1 then
            table.insert( Data, "Cultist" )
        end
    elseif _Index == 10 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_AI_SpawnAndAttackTerritory:CustomFunction(_Quest)
    local TargetID = Logic.GetTerritoryAcquiringBuildingID( self.TerritoryID )
    if TargetID ~= 0 then
        AIScript_SpawnAndAttackCity(
            self.AIPlayerID,
            TargetID,
            self.Spawnpoint,
            self.NumSword,
            self.NumBow,
            self.NumCatapults,
            self.NumSiegeTowers,
            self.NumRams,
            self.NumAmmoCarts,
            self.TroopType,
            self.ReuseTroops
        )
    end
end

function B_Reward_AI_SpawnAndAttackTerritory:Debug(_Quest)
    if self.AIPlayerID < 2 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif self.TerritoryID == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Territory unknown")
        return true
    elseif self.NumSword < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": No Soldiers?")
        return true
    elseif self.NumCatapults < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Catapults is negative")
        return true
    elseif self.NumSiegeTowers < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": SiegeTowers is negative")
        return true
    elseif self.NumRams < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Rams is negative")
        return true
    elseif self.NumAmmoCarts < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": AmmoCarts is negative")
        return true
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_AI_SpawnAndAttackTerritory);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt eine Armee, die sich zum Zielpunkt bewegt und das Gebiet angreift.
--
-- Dabei werden die Soldaten alle erreichbaren Gebäude in Brand stecken. Ist
-- Das Zielgebiet eingemauert, können die Soldaten nicht angreifen und werden
-- sich zurückziehen.
--
-- @param _PlayerID   PlayerID des Angreifers
-- @param _SpawnPoint Skriptname des Entstehungspunktes
-- @param _Target     Skriptname des Ziels
-- @param _Radius     Aktionsradius um das Ziel
-- @param _Sword      Anzahl Schwertkämpfer (Battalione)
-- @param _Bow        Anzahl Bogenschützen (Battalione)
-- @param _Soldier    Typ der Soldaten
-- @param _Reuse      Freie Truppen wiederverwenden
--
-- @within Reward
--
function Reward_AI_SpawnAndAttackArea(...)
    return B_Reward_AI_SpawnAndAttackArea:new(...);
end

B_Reward_AI_SpawnAndAttackArea = {
    Name = "Reward_AI_SpawnAndAttackArea",
    Description = {
        en = "Reward: Spawns AI troops and attacks everything within the specified area, except the players main buildings",
        de = "Lohn: Erstellt KI Truppen und greift ein angegebenes Gebiet an, aber nicht die Hauptgebauede eines Spielers",
        fr = "Récompense: Crée des troupes IA et attaque une zone spécifiée, mais pas les bâtiments principaux d'un joueur.",
    },
    Parameter = {
        { ParameterType.PlayerID,   en = "AI Player",       de = "KI Spieler",                  fr = "Joueur AI" },
        { ParameterType.ScriptName, en = "Spawn point",     de = "Erstellungsort",              fr = "Lieu de création" },
        { ParameterType.ScriptName, en = "Target",          de = "Ziel",                        fr = "Cible" },
        { ParameterType.Number,     en = "Radius",          de = "Radius",                      fr = "Rayon" },
        { ParameterType.Number,     en = "Sword",           de = "Schwert",                     fr = "Épéiste" },
        { ParameterType.Number,     en = "Bow",             de = "Bogen",                       fr = "Archer" },
        { ParameterType.Custom,     en = "Soldier type",    de = "Soldatentyp",                 fr = "Type de soldats" },
        { ParameterType.Custom,     en = "Reuse troops",    de = "Verwende bestehende Truppen", fr = "Utiliser des troupes existantes" },
    },
}

function B_Reward_AI_SpawnAndAttackArea:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_SpawnAndAttackArea:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TargetName = _Parameter
    elseif (_Index == 3) then
        self.Radius = _Parameter * 1
    elseif (_Index == 4) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 5) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 6) then
        if _Parameter == "Normal" or _Parameter == false then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == true then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 7) then
        self.ReuseTroops = API.ToBoolean(_Parameter)
    end
end

function B_Reward_AI_SpawnAndAttackArea:GetCustomData( _Index )
    local Data = {}
    if _Index == 6 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo >= 1 then
            table.insert( Data, "Cultist" )
        end
    elseif _Index == 7 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_AI_SpawnAndAttackArea:CustomFunction(_Quest)
    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then
        local TargetID = GetID( self.TargetName )
        AIScript_SpawnAndRaidSettlement(
            self.AIPlayerID,
            TargetID,
            self.Spawnpoint,
            self.Radius,
            self.NumSword,
            self.NumBow,
            self.TroopType,
            self.ReuseTroops
        )
    end
end

function B_Reward_AI_SpawnAndAttackArea:Debug(_Quest)
    if self.AIPlayerID < 2 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif Logic.IsEntityDestroyed(self.TargetName) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.TargetName .. " is missing")
        return true
    elseif self.Radius < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Radius is to small or negative")
        return true
    elseif self.NumSword < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": No Soldiers?")
        return true
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_AI_SpawnAndAttackArea);

-- -------------------------------------------------------------------------- --

---
-- Erstellt eine Armee, die das Zielgebiet verteidigt.
--
-- @param _PlayerID     PlayerID des Angreifers
-- @param _SpawnPoint   Skriptname des Entstehungspunktes
-- @param _Target       Skriptname des Ziels
-- @param _Radius       Bewachtes Gebiet
-- @param _Time         Dauer der Bewachung (-1 für unendlich)
-- @param _Sword        Anzahl Schwertkämpfer (Battalione)
-- @param _Bow          Anzahl Bogenschützen (Battalione)
-- @param _CaptureCarts Soldaten greifen Karren an
-- @param _Type         Typ der Soldaten
-- @param _Reuse        Freie Truppen wiederverwenden
--
-- @within Reward
--
function Reward_AI_SpawnAndProtectArea(...)
    return B_Reward_AI_SpawnAndProtectArea:new(...);
end

B_Reward_AI_SpawnAndProtectArea = {
    Name = "Reward_AI_SpawnAndProtectArea",
    Description = {
        en = "Reward: Spawns AI troops and defends a specified area",
        de = "Lohn: Erstellt KI Truppen und verteidigt ein angegebenes Gebiet",
        fr = "Récompense: Crée des troupes d'IA et défend un territoire donné",
    },
    Parameter = {
        { ParameterType.PlayerID,   en = "AI Player",               de = "KI Spieler",                  fr = "Joueur AI" },
        { ParameterType.ScriptName, en = "Spawn point",             de = "Erstellungsort",              fr = "Lieu de création" },
        { ParameterType.ScriptName, en = "Target",                  de = "Ziel",                        fr = "Cible" },
        { ParameterType.Number,     en = "Radius",                  de = "Radius",                      fr = "Rayon" },
        { ParameterType.Number,     en = "Time (-1 for infinite)",  de = "Zeit (-1 fuer unendlich)",    fr = "Temps (-1 pour infini)" },
        { ParameterType.Number,     en = "Sword",                   de = "Schwert",                     fr = "Épéiste" },
        { ParameterType.Number,     en = "Bow",                     de = "Bogen",                       fr = "Archer" },
        { ParameterType.Custom,     en = "Capture tradecarts",      de = "Handelskarren angreifen",     fr = "Attaquer les chariots de commerce" },
        { ParameterType.Custom,     en = "Soldier type",            de = "Soldatentyp",                 fr = "Type de soldat" },
        { ParameterType.Custom,     en = "Reuse troops",            de = "Verwende bestehende Truppen", fr = "Utiliser les troupes existantes" },
    },
}

function B_Reward_AI_SpawnAndProtectArea:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_SpawnAndProtectArea:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TargetName = _Parameter
    elseif (_Index == 3) then
        self.Radius = _Parameter * 1
    elseif (_Index == 4) then
        self.Time = _Parameter * 1
    elseif (_Index == 5) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 6) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 7) then
        self.CaptureTradeCarts = API.ToBoolean(_Parameter)
    elseif (_Index == 8) then
        if _Parameter == "Normal" or _Parameter == true then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == false then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 9) then
        self.ReuseTroops = API.ToBoolean(_Parameter)
    end

end

function B_Reward_AI_SpawnAndProtectArea:GetCustomData( _Index )

    local Data = {}
    if _Index == 7 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    elseif _Index == 8 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo >= 1 then
            table.insert( Data, "Cultist" )
        end

    elseif _Index == 9 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )

    else
        assert( false )
    end

    return Data

end

function B_Reward_AI_SpawnAndProtectArea:CustomFunction(_Quest)
    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then
        local TargetID = GetID( self.TargetName )
        AIScript_SpawnAndProtectArea(
            self.AIPlayerID,
            TargetID,
            self.Spawnpoint,
            self.Radius,
            self.NumSword,
            self.NumBow,
            self.Time,
            self.TroopType,
            self.ReuseTroops,
            self.CaptureTradeCarts
        )
    end
end

function B_Reward_AI_SpawnAndProtectArea:Debug(_Quest)
    if self.AIPlayerID < 2 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif Logic.IsEntityDestroyed(self.TargetName) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.TargetName .. " is missing")
        return true
    elseif self.Radius < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Radius is to small or negative")
        return true
    elseif self.Time < -1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Time is smaller than -1")
        return true
    elseif self.NumSword < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": No Soldiers?")
        return true
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_AI_SpawnAndProtectArea);

-- -------------------------------------------------------------------------- --

---
-- Ändert die Konfiguration eines KI-Spielers.
--
-- Optionen:
-- <ul>
-- <li>Courage/FEAR: Angstfaktor (0 bis ?)</li>
-- <li>Reconstruction/BARB: Wiederaufbau von Gebäuden (0 oder 1)</li>
-- <li>Build Order/BPMX: Buildorder ausführen (Nummer der Build Order)</li>
-- <li>Conquer Outposts/FCOP: Außenposten einnehmen (0 oder 1)</li>
-- <li>Mount Outposts/FMOP: Eigene Außenposten bemannen (0 oder 1)</li>
-- <li>max. Bowmen/FMBM: Maximale Anzahl an Bogenschützen (min. 1)</li>
-- <li>max. Swordmen/FMSM: Maximale Anzahl an Schwerkkämpfer (min. 1) </li>
-- <li>max. Rams/FMRA: Maximale Anzahl an Rammen (min. 1)</li>
-- <li>max. Catapults/FMCA: Maximale Anzahl an Katapulten (min. 1)</li>
-- <li>max. Ammunition Carts/FMAC: Maximale Anzahl an Minitionswagen (min. 1)</li>
-- <li>max. Siege Towers/FMST: Maximale Anzahl an Belagerungstürmen (min. 1)</li>
-- <li>max. Wall Catapults/FMBA: Maximale Anzahl an Mauerkatapulten (min. 1)</li>
-- </ul>
--
-- @param _PlayerID PlayerID des KI
-- @param _Fact     Konfigurationseintrag
-- @param _Value    Neuer Wert
--
-- @within Reward
--
function Reward_AI_SetNumericalFact(...)
    return B_Reward_AI_SetNumericalFact:new(...);
end

B_Reward_AI_SetNumericalFact = {
    Name = "Reward_AI_SetNumericalFact",
    Description = {
        en = "Reward: Sets a numerical fact for the AI player",
        de = "Lohn: Setzt eine Verhaltensregel fuer den KI-Spieler. ",
        fr = "Récompense: Définit une règle de comportement pour le joueur IA.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "AI Player",      de = "KI Spieler",         fr = "Joueur AI" },
        { ParameterType.Custom,   en = "Numerical Fact", de = "Verhaltensregel",    fr = "Règle de conduite" },
        { ParameterType.Number,   en = "Value",          de = "Wert",               fr = "Valeur" },
    },
}

function B_Reward_AI_SetNumericalFact:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_SetNumericalFact:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        -- mapping of numerical facts
        local fact = {
            ["Courage"]               = "FEAR",
            ["Reconstruction"]        = "BARB",
            ["Build Order"]           = "BPMX",
            ["Conquer Outposts"]      = "FCOP",
            ["Mount Outposts"]        = "FMOP",
            ["max. Bowmen"]           = "FMBM",
            ["max. Swordmen"]         = "FMSM",
            ["max. Rams"]             = "FMRA",
            ["max. Catapults"]        = "FMCA",
            ["max. Ammunition Carts"] = "FMAC",
            ["max. Siege Towers"]     = "FMST",
            ["max. Wall Catapults"]   = "FMBA",
            ["FEAR"]                  = "FEAR", -- > 0
            ["BARB"]                  = "BARB", -- 1 or 0
            ["BPMX"]                  = "BPMX", -- >= 0
            ["FCOP"]                  = "FCOP", -- 1 or 0
            ["FMOP"]                  = "FMOP", -- 1 or 0
            ["FMBM"]                  = "FMBM", -- >= 0
            ["FMSM"]                  = "FMSM", -- >= 0
            ["FMRA"]                  = "FMRA", -- >= 0
            ["FMCA"]                  = "FMCA", -- >= 0
            ["FMAC"]                  = "FMAC", -- >= 0
            ["FMST"]                  = "FMST", -- >= 0
            ["FMBA"]                  = "FMBA", -- >= 0
        }
        self.NumericalFact = fact[_Parameter]
    elseif (_Index == 2) then
        self.Value = _Parameter * 1
    end
end

function B_Reward_AI_SetNumericalFact:CustomFunction(_Quest)
    AICore.SetNumericalFact(self.AIPlayerID, self.NumericalFact, self.Value)
end

function B_Reward_AI_SetNumericalFact:GetCustomData(_Index)
    if (_Index == 1) then
        return {
            "Courage",
            "Reconstruction",
            "Build Order",
            "Conquer Outposts",
            "Mount Outposts",
            "max. Bowmen",
            "max. Swordmen",
            "max. Rams",
            "max. Catapults",
            "max. Ammunition Carts",
            "max. Siege Towers",
            "max. Wall Catapults",
        };
    end
end

function B_Reward_AI_SetNumericalFact:Debug(_Quest)
    if Logic.GetStoreHouse(self.AIPlayerID) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong or dead!");
        return true;
    elseif not self.NumericalFact then
        error(_Quest.Identifier.. ": " ..self.Name .. ": invalid numerical fact choosen!");
        return true;
    else
        if self.NumericalFact == "BARB" or self.NumericalFact == "FCOP" or self.NumericalFact == "FMOP" then
            if self.Value ~= 0 and self.Value ~= 1 then
                error(_Quest.Identifier.. ": " ..self.Name .. ": BARB, FCOP, FMOP: value must be 1 or 0!");
                return true;
            end
        elseif self.NumericalFact == "FEAR" then
            if self.Value <= 0 then
                error(_Quest.Identifier.. ": " ..self.Name .. ": FEAR: value must greater than 0!");
                return true;
            end
        else
            if self.Value < 0 then
                error(_Quest.Identifier.. ": " ..self.Name .. ": value must always greater than or equal 0!");
                return true;
            end
        end
    end
    return false
end

Swift:RegisterBehavior(B_Reward_AI_SetNumericalFact);

-- -------------------------------------------------------------------------- --

---
-- Stellt den Aggressivitätswert des KI-Spielers nachträglich ein.
--
-- @param _PlayerID         PlayerID des KI-Spielers
-- @param _Aggressiveness   Aggressivitätswert (1 bis 3)
--
-- @within Reward
--
function Reward_AI_Aggressiveness(...)
    return B_Reward_AI_Aggressiveness:new(...);
end

B_Reward_AI_Aggressiveness = {
    Name = "Reward_AI_Aggressiveness",
    Description = {
        en = "Reward: Sets the AI player's aggressiveness.",
        de = "Lohn: Setzt die Aggressivität des KI-Spielers fest.",
        fr = "Récompense: Définit l'agressivité du joueur IA.",
    },
    Parameter =
    {
        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler", fr = "Joueur AI" },
        { ParameterType.Custom, en = "Aggressiveness (1-3)", de = "Aggressivität (1-3)", fr = "Agressivité (1-3)" }
    }
};

function B_Reward_AI_Aggressiveness:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction} };
end

function B_Reward_AI_Aggressiveness:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.AIPlayer = _Parameter * 1;
    elseif _Index == 1 then
        self.Aggressiveness = tonumber(_Parameter);
    end
end

function B_Reward_AI_Aggressiveness:CustomFunction()
    local player = (PlayerAIs[self.AIPlayer]
        or AIPlayerTable[self.AIPlayer]
        or AIPlayer:new(self.AIPlayer, AIPlayerProfile_City));
    PlayerAIs[self.AIPlayer] = player;
    if self.Aggressiveness >= 2 then
        player.ProfileLoop = AIProfile_Skirmish;
        player.Skirmish = player.Skirmish or {};
        player.Skirmish.Claim_MinTime = SkirmishDefault.Claim_MinTime + (self.Aggressiveness - 2) * 390;
        player.Skirmish.Claim_MaxTime = player.Skirmish.Claim_MinTime * 2;
    else
        player.ProfileLoop = AIPlayerProfile_City;
    end
end

function B_Reward_AI_Aggressiveness:Debug(_Quest)
    if self.AIPlayer < 1 or Logic.GetStoreHouse(self.AIPlayer) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayer .. " is wrong");
        return true;
    end
end

function B_Reward_AI_Aggressiveness:GetCustomData(_Index)
    return { "1", "2", "3" };
end

Swift:RegisterBehavior(B_Reward_AI_Aggressiveness)

-- -------------------------------------------------------------------------- --

---
-- Stellt den Feind des Skirmish-KI ein.
--
-- Der Skirmish-KI (maximale Aggressivität) kann nur einen Spieler als Feind
-- behandeln. Für gewöhnlich ist dies der menschliche Spieler.
--
-- @param _PlayerID      PlayerID des KI
-- @param _EnemyPlayerID PlayerID des Feindes
--
-- @within Reward
--
function Reward_AI_SetEnemy(...)
    return B_Reward_AI_SetEnemy:new(...);
end

B_Reward_AI_SetEnemy = {
    Name = "Reward_AI_SetEnemy",
    Description = {
        en = "Reward:Sets the enemy of an AI player (the AI only handles one enemy properly).",
        de = "Lohn: Legt den Feind eines KI-Spielers fest (die KI behandelt nur einen Feind korrekt).",
        fr = "Récompense: Définit l'ennemi d'un joueur IA (l'IA ne traite correctement qu'un seul ennemi).",
    },
    Parameter =
    {
        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler", fr = "Joueur AI" },
        { ParameterType.PlayerID, en = "Enemy", de = "Feind", fr = "Ennemi" }
    }
};

function B_Reward_AI_SetEnemy:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction} };
end

function B_Reward_AI_SetEnemy:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.AIPlayer = _Parameter * 1;
    elseif _Index == 1 then
        self.Enemy = _Parameter * 1;
    end
end

function B_Reward_AI_SetEnemy:CustomFunction()
    local player = PlayerAIs[self.AIPlayer];
    if player and player.Skirmish then
        player.Skirmish.Enemy = self.Enemy;
    end
end

function B_Reward_AI_SetEnemy:Debug(_Quest)
    if self.AIPlayer < 1 or self.AIPlayer > 8 or Logic.PlayerGetIsHumanFlag(self.AIPlayer) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayer .. " is wrong");
        return true;
    end
    return false;
end
Swift:RegisterBehavior(B_Reward_AI_SetEnemy)

-- -------------------------------------------------------------------------- --

---
-- Ein Entity wird durch ein neues anderen Typs ersetzt.
--
-- Das neue Entity übernimmt Skriptname, Besitzer und Ausrichtung des
-- alten Entity.
--
-- @param _Entity Skriptname oder ID des Entity
-- @param _Type   Neuer Typ des Entity
-- @param _Owner  Besitzer des Entity
--
-- @within Reward
--
function Reward_ReplaceEntity(...)
    return B_Reward_ReplaceEntity:new(...);
end

B_Reward_ReplaceEntity = Swift.LuaBase:CopyTable(B_Reprisal_ReplaceEntity);
B_Reward_ReplaceEntity.Name = "Reward_ReplaceEntity";
B_Reward_ReplaceEntity.Description.en = "Reward: Replaces an entity with a new one of a different type. The playerID can be changed too.";
B_Reward_ReplaceEntity.Description.de = "Lohn: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.";
B_Reward_ReplaceEntity.Description.fr = "Récompense: Remplace une entité par une nouvelle entité d'un autre type. Il est également possible de changer l'appartenance d'un joueur.";
B_Reward_ReplaceEntity.GetReprisalTable = nil;

B_Reward_ReplaceEntity.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_ReplaceEntity);

-- -------------------------------------------------------------------------- --

---
-- Setzt die Menge von Rohstoffen in einer Mine.
--
-- <b>Achtung:</b> Im Reich des Ostens darf die Mine nicht eingestürzt sein!
-- Außerdem bringt dieses Behavior die Nachfüllmechanik durcheinander.
--
-- @param _ScriptName Skriptname der Mine
-- @param _Amount     Menge an Rohstoffen
--
-- @within Reward
--
function Reward_SetResourceAmount(...)
    return B_Reward_SetResourceAmount:new(...);
end

B_Reward_SetResourceAmount = {
    Name = "Reward_SetResourceAmount",
    Description = {
        en = "Reward: Set the current and maximum amount of a resource doodad (the amount can also set to 0)",
        de = "Lohn: Setzt die aktuellen sowie maximalen Resourcen in einem Doodad (auch 0 ist möglich)",
        fr = "Récompense: Définit les ressources actuelles ainsi que les ressources maximales dans un Doodad (0 est également possible)",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Ressource", de = "Resource", fr = "Ressources" },
        { ParameterType.Number, en = "Amount", de = "Menge", fr = "Quantité" },
    },
}

function B_Reward_SetResourceAmount:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_SetResourceAmount:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    end

end

function B_Reward_SetResourceAmount:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.ScriptName ) then
        return false
    end
    local EntityID = GetID( self.ScriptName )
    if Logic.GetResourceDoodadGoodType( EntityID ) == 0 then
        return false
    end
    Logic.SetResourceDoodadGoodAmount( EntityID, self.Amount )
end

function B_Reward_SetResourceAmount:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": resource entity does not exist!")
        return true
    elseif not type(self.Amount) == "number" or self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": resource amount can not be negative!")
        return true
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_SetResourceAmount);

-- -------------------------------------------------------------------------- --

---
-- Fügt dem Lagerhaus des Auftragnehmers eine Menge an Rohstoffen hinzu. Die
-- Rohstoffe werden direkt ins Lagerhaus bzw. die Schatzkammer gelegt.
--
-- @param _Type   Rohstofftyp
-- @param _Amount Menge an Rohstoffen
--
-- @within Reward
--
function Reward_Resources(...)
    return B_Reward_Resources:new(...);
end

B_Reward_Resources = {
    Name = "Reward_Resources",
    Description = {
        en = "Reward: The player receives a given amount of Goods in his store.",
        de = "Lohn: Legt der Partei die angegebenen Rohstoffe ins Lagerhaus.",
        fr = "Récompense: Placez les matières premières indiquées dans l'entrepôt de la faction.",
    },
    Parameter = {
        { ParameterType.RawGoods,   en = "Type of good",    de = "Resourcentyp",        fr = "Type de ressources" },
        { ParameterType.Number,     en = "Amount of good",  de = "Anzahl der Resource", fr = "Nombre de ressources" },
    },
}

function B_Reward_Resources:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    end
end

function B_Reward_Resources:GetRewardTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Reward.Resources, GoodType, self.GoodAmount }
end

Swift:RegisterBehavior(B_Reward_Resources);

-- -------------------------------------------------------------------------- --

---
-- Entsendet einen Karren zum angegebenen Spieler.
--
-- Wenn der Spawnpoint ein Gebäude ist, wird der Wagen am Eingang erstellt.
-- Andernfalls kann der Spawnpoint gelöscht werden und der Wagen übernimmt
-- dann den Skriptnamen.
--
-- @param _ScriptName    Skriptname des Spawnpoint
-- @param _Owner         Empfänger der Lieferung
-- @param _Type          Typ des Wagens
-- @param _Good          Typ der Ware
-- @param _Amount        Menge an Waren
-- @param _OtherPlayer   Anderer Empfänger als Auftraggeber
-- @param _NoReservation Platzreservation auf dem Markt ignorieren (Sinnvoll?)
-- @param _Replace       Spawnpoint ersetzen
--
-- @within Reward
--
function Reward_SendCart(...)
    return B_Reward_SendCart:new(...);
end

B_Reward_SendCart = {
    Name = "Reward_SendCart",
    Description = {
        en = "Reward: Sends a cart to a player. It spawns at a building or by replacing an entity. The cart can replace the entity if it's not a building.",
        de = "Lohn: Sendet einen Karren zu einem Spieler. Der Karren wird an einem Gebäude oder einer Entity erstellt. Er ersetzt die Entity, wenn diese kein Gebäude ist.",
        fr = "Récompense: Envoie un chariot à un joueur. Le chariot est créé sur un bâtiment ou une entité. Elle remplace l'entité si celle-ci n'est pas un bâtiment.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity",           de = "Script Entity",               fr = "Entité de Script" },
        { ParameterType.PlayerID,   en = "Owning player",           de = "Besitzer",                    fr = "Propriétaire" },
        { ParameterType.Custom,     en = "Type name",               de = "Typbezeichnung",              fr = "Désignation du type" },
        { ParameterType.Custom,     en = "Good type",               de = "Warentyp",                    fr = "Type de marchandise" },
        { ParameterType.Number,     en = "Amount",                  de = "Anzahl",                      fr = "Quantité" },
        { ParameterType.Custom,     en = "Override target player",  de = "Anderer Zielspieler",         fr = "Autre joueur destinataire" },
        { ParameterType.Custom,     en = "Ignore reservations",     de = "Ignoriere Reservierungen",    fr = "Ignorer les réservations" },
        { ParameterType.Custom,     en = "Replace entity",          de = "Entity ersetzen",             fr = "Remplacer une entité" },
    },
}

function B_Reward_SendCart:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_SendCart:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.GoodType = _Parameter
    elseif (_Index == 4) then
        self.GoodAmount = _Parameter * 1
    elseif (_Index == 5) then
        self.OverrideTargetPlayer = tonumber(_Parameter)
    elseif (_Index == 6) then
        self.IgnoreReservation = API.ToBoolean(_Parameter)
    elseif (_Index == 7) then
        self.ReplaceEntity = API.ToBoolean(_Parameter)
    end
end

function B_Reward_SendCart:CustomFunction(_Quest)

    if not IsExisting( self.ScriptNameEntity ) then
        return false;
    end

    local ID = API.SendCart(self.ScriptNameEntity, self.PlayerID, Goods[self.GoodType], self.GoodAmount, Entities[self.UnitKey], self.IgnoreReservation);

    if self.ReplaceEntity and Logic.IsBuilding(GetID(self.ScriptNameEntity)) == 0 then
        DestroyEntity(self.ScriptNameEntity);
        Logic.SetEntityName(ID, self.ScriptNameEntity);
    end
    if self.OverrideTargetPlayer then
        Logic.ResourceMerchant_OverrideTargetPlayerID(ID,self.OverrideTargetPlayer);
    end
end

function B_Reward_SendCart:GetCustomData( _Index )
    local Data = {};
    if _Index == 2 then
        Data = { "U_ResourceMerchant", "U_Medicus", "U_Marketer", "U_ThiefCart", "U_GoldCart", "U_Noblemen_Cart", "U_RegaliaCart" };
    elseif _Index == 3 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k );
            end
        end
        table.sort( Data );
    elseif _Index == 5 then
        table.insert( Data, "-" );
        for i = 1, 8 do
            table.insert( Data, i );
        end
    elseif _Index == 6 then
        table.insert( Data, "false" );
        table.insert( Data, "true" );
    elseif _Index == 7 then
        table.insert( Data, "false" );
        table.insert( Data, "true" );
    end
    return Data;
end

function B_Reward_SendCart:Debug(_Quest)
    if not IsExisting(self.ScriptNameEntity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": got a invalid playerID!");
        return true;
    elseif not Entities[self.UnitKey] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity type '"..self.UnitKey.."' is invalid!");
        return true;
    elseif not Goods[self.GoodType] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": good type '"..self.GoodType.."' is invalid!");
        return true;
    elseif not tonumber(self.GoodAmount) or self.GoodAmount < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": good amount can not be below 1!");
        return true;
    elseif tonumber(self.OverrideTargetPlayer) and (self.OverrideTargetPlayer < 1 or self.OverrideTargetPlayer > 8) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": overwrite target player with invalid playerID!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_SendCart);

-- -------------------------------------------------------------------------- --

---
-- Gibt dem Auftragnehmer eine Menge an Einheiten.
--
-- Die Einheiten erscheinen an der Burg. Hat der Spieler keine Burg, dann
-- erscheinen sie vorm Lagerhaus.
--
-- @param _Type   Typ der Einheit
-- @param _Amount Menge an Einheiten
--
-- @within Reward
--
function Reward_Units(...)
    return B_Reward_Units:new(...)
end

B_Reward_Units = {
    Name = "Reward_Units",
    Description = {
        en = "Reward: Units",
        de = "Lohn: Einheiten",
        fr = "Récompense: Unités",
    },
    Parameter = {
        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung", fr ="Désignation de type" },
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr ="Quantité" },
    },
}

function B_Reward_Units:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    end
end

function B_Reward_Units:GetRewardTable()
    return { Reward.Units, assert( Entities[self.EntityName] ), self.Amount }
end

Swift:RegisterBehavior(B_Reward_Units);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest neu.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestRestart(...)
    return B_Reward_QuestRestart:new(...)
end

B_Reward_QuestRestart = Swift.LuaBase:CopyTable(B_Reprisal_QuestRestart);
B_Reward_QuestRestart.Name = "Reward_QuestRestart";
B_Reward_QuestRestart.Description.en = "Reward: Restarts a (completed) quest so it can be triggered and completed again.";
B_Reward_QuestRestart.Description.de = "Lohn: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann.";
B_Reward_QuestRestart.Description.fr = "Récompense: Redémarre une quête (terminée) pour qu'elle puisse être redéclenchée et terminée.";
B_Reward_QuestRestart.GetReprisalTable = nil;

B_Reward_QuestRestart.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_QuestRestart);

-- -------------------------------------------------------------------------- --

---
-- Lässt einen Quest fehlschlagen.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestFailure(...)
    return B_Reward_QuestFailure:new(...)
end

B_Reward_QuestFailure = Swift.LuaBase:CopyTable(B_Reprisal_QuestFailure);
B_Reward_QuestFailure.Name = "Reward_QuestFailure";
B_Reward_QuestFailure.Description.en = "Reward: Lets another active quest fail.";
B_Reward_QuestFailure.Description.de = "Lohn: Lässt eine andere aktive Quest fehlschlagen.";
B_Reward_QuestFailure.Description.fr = "Récompense: Fait échouer une autre quête active.";
B_Reward_QuestFailure.GetReprisalTable = nil;

B_Reward_QuestFailure.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_QuestFailure);

-- -------------------------------------------------------------------------- --

---
-- Wertet einen Quest als erfolgreich.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestSuccess(...)
    return B_Reward_QuestSuccess:new(...)
end

B_Reward_QuestSuccess = Swift.LuaBase:CopyTable(B_Reprisal_QuestSuccess);
B_Reward_QuestSuccess.Name = "Reward_QuestSuccess";
B_Reward_QuestSuccess.Description.en = "Reward: Completes another active quest successfully.";
B_Reward_QuestSuccess.Description.de = "Lohn: Beendet eine andere aktive Quest erfolgreich.";
B_Reward_QuestSuccess.Description.fr = "Récompense: Termine avec succès une autre quête active.";
B_Reward_QuestSuccess.GetReprisalTable = nil;

B_Reward_QuestSuccess.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_QuestSuccess);

-- -------------------------------------------------------------------------- --

---
-- Triggert einen Quest.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestActivate(...)
    return B_Reward_QuestActivate:new(...)
end

B_Reward_QuestActivate = Swift.LuaBase:CopyTable(B_Reprisal_QuestActivate);
B_Reward_QuestActivate.Name = "Reward_QuestActivate";
B_Reward_QuestActivate.Description.en = "Reward: Activates another quest that is not triggered yet.";
B_Reward_QuestActivate.Description.de = "Lohn: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.";
B_Reward_QuestActivate.Description.fr = "Récompense: Active une autre quête qui n'a pas encore été déclenchée.";
B_Reward_QuestActivate.GetReprisalTable = nil;

B_Reward_QuestActivate.GetRewardTable = function(self, _Quest)
    return {Reward.Custom, {self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_QuestActivate)

-- -------------------------------------------------------------------------- --

---
-- Unterbricht einen Quest.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestInterrupt(...)
    return B_Reward_QuestInterrupt:new(...)
end

B_Reward_QuestInterrupt = Swift.LuaBase:CopyTable(B_Reprisal_QuestInterrupt);
B_Reward_QuestInterrupt.Name = "Reward_QuestInterrupt";
B_Reward_QuestInterrupt.Description.en = "Reward: Interrupts another active quest without success or failure.";
B_Reward_QuestInterrupt.Description.de = "Lohn: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg.";
B_Reward_QuestInterrupt.Description.fr = "Récompense: Termine une autre quête active sans succès ni échec.";
B_Reward_QuestInterrupt.GetReprisalTable = nil;

B_Reward_QuestInterrupt.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_QuestInterrupt);

-- -------------------------------------------------------------------------- --

---
-- Unterbricht einen Quest, selbst wenn dieser noch nicht ausgelöst wurde.
--
-- @param _QuestName   Name des Quest
-- @param _EndetQuests Bereits beendete unterbrechen
--
-- @within Reward
--
function Reward_QuestForceInterrupt(...)
    return B_Reward_QuestForceInterrupt:new(...)
end

B_Reward_QuestForceInterrupt = Swift.LuaBase:CopyTable(B_Reprisal_QuestForceInterrupt);
B_Reward_QuestForceInterrupt.Name = "Reward_QuestForceInterrupt";
B_Reward_QuestForceInterrupt.Description.en = "Reward: Interrupts another quest (even when it isn't active yet) without success or failure.";
B_Reward_QuestForceInterrupt.Description.de = "Lohn: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg.";
B_Reward_QuestForceInterrupt.Description.fr = "Récompense: Termine une autre quête, même si elle n'est pas encore active, sans succès ni échec.";
B_Reward_QuestForceInterrupt.GetReprisalTable = nil;

B_Reward_QuestForceInterrupt.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_QuestForceInterrupt);

-- -------------------------------------------------------------------------- --

---
-- Ändert den Wert einer benutzerdefinierten Variable.
--
-- Benutzerdefinierte Variablen können ausschließlich Zahlen sein. Nutze
-- dieses Behavior bevor die Variable in einem Goal oder Trigger abgefragt
-- wird, um sie zu initialisieren!
--
-- <p>Operatoren</p>
-- <ul>
-- <li>= - Variablenwert wird auf den Wert gesetzt</li>
-- <li>- - Variablenwert mit Wert Subtrahieren</li>
-- <li>+ - Variablenwert mit Wert addieren</li>
-- <li>* - Variablenwert mit Wert multiplizieren</li>
-- <li>/ - Variablenwert mit Wert dividieren</li>
-- <li>^ - Variablenwert mit Wert potenzieren</li>
-- </ul>
--
-- @param _Name     Name der Variable
-- @param _Operator Rechen- oder Zuweisungsoperator
-- @param _Value    Wert oder andere Custom Variable
--
-- @within Reward
--
function Reward_CustomVariables(...)
    return B_Reward_CustomVariables:new(...);
end

B_Reward_CustomVariables = Swift.LuaBase:CopyTable(B_Reprisal_CustomVariables);
B_Reward_CustomVariables.Name = "Reward_CustomVariables";
B_Reward_CustomVariables.Description.en = "Reward: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.";
B_Reward_CustomVariables.Description.de = "Lohn: Führt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.";
B_Reward_CustomVariables.Description.fr = "Récompense: Effectue une opération mathématique sur la variable. L'autre opérateur peut être un nombre ou une variable personnalisée.";
B_Reward_CustomVariables.GetReprisalTable = nil;

B_Reward_CustomVariables.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} };
end

Swift:RegisterBehavior(B_Reward_CustomVariables)

-- -------------------------------------------------------------------------- --

---
-- Führt eine Funktion im Skript als Reward aus.
--
-- Wird ein Funktionsname als String übergeben, wird die Funktion mit den
-- Daten des Behavors und des zugehörigen Quest aufgerufen (Standard).
--
-- Wird eine Funktionsreferenz angegeben, wird die Funktion zusammen mit allen
-- optionalen Parametern aufgerufen, als sei es ein gewöhnlicher Aufruf im
-- Skript.
-- <pre>Reward_MapScriptFunction(ReplaceEntity, "block", Entities.XD_ScriptEntity);
-- -- entspricht: ReplaceEntity("block", Entities.XD_ScriptEntity);</pre>
-- <b>Achtung:</b> Nicht über den Assistenten verfügbar!
--
-- @param _FunctionName Name der Funktion oder Funktionsreferenz
--
-- @within Reward
--
function Reward_MapScriptFunction(...)
    return B_Reward_MapScriptFunction:new(...);
end

B_Reward_MapScriptFunction = Swift.LuaBase:CopyTable(B_Reprisal_MapScriptFunction);
B_Reward_MapScriptFunction.Name = "Reward_MapScriptFunction";
B_Reward_MapScriptFunction.Description.en = "Reward: Calls a function within the global map script if the quest has failed.";
B_Reward_MapScriptFunction.Description.de = "Lohn: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.";
B_Reward_MapScriptFunction.Description.fr = "Récompense: Invoque une fonction dans le script global de la carte en cas d'échec de la quête.";
B_Reward_MapScriptFunction.GetReprisalTable = nil;

B_Reward_MapScriptFunction.GetRewardTable = function(self, _Quest)
    return {Reward.Custom, {self, self.CustomFunction}};
end

Swift:RegisterBehavior(B_Reward_MapScriptFunction);

-- -------------------------------------------------------------------------- --

---
-- Erlaubt oder verbietet einem Spieler ein Recht.
--
-- @param _PlayerID   ID des Spielers
-- @param _Lock       Sperren/Entsperren
-- @param _Technology Name des Rechts
--
-- @within Reward
--
function Reward_Technology(...)
    return B_Reward_Technology:new(...);
end

B_Reward_Technology = Swift.LuaBase:CopyTable(B_Reprisal_Technology);
B_Reward_Technology.Name = "Reward_Technology";
B_Reward_Technology.Description.en = "Reward: Locks or unlocks a technology for the given player.";
B_Reward_Technology.Description.de = "Lohn: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player.";
B_Reward_Technology.Description.fr = "Récompense: Bloque ou autorise une technologie pour le joueur spécifié.";
B_Reward_Technology.GetReprisalTable = nil;

B_Reward_Technology.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_Technology);

---
-- Gibt dem Auftragnehmer eine Anzahl an Prestigepunkten.
--
-- Prestige hat i.d.R. keine Funktion und wird nur als Zusatzpunkte in der
-- Statistik angezeigt.
--
-- @param _Amount Menge an Prestige
--
-- @within Reward
--
function Reward_PrestigePoints(...)
    return B_Reward_PrestigePoints:mew(...);
end

B_Reward_PrestigePoints  = {
    Name = "Reward_PrestigePoints",
    Description = {
        en = "Reward: Prestige",
        de = "Lohn: Prestige",
        fr = "Récompense: Prestige",
    },
    Parameter = {
        { ParameterType.Number, en = "Points", de = "Punkte", fr = "Points" },
    },
}

function B_Reward_PrestigePoints :AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Points = _Parameter
    end
end

function B_Reward_PrestigePoints :GetRewardTable()
    return { Reward.PrestigePoints, self.Points }
end

Swift:RegisterBehavior(B_Reward_PrestigePoints);

-- -------------------------------------------------------------------------- --

---
-- Besetzt einen Außenposten mit Soldaten.
--
-- @param _ScriptName Skriptname des Außenposten
-- @param _Type       Soldatentyp
--
-- @within Reward
--
function Reward_AI_MountOutpost(...)
    return B_Reward_AI_MountOutpost:new(...);
end

B_Reward_AI_MountOutpost = {
    Name = "Reward_AI_MountOutpost",
    Description = {
        en = "Reward: Places a troop of soldiers on a named outpost.",
        de = "Lohn: Platziert einen Trupp Soldaten auf einem Aussenposten der KI.",
        fr = "Récompense: Place un groupe de soldats sur un avant-poste de l'IA.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name",   de = "Skriptname",  fr = "Nom de l'entité" },
        { ParameterType.Custom,     en = "Soldiers type", de = "Soldatentyp", fr = "Type de soldat" },
    },
}

function B_Reward_AI_MountOutpost:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_MountOutpost:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.Scriptname = _Parameter
    else
        self.SoldiersType = _Parameter
    end
end

function B_Reward_AI_MountOutpost:CustomFunction(_Quest)
    local outpostID = assert(
        not Logic.IsEntityDestroyed(self.Scriptname) and GetID(self.Scriptname),
       _Quest.Identifier .. ": Error in " .. self.Name .. ": CustomFunction: Outpost is invalid"
    )
    local AIPlayerID = Logic.EntityGetPlayer(outpostID)
    local ax, ay = Logic.GetBuildingApproachPosition(outpostID)
    local TroopID = Logic.CreateBattalionOnUnblockedLand(Entities[self.SoldiersType], ax, ay, 0, AIPlayerID, 0)
    AICore.HideEntityFromAI(AIPlayerID, TroopID, true)
    Logic.CommandEntityToMountBuilding(TroopID, outpostID)
end

function B_Reward_AI_MountOutpost:GetCustomData(_Index)
    if _Index == 1 then
        local Data = {}
        for k,v in pairs(Entities) do
            if string.find(k, "U_MilitaryBandit") or string.find(k, "U_MilitarySword") or string.find(k, "U_MilitaryBow") then
                Data[#Data+1] = k
            end
        end
        return Data
    end
end

function B_Reward_AI_MountOutpost:Debug(_Quest)
    if Logic.IsEntityDestroyed(self.Scriptname) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Outpost " .. self.Scriptname .. " is missing")
        return true
    end
end

Swift:RegisterBehavior(B_Reward_AI_MountOutpost)

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest neu und lößt ihn sofort aus.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestRestartForceActive(...)
    return B_Reward_QuestRestartForceActive:new(...);
end

B_Reward_QuestRestartForceActive = {
    Name = "Reward_QuestRestartForceActive",
    Description = {
        en = "Reward: Restarts a (completed) quest and triggers it immediately.",
        de = "Lohn: Startet eine (beendete) Quest neu und triggert sie sofort.",
        fr = "Récompense: Redémarre une quête (terminée) et la déclenche immédiatement.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la quête" },
    },
}

function B_Reward_QuestRestartForceActive:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_QuestRestartForceActive:AddParameter(_Index, _Parameter)
    self.QuestName = _Parameter
end

function B_Reward_QuestRestartForceActive:CustomFunction(_Quest)
    local QuestID, Quest = self:ResetQuest(_Quest);
    if QuestID then
        Quest:SetMsgKeyOverride();
        Quest:SetIconOverride();
        Quest:Trigger();
    end
end

B_Reward_QuestRestartForceActive.ResetQuest = B_Reward_QuestRestart.CustomFunction;
function B_Reward_QuestRestartForceActive:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Quest: "..  self.QuestName .. " does not exist");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_QuestRestartForceActive)

-- -------------------------------------------------------------------------- --

---
-- Baut das angegebene Gabäude um eine Stufe aus. Das Gebäude wird durch einen
-- Arbeiter um eine Stufe erweitert. Der Arbeiter muss zuerst aus dem Lagerhaus
-- kommen und sich zum Gebäude bewegen.
--
-- <b>Achtung:</b> Ein Gebäude muss erst fertig ausgebaut sein, bevor ein
-- weiterer Ausbau begonnen werden kann!
--
-- @param _ScriptName Skriptname des Gebäudes
--
-- @within Reward
--
function Reward_UpgradeBuilding(...)
    return B_Reward_UpgradeBuilding:new(...);
end

B_Reward_UpgradeBuilding = {
    Name = "Reward_UpgradeBuilding",
    Description = {
        en = "Reward: Upgrades a building",
        de = "Lohn: Baut ein Gebäude aus",
        fr = "Récompense: Améliore un Bâtiment",
    },
    Parameter =    {
        { ParameterType.ScriptName, en = "Building", de = "Gebäude", fr = "Bâtiment" }
    }
};

function B_Reward_UpgradeBuilding:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction}};
end

function B_Reward_UpgradeBuilding:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.Building = _Parameter;
    end
end

function B_Reward_UpgradeBuilding:CustomFunction(_Quest)
    local building = GetID(self.Building);
    if building ~= 0
    and Logic.IsBuilding(building) == 1
    and Logic.IsBuildingUpgradable(building, true)
    and Logic.IsBuildingUpgradable(building, false)
    then
        Logic.UpgradeBuilding(building);
    end
end

function B_Reward_UpgradeBuilding:Debug(_Quest)
    local building = GetID(self.Building);
    if not (building ~= 0
            and Logic.IsBuilding(building) == 1
            and Logic.IsBuildingUpgradable(building, true)
            and Logic.IsBuildingUpgradable(building, false) )
    then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Building is wrong")
        return true
    end
end

Swift:RegisterBehavior(B_Reward_UpgradeBuilding)

---
-- Setzt das Upgrade Level des angegebenen Gebäudes.
--
-- Ein Geböude erhält sofort eine neue Stufe, ohne dass ein Arbeiter kommen
-- und es ausbauen muss. Für eine Werkstatt wird ein neuer Arbeiter gespawnt.
--
-- @param _ScriptName Skriptname des Gebäudes
-- @param _Level Upgrade Level
--
-- @within Reward
--
function Reward_SetBuildingUpgradeLevel(...)
    return B_Reward_SetBuildingUpgradeLevel:new(...);
end

B_Reward_SetBuildingUpgradeLevel = {
	Name = "Reward_SetBuildingUpgradeLevel",
	Description = {
		en = "Reward: Sets the upgrade level of the specified building.",
		de = "Lohn: Legt das Upgrade-Level eines Gebaeudes fest.",
        fr = "Récompense: Définit le niveau d'amélioration d'un bâtiment.",
	},
	Parameter = {
		{ ParameterType.ScriptName, en = "Building",        de = "Gebäude",         fr = "Bâtiment" },
		{ ParameterType.Custom,     en = "Upgrade level",   de = "Upgrade-Level",   fr = "Niveau d'amélioration" },
	}
};
 
function B_Reward_SetBuildingUpgradeLevel:GetRewardTable()
	return {Reward.Custom, self, self.CustomFunction};
end
 
function B_Reward_SetBuildingUpgradeLevel:AddParameter(_Index, _Parameter)
	if _Index == 0 then
		self.Building = _Parameter;
	elseif _Index == 1 then
		self.UpgradeLevel = tonumber(_Parameter);
	end
end
 
function B_Reward_SetBuildingUpgradeLevel:CustomFunction()
	local building = Logic.GetEntityIDByName(self.Building);
	local upgradeLevel = Logic.GetUpgradeLevel(building);
	local maxUpgradeLevel = Logic.GetMaxUpgradeLevel(building);
	if building ~= 0 
	and Logic.IsBuilding(building) == 1 
	and (Logic.IsBuildingUpgradable(building, true) 
	or (maxUpgradeLevel ~= 0 
	and maxUpgradeLevel == upgradeLevel)) 
	then
		Logic.SetUpgradableBuildingState(building, math.min(self.UpgradeLevel, maxUpgradeLevel), 0);
	end
end

function B_Reward_SetBuildingUpgradeLevel:Debug(_Quest)
	local building = Logic.GetEntityIDByName( self.Building )
	local maxUpgradeLevel = Logic.GetMaxUpgradeLevel(building);
	if not building or Logic.IsBuilding(building) == 0  then
		error(_Quest.Identifier.. ": " ..self.Name .. ": Building " .. self.Building .. " is missing or no building.")
		return true
	elseif not self.UpgradeLevel or self.UpgradeLevel < 0 then
		error(_Quest.Identifier.. ": " ..self.Name .. ": Upgrade level is wrong")
		return true
	end
end

function B_Reward_SetBuildingUpgradeLevel:GetCustomData(_Index)
    if _Index == 1 then
        return { "0", "1", "2", "3" };
    end
end

Swift:RegisterBehavior(B_Reward_SetBuildingUpgradeLevel);

-- -------------------------------------------------------------------------- --
-- TRIGGERS

---
-- Starte den Quest, wenn ein anderer Spieler entdeckt wurde.
--
-- Ein Spieler ist dann entdeckt, wenn sein Heimatterritorium aufgedeckt wird.
--
-- @param _PlayerID Zu entdeckender Spieler
--
-- @within Trigger
--
function Trigger_PlayerDiscovered(...)
    return B_Trigger_PlayerDiscovered:new(...);
end

B_Trigger_PlayerDiscovered = {
    Name = "Trigger_PlayerDiscovered",
    Description = {
        en = "Trigger: if a given player has been discovered",
        de = "Auslöser: wenn ein angegebener Spieler entdeckt wurde",
        fr = "Déclencheur: lorsqu'un joueur spécifié est découvert",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Trigger_PlayerDiscovered:GetTriggerTable()
    return {Triggers.PlayerDiscovered, self.PlayerID}
end

function B_Trigger_PlayerDiscovered:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1;
    end
end

Swift:RegisterBehavior(B_Trigger_PlayerDiscovered);

-- -------------------------------------------------------------------------- --

---
-- Starte den Quest, wenn zwischen dem Empfänger und der angegebenen Partei
-- der geforderte Diplomatiestatus herrscht.
--
-- @param _PlayerID ID der Partei
-- @param _State    Diplomatie-Status
--
-- @within Trigger
--
function Trigger_OnDiplomacy(...)
    return B_Trigger_OnDiplomacy:new(...);
end

B_Trigger_OnDiplomacy = {
    Name = "Trigger_OnDiplomacy",
    Description = {
        en = "Trigger: if diplomatic relations have been established with a player",
        de = "Auslöser: wenn ein angegebener Diplomatie-Status mit einem Spieler erreicht wurde.",
        fr = "Déclencheur: lorsqu'un statut diplomatique spécifié a été atteint avec un joueur.",
    },
    Parameter = {
        { ParameterType.PlayerID,       en = "Player",      de = "Spieler",     fr = "Joueur" },
        { ParameterType.DiplomacyState, en = "Relation",    de = "Beziehung",   fr = "Relation diplomatique" },
    },
}

function B_Trigger_OnDiplomacy:GetTriggerTable()
    return {Triggers.Diplomacy, self.PlayerID, assert( DiplomacyStates[self.DiplState] ) }
end

function B_Trigger_OnDiplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.DiplState = _Parameter
    end
end

Swift:RegisterBehavior(B_Trigger_OnDiplomacy);

-- -------------------------------------------------------------------------- --

---
-- Starte den Quest, sobald ein Bedürfnis nicht erfüllt wird.
--
-- @param _PlayerID ID des Spielers
-- @param _Need     Bedürfnis
-- @param _Amount   Menge an skreikenden Siedlern
--
-- @within Trigger
--
function Trigger_OnNeedUnsatisfied(...)
    return B_Trigger_OnNeedUnsatisfied:new(...);
end

B_Trigger_OnNeedUnsatisfied = {
    Name = "Trigger_OnNeedUnsatisfied",
    Description = {
        en = "Trigger: if a specified need is unsatisfied",
        de = "Auslöser: wenn ein bestimmtes Beduerfnis nicht befriedigt ist.",
        fr = "Déclencheur: lorsqu'un certain besoin n'est pas satisfait.",
    },
    Parameter = {
        { ParameterType.PlayerID,   en = "Player",              de = "Spieler",             fr = "Joueur" },
        { ParameterType.Need,       en = "Need",                de = "Beduerfnis",          fr = "Besoin" },
        { ParameterType.Number,     en = "Workers on strike",   de = "Streikende Arbeiter", fr = "Travailleurs en grève" },
    },
}

function B_Trigger_OnNeedUnsatisfied:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnNeedUnsatisfied:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Need = _Parameter
    elseif (_Index == 2) then
        self.WorkersOnStrike = _Parameter * 1
    end
end

function B_Trigger_OnNeedUnsatisfied:CustomFunction(_Quest)
    return Logic.GetNumberOfStrikingWorkersPerNeed( self.PlayerID, Needs[self.Need] ) >= self.WorkersOnStrike
end

function B_Trigger_OnNeedUnsatisfied:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": " .. self.PlayerID .. " does not exist.")
        return true
    elseif not Needs[self.Need] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": " .. self.Need .. " does not exist.")
        return true
    elseif self.WorkersOnStrike < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": WorkersOnStrike value negative")
        return true
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_OnNeedUnsatisfied);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, wenn die angegebene Mine erschöpft ist.
--
-- @param _ScriptName Skriptname der Mine
--
-- @within Trigger
--
function Trigger_OnResourceDepleted(...)
    return B_Trigger_OnResourceDepleted:new(...);
end

B_Trigger_OnResourceDepleted = {
    Name = "Trigger_OnResourceDepleted",
    Description = {
        en = "Trigger: if a resource is (temporarily) depleted",
        de = "Auslöser: wenn eine Ressource (zeitweilig) verbraucht ist",
        fr = "Déclencheur: lorsqu'une ressource est (temporairement) consommée",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de script" },
    },
}

function B_Trigger_OnResourceDepleted:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnResourceDepleted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Trigger_OnResourceDepleted:CustomFunction(_Quest)
    local ID = GetID(self.ScriptName)
    return not ID or ID == 0 or Logic.GetResourceDoodadGoodType(ID) == 0 or Logic.GetResourceDoodadGoodAmount(ID) == 0
end

Swift:RegisterBehavior(B_Trigger_OnResourceDepleted);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald der angegebene Spieler eine Menge an Rohstoffen
-- im Lagerhaus hat.
--
-- @param  _PlayerID ID des Spielers
-- @param  _Type     Typ des Rohstoffes
-- @param _Amount    Menge an Rohstoffen
--
-- @within Trigger
--
function Trigger_OnAmountOfGoods(...)
    return B_Trigger_OnAmountOfGoods:new(...);
end

B_Trigger_OnAmountOfGoods = {
    Name = "Trigger_OnAmountOfGoods",
    Description = {
        en = "Trigger: if the player has gathered a given amount of resources in his storehouse",
        de = "Auslöser: wenn der Spieler eine bestimmte Menge einer Ressource in seinem Lagerhaus hat",
        fr = "Déclencheur: lorsque le joueur a une certaine quantité d'une ressource dans son entrepôt",
    },
    Parameter = {
        { ParameterType.PlayerID,   en = "Player",          de = "Spieler",             fr = "Joueur" },
        { ParameterType.RawGoods,   en = "Type of good",    de = "Resourcentyp",        fr = "Type de ressources" },
        { ParameterType.Number,     en = "Amount of good",  de = "Anzahl der Resource", fr = "Quantité de ressources" },
    },
}

function B_Trigger_OnAmountOfGoods:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnAmountOfGoods:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 2) then
        self.GoodAmount = _Parameter * 1
    end
end

function B_Trigger_OnAmountOfGoods:CustomFunction(_Quest)
    local StoreHouseID = Logic.GetStoreHouse(self.PlayerID)
    if (StoreHouseID == 0) then
        return false
    end
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    local GoodAmount = Logic.GetAmountOnOutStockByGoodType(StoreHouseID, GoodType)
    if (GoodAmount >= self.GoodAmount)then
        return true
    end
    return false
end

function B_Trigger_OnAmountOfGoods:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": " .. self.PlayerID .. " does not exist.")
        return true
    elseif not Goods[self.GoodTypeName] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Good type is wrong.")
        return true
    elseif self.GoodAmount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Good amount is negative.")
        return true
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_OnAmountOfGoods);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein anderer aktiv ist.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestActive(...)
    return B_Trigger_OnQuestActiveWait:new(...);
end
Trigger_OnQuestActiveWait = Trigger_OnQuestActive;

B_Trigger_OnQuestActiveWait = {
    Name = "Trigger_OnQuestActiveWait",
    Description = {
        en = "Trigger: if a given quest has been activated. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest aktiviert wurde. Optional mit Wartezeit",
        fr = "Déclencheur: lorsqu'une quête indiquée a été activée. En option avec délai d'attente",
    },
    Parameter = {
        { ParameterType.QuestName,  en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente" },
    },
}

function B_Trigger_OnQuestActiveWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestActiveWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestActiveWait:CustomFunction(_Quest)
    local QuestID = GetQuestID(self.QuestName)
    if QuestID ~= nil then
        assert(type(QuestID) == "number");

        if (Quests[QuestID].State == QuestState.Active) then
            self.WasActivated = self.WasActivated or true;
        end
        if self.WasActivated then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestActiveWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        error(_Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestActiveWait:Interrupt(_Quest)
    -- does this realy matter after interrupt?
    -- self.WaitTimeTimer = nil;
    -- self.WasActivated = nil;
end

function B_Trigger_OnQuestActiveWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
    self.WasActivated = nil;
end

Swift:RegisterBehavior(B_Trigger_OnQuestActiveWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestActive = Swift.LuaBase:CopyTable(B_Trigger_OnQuestActiveWait);
B_Trigger_OnQuestActive.Name = "Trigger_OnQuestActive";
B_Trigger_OnQuestActive.Description.en = "Trigger: Starts the quest after another has been activated.";
B_Trigger_OnQuestActive.Description.de = "Auslöser: Startet den Quest, wenn ein anderer aktiviert wird.";
B_Trigger_OnQuestActive.Description.fr = "Déclencheur: Démarre la quête lorsqu'une autre est activée.";
B_Trigger_OnQuestActive.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestActive:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

Swift:RegisterBehavior(B_Trigger_OnQuestActive);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest, sobald ein anderer fehlschlägt.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestFailure(...)
    return B_Trigger_OnQuestFailureWait:new(...);
end
Trigger_OnQuestFailureWait = Trigger_OnQuestFailure;

B_Trigger_OnQuestFailureWait = {
    Name = "Trigger_OnQuestFailureWait",
    Description = {
        en = "Trigger: if a given quest has failed. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest fehlgeschlagen ist. Optional mit Wartezeit",
        fr = "Déclencheur: lorsqu'une quête indiquée a échoué. En option avec délai d'attente",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,    en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente" },
    },
}

function B_Trigger_OnQuestFailureWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestFailureWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestFailureWait:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].Result == QuestResult.Failure) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestFailureWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        error(_Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestFailureWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function B_Trigger_OnQuestFailureWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

Swift:RegisterBehavior(B_Trigger_OnQuestFailureWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestFailure = Swift.LuaBase:CopyTable(B_Trigger_OnQuestFailureWait);
B_Trigger_OnQuestFailure.Name = "Trigger_OnQuestFailure";
B_Trigger_OnQuestFailure.Description.en = "Trigger: Starts the quest after another has failed.";
B_Trigger_OnQuestFailure.Description.de = "Auslöser: Startet den Quest, wenn ein anderer fehlschlägt.";
B_Trigger_OnQuestFailure.Description.fr = "Déclencheur: Lance la quête lorsqu'une autre échoue.";
B_Trigger_OnQuestFailure.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestFailure:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

Swift:RegisterBehavior(B_Trigger_OnQuestFailure);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest, wenn ein anderer noch nicht ausgelöst wurde.
--
-- @param _QuestName Name des Quest
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestNotTriggered(...)
    return B_Trigger_OnQuestNotTriggered:new(...);
end

B_Trigger_OnQuestNotTriggered = {
    Name = "Trigger_OnQuestNotTriggered",
    Description = {
        en = "Trigger: if a given quest is not yet active. Should be used in combination with other triggers.",
        de = "Auslöser: wenn eine angegebene Quest noch inaktiv ist. Sollte mit weiteren Triggern kombiniert werden.",
        fr = "Déclencheur: lorsqu'une quête indiquée est encore inactive. Doit être combiné avec d'autres déclencheurs."
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
    },
}

function B_Trigger_OnQuestNotTriggered:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestNotTriggered:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Trigger_OnQuestNotTriggered:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.NotTriggered) then
            return true;
        end
    end
    return false;
end

function B_Trigger_OnQuestNotTriggered:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_OnQuestNotTriggered);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein anderer unterbrochen wurde.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestInterrupted(...)
    return B_Trigger_OnQuestInterruptedWait:new(...);
end
Trigger_OnQuestInterruptedWait = Trigger_OnQuestInterrupted;

B_Trigger_OnQuestInterruptedWait = {
    Name = "Trigger_OnQuestInterruptedWait",
    Description = {
        en = "Trigger: if a given quest has been interrupted. Should be used in combination with other triggers.",
        de = "Auslöser: wenn eine angegebene Quest abgebrochen wurde. Sollte mit weiteren Triggern kombiniert werden.",
        fr = "Déclencheur: lorsqu'une quête indiquée a été interrompue. Doit être combiné avec d'autres déclencheurs."
    },
    Parameter = {
        { ParameterType.QuestName,  en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente"},
    },
}

function B_Trigger_OnQuestInterruptedWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestInterruptedWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestInterruptedWait:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result == QuestResult.Interrupted) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestInterruptedWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        error(_Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestInterruptedWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function B_Trigger_OnQuestInterruptedWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

Swift:RegisterBehavior(B_Trigger_OnQuestInterruptedWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestInterrupted = Swift.LuaBase:CopyTable(B_Trigger_OnQuestInterruptedWait);
B_Trigger_OnQuestInterrupted.Name = "Trigger_OnQuestInterrupted";
B_Trigger_OnQuestInterrupted.Description.en = "Trigger: Starts the quest after another is interrupted.";
B_Trigger_OnQuestInterrupted.Description.de = "Auslöser: Startet den Quest, wenn ein anderer abgebrochen wurde.";
B_Trigger_OnQuestInterrupted.Description.fr = "Déclencheur: Démarre la quête lorsqu'une autre a été annulée.";
B_Trigger_OnQuestInterrupted.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestInterrupted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

Swift:RegisterBehavior(B_Trigger_OnQuestInterrupted);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein anderer bendet wurde.
--
-- Dabei ist das Resultat egal. Der Quest kann entweder erfolgreich beendet
-- wurden oder fehlgeschlagen sein.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestOver(...)
    return B_Trigger_OnQuestOverWait:new(...);
end
Trigger_OnQuestOverWait = Trigger_OnQuestOver;

B_Trigger_OnQuestOverWait = {
    Name = "Trigger_OnQuestOverWait",
    Description = {
        en = "Trigger: if a given quest has been finished, regardless of its result. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest beendet wurde, unabhängig von deren Ergebnis. Wartezeit optional",
        fr = "Déclencheur: lorsqu'une quête indiquée est terminée, indépendamment de son résultat. Délai d'attente optionnel"
    },
    Parameter = {
        { ParameterType.QuestName,  en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente"},
    },
}

function B_Trigger_OnQuestOverWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestOverWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestOverWait:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result ~= QuestResult.Interrupted) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestOverWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        error(_Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestOverWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function B_Trigger_OnQuestOverWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

Swift:RegisterBehavior(B_Trigger_OnQuestOverWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestOver = Swift.LuaBase:CopyTable(B_Trigger_OnQuestOverWait);
B_Trigger_OnQuestOver.Name = "Trigger_OnQuestOver";
B_Trigger_OnQuestOver.Description.en = "Trigger: Starts the quest after another finished.";
B_Trigger_OnQuestOver.Description.de = "Auslöser: Startet den Quest, wenn ein anderer abgeschlossen wurde.";
B_Trigger_OnQuestOver.Description.fr = "Déclencheur: Démarre la quête lorsqu'une autre est terminée.";
B_Trigger_OnQuestOver.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestOver:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

Swift:RegisterBehavior(B_Trigger_OnQuestOver);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein anderer Quest erfolgreich abgeschlossen wurde.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestSuccess(...)
    return B_Trigger_OnQuestSuccessWait:new(...);
end
Trigger_OnQuestSuccessWait = Trigger_OnQuestSuccess;

B_Trigger_OnQuestSuccessWait = {
    Name = "Trigger_OnQuestSuccessWait",
    Description = {
        en = "Trigger: if a given quest has been finished successfully. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest erfolgreich abgeschlossen wurde. Wartezeit optional",
        fr = "Déclencheur: lorsqu'une quête indiquée a été accomplie avec succès. Délai d'attente optionnel",
    },
    Parameter = {
        { ParameterType.QuestName,  en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente" },
    },
}

function B_Trigger_OnQuestSuccessWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestSuccessWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestSuccessWait:CustomFunction()
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].Result == QuestResult.Success) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestSuccessWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        error(_Quest.Identifier.. ": " ..self.Name..": waittime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestSuccessWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function B_Trigger_OnQuestSuccessWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

Swift:RegisterBehavior(B_Trigger_OnQuestSuccessWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestSuccess = Swift.LuaBase:CopyTable(B_Trigger_OnQuestSuccessWait);
B_Trigger_OnQuestSuccess.Name = "Trigger_OnQuestSuccess";
B_Trigger_OnQuestSuccess.Description.en = "Trigger: Starts the quest after another finished successfully.";
B_Trigger_OnQuestSuccess.Description.de = "Auslöser: Startet den Quest, wenn ein anderer erfolgreich abgeschlossen wurde.";
B_Trigger_OnQuestSuccess.Description.de = "Déclencheur: Démarre la quête lorsqu'une autre a été accomplie avec succès.";
B_Trigger_OnQuestSuccess.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

Swift:RegisterBehavior(B_Trigger_OnQuestSuccess);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, wenn eine benutzerdefinierte Variable einen bestimmten
-- Wert angenommen hat.
--
-- Benutzerdefinierte Variablen müssen Zahlen sein. Bevor eine
-- Variable in einem Goal abgefragt werden kann, muss sie zuvor mit
-- Reprisal_CustomVariables oder Reward_CutsomVariables initialisiert
-- worden sein.
--
-- @param _Name     Name der Variable
-- @param _Relation Vergleichsoperator
-- @param _Value    Wert oder Custom Variable
--
-- @within Trigger
--
function Trigger_CustomVariables(...)
    return B_Trigger_CustomVariables:new(...);
end

B_Trigger_CustomVariables = {
    Name = "Trigger_CustomVariables",
    Description = {
        en = "Trigger: if the variable has a certain value.",
        de = "Auslöser: wenn die Variable einen bestimmen Wert eingenommen hat.",
        fr = "Déclencheur: lorsque la variable a pris une valeur déterminée."
    },
    Parameter = {
        { ParameterType.Default, en = "Name of Variable",   de = "Variablennamen",  fr = "Noms de variables" },
        { ParameterType.Custom,  en = "Relation",           de = "Relation",        fr = "Relation" },
        { ParameterType.Default, en = "Value",              de = "Wert",            fr = "Valeur" }
    }
};

function B_Trigger_CustomVariables:GetTriggerTable()
    return { Triggers.Custom2, {self, self.CustomFunction} };
end

function B_Trigger_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Relation = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        value = (value ~= nil and value) or _Parameter;
        self.Value = value
    end
end

function B_Trigger_CustomVariables:CustomFunction()
    local Value1 = API.ObtainCustomVariable("BehaviorVariable_" ..self.VariableName, 0);
    local Value2 = self.Value;
    if type(self.Value) == "string" then
        Value2 = API.ObtainCustomVariable("BehaviorVariable_" ..self.Value, 0);
    end

    if self.Relation == "==" then
        return Value1 == Value2;
    elseif self.Relation ~= "~=" then
        return Value1 ~= Value2;
    elseif self.Relation == ">" then
        return Value1 > Value2;
    elseif self.Relation == ">=" then
        return Value1 >= Value2;
    elseif self.Relation == "<=" then
        return Value1 <= Value2;
    else
        return Value1 < Value2;
    end
    return false;
end

function B_Trigger_CustomVariables:GetCustomData( _Index )
    if _Index == 1 then
        return {"==", "~=", "<=", "<", ">", ">="};
    end
end

function B_Trigger_CustomVariables:Debug(_Quest)
    local relations = {"==", "~=", "<=", "<", ">", ">="}
    local results    = {true, false, nil}

    if not API.ObtainCustomVariable("BehaviorVariable_" ..self.VariableName) then
        warn(_Quest.Identifier.. ": " ..self.Name..": variable '"..self.VariableName.."' do not exist!");
    end
    if not table.contains(relations, self.Relation) then
        error(_Quest.Identifier.. ": " ..self.Name..": '"..self.Relation.."' is an invalid relation!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_CustomVariables)

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest sofort.
--
-- @within Trigger
--
function Trigger_AlwaysActive()
    return B_Trigger_AlwaysActive:new()
end

B_Trigger_AlwaysActive = {
    Name = "Trigger_AlwaysActive",
    Description = {
        en = "Trigger: the map has been started.",
        de = "Auslöser: Start der Karte.",
        fr = "Déclencheur: Démarrage de la carte.",
    },
}

function B_Trigger_AlwaysActive:GetTriggerTable()
    return {Triggers.Time, 0 }
end

Swift:RegisterBehavior(B_Trigger_AlwaysActive);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest im angegebenen Monat.
--
-- @param _Month Monat
--
-- @within Trigger
--
function Trigger_OnMonth(...)
    return B_Trigger_OnMonth:new(...);
end

B_Trigger_OnMonth = {
    Name = "Trigger_OnMonth",
    Description = {
        en = "Trigger: a specified month",
        de = "Auslöser: ein bestimmter Monat",
        fr = "Déclencheur: un mois donné"
    },
    Parameter = {
        { ParameterType.Custom, en = "Month", de = "Monat", fr = "Mois" },
    },
}

function B_Trigger_OnMonth:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnMonth:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Month = _Parameter * 1
    end
end

function B_Trigger_OnMonth:CustomFunction(_Quest)
    return self.Month == Logic.GetCurrentMonth()
end

function B_Trigger_OnMonth:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for i = 1, 12 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function B_Trigger_OnMonth:Debug(_Quest)
    if self.Month < 1 or self.Month > 12 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Month has the wrong value")
        return true
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_OnMonth);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest sobald der Monsunregen einsetzt.
--
-- <b>Achtung:</b> Dieses Behavior ist nur für Reich des Ostens verfügbar.
--
-- @within Trigger
--
function Trigger_OnMonsoon()
    return B_Trigger_OnMonsoon:new();
end

B_Trigger_OnMonsoon = {
    Name = "Trigger_OnMonsoon",
    Description = {
        en = "Trigger: on monsoon.",
        de = "Auslöser: wenn der Monsun beginnt.",
        fr = "Déclencheur: lorsque la mousson commence.",
    },
    RequiresExtraNo = 1,
}

function B_Trigger_OnMonsoon:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnMonsoon:CustomFunction(_Quest)
    if Logic.GetWeatherDoesShallowWaterFlood(0) then
        return true
    end
end

Swift:RegisterBehavior(B_Trigger_OnMonsoon);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest sobald der Timer abgelaufen ist.
--
-- Der Timer zählt immer vom Start der Map an.
--
-- @param _Time Zeit bis zum Start
--
-- @within Trigger
--
function Trigger_Time(...)
    return B_Trigger_Time:new(...);
end

B_Trigger_Time = {
    Name = "Trigger_Time",
    Description = {
        en = "Trigger: a given amount of time since map start",
        de = "Auslöser: eine gewisse Anzahl Sekunden nach Spielbeginn",
        fr = "Déclencheur: un certain nombre de secondes après le début du jeu",
    },
    Parameter = {
        { ParameterType.Number, en = "Time (sec.)", de = "Zeit (Sek.)", fr = "Temps (sec.)" },
    },
}

function B_Trigger_Time:GetTriggerTable()
    return {Triggers.Time, self.Time }
end

function B_Trigger_Time:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Time = _Parameter * 1
    end
end

Swift:RegisterBehavior(B_Trigger_Time);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest sobald das Wasser gefriert.
--
-- @within Trigger
--
function Trigger_OnWaterFreezes()
    return B_Trigger_OnWaterFreezes:new();
end

B_Trigger_OnWaterFreezes = {
    Name = "Trigger_OnWaterFreezes",
    Description = {
        en = "Trigger: if the water starts freezing",
        de = "Auslöser: wenn die Gewässer gefrieren",
        fr = "Déclencheur: lorsque les eaux gèlent",
    },
}

function B_Trigger_OnWaterFreezes:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnWaterFreezes:CustomFunction(_Quest)
    if Logic.GetWeatherDoesWaterFreeze(0) then
        return true
    end
end

Swift:RegisterBehavior(B_Trigger_OnWaterFreezes);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest niemals.
--
-- Quests, für die dieser Trigger gesetzt ist, müssen durch einen anderen
-- Quest über Reward_QuestActive oder Reprisal_QuestActive gestartet werden.
--
-- @within Trigger
--
function Trigger_NeverTriggered()
    return B_Trigger_NeverTriggered:new();
end

B_Trigger_NeverTriggered = {
    Name = "Trigger_NeverTriggered",
    Description = {
        en = "Trigger: Never triggers a Quest. The quest may be set active by Reward_QuestActivate or Reward_QuestRestartForceActive",
        de = "Auslöser: Löst nie eine Quest aus. Die Quest kann von Reward_QuestActivate oder Reward_QuestRestartForceActive aktiviert werden.",
        fr = "Déclencheur: Ne déclenche jamais de quête. La quête peut être activée par Reward_QuestActivate ou Reward_QuestRestartForceActive.",
    },
}

function B_Trigger_NeverTriggered:GetTriggerTable()

    return {Triggers.Custom2, {self, function() end} }

end

Swift:RegisterBehavior(B_Trigger_NeverTriggered)

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald wenigstens einer von zwei Quests fehlschlägt.
--
-- @param _QuestName1 Name des ersten Quest
-- @param _QuestName2 Name des zweiten Quest
--
-- @within Trigger
--
function Trigger_OnAtLeastOneQuestFailure(...)
    return B_Trigger_OnAtLeastOneQuestFailure:new(...);
end

B_Trigger_OnAtLeastOneQuestFailure = {
    Name = "Trigger_OnAtLeastOneQuestFailure",
    Description = {
        en = "Trigger: if one or both of the given quests have failed.",
        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge fehlgeschlagen sind.",
        fr = "Déclencheur: si l'une des quêtes indiquées ou les deux ont échoué.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1", fr = "Nom de la quête 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2", fr = "Nom de la quête 2" },
    },
}

function B_Trigger_OnAtLeastOneQuestFailure:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_OnAtLeastOneQuestFailure:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function B_Trigger_OnAtLeastOneQuestFailure:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure)
    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure) then
        return true;
    end
    return false;
end

function B_Trigger_OnAtLeastOneQuestFailure:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        error(_Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_OnAtLeastOneQuestFailure);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald wenigstens einer von zwei Quests erfolgreich ist.
--
-- @param _QuestName1 Name des ersten Quest
-- @param _QuestName2 Name des zweiten Quest
--
-- @within Trigger
--
function Trigger_OnAtLeastOneQuestSuccess(...)
    return B_Trigger_OnAtLeastOneQuestSuccess:new(...);
end

B_Trigger_OnAtLeastOneQuestSuccess = {
    Name = "Trigger_OnAtLeastOneQuestSuccess",
    Description = {
        en = "Trigger: if one or both of the given quests are won.",
        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge gewonnen wurden.",
        fr = "Déclencheur : si une ou les deux missions indiquées ont été gagnées.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1", fr = "Nom de la quête 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2", fr = "Nom de la quête 2" },
    },
}

function B_Trigger_OnAtLeastOneQuestSuccess:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_OnAtLeastOneQuestSuccess:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function B_Trigger_OnAtLeastOneQuestSuccess:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success)
    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success) then
        return true;
    end
    return false;
end

function B_Trigger_OnAtLeastOneQuestSuccess:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        error(_Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_OnAtLeastOneQuestSuccess);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald mindestens X von Y Quests erfolgreich sind.
--
-- @param _MinAmount   Mindestens zu erfüllen (max. 5)
-- @param _QuestAmount Anzahl geprüfter Quests (max. 5 und >= _MinAmount)
-- @param _Quest1      Name des 1. Quest
-- @param _Quest2      Name des 2. Quest
-- @param _Quest3      Name des 3. Quest
-- @param _Quest4      Name des 4. Quest
-- @param _Quest5      Name des 5. Quest
--
-- @within Trigger
--
function Trigger_OnAtLeastXOfYQuestsSuccess(...)
    return B_Trigger_OnAtLeastXOfYQuestsSuccess:new(...);
end

B_Trigger_OnAtLeastXOfYQuestsSuccess = {
    Name = "Trigger_OnAtLeastXOfYQuestsSuccess",
    Description = {
        en = "Trigger: if at least X of Y given quests has been finished successfully.",
        de = "Auslöser: wenn X von Y angegebener Quests erfolgreich abgeschlossen wurden.",
        fr = "Déclencheur: lorsque X des Y quêtes indiquées ont été accomplies avec succès.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Least Amount", de = "Mindest Anzahl", fr = "Nombre minimum" },
        { ParameterType.Custom, en = "Quest Amount", de = "Quest Anzahl",   fr = "Nombre de quêtes" },
        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1", fr = "Nom de la quête 1" },
        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2", fr = "Nom de la quête 2" },
        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3", fr = "Nom de la quête 3" },
        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4", fr = "Nom de la quête 4" },
        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5", fr = "Nom de la quête 5" },
    },
}

function B_Trigger_OnAtLeastXOfYQuestsSuccess:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnAtLeastXOfYQuestsSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.LeastAmount = tonumber(_Parameter)
    elseif (_Index == 1) then
        self.QuestAmount = tonumber(_Parameter)
    elseif (_Index == 2) then
        self.QuestName1 = _Parameter
    elseif (_Index == 3) then
        self.QuestName2 = _Parameter
    elseif (_Index == 4) then
        self.QuestName3 = _Parameter
    elseif (_Index == 5) then
        self.QuestName4 = _Parameter
    elseif (_Index == 6) then
        self.QuestName5 = _Parameter
    end
end

function B_Trigger_OnAtLeastXOfYQuestsSuccess:CustomFunction()
    local least = 0
    for i = 1, self.QuestAmount do
        local QuestID = GetQuestID(self["QuestName"..i]);
        if IsValidQuest(QuestID) then
			if (Quests[QuestID].Result == QuestResult.Success) then
				least = least + 1
				if least >= self.LeastAmount then
					return true
				end
			end
		end
    end
    return false
end

function B_Trigger_OnAtLeastXOfYQuestsSuccess:Debug(_Quest)
    local leastAmount = self.LeastAmount
    local questAmount = self.QuestAmount
    if leastAmount <= 0 or leastAmount >5 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": LeastAmount is wrong")
        return true
    elseif questAmount <= 0 or questAmount > 5 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": QuestAmount is wrong")
        return true
    elseif leastAmount > questAmount then
        error(_Quest.Identifier.. ": " ..self.Name .. ": LeastAmount is greater than QuestAmount")
        return true
    end
    for i = 1, questAmount do
        if not IsValidQuest(self["QuestName"..i]) then
            error(_Quest.Identifier.. ": " ..self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")
            return true
        end
    end
    return false
end

function B_Trigger_OnAtLeastXOfYQuestsSuccess:GetCustomData(_Index)
    if (_Index == 0) or (_Index == 1) then
        return {"1", "2", "3", "4", "5"}
    end
end

Swift:RegisterBehavior(B_Trigger_OnAtLeastXOfYQuestsSuccess)

-- -------------------------------------------------------------------------- --

---
-- Führt eine Funktion im Skript als Trigger aus.
--
-- Die Funktion muss entweder true or false zurückgeben.
--
-- Nur Skipt: Wird statt einem Funktionsnamen (String) eine Funktionsreferenz
-- übergeben, werden alle weiteren Parameter an die Funktion weitergereicht.
--
-- @param _FunctionName Name der Funktion
--
-- @within Trigger
--
function Trigger_MapScriptFunction(...)
    return B_Trigger_MapScriptFunction:new(...);
end

B_Trigger_MapScriptFunction = {
    Name = "Trigger_MapScriptFunction",
    Description = {
        en = "Trigger: Calls a function within the global map script. If the function returns true the quest will be started",
        de = "Auslöser: Ruft eine Funktion im globalen Skript auf. Wenn sie true sendet, wird die Quest gestartet.",
        fr = "Déclencheur: Appelle une fonction dans le script global. Si elle envoie true, la quête est lancée.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname", fr = "Nom de la fonction" },
    },
}

function B_Trigger_MapScriptFunction:GetTriggerTable(_Quest)
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_MapScriptFunction:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.FuncName = _Parameter
    end
end

function B_Trigger_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        return self.FuncName(unpack(self.i47ya_6aghw_frxil));
    end
    return _G[self.FuncName](self, _Quest);
end

function B_Trigger_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        error(_Quest.Identifier.. ": " ..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) ~= "function" and not _G[self.FuncName] then
        error(_Quest.Identifier.. ": " ..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_MapScriptFunction);

---
-- Startet den Quest, sobald ein Effekt zerstört wird oder verschwindet.
--
-- <b>Achtung</b>: Das Behavior kann nur auf Effekte angewand werden, die
-- über Effekt-Behavior erzeugt wurden.
--
-- @param _EffectName Name des Effekt
--
-- @within Trigger
--
function Trigger_OnEffectDestroyed(...)
    return B_Trigger_OnEffectDestroyed:new(...);
end

B_Trigger_OnEffectDestroyed = {
	Name = "Trigger_OnEffectDestroyed",
	Description = {
		en = "Trigger: Starts a quest after an effect was destroyed",
		de = "Auslöser: Startet eine Quest, nachdem ein Effekt zerstoert wurde",
        fr = "Déclencheur: Démarre une quête après la destruction d'un effet.",
	},
	Parameter = {
		{ ParameterType.Default, en = "Effect name", de = "Effektname", fr = "Nom de l'effet" },
	},
}

function B_Trigger_OnEffectDestroyed:GetTriggerTable()
	return { Triggers.Custom2, {self, self.CustomFunction} }
end

function B_Trigger_OnEffectDestroyed:AddParameter(_Index, _Parameter)
	if _Index == 0 then	
		self.EffectName = _Parameter
	end
end

function B_Trigger_OnEffectDestroyed:CustomFunction()
	return not QSB.EffectNameToID[self.EffectName] or not Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]);
end

function B_Trigger_OnEffectDestroyed:Debug(_Quest)
	if not QSB.EffectNameToID[self.EffectName] then
		error(_Quest.Identifier.. ": " ..self.Name .. ": Effect has never existed")
		return true
	end
end
Swift:RegisterBehavior(B_Trigger_OnEffectDestroyed)

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleEntity = {
    Properties = {
        Name = "ModuleEntity",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        RegisteredEntities = {},
        MineAmounts = {},
        AttackedEntities = {},
        OverkillEntities = {},
        DisableThiefStorehouseHeist = false,
        DisableThiefCathedralSabotage = false,
        DisableThiefCisternSabotage = false,

        -- TODO: Add predators?
        StaticSpawnerTypes = {
            "B_NPC_BanditsHQ_ME",
            "B_NPC_BanditsHQ_NA",
            "B_NPC_BanditsHQ_NE",
            "B_NPC_BanditsHQ_SE",
            "B_NPC_BanditsHutBig_ME",
            "B_NPC_BanditsHutBig_NA",
            "B_NPC_BanditsHutBig_NE",
            "B_NPC_BanditsHutBig_SE",
            "B_NPC_BanditsHutSmall_ME",
            "B_NPC_BanditsHutSmall_NA",
            "B_NPC_BanditsHutSmall_NE",
            "B_NPC_BanditsHutSmall_SE",
            "B_NPC_Barracks_ME",
            "B_NPC_Barracks_NA",
            "B_NPC_Barracks_NE",
            "B_NPC_Barracks_SE",
            "B_NPC_BanditsHQ_AS",
            "B_NPC_BanditsHutBig_AS",
            "B_NPC_BanditsHutSmall_AS",
            "B_NPC_Barracks_AS",
        },

        -- Those are "fluctuating" spawner entities that are keep appearing
        -- and disappearing depending of if they have resources spawned. They
        -- change their ID every time they do it. So scriptnames are a nono.
        DynamicSpawnerTypes = {
            "S_AxisDeer_AS",
            "S_Deer_ME",
            "S_FallowDeer_SE",
            "S_Gazelle_NA",
            "S_Herbs",
            "S_Moose_NE",
            "S_RawFish",
            "S_Reindeer_NE",
            "S_WildBoar",
            "S_Zebra_NA",
        },
    },
    Local = {},
    Shared = {},
}

-- Global ------------------------------------------------------------------- --

function ModuleEntity.Global:OnGameStart()
    QSB.ScriptEvents.SettlerAttracted = API.RegisterScriptEvent("Event_SettlerAttracted");
    QSB.ScriptEvents.EntitySpawned = API.RegisterScriptEvent("Event_EntitySpawned");
    QSB.ScriptEvents.EntityDestroyed = API.RegisterScriptEvent("Event_EntityDestroyed");
    QSB.ScriptEvents.EntityHurt = API.RegisterScriptEvent("Event_EntityHurt");
    QSB.ScriptEvents.EntityKilled = API.RegisterScriptEvent("Event_EntityKilled");
    QSB.ScriptEvents.EntityOwnerChanged = API.RegisterScriptEvent("Event_EntityOwnerChanged");
    QSB.ScriptEvents.EntityResourceChanged = API.RegisterScriptEvent("Event_EntityResourceChanged");

    QSB.ScriptEvents.ThiefInfiltratedBuilding = API.RegisterScriptEvent("Event_ThiefInfiltratedBuilding");
    QSB.ScriptEvents.ThiefDeliverEarnings = API.RegisterScriptEvent("Event_ThiefDeliverEarnings");
    QSB.ScriptEvents.BuildingConstructed = API.RegisterScriptEvent("Event_BuildingConstructed");
    QSB.ScriptEvents.BuildingUpgradeCollapsed = API.RegisterScriptEvent("Event_BuildingUpgradeCollapsed");
    QSB.ScriptEvents.BuildingUpgraded = API.RegisterScriptEvent("Event_BuildingUpgraded");

    self:StartTriggers();
    self:OverrideCallback();
    self:OverrideLogic();
end

function ModuleEntity.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.SaveGameLoaded then
        self:OnSaveGameLoaded();
    elseif _ID == QSB.ScriptEvents.EntityHurt then
        self.AttackedEntities[arg[1]] = {arg[3], 100};
    end
end

function ModuleEntity.Global:TriggerEntityOnwershipChangedEvent(_OldID, _OldOwnerID, _NewID, _NewOwnerID)
    _OldID = (type(_OldID) ~= "table" and {_OldID}) or _OldID;
    _NewID = (type(_NewID) ~= "table" and {_NewID}) or _NewID;
    assert(#_OldID == #_NewID, "Sums of entities with changed owner does not add up!");
    for i=1, #_OldID do
        API.SendScriptEvent(QSB.ScriptEvents.EntityOwnerChanged, _OldID[i], _OldOwnerID, _NewID[i], _NewOwnerID);
        Logic.ExecuteInLuaLocalState(string.format(
            "API.SendScriptEvent(QSB.ScriptEvents.EntityOwnerChanged, %d)",
            _OldID[i], _OldOwnerID, _NewID[i], _NewOwnerID
        ));
    end
end

function ModuleEntity.Global:OnSaveGameLoaded()
    self:OverrideLogic();
end

function ModuleEntity.Global:CleanTaggedAndDeadEntities()
    -- check if entity should no longer be considered attacked
    for k,v in pairs(self.AttackedEntities) do
        self.AttackedEntities[k][2] = v[2] - 1;
        if v[2] <= 0 then
            self.AttackedEntities[k] = nil;
        else
            -- Send killed event for knights
            if IsExisting(k) and IsExisting(v[1]) and Logic.IsKnight(k) then
                if not self.OverkillEntities[k] and Logic.KnightGetResurrectionProgress(k) ~= 1 then
                    local PlayerID1 = Logic.EntityGetPlayer(k);
                    local PlayerID2 = Logic.EntityGetPlayer(v[1]);
                    self:TriggerEntityKilledEvent(k, PlayerID1, v[1], PlayerID2);
                    self.OverkillEntities[k] = 50;
                    self.AttackedEntities[k] = nil;
                end
            end
        end
    end
    -- unregister overkill entities
    for k,v in pairs(self.OverkillEntities) do
        self.OverkillEntities[k] = v - 1;
        if v <= 0 then
            self.OverkillEntities[k] = nil;
        end
    end
end

function ModuleEntity.Global:OverrideCallback()
    GameCallback_SettlerSpawned_Orig_QSB_EntityCore = GameCallback_SettlerSpawned;
    GameCallback_SettlerSpawned = function(_PlayerID, _EntityID)
        GameCallback_SettlerSpawned_Orig_QSB_EntityCore(_PlayerID, _EntityID);
        ModuleEntity.Global:TriggerSettlerArrivedEvent(_PlayerID, _EntityID);
    end

    GameCallback_OnBuildingConstructionComplete_Orig_QSB_EntityCore = GameCallback_OnBuildingConstructionComplete;
    GameCallback_OnBuildingConstructionComplete = function(_PlayerID, _EntityID)
        GameCallback_OnBuildingConstructionComplete_Orig_QSB_EntityCore(_PlayerID, _EntityID);
        ModuleEntity.Global:TriggerConstructionCompleteEvent(_PlayerID, _EntityID);
    end

    GameCallback_FarmAnimalChangedPlayerID_Orig_QSB_EntityCore = GameCallback_FarmAnimalChangedPlayerID;
    GameCallback_FarmAnimalChangedPlayerID = function(_PlayerID, _NewEntityID, _OldEntityID)
        GameCallback_FarmAnimalChangedPlayerID_Orig_QSB_EntityCore(_PlayerID, _NewEntityID, _OldEntityID);
        local OldPlayerID = Logic.EntityGetPlayer(_OldEntityID);
        local NewPlayerID = Logic.EntityGetPlayer(_NewEntityID);
        ModuleEntity.Global:TriggerEntityOnwershipChangedEvent(_OldEntityID, OldPlayerID, _NewEntityID, NewPlayerID);
    end

    GameCallback_EntityCaptured_Orig_QSB_EntityCore = GameCallback_EntityCaptured;
    GameCallback_EntityCaptured = function(_OldEntityID, _OldEntityPlayerID, _NewEntityID, _NewEntityPlayerID)
        GameCallback_EntityCaptured_Orig_QSB_EntityCore(_OldEntityID, _OldEntityPlayerID, _NewEntityID, _NewEntityPlayerID)
        ModuleEntity.Global:TriggerEntityOnwershipChangedEvent(_OldEntityID, _OldEntityPlayerID, _NewEntityID, _NewEntityPlayerID);
    end

    GameCallback_CartFreed_Orig_QSB_EntityCore = GameCallback_CartFreed;
    GameCallback_CartFreed = function(_OldEntityID, _OldEntityPlayerID, _NewEntityID, _NewEntityPlayerID)
        GameCallback_CartFreed_Orig_QSB_EntityCore(_OldEntityID, _OldEntityPlayerID, _NewEntityID, _NewEntityPlayerID);
        ModuleEntity.Global:TriggerEntityOnwershipChangedEvent(_OldEntityID, _OldEntityPlayerID, _NewEntityID, _NewEntityPlayerID);
    end

    GameCallback_OnThiefDeliverEarnings_Orig_QSB_EntityCore = GameCallback_OnThiefDeliverEarnings;
    GameCallback_OnThiefDeliverEarnings = function(_ThiefPlayerID, _ThiefID, _BuildingID, _GoodAmount)
        GameCallback_OnThiefDeliverEarnings_Orig_QSB_EntityCore(_ThiefPlayerID, _ThiefID, _BuildingID, _GoodAmount);
        local BuildingPlayerID = Logic.EntityGetPlayer(_BuildingID);
        ModuleEntity.Global:TriggerThiefDeliverEarningsEvent(_ThiefID, _ThiefPlayerID, _BuildingID, BuildingPlayerID, _GoodAmount);
    end

    GameCallback_OnThiefStealBuilding_Orig_QSB_EntityCore = GameCallback_OnThiefStealBuilding;
    GameCallback_OnThiefStealBuilding = function(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID)
        ModuleEntity.Global:TriggerThiefStealFromBuildingEvent(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);
    end

    GameCallback_OnBuildingUpgraded_Orig_QSB_EntityCore = GameCallback_OnBuildingUpgradeFinished;
	GameCallback_OnBuildingUpgradeFinished = function(_PlayerID, _EntityID, _NewUpgradeLevel)
		GameCallback_OnBuildingUpgraded_Orig_QSB_EntityCore(_PlayerID, _EntityID, _NewUpgradeLevel);
        ModuleEntity.Global:TriggerUpgradeCompleteEvent(_PlayerID, _EntityID, _NewUpgradeLevel);
    end

    GameCallback_OnUpgradeLevelCollapsed_Orig_QSB_EntityCore = GameCallback_OnUpgradeLevelCollapsed;
    GameCallback_OnUpgradeLevelCollapsed = function(_PlayerID, _BuildingID, _NewUpgradeLevel)
        GameCallback_OnUpgradeLevelCollapsed_Orig_QSB_EntityCore(_PlayerID, _BuildingID, _NewUpgradeLevel);
        ModuleEntity.Global:TriggerUpgradeCollapsedEvent(_PlayerID, _BuildingID, _NewUpgradeLevel);
    end
end

function ModuleEntity.Global:OverrideLogic()
    self.Logic_ChangeEntityPlayerID = Logic.ChangeEntityPlayerID;
    Logic.ChangeEntityPlayerID = function(...)
        local OldID = {arg[1]};
        local OldPlayerID = Logic.EntityGetPlayer(arg[1]);
        local NewID = {self.Logic_ChangeEntityPlayerID(unpack(arg))};
        local NewPlayerID = Logic.EntityGetPlayer(NewID[1]);
        ModuleEntity.Global:TriggerEntityOnwershipChangedEvent(OldID, OldPlayerID, NewID, NewPlayerID);
        return NewID;
    end

    self.Logic_ChangeSettlerPlayerID = Logic.ChangeSettlerPlayerID;
    Logic.ChangeSettlerPlayerID = function(...)
        local OldID = {arg[1]};
        local OldPlayerID = Logic.EntityGetPlayer(arg[1]);
        local OldSoldierTable = {Logic.GetSoldiersAttachedToLeader(arg[1])};
        if OldSoldierTable[1] and OldSoldierTable[1] > 0 then
            for i=2, OldSoldierTable[1]+1 do
                table.insert(OldID, OldSoldierTable[i]);
            end
        end
        local NewID = {self.Logic_ChangeSettlerPlayerID(unpack(arg))};
        local NewSoldierTable = {Logic.GetSoldiersAttachedToLeader(NewID[1])};
        if NewSoldierTable[1] and NewSoldierTable[1] > 0 then
            for i=2, NewSoldierTable[1]+1 do
                table.insert(NewID, NewSoldierTable[i]);
            end
        end
        local NewPlayerID = Logic.EntityGetPlayer(NewID[1]);
        ModuleEntity.Global:TriggerEntityOnwershipChangedEvent(OldID, OldPlayerID, NewID, NewPlayerID);
        return NewID[1];
    end
end

function ModuleEntity.Global:TriggerThiefDeliverEarningsEvent(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID, _GoodAmount)
    API.SendScriptEvent(QSB.ScriptEvents.ThiefDeliverEarnings, _ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID, _GoodAmount);
    Logic.ExecuteInLuaLocalState(string.format(
        "API.SendScriptEvent(QSB.ScriptEvents.ThiefDeliverEarnings, %d, %d, %d, %d, %d)",
        _ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID, _GoodAmount
    ));
end

function ModuleEntity.Global:TriggerThiefStealFromBuildingEvent(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID)
    local HeadquartersID = Logic.GetHeadquarters(_BuildingPlayerID);
    local CathedralID = Logic.GetCathedral(_BuildingPlayerID);
    local StorehouseID = Logic.GetStoreHouse(_BuildingPlayerID);
    local IsVillageStorehouse = Logic.IsEntityInCategory(StorehouseID, EntityCategories.VillageStorehouse) == 0;
    local BuildingType = Logic.GetEntityType(_BuildingID);

    -- Aus Lagerhaus stehlen
    if StorehouseID == _BuildingID and (not IsVillageStorehouse or HeadquartersID == 0) then
        if not self.DisableThiefStorehouseHeist then
            GameCallback_OnThiefStealBuilding_Orig_QSB_EntityCore(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);
        end
    end
    -- Kirche sabotieren
    if CathedralID == _BuildingID then
        if not self.DisableThiefCathedralSabotage then
            GameCallback_OnThiefStealBuilding_Orig_QSB_EntityCore(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);
        end
    end
    -- Brunnen sabotieren
    if Framework.GetGameExtraNo() > 0 and BuildingType == Entities.B_Cistern then
        if not self.DisableThiefCisternSabotage then
            GameCallback_OnThiefStealBuilding_Orig_QSB_EntityCore(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);
        end
    end

    -- Send event
    API.SendScriptEvent(QSB.ScriptEvents.ThiefInfiltratedBuilding, _ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        "API.SendScriptEvent(QSB.ScriptEvents.ThiefInfiltratedBuilding, %d, %d, %d, %d)",
        _ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID
    ));
end

function ModuleEntity.Global:TriggerEntitySpawnedEvent(_EntityID, _SpawnerID)
    local PlayerID = Logic.EntityGetPlayer(_EntityID);
    API.SendScriptEvent(QSB.ScriptEvents.EntitySpawned, _EntityID, PlayerID, _SpawnerID);
    Logic.ExecuteInLuaLocalState(string.format(
        "API.SendScriptEvent(QSB.ScriptEvents.EntitySpawned, %d, %d, %d)",
        _EntityID, PlayerID, _SpawnerID
    ));
end

function ModuleEntity.Global:TriggerSettlerArrivedEvent(_PlayerID, _EntityID)
    API.SendScriptEvent(QSB.ScriptEvents.SettlerAttracted, _EntityID, _PlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        "API.SendScriptEvent(QSB.ScriptEvents.SettlerAttracted, %d, %d)",
        _EntityID, _PlayerID
    ));
end

function ModuleEntity.Global:TriggerEntityDestroyedEvent(_EntityID, _PlayerID)
    API.SendScriptEvent(QSB.ScriptEvents.EntityDestroyed, _EntityID, _PlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        "API.SendScriptEvent(QSB.ScriptEvents.EntityDestroyed, %d, %d)",
        _EntityID, _PlayerID
    ));
end

function ModuleEntity.Global:TriggerEntityKilledEvent(_EntityID1, _PlayerID1, _EntityID2, _PlayerID2)
    API.SendScriptEvent(QSB.ScriptEvents.EntityKilled, _EntityID1, _PlayerID1, _EntityID2, _PlayerID2);
    Logic.ExecuteInLuaLocalState(string.format(
        "API.SendScriptEvent(QSB.ScriptEvents.EntityKilled, %d, %d, %d, %d)",
        _EntityID1, _PlayerID1, _EntityID2, _PlayerID2
    ));
end

function ModuleEntity.Global:TriggerConstructionCompleteEvent(_PlayerID, _EntityID)
    API.SendScriptEvent(QSB.ScriptEvents.BuildingConstructed, _EntityID, _PlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        "API.SendScriptEvent(QSB.ScriptEvents.BuildingConstructed, %d, %d)",
        _EntityID, _PlayerID
    ));
end

function ModuleEntity.Global:TriggerUpgradeCompleteEvent(_PlayerID, _EntityID, _NewUpgradeLevel)
    API.SendScriptEvent(QSB.ScriptEvents.BuildingUpgraded, _EntityID, _PlayerID, _NewUpgradeLevel);
    Logic.ExecuteInLuaLocalState(string.format(
        "API.SendScriptEvent(QSB.ScriptEvents.BuildingUpgraded, %d, %d, %d)",
        _EntityID, _PlayerID, _NewUpgradeLevel
    ));
end

function ModuleEntity.Global:TriggerUpgradeCollapsedEvent(_PlayerID, _EntityID, _NewUpgradeLevel)
    API.SendScriptEvent(QSB.ScriptEvents.BuildingUpgradeCollapsed, _EntityID, _PlayerID, _NewUpgradeLevel);
    Logic.ExecuteInLuaLocalState(string.format(
        "API.SendScriptEvent(QSB.ScriptEvents.BuildingUpgradeCollapsed, %d, %d, %d)",
        _EntityID, _PlayerID, _NewUpgradeLevel
    ));
end

function ModuleEntity.Global:StartTriggers()
    API.StartHiResJob(function()
        if Logic.GetCurrentTurn() > 0 then
            ModuleEntity.Global:CleanTaggedAndDeadEntities();
            ModuleEntity.Global:CheckOnSpawnerEntities();
        end
    end);

    API.StartJob(function()
        local MineEntityTypes = {
            Entities.R_IronMine,
            Entities.R_StoneMine
        };
        for i= 1, #MineEntityTypes do
            local Mines = Logic.GetEntitiesOfType(MineEntityTypes[i]);
            for j= 1, #Mines do
                local Old = self.MineAmounts[Mines[j]];
                local New = Logic.GetResourceDoodadGoodAmount(Mines[j]);
                if Old and New and Old ~= New then
                    local Type = Logic.GetResourceDoodadGoodType(Mines[j]);
                    API.SendScriptEvent(QSB.ScriptEvents.EntityResourceChanged, Mines[j], Type, Old, New);
                    Logic.ExecuteInLuaLocalState(string.format(
                        [[API.SendScriptEvent(QSB.ScriptEvents.EntityResourceChanged, %d, %d, %d, %d)]],
                        Mines[j], Type, Old, New
                    ));
                end
                self.MineAmounts[Mines[j]] = New;
            end
        end
    end);

    API.StartJobByEventType(
        Events.LOGIC_EVENT_ENTITY_DESTROYED,
        function()
            local EntityID1 = Event.GetEntityID();
            local PlayerID1 = Logic.EntityGetPlayer(EntityID1);
            ModuleEntity.Global:TriggerEntityDestroyedEvent(EntityID1, PlayerID1);
            if ModuleEntity.Global.AttackedEntities[EntityID1] ~= nil then
                local EntityID2 = ModuleEntity.Global.AttackedEntities[EntityID1][1];
                local PlayerID2 = Logic.EntityGetPlayer(EntityID2);
                ModuleEntity.Global.AttackedEntities[EntityID1] = nil;
                ModuleEntity.Global:TriggerEntityKilledEvent(EntityID1, PlayerID1, EntityID2, PlayerID2);
            end
        end
    );

    API.StartJobByEventType(
        Events.LOGIC_EVENT_ENTITY_HURT_ENTITY,
        function()
            local EntityID1 = Event.GetEntityID1();
            local PlayerID1 = Logic.EntityGetPlayer(EntityID1);
            local EntityID2 = Event.GetEntityID2();
            local PlayerID2 = Logic.EntityGetPlayer(EntityID2);

            API.SendScriptEvent(QSB.ScriptEvents.EntityHurt, EntityID2, PlayerID2, EntityID1, PlayerID1);
            Logic.ExecuteInLuaLocalState(string.format(
                [[API.SendScriptEvent(QSB.ScriptEvents.EntityHurt, %d, %d, %d, %d)]],
                EntityID2, PlayerID2, EntityID1, PlayerID1
            ));
        end
    );
end

function ModuleEntity.Global:CheckOnSpawnerEntities()
    -- Get spawners
    local SpawnerEntities = {};
    for i= 1, #self.DynamicSpawnerTypes do
        if Entities[self.DynamicSpawnerTypes[i]] then
            if Logic.GetCurrentTurn() % 10 == i then
                for k, v in pairs(Logic.GetEntitiesOfType(Entities[self.DynamicSpawnerTypes[i]])) do
                    table.insert(SpawnerEntities, v);
                end
            end
        end
    end
    for i= 1, #self.StaticSpawnerTypes do
        if Entities[self.StaticSpawnerTypes[i]] then
            if Logic.GetCurrentTurn() % 10 == i then
                for k, v in pairs(Logic.GetEntitiesOfType(Entities[self.StaticSpawnerTypes[i]])) do
                    table.insert(SpawnerEntities, v);
                end
            end
        end
    end
    -- Check spawned entities
    for i= 1, #SpawnerEntities do
        for k, v in pairs{Logic.GetSpawnedEntities(SpawnerEntities[i])} do
            -- On Spawner entity spawned
            if not self.RegisteredEntities[v] then
                self:TriggerEntitySpawnedEvent(v, SpawnerEntities[i]);
                self.RegisteredEntities[v] = SpawnerEntities[i];
            end
        end
    end
end

-- Local -------------------------------------------------------------------- --

function ModuleEntity.Local:OnGameStart()
    QSB.ScriptEvents.SettlerAttracted = API.RegisterScriptEvent("Event_SettlerAttracted");
    QSB.ScriptEvents.EntitySpawned = API.RegisterScriptEvent("Event_EntitySpawned");
    QSB.ScriptEvents.EntityDestroyed = API.RegisterScriptEvent("Event_EntityDestroyed");
    QSB.ScriptEvents.EntityHurt = API.RegisterScriptEvent("Event_EntityHurt");
    QSB.ScriptEvents.EntityKilled = API.RegisterScriptEvent("Event_EntityKilled");
    QSB.ScriptEvents.EntityOwnerChanged = API.RegisterScriptEvent("Event_EntityOwnerChanged");
    QSB.ScriptEvents.EntityResourceChanged = API.RegisterScriptEvent("Event_EntityResourceChanged");

    QSB.ScriptEvents.ThiefInfiltratedBuilding = API.RegisterScriptEvent("Event_ThiefInfiltratedBuilding");
    QSB.ScriptEvents.ThiefDeliverEarnings = API.RegisterScriptEvent("Event_ThiefDeliverEarnings");
    QSB.ScriptEvents.BuildingConstructed = API.RegisterScriptEvent("Event_BuildingConstructed");
    QSB.ScriptEvents.BuildingUpgradeCollapsed = API.RegisterScriptEvent("Event_BuildingUpgradeCollapsed");
    QSB.ScriptEvents.BuildingUpgraded = API.RegisterScriptEvent("Event_BuildingUpgraded");
end

function ModuleEntity.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- Shared ------------------------------------------------------------------- --

function ModuleEntity.Shared:IterateOverEntities(_Filter, _TypeList)
    _TypeList = _TypeList or Entities;
    local ResultList = {};
    for _, v in pairs(_TypeList) do
        local AllEntitiesOfType = Logic.GetEntitiesOfType(v);
        for i= 1, #AllEntitiesOfType do
            if _Filter(AllEntitiesOfType[i]) then
                table.insert(ResultList, AllEntitiesOfType[i]);
            end
        end
    end
    return ResultList;
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleEntity);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Ermöglicht, Entities suchen und auf bestimmte Ereignisse reagieren.
--
-- <h5>Entity Suche</h5>
-- Es kann entweder mit vordefinierten Funktionen oder mit eigenen Filtern
-- nach allen Entities gesucht werden.
--
-- <h5>Diebstahleffekte</h5>
-- Die Effekte von Diebstählen können deaktiviert und mittels Event neu
-- geschrieben werden.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field EntitySpawned Ein Entity wurde aus einem Spawner erzeugt. (Parameter: EntityID, PlayerID, SpawnerID)
-- @field SettlerAttracted Ein Siedler kommt in die Siedlung. (Parameter: EntityID, PlayerID)
-- @field EntityDestroyed Ein Entity wurde zerstört. Wird auch durch Spieler ändern ausgelöst! (Parameter: EntityID, PlayerID)
-- @field EntityHurt Ein Entity wurde angegriffen. (Parameter: AttackedEntityID, AttackedPlayerID, AttackingEntityID, AttackingPlayerID)
-- @field EntityKilled Ein Entity wurde getötet. (Parameter: KilledEntityID, KilledPlayerID, KillerEntityID, KillerPlayerID)
-- @field EntityOwnerChanged Ein Entity wechselt den Besitzer. (Parameter: OldIDList, OldPlayer, NewIDList, OldPlayer)
-- @field EntityResourceChanged Resourcen im Entity verändern sich. (Parameter: EntityID, GoodType, OldAmount, NewAmount)
-- @field BuildingConstructed Ein Gebäude wurde fertiggestellt. (Parameter: BuildingID, PlayerID)
-- @field BuildingUpgraded Ein Gebäude wurde aufgewertet. (Parameter: BuildingID, PlayerID, NewUpgradeLevel)
-- @field BuildingUpgradeCollapsed Eine Ausbaustufe eines Gebäudes wurde zerstört. (Parameter: BuildingID, PlayerID, NewUpgradeLevel)
-- @field ThiefInfiltratedBuilding Ein Dieb hat ein Gebäude infiltriert. (Parameter: ThiefID, PlayerID, BuildingID, BuildingPlayerID)
-- @field ThiefDeliverEarnings Ein Dieb liefert seine Beute ab. (Parameter: ThiefID, PlayerID, BuildingID, BuildingPlayerID, GoldAmount)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

-- -------------------------------------------------------------------------- --
-- Search

---
-- Findet <u>alle</u> Entities.
--
-- @param[type=number]  _PlayerID               (Optional) ID des Besitzers
-- @param[type=boolean] _WithoutDefeatResistant (Optional) Niederlageresistente Entities filtern
-- @return[type=table] Liste mit Ergebnissen
-- @within Suche
-- @see API.CommenceEntitySearch
--
-- @usage
-- -- ALLE Entities
-- local Result = API.SearchEntities();
-- -- Alle Entities von Spieler 5.
-- local Result = API.SearchEntities(5);
--
function API.SearchEntities(_PlayerID, _WithoutDefeatResistant)
    if _WithoutDefeatResistant == nil then
        _WithoutDefeatResistant = false;
    end
    local Filter = function(_ID)
        if _PlayerID and Logic.EntityGetPlayer(_ID) ~= _PlayerID then
            return false;
        end
        if _WithoutDefeatResistant then
            if (Logic.IsBuilding(_ID) or Logic.IsWall(_ID)) and Logic.IsConstructionComplete(_ID) == 0 then
                return false;
            end
            local Type = Logic.GetEntityType(_ID);
            local TypeName = Logic.GetEntityType(Type);
            if TypeName and (string.find(TypeName, "^S_") or string.find(TypeName, "^XD_")) then
                return false;
            end
        end
        return true;
    end
    return API.CommenceEntitySearch(Filter);
end

---
-- Findet alle Entities des Typs in einem Gebiet.
--
-- @param[type=number] _Area     Größe des Suchgebiet
-- @param              _Position Mittelpunkt (EntityID, Skriptname oder Table)
-- @param[type=number] _Type     Typ des Entity
-- @param[type=number] _PlayerID (Optional) ID des Besitzers
-- @return[type=table] Liste mit Ergebnissen
-- @within Suche
-- @see API.CommenceEntitySearch
--
-- @usage
-- local Result = API.SearchEntitiesInArea(5000, "Busches", Entities.R_HerbBush);
--
function API.SearchEntitiesOfTypeInArea(_Area, _Position, _Type, _PlayerID)
    return API.SearchEntitiesInArea(_Area, _Position, _PlayerID, _Type, nil);
end

---
-- Findet alle Entities der Kategorie in einem Gebiet.
--
-- @param[type=number] _Area     Größe des Suchgebiet
-- @param              _Position Mittelpunkt (EntityID, Skriptname oder Table)
-- @param[type=number] _Category Category des Entity
-- @param[type=number] _PlayerID (Optional) ID des Besitzers
-- @return[type=table] Liste mit Ergebnissen
-- @within Suche
-- @see API.CommenceEntitySearch
--
-- @usage
-- local Result = API.SearchEntitiesInArea(5000, "City", EntityCategories.CityBuilding, 2);
--
function API.SearchEntitiesOfCategoryInArea(_Area, _Position, _Category, _PlayerID)
    return API.SearchEntitiesInArea(_Area, _Position, _PlayerID, nil, _Category);
end

-- Not supposed to be used directly!
function API.SearchEntitiesInArea(_Area, _Position, _PlayerID, _Type, _Category)
    local Position = _Position;
    if type(Position) ~= "table" then
        Position = GetPosition(Position);
    end
    local Filter = function(_ID)
        if _PlayerID and Logic.EntityGetPlayer(_ID) ~= _PlayerID then
            return false;
        end
        if _Type and Logic.GetEntityType(_ID) ~= _Type then
            return false;
        end
        if _Category and Logic.IsEntityInCategory(_ID, _Category) == 0 then
            return false;
        end
        if API.GetDistance(_ID, Position) > _Area then
            return false;
        end
        return true;
    end
    return API.CommenceEntitySearch(Filter);
end

---
-- Findet alle Entities des Typs in einem Territorium.
--
-- @param[type=number] _Territory Territorium für die Suche
-- @param[type=number] _Type      Typ des Entity
-- @param[type=number] _PlayerID  (Optional) ID des Besitzers
-- @return[type=table] Liste mit Ergebnissen
-- @within Suche
-- @see API.CommenceEntitySearch
--
-- @usage
-- local Result = API.SearchEntitiesInTerritory(7, Entities.R_HerbBush);
--
function API.SearchEntitiesOfTypeInTerritory(_Territory, _Type, _PlayerID)
    return API.SearchEntitiesInTerritory(_Territory, _PlayerID, _Type, nil);
end

---
-- Findet alle Entities der Kategorie in einem Territorium.
--
-- @param[type=number] _Territory Territorium für die Suche
-- @param[type=number] _Category  Category des Entity
-- @param[type=number] _PlayerID  (Optional) ID des Besitzers
-- @return[type=table] Liste mit Ergebnissen
-- @within Suche
-- @see API.CommenceEntitySearch
--
-- @usage
-- local Result = API.SearchEntitiesInTerritory(7, EntityCategories.CityBuilding, 6);
--
function API.SearchEntitiesOfCategoryInTerritory(_Territory, _Category, _PlayerID)
    return API.SearchEntitiesInTerritory(_Territory, _PlayerID, nil, _Category);
end

-- Not supposed to be used directly!
function API.SearchEntitiesInTerritory(_Territory, _PlayerID, _Type, _Category)
    local Filter = function(_ID)
        if _PlayerID and Logic.EntityGetPlayer(_ID) ~= _PlayerID then
            return false;
        end
        if _Type and Logic.GetEntityType(_ID) ~= _Type then
            return false;
        end
        if _Category and Logic.IsEntityInCategory(_ID, _Category) == 0 then
            return false;
        end
        if _Territory and GetTerritoryUnderEntity(_ID) ~= _Territory then
            return false;
        end
        return true;
    end
    return API.CommenceEntitySearch(Filter);
end

---
-- Findet alle Entities deren Skriptname das Suchwort enthält.
--
-- @param[type=number] _Pattern Suchwort
-- @return[type=table] Liste mit Ergebnissen
-- @within Suche
-- @see API.CommenceEntitySearch
--
-- @usage
-- -- Findet alle Entities, deren Name mit "TreasureChest" beginnt.
-- local Result = API.SearchEntitiesByScriptname("^TreasureChest");
--
function API.SearchEntitiesByScriptname(_Pattern)
    _Filter = _Filter or function(_ID)
        local ScriptName = Logic.GetEntityName(_ID);
        if not string.find(ScriptName, _Pattern) then
            return false;
        end
        return true;
    end
    return ModuleEntity.Shared:IterateOverEntities(_Filter);
end

---
-- Führt eine benutzerdefinierte Suche nach Entities aus.
--
-- <b>Achtung</b>: Die Reihenfolge der Abfragen im Filter hat direkten
-- Einfluss auf die Dauer der Suche. Während Abfragen auf den Besitzer oder
-- den Typ schnell gehen, dauern Gebietssuchen lange! Es ist daher klug, zuerst
-- Kriterien auszuschließen, die schnell bestimmt werden können!
--
-- @param[type=function] _Filter Funktion zur Filterung
-- @return[type=table] Liste mit Ergebnissen
-- @within Suche
-- @see QSB.SearchPredicate
--
-- @usage
-- -- Es werden alle Kühe und Schafe von Spieler 1 gefunden, die nicht auf den
-- -- Territorien 7 und 15 sind.
-- local Result = API.CommenceEntitySearch(
--     function(_ID)
--         -- Nur Entities von Spieler 1 akzeptieren
--         if Logic.EntityGetPlayer(_ID) == 1 then
--             -- Nur Entities akzeptieren, die Kühe oder Schafe sind.
--             if Logic.IsEntityInCategory(_ID, EntityCategories.CattlePasture) == 1
--             or Logic.IsEntityInCategory(_ID, EntityCategories.SheepPasture) == 1 then
--                 -- Nur Entities akzeptieren, die nicht auf den Territorien 7 und 15 sind.
--                 local Territory = GetTerritoryUnderEntity(_ID);
--                 return Territory ~= 7 and Territory ~= 15;
--             end
--         end
--         return false;
--     end
-- );
--
function API.CommenceEntitySearch(_Filter)
    _Filter = _Filter or function(_ID)
        return true;
    end
    return ModuleEntity.Shared:IterateOverEntities(_Filter);
end

-- Compatibility option
function API.GetEntitiesOfCategoryInTerritory(_PlayerID, _Category, _Territory)
    return API.SearchEntitiesOfCategoryInTerritory(_Territory, _Category, _PlayerID);
end

-- Compatibility option
-- FIXME: Realy needed? Don't they throw the old version in the script anyway?
function API.GetEntitiesOfCategoriesInTerritories(_PlayerID, _Category, _Territory)
    local p = (type(_PlayerID) == "table" and _PlayerID) or {_PlayerID};
    local c = (type(_Category) == "table" and _Category) or {_Category};
    local t = (type(_Territory) == "table" and _Territory) or {_Territory};
    local PlayerEntities = {};
    for i=1, #p, 1 do
        for j=1, #c, 1 do
            for k=1, #t, 1 do
                local Units = API.SearchEntitiesOfCategoryInTerritory(t[k], c[j], p[i]);
                PlayerEntities = Array_Append(PlayerEntities, Units);
            end
        end
    end
    return PlayerEntities;
end

-- -------------------------------------------------------------------------- --
-- Thief

---
-- Deaktiviert die Standardaktion wenn ein Dieb in ein Lagerhaus eindringt.
--
-- <b>Hinweis</b>: Wird die Standardaktion deaktiviert, stielt der Dieb
-- stattdessen Informationen.
--
-- @param[type=boolean] _Flag Standardeffekt deaktiviert
-- @within Dieb
--
-- @usage
-- -- Deaktivieren
-- API.ThiefDisableStorehouseEffect(true);
-- -- Aktivieren
-- API.ThiefDisableStorehouseEffect(false);
--
function API.ThiefDisableStorehouseEffect(_Flag)
    ModuleEntity.Global.DisableThiefStorehouseHeist = _Flag == true;
end

---
-- Deaktiviert die Standardaktion wenn ein Dieb in eine Kirche eindringt.
--
-- <b>Hinweis</b>: Wird die Standardaktion deaktiviert, stielt der Dieb
-- stattdessen Informationen.
--
-- @param[type=boolean] _Flag Standardeffekt deaktiviert
-- @within Dieb
--
-- @usage
-- -- Deaktivieren
-- API.ThiefDisableCathedralEffect(true);
-- -- Aktivieren
-- API.ThiefDisableCathedralEffect(false);
--
function API.ThiefDisableCathedralEffect(_Flag)
    ModuleEntity.Global.DisableThiefCathedralSabotage = _Flag == true;
end

---
-- Deaktiviert die Standardaktion wenn ein Dieb einen Brunnen sabotiert.
--
-- <b>Hinweis</b>: Brunnen können nur im Addon gebaut und sabotiert werden.
--
-- @param[type=boolean] _Flag Standardeffekt deaktiviert
-- @within Dieb
--
-- @usage
-- -- Deaktivieren
-- API.ThiefDisableCisternEffect(true);
-- -- Aktivieren
-- API.ThiefDisableCisternEffect(false);
--
function API.ThiefDisableCisternEffect(_Flag)
    ModuleEntity.Global.DisableThiefCisternSabotage = _Flag == true;
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleGuiControl = {
    Properties = {
        Name = "ModuleGuiControl",
        Version = "3.0.0 (BETA 2.0.0)"
    },

    Global = {},
    Local = {
        HiddenWidgets = {},
        HotkeyDescriptions = {},
        SpeedLimit = 1,
    },

    Shared = {
        Text = {
            Message = {
                NoSpeedUp = {
                    de = "Die Spielgeschwindigkeit kann nicht erhöht werden!",
                    en = "The game speed can not be increased!",
                    fr = "La vitesse du jeu ne peut pas être augmentée!"
                }
            }
        }
    };
}

QSB.PlayerNames = {};

-- Global ------------------------------------------------------------------- --

function ModuleGuiControl.Global:OnGameStart()
    QSB.ScriptEvents.BuildingPlaced = API.RegisterScriptEvent("Event_BuildingPlaced");

    API.RegisterScriptCommand("Cmd_UpdateTexturePosition", function(_Category, _Key, _Value)
        g_TexturePositions = g_TexturePositions or {};
        g_TexturePositions[_Category] = g_TexturePositions[_Category] or {};
        g_TexturePositions[_Category][_Key] = _Value;
    end);
end

function ModuleGuiControl.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- Local -------------------------------------------------------------------- --

function ModuleGuiControl.Local:OnGameStart()
    QSB.ScriptEvents.BuildingPlaced = API.RegisterScriptEvent("Event_BuildingPlaced");

    self:PostTexturePositionsToGlobal();
    self:OverrideAfterBuildingPlacement();
    self:OverrideMissionGoodCounter();
    self:OverrideUpdateClaimTerritory();
    self:SetupHackRegisterHotkey();
    self:InitForbidSpeedUp();
end

function ModuleGuiControl.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.SaveGameLoaded then
        self:UpdateHiddenWidgets();
    end
end

-- -------------------------------------------------------------------------- --

function ModuleGuiControl.Local:OverrideAfterBuildingPlacement()
    GameCallback_GUI_AfterBuildingPlacement_Orig_EntityEventCore = GameCallback_GUI_AfterBuildingPlacement;
    GameCallback_GUI_AfterBuildingPlacement = function ()
        GameCallback_GUI_AfterBuildingPlacement_Orig_EntityEventCore();

        local x,y = GUI.Debug_GetMapPositionUnderMouse();
        API.StartHiResDelay(0, function()
            local Results = {Logic.GetPlayerEntitiesInArea(GUI.GetPlayerID(), 0, x, y, 50, 16)};
            for i= 2, Results[1] +1 do
                if  Results[i]
                and Results[i] ~= 0
                and Logic.IsBuilding(Results[i]) == 1
                and Logic.IsConstructionComplete(Results[i]) == 0
                then
                    API.BroadcastScriptEventToGlobal("BuildingPlaced", Results[i], Logic.EntityGetPlayer(Results[i]));
                    API.SendScriptEvent(QSB.ScriptEvents.BuildingPlaced, Results[i], Logic.EntityGetPlayer(Results[i]));
                end
            end
        end, x, y);
    end
end

-- -------------------------------------------------------------------------- --

function ModuleGuiControl.Local:PostTexturePositionsToGlobal()
    API.StartJob(function()
        if Logic.GetTime() > 1 then
            for k, v in pairs(g_TexturePositions) do
                for kk, vv in pairs(v) do
                    API.SendScriptCommand(
                        QSB.ScriptCommands.UpdateTexturePosition,
                        GUI.GetPlayerID(),
                        k,
                        kk,
                        vv
                    );
                end
            end
            return true;
        end
    end);
end

-- -------------------------------------------------------------------------- --

function ModuleGuiControl.Local:DisplayInterfaceButton(_Widget, _Hide)
    self.HiddenWidgets[_Widget] = _Hide == true;
    XGUIEng.ShowWidget(_Widget, (_Hide == true and 0) or 1);
end

function ModuleGuiControl.Local:UpdateHiddenWidgets()
    for k, v in pairs(self.HiddenWidgets) do
        XGUIEng.ShowWidget(k, 0);
    end
end

function ModuleGuiControl.Local:OverrideMissionGoodCounter()
    StartMissionGoodOrEntityCounter = function(_Icon, _AmountToReach)
        local IconWidget = "/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon";
        local CounterWidget = "/InGame/Root/Normal/MissionGoodOrEntityCounter";
        if type(_Icon[3]) == "string" or _Icon[3] > 2 then
            ModuleGuiControl.Local:SetIcon(IconWidget, _Icon, 64, _Icon[3]);
        else
            SetIcon(IconWidget, _Icon);
        end
        g_MissionGoodOrEntityCounterAmountToReach = _AmountToReach;
        g_MissionGoodOrEntityCounterIcon = _Icon;
        XGUIEng.ShowWidget(CounterWidget, 1);
    end
end

function ModuleGuiControl.Local:OverrideUpdateClaimTerritory()
    GUI_Knight.ClaimTerritoryUpdate_Orig_QSB_Interface = GUI_Knight.ClaimTerritoryUpdate;
    GUI_Knight.ClaimTerritoryUpdate = function()
        GUI_Knight.ClaimTerritoryUpdate_Orig_QSB_Interface();
        local Key = "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/ClaimTerritory";
        if ModuleGuiControl.Local.HiddenWidgets[Key] == true then
            XGUIEng.ShowWidget(Key, 0);
            return true;
        end
    end
end

function ModuleGuiControl.Local:SetPlayerPortraitByPrimaryKnight(_PlayerID)
    local KnightID = Logic.GetKnightID(_PlayerID);
    local HeadModelName = "H_NPC_Generic_Trader";
    if KnightID ~= 0 then
        local KnightType = Logic.GetEntityType(KnightID);
        local KnightTypeName = Logic.GetEntityTypeName(KnightType);
        HeadModelName = "H" .. string.sub(KnightTypeName, 2, 8) .. "_" .. string.sub(KnightTypeName, 9);

        if not Models["Heads_" .. HeadModelName] then
            HeadModelName = "H_NPC_Generic_Trader";
        end
    end
    g_PlayerPortrait[_PlayerID] = HeadModelName;
end

function ModuleGuiControl.Local:SetPlayerPortraitBySettler(_PlayerID, _Portrait)
    local PortraitMap = {
        ["U_KnightChivalry"]           = "H_Knight_Chivalry",
        ["U_KnightHealing"]            = "H_Knight_Healing",
        ["U_KnightPlunder"]            = "H_Knight_Plunder",
        ["U_KnightRedPrince"]          = "H_Knight_RedPrince",
        ["U_KnightSabatta"]            = "H_Knight_Sabatt",
        ["U_KnightSong"]               = "H_Knight_Song",
        ["U_KnightTrading"]            = "H_Knight_Trading",
        ["U_KnightWisdom"]             = "H_Knight_Wisdom",
        ["U_NPC_Amma_NE"]              = "H_NPC_Amma",
        ["U_NPC_Castellan_ME"]         = "H_NPC_Castellan_ME",
        ["U_NPC_Castellan_NA"]         = "H_NPC_Castellan_NA",
        ["U_NPC_Castellan_NE"]         = "H_NPC_Castellan_NE",
        ["U_NPC_Castellan_SE"]         = "H_NPC_Castellan_SE",
        ["U_MilitaryBandit_Ranged_ME"] = "H_NPC_Mercenary_ME",
        ["U_MilitaryBandit_Melee_NA"]  = "H_NPC_Mercenary_NA",
        ["U_MilitaryBandit_Melee_NE"]  = "H_NPC_Mercenary_NE",
        ["U_MilitaryBandit_Melee_SE"]  = "H_NPC_Mercenary_SE",
        ["U_NPC_Monk_ME"]              = "H_NPC_Monk_ME",
        ["U_NPC_Monk_NA"]              = "H_NPC_Monk_NA",
        ["U_NPC_Monk_NE"]              = "H_NPC_Monk_NE",
        ["U_NPC_Monk_SE"]              = "H_NPC_Monk_SE",
        ["U_NPC_Villager01_ME"]        = "H_NPC_Villager01_ME",
        ["U_NPC_Villager01_NA"]        = "H_NPC_Villager01_NA",
        ["U_NPC_Villager01_NE"]        = "H_NPC_Villager01_NE",
        ["U_NPC_Villager01_SE"]        = "H_NPC_Villager01_SE",
    }

    if g_GameExtraNo > 0 then
        PortraitMap["U_KnightPraphat"]           = "H_Knight_Praphat";
        PortraitMap["U_KnightSaraya"]            = "H_Knight_Saraya";
        PortraitMap["U_KnightKhana"]             = "H_Knight_Khana";
        PortraitMap["U_MilitaryBandit_Melee_AS"] = "H_NPC_Mercenary_AS";
        PortraitMap["U_NPC_Castellan_AS"]        = "H_NPC_Castellan_AS";
        PortraitMap["U_NPC_Villager_AS"]         = "H_NPC_Villager_AS";
        PortraitMap["U_NPC_Monk_AS"]             = "H_NPC_Monk_AS";
        PortraitMap["U_NPC_Monk_Khana"]          = "H_NPC_Monk_Khana";
    end

    local HeadModelName = "H_NPC_Generic_Trader";
    local EntityID = GetID(_Portrait);
    if EntityID ~= 0 then
        local EntityType = Logic.GetEntityType(EntityID);
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);
        HeadModelName = PortraitMap[EntityTypeName] or "H_NPC_Generic_Trader";
        if not HeadModelName then
            HeadModelName = "H_NPC_Generic_Trader";
        end
    end
    g_PlayerPortrait[_PlayerID] = HeadModelName;
end

function ModuleGuiControl.Local:SetPlayerPortraitByModelName(_PlayerID, _Portrait)
    if not Models["Heads_" .. tostring(_Portrait)] then
        _Portrait = "H_NPC_Generic_Trader";
    end
    g_PlayerPortrait[_PlayerID] = _Portrait;
end

function ModuleGuiControl.Local:SetIcon(_WidgetID, _Coordinates, _Size, _Name)
    _Size = _Size or 64;
    _Coordinates[3] = _Coordinates[3] or 0;
    if _Name == nil then
        return SetIcon(_WidgetID, _Coordinates, _Size);
    end
    assert(_Size == 44 or _Size == 64 or _Size == 128);
    if _Size == 44 then
        _Name = _Name.. ".png";
    end
    if _Size == 64 then
        _Name = _Name.. "big.png";
    end
    if _Size == 128 then
        _Name = _Name.. "verybig.png";
    end

    local u0, u1, v0, v1;
    u0 = (_Coordinates[1] - 1) * _Size;
    v0 = (_Coordinates[2] - 1) * _Size;
    u1 = (_Coordinates[1]) * _Size;
    v1 = (_Coordinates[2]) * _Size;
    State = 1;
    if XGUIEng.IsButton(_WidgetID) == 1 then
        State = 7;
    end
    XGUIEng.SetMaterialAlpha(_WidgetID, State, 255);
    XGUIEng.SetMaterialTexture(_WidgetID, State, _Name);
    XGUIEng.SetMaterialUV(_WidgetID, State, u0, v0, u1, v1);
end

function ModuleGuiControl.Local:TooltipNormal(_title, _text, _disabledText)
    if _title and _title:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _title = XGUIEng.GetStringTableText(_title);
    end
    if _text and _text:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _text = XGUIEng.GetStringTableText(_text);
    end
    _disabledText = _disabledText or "";
    if _disabledText and _disabledText:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _disabledText = XGUIEng.GetStringTableText(_disabledText);
    end

    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG");
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn");
    local PositionWidget = XGUIEng.GetCurrentWidgetID();

    local title = (_title and _title) or "";
    local text = (_text and _text) or "";
    local disabled = "";
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _disabledText;
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. title);
    XGUIEng.SetText(TooltipDescriptionWidget, text .. disabled);
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);

    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget);
    local TooltipContainerSizeWidgets = {TooltipBGWidget};
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget);
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer);
end

function ModuleGuiControl.Local:TooltipCosts(_title,_text,_disabledText,_costs,_inSettlement)
    _costs = _costs or {};
    local Costs = {};
    -- This transforms the content of a metatable to a new table so that the
    -- internal script does correctly render the costs.
    for i= 1, 4, 1 do
        Costs[i] = _costs[i];
    end
    if _title and _title:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _title = XGUIEng.GetStringTableText(_title);
    end
    if _text and _text:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _text = XGUIEng.GetStringTableText(_text);
    end
    if _disabledText and _disabledText:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _disabledText = XGUIEng.GetStringTableText(_disabledText);
    end

    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy";
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG");
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn");
    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs");
    local PositionWidget = XGUIEng.GetCurrentWidgetID();

    local title = (_title and _title) or "";
    local text = (_text and _text) or "";
    local disabled = "";
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _disabledText;
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. title);
    XGUIEng.SetText(TooltipDescriptionWidget, text .. disabled);
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);

    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget);
    GUI_Tooltip.SetCosts(TooltipCostsContainer, Costs, _inSettlement);
    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget};
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true);
    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget);
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer);
end

function ModuleGuiControl.Local:SetupHackRegisterHotkey()
    function g_KeyBindingsOptions:OnShow()
        if Game ~= nil then
            XGUIEng.ShowWidget("/InGame/KeyBindingsMain/Backdrop", 1);
        else
            XGUIEng.ShowWidget("/InGame/KeyBindingsMain/Backdrop", 0);
        end

        if g_KeyBindingsOptions.Descriptions == nil then
            g_KeyBindingsOptions.Descriptions = {};
            DescRegister("MenuInGame");
            DescRegister("MenuDiplomacy");
            DescRegister("MenuProduction");
            DescRegister("MenuPromotion");
            DescRegister("MenuWeather");
            DescRegister("ToggleOutstockInformations");
            DescRegister("JumpMarketplace");
            DescRegister("JumpMinimapEvent");
            DescRegister("BuildingUpgrade");
            DescRegister("BuildLastPlaced");
            DescRegister("BuildStreet");
            DescRegister("BuildTrail");
            DescRegister("KnockDown");
            DescRegister("MilitaryAttack");
            DescRegister("MilitaryStandGround");
            DescRegister("MilitaryGroupAdd");
            DescRegister("MilitaryGroupSelect");
            DescRegister("MilitaryGroupStore");
            DescRegister("MilitaryToggleUnits");
            DescRegister("UnitSelect");
            DescRegister("UnitSelectToggle");
            DescRegister("UnitSelectSameType");
            DescRegister("StartChat");
            DescRegister("StopChat");
            DescRegister("QuickSave");
            DescRegister("QuickLoad");
            DescRegister("TogglePause");
            DescRegister("RotateBuilding");
            DescRegister("ExitGame");
            DescRegister("Screenshot");
            DescRegister("ResetCamera");
            DescRegister("CameraMove");
            DescRegister("CameraMoveMouse");
            DescRegister("CameraZoom");
            DescRegister("CameraZoomMouse");
            DescRegister("CameraRotate");

            for k,v in pairs(ModuleGuiControl.Local.HotkeyDescriptions) do
                if v then
                    v[1] = (type(v[1]) == "table" and API.Localize(v[1])) or v[1];
                    v[2] = (type(v[2]) == "table" and API.Localize(v[2])) or v[2];
                    table.insert(g_KeyBindingsOptions.Descriptions, 1, v);
                end
            end
        end
        XGUIEng.ListBoxPopAll(g_KeyBindingsOptions.Widget.ShortcutList);
        XGUIEng.ListBoxPopAll(g_KeyBindingsOptions.Widget.ActionList);
        for Index, Desc in ipairs(g_KeyBindingsOptions.Descriptions) do
            XGUIEng.ListBoxPushItem(g_KeyBindingsOptions.Widget.ShortcutList, Desc[1]);
            XGUIEng.ListBoxPushItem(g_KeyBindingsOptions.Widget.ActionList,   Desc[2]);
        end
    end
end

-- -------------------------------------------------------------------------- --

function ModuleGuiControl.Local:SetSpeedLimit(_Limit)
    if Framework.IsNetworkGame() then
        debug("ModuleGuiControl: Detect network game. Aborting!");
        return;
    end
    _Limit = (_Limit < 1 and 1) or math.floor(_Limit);
    debug("ModuleGuiControl: Setting speed limit to " .._Limit);
    self.SpeedLimit = _Limit;
end

function ModuleGuiControl.Local:ActivateSpeedLimit(_Flag)
    if Framework.IsNetworkGame() then
        debug("ModuleGuiControl: Detect network game. Aborting!");
        return;
    end
    self.UseSpeedLimit = _Flag == true;
    if _Flag and Game.GameTimeGetFactor(GUI.GetPlayerID()) > self.SpeedLimit then
        debug("ModuleGuiControl: Speed is capped at " ..self.SpeedLimit);
        Game.GameTimeSetFactor(GUI.GetPlayerID(), self.SpeedLimit);
        g_GameSpeed = 1;
    end
end

function ModuleGuiControl.Local:InitForbidSpeedUp()
    GameCallback_GameSpeedChanged_Orig_Preferences_ForbidSpeedUp = GameCallback_GameSpeedChanged;
    GameCallback_GameSpeedChanged = function( _Speed )
        GameCallback_GameSpeedChanged_Orig_Preferences_ForbidSpeedUp( _Speed );
        if ModuleGuiControl.Local.UseSpeedLimit == true then
            debug("ModuleGuiControl: Checking speed limit.");
            if _Speed > ModuleGuiControl.Local.SpeedLimit then
                debug("ModuleGuiControl: Speed is capped at " ..tostring(_Speed).. ".");
                Game.GameTimeSetFactor(GUI.GetPlayerID(), ModuleGuiControl.Local.SpeedLimit);
                g_GameSpeed = 1;
                API.Message(ModuleGuiControl.Shared.Text.Message.NoSpeedUp);
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleGuiControl);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Ermöglicht, die Anzeige von Menüoptionen zu steuern.
--
-- Es können verschiedene Anzeigen ausgetauscht werden.
-- <ul>
-- <li>Spielerfrabe</li>
-- <li>Spielername</li>
-- <li>Spielerportrait</li>
-- <li>Territorienname</li>
-- </ul>
--
-- Es können verschiedene Zugriffsoptionen für den Spieler gesetzt werden.
-- <ul>
-- <li>Minimap anzeigen/deaktivieren</li>
-- <li>Minimap umschalten anzeigen/deaktivieren</li>
-- <li>Diplomatiemenü anzeigen/deaktivieren</li>
-- <li>Produktionsmenü anzeigen/deaktivieren</li>
-- <li>Wettermenü anzeigen/deaktivieren</li>
-- <li>Baumenü anzeigen/deaktivieren</li>
-- <li>Territorium einnehmen anzeigen/deaktivieren</li>
-- <li>Ritterfähigkeit anzeigen/deaktivieren</li>
-- <li>Ritter selektieren anzeigen/deaktivieren</li>
-- <li>Militär selektieren anzeigen/deaktivieren</li>
-- </ul>
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field BuildingPlaced      Ein Gebäude wurde in Auftrag gegeben. (Parameter: EntityID, PlayerID)
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Gibt den Namen des Territoriums zurück.
--
-- @param[type=number] _TerritoryID ID des Territoriums
-- @return[type=string]  Name des Territorium
-- @within Anwenderfunktionen
--
function API.GetTerritoryName(_TerritoryID)
    local Name = Logic.GetTerritoryName(_TerritoryID);
    local MapType = Framework.GetCurrentMapTypeAndCampaignName();
    if MapType == 1 or MapType == 3 then
        return Name;
    end

    local MapName = Framework.GetCurrentMapName();
    local StringTable = "Map_" .. MapName;
    local TerritoryName = string.gsub(Name, " ","");
    TerritoryName = XGUIEng.GetStringTableText(StringTable .. "/Territory_" .. TerritoryName);
    if TerritoryName == "" then
        TerritoryName = Name .. "(key?)";
    end
    return TerritoryName;
end
GetTerritoryName = API.GetTerritoryName;

---
-- Gibt den Namen des Spielers zurück.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=string]  Name des Spielers
-- @within Anwenderfunktionen
--
function API.GetPlayerName(_PlayerID)
    local PlayerName = Logic.GetPlayerName(_PlayerID);
    local name = QSB.PlayerNames[_PlayerID];
    if name ~= nil and name ~= "" then
        PlayerName = name;
    end

    local MapType = Framework.GetCurrentMapTypeAndCampaignName();
    local MutliplayerMode = Framework.GetMultiplayerMapMode(Framework.GetCurrentMapName(), MapType);

    if MutliplayerMode > 0 then
        return PlayerName;
    end
    if MapType == 1 or MapType == 3 then
        local PlayerNameTmp, PlayerHeadTmp, PlayerAITmp = Framework.GetPlayerInfo(_PlayerID);
        if PlayerName ~= "" then
            return PlayerName;
        end
        return PlayerNameTmp;
    end
end
GetPlayerName_OrigName = GetPlayerName;
GetPlayerName = API.GetPlayerName;

---
-- Gibt dem Spieler einen neuen Namen.
--
-- <b>hinweis</b>: Die Änderung des Spielernamens betrifft sowohl die Anzeige
-- bei den Quests als auch im Diplomatiemenü.
--
-- @param[type=number] _playerID ID des Spielers
-- @param[type=string] _name Name des Spielers
-- @within Anwenderfunktionen
--
function API.SetPlayerName(_playerID,_name)
    assert(type(_playerID) == "number");
    assert(type(_name) == "string");
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SetPlayerName(%d, "%s")]],
            _playerID,
            _name
        ));
        return;
    end
    GUI_MissionStatistic.PlayerNames[_playerID] = _name
    QSB.PlayerNames[_playerID] = _name;
end
SetPlayerName = API.SetPlayerName;

---
-- Setzt eine andere Spielerfarbe.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Color Spielerfarbe
-- @param[type=number] _Logo Logo (optional)
-- @param[type=number] _Pattern Pattern (optional)
-- @within Anwenderfunktionen
--
function API.SetPlayerColor(_PlayerID, _Color, _Logo, _Pattern)
    if GUI then
        return;
    end
    g_ColorIndex["ExtraColor1"] = g_ColorIndex["ExtraColor1"] or 16;
    g_ColorIndex["ExtraColor2"] = g_ColorIndex["ExtraColor2"] or 17;

    local Col     = (type(_Color) == "string" and g_ColorIndex[_Color]) or _Color;
    local Logo    = _Logo or -1;
    local Pattern = _Pattern or -1;

    Logic.PlayerSetPlayerColor(_PlayerID, Col, Logo, Pattern);
    Logic.ExecuteInLuaLocalState([[
        Display.UpdatePlayerColors()
        GUI.RebuildMinimapTerrain()
        GUI.RebuildMinimapTerritory()
    ]]);
end

---
-- Setzt das Portrait eines Spielers.
--
-- Dabei gibt es 3 verschiedene Varianten:
-- <ul>
-- <li>Wenn _Portrait nicht gesetzt wird, wird das Portrait des Primary
-- Knight genommen.</li>
-- <li>Wenn _Portrait ein existierendes Entity ist, wird anhand des Typs
-- das Portrait bestimmt.</li>
-- <li>Wenn _Portrait der Modellname eines Portrait ist, wird der Wert
-- als Portrait gesetzt.</li>
-- </ul>
--
-- Wenn kein Portrait bestimmt werden kann, wird H_NPC_Generic_Trader verwendet.
--
-- <b>Trivia</b>: Diese Funktionalität wird Umgangssprachlich als "Kopf
-- tauschen" oder "Kopf wechseln" bezeichnet.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=string] _Portrait Name des Models
-- @within Anwenderfunktionen
--
-- @usage
-- -- Kopf des Primary Knight
-- API.SetPlayerPortrait(2);
-- -- Kopf durch Entity bestimmen
-- API.SetPlayerPortrait(2, "amma");
-- -- Kopf durch Modelname setzen
-- API.SetPlayerPortrait(2, "H_NPC_Monk_AS");
--
function API.SetPlayerPortrait(_PlayerID, _Portrait)
    if not _PlayerID or type(_PlayerID) ~= "number" or (_PlayerID < 1 or _PlayerID > 8) then
        error("API.SetPlayerPortrait: Invalid player ID!");
        return;
    end
    if not GUI then
        local Portrait = (_Portrait ~= nil and "'" .._Portrait.. "'") or "nil";
        Logic.ExecuteInLuaLocalState("API.SetPlayerPortrait(" .._PlayerID.. ", " ..Portrait.. ")")
        return;
    end

    if _Portrait == nil then
        ModuleGuiControl.Local:SetPlayerPortraitByPrimaryKnight(_PlayerID);
        return;
    end
    if _Portrait ~= nil and IsExisting(_Portrait) then
        ModuleGuiControl.Local:SetPlayerPortraitBySettler(_PlayerID, _Portrait);
        return;
    end
    ModuleGuiControl.Local:SetPlayerPortraitByModelName(_PlayerID, _Portrait);
end

---
-- Fügt eine Beschreibung zu einem benutzerdefinierten Hotkey hinzu.
--
-- Ist der Hotkey bereits vorhanden, wird -1 zurückgegeben.
--
-- <b>Hinweis</b>: Diese Funktionalität selbst muss mit Input.KeyBindDown oder
-- Input.KeyBindUp separat implementiert werden!
--
-- @param[type=string] _Key         Tastenkombination
-- @param[type=string] _Description Beschreibung des Hotkey
-- @return[type=number] Index oder Fehlercode
-- @within Anwenderfunktionen
-- @local
--
function API.AddShortcutEntry(_Key, _Description)
    if not GUI then
        return;
    end
    g_KeyBindingsOptions.Descriptions = nil;
    for i= 1, #ModuleGuiControl.Local.HotkeyDescriptions do
        if ModuleGuiControl.Local.HotkeyDescriptions[i][1] == _Key then
            return -1;
        end
    end
    local ID = #ModuleGuiControl.Local.HotkeyDescriptions+1;
    table.insert(ModuleGuiControl.Local.HotkeyDescriptions, {ID = ID, _Key, _Description});
    return #ModuleGuiControl.Local.HotkeyDescriptions;
end

---
-- Entfernt eine Beschreibung eines benutzerdefinierten Hotkeys.
--
-- @param[type=number] _ID Index in Table
-- @within Anwenderfunktionen
-- @local
--
function API.RemoveShortcutEntry(_ID)
    if not GUI then
        return;
    end
    g_KeyBindingsOptions.Descriptions = nil;
    for k, v in pairs(ModuleGuiControl.Local.HotkeyDescriptions) do
        if v.ID == _ID then
            ModuleGuiControl.Local.HotkeyDescriptions[k] = nil;
        end
    end
end

---
-- Setzt einen Icon aus einer Icon Matrix.
--
-- Es ist möglich, eine benutzerdefinierte Icon Matrix zu verwenden.
-- Dafür müssen die Quellen nach gui_768, gui_920 und gui_1080 in der
-- entsprechenden Größe gepackt werden, da das Spiel für unterschiedliche
-- Auflösungen in verschiedene Verzeichnisse schaut.
-- 
-- Die Dateien müssen in <i>graphics/textures</i> liegen, was auf gleicher
-- Ebene ist, wie <i>maps/externalmap</i>.
-- Jede Map muss einen eigenen eindeutigen Namen für jede Grafik verwenden, da
-- diese Grafiken solange geladen werden, wie die Map im Verzeichnis liegt.
--
-- Es können 3 verschiedene Icon-Größen angegeben werden. Je nach dem welche
-- Größe gefordert wird, wird nach einer anderen Datei gesucht. Es entscheidet
-- der als Name angegebene Präfix.
-- <ul>
-- <li>keine: siehe 64</li>
-- <li>44: [Dateiname].png</li>
-- <li>64: [Dateiname]big.png</li>
-- <li>1200: [Dateiname]verybig.png</li>
-- </ul>
--
-- @param[type=string] _WidgetID Widgetpfad oder ID
-- @param[type=table]  _Coordinates Koordinaten [Format: {x, y, addon}]
-- @param[type=number] _Size (Optional) Größe des Icon
-- @param[type=string] _Name (Optional) Base Name der Icon Matrix
-- @within Anwenderfunktionen
--
-- @usage
-- -- Setzt eine Originalgrafik
-- API.SetIcon(AnyWidgetID, {1, 1, 1});
--
-- -- Setzt eine benutzerdefinierte Grafik
-- API.SetIcon(AnyWidgetID, {8, 5}, nil, "meinetollenicons");
-- -- (Es wird als Datei gesucht: meinetolleniconsbig.png)
--
-- -- Setzt eine benutzerdefinierte Grafik
-- API.SetIcon(AnyWidgetID, {8, 5}, 128, "meinetollenicons");
-- -- (Es wird als Datei gesucht: meinetolleniconsverybig.png)
--
function API.SetIcon(_WidgetID, _Coordinates, _Size, _Name)
    if not GUI then
        return;
    end
    _Coordinates = _Coordinates or {10, 14};
    ModuleGuiControl.Local:SetIcon(_WidgetID, _Coordinates, _Size, _Name);
end

---
-- Ändert den Beschreibungstext eines Button oder eines Icon.
--
-- Wichtig ist zu beachten, dass diese Funktion in der Tooltip-Funktion des
-- Button oder Icon ausgeführt werden muss.
--
-- Die Funktion kann auch mit deutsch/english lokalisierten Tabellen als
-- Text gefüttert werden. In diesem Fall wird der deutsche Text genommen,
-- wenn es sich um eine deutsche Spielversion handelt. Andernfalls wird
-- immer der englische Text verwendet.
--
-- @param[type=string] _title        Titel des Tooltip
-- @param[type=string] _text         Text des Tooltip
-- @param[type=string] _disabledText Textzusatz wenn inaktiv
-- @within Anwenderfunktionen
--
function API.SetTooltipNormal(_title, _text, _disabledText)
    if not GUI then
        return;
    end
    ModuleGuiControl.Local:TooltipNormal(_title, _text, _disabledText);
end

---
-- Ändert den Beschreibungstext und die Kosten eines Button.
--
-- Wichtig ist zu beachten, dass diese Funktion in der Tooltip-Funktion des
-- Button oder Icon ausgeführt werden muss.
--
-- @see API.SetTooltipNormal
--
-- @param[type=string]  _title        Titel des Tooltip
-- @param[type=string]  _text         Text des Tooltip
-- @param[type=string]  _disabledText Textzusatz wenn inaktiv
-- @param[type=table]   _costs        Kostentabelle
-- @param[type=boolean] _inSettlement Kosten in Siedlung suchen
-- @within Anwenderfunktionen
--
function API.SetTooltipCosts(_title,_text,_disabledText,_costs,_inSettlement)
    if not GUI then
        return;
    end
    ModuleGuiControl.Local:TooltipCosts(_title,_text,_disabledText,_costs,_inSettlement);
end

---
-- Graut die Minimap aus oder macht sie wieder verwendbar.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.HideMinimap(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.HideMinimap(" ..tostring(_Flag).. ")");
        return;
    end

    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapOverlay",_Flag);
    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapTerrain",_Flag);
end

---
-- Versteckt den Umschaltknopf der Minimap oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.HideToggleMinimap(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.HideToggleMinimap(" ..tostring(_Flag).. ")");
        return;
    end

    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/MinimapButton",_Flag);
end

---
-- Versteckt den Button des Diplomatiemenü oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.HideDiplomacyMenu(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.HideDiplomacyMenu(" ..tostring(_Flag).. ")");
        return;
    end

    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/DiplomacyMenuButton",_Flag);
end

---
-- Versteckt den Button des Produktionsmenü oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.HideProductionMenu(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.HideProductionMenu(" ..tostring(_Flag).. ")");
        return;
    end

    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/ProductionMenuButton",_Flag);
end

---
-- Versteckt den Button des Wettermenüs oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.HideWeatherMenu(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.HideWeatherMenu(" ..tostring(_Flag).. ")");
        return;
    end

    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/WeatherMenuButton",_Flag);
end

---
-- Versteckt den Button zum Territorienkauf oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.HideBuyTerritory(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.HideBuyTerritory(" ..tostring(_Flag).. ")");
        return;
    end

    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/ClaimTerritory",_Flag);
end

---
-- Versteckt den Button der Heldenfähigkeit oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.HideKnightAbility(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.HideKnightAbility(" ..tostring(_Flag).. ")");
        return;
    end

    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/StartAbilityProgress",_Flag);
    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/StartAbility",_Flag);
end

---
-- Versteckt den Button zur Heldenselektion oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.HideKnightButton(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.HideKnightButton(" ..tostring(_Flag).. ")");
        Logic.SetEntitySelectableFlag("..KnightID..", (_Flag and 0) or 1);
        return;
    end

    local KnightID = Logic.GetKnightID(GUI.GetPlayerID());
    if _Flag then
        GUI.DeselectEntity(KnightID);
    end

    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButtonProgress",_Flag);
    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButton",_Flag);
end

---
-- Versteckt den Button zur Selektion des Militärs oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.HideSelectionButton(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.HideSelectionButton(" ..tostring(_Flag).. ")");
        return;
    end
    API.HideKnightButton(_Flag);
    GUI.ClearSelection();

    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/BattalionButton",_Flag);
end

---
-- Versteckt das Baumenü oder blendet es ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.HideBuildMenu(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.HideBuildMenu(" ..tostring(_Flag).. ")");
        return;
    end

    ModuleGuiControl.Local:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/BuildMenu", _Flag);
end

---
-- Setzt die Spielgeschwindigkeit auf Stufe 1 fest oder gibt sie wieder frei.
--
-- <b>Hinweis</b>: Die Geschwindigkeitsbeschränkung wirkt sich ebenfalls auf
-- Cheats aus. Es ist generell nicht mehr möglich, das Spiel zu beschleunigen,
-- wenn die "Speedbremse" aktiv ist.
--
-- @param[type=boolean] _Flag Speedbremse ist aktiv
-- @within Anwenderfunktionen
--
-- @usage
-- -- Geschwindigkeit auf Stufe 1 festsetzen
-- API.SpeedLimitActivate(true);
-- -- Geschwindigkeit freigeben
-- API.SpeedLimitActivate(false);
--
function API.SpeedLimitActivate(_Flag)
    if GUI or Framework.IsNetworkGame() then
        return;
    end
    return Logic.ExecuteInLuaLocalState("ModuleGuiControl.Local:ActivateSpeedLimit(" ..tostring(_Flag).. ")");
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleGuiEffects = {
    Properties = {
        Name = "ModuleGuiEffects",
        Version = "3.0.0 (BETA 2.0.0)"
    },

    Global = {
        CinematicEventID = 0,
        CinematicEventStatus = {},
        CinematicEventQueue = {},
        TypewriterEventData = {},
        TypewriterEventCounter = 0,
    },
    Local = {
        CinematicEventStatus = {},
        ChatOptionsWasShown = false,
        MessageLogWasShown = false,
        PauseScreenShown = false,
        NormalModeHidden = false,
        BorderScrollDeactivated = false,
    },

    Shared = {};
}

QSB.FarClipDefault = {
    -- Default: 0
    -- Setting this to 0 when the max default is not also set to 0 results in
    -- nothing being rendered at all.
    MIN = 45000,
    -- Default: 1000000
    -- Using the default is way to much render distance and will cause the
    -- game to stutter when in cutscene mode.
    MAX = 45000
};
QSB.CinematicEvent = {};
QSB.CinematicEventTypes = {};

-- Global ------------------------------------------------------------------- --

function ModuleGuiEffects.Global:OnGameStart()
    QSB.ScriptEvents.BuildingPlaced = API.RegisterScriptEvent("Event_BuildingPlaced");
    QSB.ScriptEvents.CinematicActivated = API.RegisterScriptEvent("Event_CinematicEventActivated");
    QSB.ScriptEvents.CinematicConcluded = API.RegisterScriptEvent("Event_CinematicEventConcluded");
    QSB.ScriptEvents.BorderScrollLocked = API.RegisterScriptEvent("Event_BorderScrollLocked");
    QSB.ScriptEvents.BorderScrollReset = API.RegisterScriptEvent("Event_BorderScrollReset");
    QSB.ScriptEvents.GameInterfaceShown = API.RegisterScriptEvent("Event_GameInterfaceShown");
    QSB.ScriptEvents.GameInterfaceHidden = API.RegisterScriptEvent("Event_GameInterfaceHidden");
    QSB.ScriptEvents.ImageScreenShown = API.RegisterScriptEvent("Event_ImageScreenShown");
    QSB.ScriptEvents.ImageScreenHidden = API.RegisterScriptEvent("Event_ImageScreenHidden");
    QSB.ScriptEvents.TypewriterStarted = API.RegisterScriptEvent("Event_TypewriterStarted");
    QSB.ScriptEvents.TypewriterEnded = API.RegisterScriptEvent("Event_TypewriterEnded");

    for i= 1, 8 do
        self.CinematicEventStatus[i] = {};
        self.CinematicEventQueue[i] = {};
    end
    API.StartHiResJob(function()
        ModuleGuiEffects.Global:ControlTypewriter();
    end);
end

function ModuleGuiEffects.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.CinematicActivated then
        -- Save cinematic state
        self.CinematicEventStatus[arg[2]][arg[1]] = 1;
        -- deactivate black background
        Logic.ExecuteInLuaLocalState(string.format(
            "ModuleGuiEffects.Local:InterfaceDeactivateImageBackground(%d)",
            arg[2]
        ));
        -- activate GUI
        Logic.ExecuteInLuaLocalState(string.format(
            "ModuleGuiEffects.Local:InterfaceActivateNormalInterface(%d)",
            arg[2]
        ));
    elseif _ID == QSB.ScriptEvents.CinematicConcluded then
        -- Save cinematic state
        if self.CinematicEventStatus[arg[2]][arg[1]] then
            self.CinematicEventStatus[arg[2]][arg[1]] = 2;
        end
        if #self.CinematicEventQueue[arg[2]] > 0 then
            -- activate black background
            Logic.ExecuteInLuaLocalState(string.format(
                [[ModuleGuiEffects.Local:InterfaceActivateImageBackground(%d, "", 0, 0, 0, 255)]],
                arg[2]
            ));
            -- deactivate GUI
            Logic.ExecuteInLuaLocalState(string.format(
                "ModuleGuiEffects.Local:InterfaceDeactivateNormalInterface(%d)",
                arg[2]
            ));
        end
    end
end

function ModuleGuiEffects.Global:PushCinematicEventToQueue(_PlayerID, _Type, _Name, _Data)
    table.insert(self.CinematicEventQueue[_PlayerID], {_Type, _Name, _Data});
end

function ModuleGuiEffects.Global:LookUpCinematicInQueue(_PlayerID)
    if #self.CinematicEventQueue[_PlayerID] > 0 then
        return self.CinematicEventQueue[_PlayerID][1];
    end
end

function ModuleGuiEffects.Global:PopCinematicEventFromQueue(_PlayerID)
    if #self.CinematicEventQueue[_PlayerID] > 0 then
        return table.remove(self.CinematicEventQueue[_PlayerID], 1);
    end
end

function ModuleGuiEffects.Global:GetNewCinematicEventID()
    self.CinematicEventID = self.CinematicEventID +1;
    return self.CinematicEventID;
end

function ModuleGuiEffects.Global:GetCinematicEventStatus(_InfoID)
    for i= 1, 8 do
        if self.CinematicEventStatus[i][_InfoID] then
            return self.CinematicEventStatus[i][_InfoID];
        end
    end
    return 0;
end

function ModuleGuiEffects.Global:ActivateCinematicEvent(_PlayerID)
    local ID = self:GetNewCinematicEventID();
    API.SendScriptEvent(QSB.ScriptEvents.CinematicActivated, ID, _PlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.CinematicActivated, %d, %d);
          if GUI.GetPlayerID() == %d then
            ModuleGuiEffects.Local.SavingWasDisabled = Swift.Save.SavingDisabled == true;
            API.DisableSaving(true);
          end]],
        ID,
        _PlayerID,
        _PlayerID
    ))
    return ID;
end

function ModuleGuiEffects.Global:ConcludeCinematicEvent(_ID, _PlayerID)
    API.SendScriptEvent(QSB.ScriptEvents.CinematicConcluded, _ID, _PlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.CinematicConcluded, %d, %d);
          if GUI.GetPlayerID() == %d then
            if not ModuleGuiEffects.Local.SavingWasDisabled then
                API.DisableSaving(false);
            end
            ModuleGuiEffects.Local.SavingWasDisabled = false;
          end]],
        _ID,
        _PlayerID,
        _PlayerID
    ))
end

-- Local -------------------------------------------------------------------- --

function ModuleGuiEffects.Local:OnGameStart()
    QSB.ScriptEvents.CinematicActivated = API.RegisterScriptEvent("Event_CinematicEventActivated");
    QSB.ScriptEvents.CinematicConcluded = API.RegisterScriptEvent("Event_CinematicEventConcluded");
    QSB.ScriptEvents.BorderScrollLocked = API.RegisterScriptEvent("Event_BorderScrollLocked");
    QSB.ScriptEvents.BorderScrollReset  = API.RegisterScriptEvent("Event_BorderScrollReset");
    QSB.ScriptEvents.GameInterfaceShown = API.RegisterScriptEvent("Event_GameInterfaceShown");
    QSB.ScriptEvents.GameInterfaceHidden = API.RegisterScriptEvent("Event_GameInterfaceHidden");
    QSB.ScriptEvents.ImageScreenShown = API.RegisterScriptEvent("Event_ImageScreenShown");
    QSB.ScriptEvents.ImageScreenHidden = API.RegisterScriptEvent("Event_ImageScreenHidden");
    QSB.ScriptEvents.TypewriterStarted = API.RegisterScriptEvent("Event_TypewriterStarted");
    QSB.ScriptEvents.TypewriterEnded = API.RegisterScriptEvent("Event_TypewriterEnded");

    for i= 1, 8 do
        self.CinematicEventStatus[i] = {};
    end
    self:OverrideInterfaceUpdateForCinematicMode();
    self:OverrideInterfaceThroneroomForCinematicMode();
    self:ResetFarClipPlane();
end

function ModuleGuiEffects.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.CinematicActivated then
        self.CinematicEventStatus[arg[2]][arg[1]] = 1;
    elseif _ID == QSB.ScriptEvents.CinematicConcluded then
        for i= 1, 8 do
            if self.CinematicEventStatus[i][arg[1]] then
                self.CinematicEventStatus[i][arg[1]] = 2;
            end
        end
    elseif _ID == QSB.ScriptEvents.SaveGameLoaded then
        self:ResetFarClipPlane();
    end
end

-- -------------------------------------------------------------------------- --

function ModuleGuiEffects.Global:StartTypewriter(_Data)
    self.TypewriterEventCounter = self.TypewriterEventCounter +1;
    local EventName = "CinematicEvent_Typewriter" ..self.TypewriterEventCounter;
    _Data.Name = EventName;
    if not self.LoadscreenClosed or API.IsCinematicEventActive(_Data.PlayerID) then
        ModuleGuiEffects.Global:PushCinematicEventToQueue(
            _Data.PlayerID,
            QSB.CinematicEventTypes.Typewriter,
            EventName,
            _Data
        );
        return _Data.Name;
    end
    return self:PlayTypewriter(_Data);
end

function ModuleGuiEffects.Global:PlayTypewriter(_Data)
    local ID = API.StartCinematicEvent(_Data.Name, _Data.PlayerID);
    _Data.ID = ID;
    _Data.TextTokens = self:TokenizeText(_Data);
    self.TypewriterEventData[_Data.PlayerID] = _Data;
    Logic.ExecuteInLuaLocalState(string.format(
        [[
        if GUI.GetPlayerID() == %d then
            API.ActivateImageScreen(GUI.GetPlayerID(), "%s", %d, %d, %d, %d)
            API.DeactivateNormalInterface(GUI.GetPlayerID())
            API.DeactivateBorderScroll(GUI.GetPlayerID(), %d)
            Input.CutsceneMode()
            GUI.ClearNotes()
        end
        ]],
        _Data.PlayerID,
        _Data.Image,
        _Data.Color.R or 0,
        _Data.Color.G or 0,
        _Data.Color.B or 0,
        _Data.Color.A or 255,
        _Data.TargetEntity
    ));

    API.SendScriptEvent(QSB.ScriptEvents.TypewriterStarted, _Data.PlayerID, _Data);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.TypewriterStarted, %d, %s)]],
        _Data.PlayerID,
        table.tostring(_Data)
    ));
    return _Data.Name;
end

function ModuleGuiEffects.Global:FinishTypewriter(_PlayerID)
    if self.TypewriterEventData[_PlayerID] then
        local EventData = table.copy(self.TypewriterEventData[_PlayerID]);
        local EventPlayer = self.TypewriterEventData[_PlayerID].PlayerID;
        Logic.ExecuteInLuaLocalState(string.format(
            [[
            if GUI.GetPlayerID() == %d then
                ModuleGuiEffects.Local:ResetFarClipPlane()
                API.DeactivateImageScreen(GUI.GetPlayerID())
                API.ActivateNormalInterface(GUI.GetPlayerID())
                API.ActivateBorderScroll(GUI.GetPlayerID())
                if ModuleGuiControl then
                    ModuleGuiControl.Local:UpdateHiddenWidgets()
                end
                Input.GameMode()
                GUI.ClearNotes()
            end
            ]],
            _PlayerID
        ));
        API.SendScriptEvent(QSB.ScriptEvents.TypewriterEnded, EventPlayer, EventData);
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.TypewriterEnded, %d, %s)]],
            EventPlayer,
            table.tostring(EventData)
        ));
        self.TypewriterEventData[_PlayerID]:Callback();
        API.FinishCinematicEvent(EventData.Name, EventPlayer);
        self.TypewriterEventData[_PlayerID] = nil;
    end
end

function ModuleGuiEffects.Global:TokenizeText(_Data)
    local TextTokens = {};
    local TempTokens = {};
    local Text = API.ConvertPlaceholders(_Data.Text);
    Text = Text:gsub("%s+", " ");
    while (true) do
        local s1, e1 = Text:find("{");
        local s2, e2 = Text:find("}");
        if not s1 or not s2 then
            table.insert(TempTokens, Text);
            break;
        end
        if s1 > 1 then
            table.insert(TempTokens, Text:sub(1, s1 -1));
        end
        table.insert(TempTokens, Text:sub(s1, e2));
        Text = Text:sub(e2 +1);
    end

    local LastWasPlaceholder = false;
    for i= 1, #TempTokens, 1 do
        if TempTokens[i]:find("{") then
            local Index = #TextTokens;
            if LastWasPlaceholder then
                TextTokens[Index] = TextTokens[Index] .. TempTokens[i];
            else
                table.insert(TextTokens, Index+1, TempTokens[i]);
            end
            LastWasPlaceholder = true;
        else
            local Index = 1;
            while (Index <= #TempTokens[i]) do
                if string.byte(TempTokens[i]:sub(Index, Index)) == 195 then
                    table.insert(TextTokens, TempTokens[i]:sub(Index, Index+1));
                    Index = Index +1;
                else
                    table.insert(TextTokens, TempTokens[i]:sub(Index, Index));
                end
                Index = Index +1;
            end
            LastWasPlaceholder = false;
        end
    end
    return TextTokens;
end

function ModuleGuiEffects.Global:ControlTypewriter()
    -- Check queue for next event
    for i= 1, 8 do
        if self.LoadscreenClosed and not API.IsCinematicEventActive(i) then
            local Next = ModuleGuiEffects.Global:LookUpCinematicInQueue(i);
            if Next and Next[1] == QSB.CinematicEventTypes.Typewriter then
                local Data = ModuleGuiEffects.Global:PopCinematicEventFromQueue(i);
                self:PlayTypewriter(Data[3]);
            end
        end
    end

    -- Perform active events
    for k, v in pairs(self.TypewriterEventData) do
        if self.TypewriterEventData[k].Delay > 0 then
            self.TypewriterEventData[k].Delay = self.TypewriterEventData[k].Delay -1;
            -- Just my paranoia...
            Logic.ExecuteInLuaLocalState(string.format(
                [[if GUI.GetPlayerID() == %d then GUI.ClearNotes() end]],
                self.TypewriterEventData[k].PlayerID
            ));
        end
        if self.TypewriterEventData[k].Delay == 0 then
            self.TypewriterEventData[k].Index = v.Index + v.CharSpeed;
            if v.Index > #self.TypewriterEventData[k].TextTokens then
                self.TypewriterEventData[k].Index = #self.TypewriterEventData[k].TextTokens;
            end
            local Index = math.floor(v.Index + 0.5);
            local Text = "";
            for i= 1, Index, 1 do
                Text = Text .. self.TypewriterEventData[k].TextTokens[i];
            end
            Logic.ExecuteInLuaLocalState(string.format(
                [[
                if GUI.GetPlayerID() == %d then
                    GUI.ClearNotes()
                    GUI.AddNote("]] ..Text.. [[");
                end
                ]],
                self.TypewriterEventData[k].PlayerID
            ));
            if Index == #self.TypewriterEventData[k].TextTokens then
                self.TypewriterEventData[k].Waittime = v.Waittime -1;
                if v.Waittime <= 0 then
                    self:FinishTypewriter(k);
                end
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

function ModuleGuiEffects.Local:SetFarClipPlane(_View)
    Camera.Cutscene_SetFarClipPlane(_View, _View);
    Display.SetFarClipPlaneMinAndMax(_View, _View);
end

function ModuleGuiEffects.Local:ResetFarClipPlane()
    Camera.Cutscene_SetFarClipPlane(QSB.FarClipDefault.MAX);
    Display.SetFarClipPlaneMinAndMax(
        QSB.FarClipDefault.MIN,
        QSB.FarClipDefault.MAX
    );
end

function ModuleGuiEffects.Local:GetCinematicEventStatus(_InfoID)
    for i= 1, 8 do
        if self.CinematicEventStatus[i][_InfoID] then
            return self.CinematicEventStatus[i][_InfoID];
        end
    end
    return 0;
end

function ModuleGuiEffects.Local:OverrideInterfaceUpdateForCinematicMode()
    GameCallback_GameSpeedChanged_Orig_ModuleGuiEffectsInterface = GameCallback_GameSpeedChanged;
    GameCallback_GameSpeedChanged = function(_Speed)
        if not ModuleGuiEffects.Local.PauseScreenShown then
            GameCallback_GameSpeedChanged_Orig_ModuleGuiEffectsInterface(_Speed);
        end
    end

    MissionTimerUpdate_Orig_ModuleGuiEffectsInterface = MissionTimerUpdate;
    MissionTimerUpdate = function()
        MissionTimerUpdate_Orig_ModuleGuiEffectsInterface();
        if ModuleGuiEffects.Local.NormalModeHidden
        or ModuleGuiEffects.Local.PauseScreenShown then
            XGUIEng.ShowWidget("/InGame/Root/Normal/MissionTimer", 0);
        end
    end

    MissionGoodOrEntityCounterUpdate_Orig_ModuleGuiEffectsInterface = MissionGoodOrEntityCounterUpdate;
    MissionGoodOrEntityCounterUpdate = function()
        MissionGoodOrEntityCounterUpdate_Orig_ModuleGuiEffectsInterface();
        if ModuleGuiEffects.Local.NormalModeHidden
        or ModuleGuiEffects.Local.PauseScreenShown then
            XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 0);
        end
    end

    MerchantButtonsUpdater_Orig_ModuleGuiEffectsInterface = GUI_Merchant.ButtonsUpdater;
    GUI_Merchant.ButtonsUpdater = function()
        MerchantButtonsUpdater_Orig_ModuleGuiEffectsInterface();
        if ModuleGuiEffects.Local.NormalModeHidden
        or ModuleGuiEffects.Local.PauseScreenShown then
            XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Merchant", 0);
        end
    end

    if GUI_Tradepost then
        TradepostButtonsUpdater_Orig_ModuleGuiEffectsInterface = GUI_Tradepost.ButtonsUpdater;
        GUI_Tradepost.ButtonsUpdater = function()
            TradepostButtonsUpdater_Orig_ModuleGuiEffectsInterface();
            if ModuleGuiEffects.Local.NormalModeHidden
            or ModuleGuiEffects.Local.PauseScreenShown then
                XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Tradepost", 0);
            end
        end
    end
end

function ModuleGuiEffects.Local:OverrideInterfaceThroneroomForCinematicMode()
    GameCallback_Camera_StartButtonPressed = function(_PlayerID)
    end
    OnStartButtonPressed = function()
        GameCallback_Camera_StartButtonPressed(GUI.GetPlayerID());
    end

    GameCallback_Camera_BackButtonPressed = function(_PlayerID)
    end
    OnBackButtonPressed = function()
        GameCallback_Camera_BackButtonPressed(GUI.GetPlayerID());
    end

    GameCallback_Camera_SkipButtonPressed = function(_PlayerID)
    end
    OnSkipButtonPressed = function()
        GameCallback_Camera_SkipButtonPressed(GUI.GetPlayerID());
    end

    GameCallback_Camera_ThroneRoomLeftClick = function(_PlayerID)
    end
    ThroneRoomLeftClick = function()
        GameCallback_Camera_ThroneRoomLeftClick(GUI.GetPlayerID());
    end

    GameCallback_Camera_ThroneroomCameraControl = function(_PlayerID)
    end
    ThroneRoomCameraControl = function()
        GameCallback_Camera_ThroneroomCameraControl(GUI.GetPlayerID());
    end
end

function ModuleGuiEffects.Local:InterfaceActivateImageBackground(_PlayerID, _Graphic, _R, _G, _B, _A)
    if _PlayerID ~= GUI.GetPlayerID() or self.PauseScreenShown then
        return;
    end
    self.PauseScreenShown = true;

    XGUIEng.PushPage("/InGame/Root/Normal/PauseScreen", false);
    XGUIEng.ShowWidget("/InGame/Root/Normal/PauseScreen", 1);
    if _Graphic and _Graphic ~= "" then
        local Size = {GUI.GetScreenSize()};
        local u0, v0, u1, v1 = 0, 0, 1, 1;
        if Size[1]/Size[2] < 1.6 then
            u0 = u0 + (u0 / 0.125);
            u1 = u1 - (u1 * 0.125);
        end
        XGUIEng.SetMaterialTexture("/InGame/Root/Normal/PauseScreen", 0, _Graphic);
        XGUIEng.SetMaterialUV("/InGame/Root/Normal/PauseScreen", 0, u0, v0, u1, v1);
    end
    XGUIEng.SetMaterialColor("/InGame/Root/Normal/PauseScreen", 0, _R, _G, _B, _A);
    API.SendScriptEventToGlobal("ImageScreenShown", _PlayerID);
    API.SendScriptEvent(QSB.ScriptEvents.ImageScreenShown, _PlayerID);
end

function ModuleGuiEffects.Local:InterfaceDeactivateImageBackground(_PlayerID)
    if _PlayerID ~= GUI.GetPlayerID() or not self.PauseScreenShown then
        return;
    end
    self.PauseScreenShown = false;

    XGUIEng.ShowWidget("/InGame/Root/Normal/PauseScreen", 0);
    XGUIEng.SetMaterialTexture("/InGame/Root/Normal/PauseScreen", 0, "");
    XGUIEng.SetMaterialColor("/InGame/Root/Normal/PauseScreen", 0, 40, 40, 40, 180);
    XGUIEng.PopPage();
    API.SendScriptEventToGlobal("ImageScreenHidden", _PlayerID);
    API.SendScriptEvent(QSB.ScriptEvents.ImageScreenHidden, _PlayerID);
end

function ModuleGuiEffects.Local:InterfaceDeactivateBorderScroll(_PlayerID, _PositionID)
    if _PlayerID ~= GUI.GetPlayerID() or self.BorderScrollDeactivated then
        return;
    end
    self.BorderScrollDeactivated = true;
    if _PositionID then
        Camera.RTS_FollowEntity(_PositionID);
    end
    Camera.RTS_SetBorderScrollSize(0);
    Camera.RTS_SetZoomWheelSpeed(0);

    API.SendScriptEventToGlobal("BorderScrollLocked", _PlayerID, (_PositionID or 0));
    API.SendScriptEvent(QSB.ScriptEvents.BorderScrollLocked, _PlayerID, _PositionID);
end

function ModuleGuiEffects.Local:InterfaceActivateBorderScroll(_PlayerID)
    if _PlayerID ~= GUI.GetPlayerID() or not self.BorderScrollDeactivated then
        return;
    end
    self.BorderScrollDeactivated = false;
    Camera.RTS_FollowEntity(0);
    Camera.RTS_SetBorderScrollSize(3.0);
    Camera.RTS_SetZoomWheelSpeed(4.2);

    API.SendScriptEventToGlobal("BorderScrollReset", _PlayerID);
    API.SendScriptEvent(QSB.ScriptEvents.BorderScrollReset, _PlayerID);
end

function ModuleGuiEffects.Local:InterfaceDeactivateNormalInterface(_PlayerID)
    if GUI.GetPlayerID() ~= _PlayerID or self.NormalModeHidden then
        return;
    end
    self.NormalModeHidden = true;

    XGUIEng.PushPage("/InGame/Root/Normal/NotesWindow", false);
    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/TextMessages", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechStartAgainOrStop", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopRight", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/UpdateFunction", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/Buttons", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/QuestLogButton", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/QuestTimers", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/SubTitles", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Merchant", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MissionTimer", 0);
    HideOtherMenus();
    if XGUIEng.IsWidgetShown("/InGame/Root/Normal/AlignTopLeft/GameClock") == 1 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock", 0);
        self.GameClockWasShown = true;
    end
    if XGUIEng.IsWidgetShownEx("/InGame/Root/Normal/ChatOptions/Background") == 1 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions", 0);
        self.ChatOptionsWasShown = true;
    end
    if XGUIEng.IsWidgetShownEx("/InGame/Root/Normal/MessageLog/Name") == 1 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog", 0);
        self.MessageLogWasShown = true;
    end
    if g_GameExtraNo > 0 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Tradepost", 0);
    end

    API.SendScriptEventToGlobal("GameInterfaceHidden", GUI.GetPlayerID());
    API.SendScriptEvent(QSB.ScriptEvents.GameInterfaceHidden, GUI.GetPlayerID());
end

function ModuleGuiEffects.Local:InterfaceActivateNormalInterface(_PlayerID)
    if GUI.GetPlayerID() ~= _PlayerID or not self.NormalModeHidden then
        return;
    end
    self.NormalModeHidden = false;

    XGUIEng.ShowWidget("/InGame/Root/Normal", 1);
    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechStartAgainOrStop", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopRight", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/UpdateFunction", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/Buttons", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/QuestLogButton", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/QuestTimers", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Merchant", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message", 1);
    XGUIEng.PopPage();

    -- Timer
    if g_MissionTimerEndTime then
        XGUIEng.ShowWidget("/InGame/Root/Normal/MissionTimer", 1);
    end
    -- Counter
    if g_MissionGoodOrEntityCounterAmountToReach then
        XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 1);
    end
    -- Debug Clock
    if self.GameClockWasShown then
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock", 1);
        self.GameClockWasShown = false;
    end
    -- Chat Options
    if self.ChatOptionsWasShown then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions", 1);
        self.ChatOptionsWasShown = false;
    end
    -- Message Log
    if self.MessageLogWasShown then
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog", 1);
        self.MessageLogWasShown = false;
    end
    -- Handelsposten
    if g_GameExtraNo > 0 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Tradepost", 1);
    end

    API.SendScriptEventToGlobal("GameInterfaceShown", GUI.GetPlayerID());
    API.SendScriptEvent(QSB.ScriptEvents.GameInterfaceShown, GUI.GetPlayerID());
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleGuiEffects);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Ermöglicht die Nutzung von verschiedenen Anzeigeeffekte.
--
-- <h5>Cinematic Event</h5> 
-- <u>Ein Kinoevent hat nichts mit den Script Events zu tun!</u> <br>
-- Es handelt sich um eine Markierung, ob für einen Spieler gerade ein Ereignis
-- stattfindet, das das normale Spielinterface manipuliert und den normalen
-- Spielfluss einschränkt. Es wird von der QSB benutzt um festzustellen, ob
-- bereits ein solcher veränderter Zustand aktiv ist und entsorechend darauf
-- zu reagieren, damit sichergestellt ist, dass beim Zurücksetzen des normalen
-- Zustandes keine Fehler passieren.
-- 
-- Der Anwender braucht sich damit nicht zu befassen, es sei denn man plant
-- etwas, das mit Kinoevents kollidieren kann. Wenn ein Feature ein Kinoevent
-- auslöst, ist dies in der Dokumentation ausgewiesen.
-- 
-- Während eines Kinoevent kann zusätzlich nicht gespeichert werden.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

QSB.CinematicEvent = {};

CinematicEvent = {
    NotTriggered = 0,
    Active = 1,
    Concluded = 2,
}

---
-- Events, auf die reagiert werden kann.
--
-- @field CinematicActivated  Ein Kinoevent wurde aktiviert (Parameter: KinoEventID, PlayerID)
-- @field CinematicConcluded  Ein Kinoevent wurde deaktiviert (Parameter: KinoEventID, PlayerID)
-- @field BorderScrollLocked  Scrollen am Bildschirmrand wurde gesperrt (Parameter: PlayerID)
-- @field BorderScrollReset   Scrollen am Bildschirmrand wurde freigegeben (Parameter: PlayerID)
-- @field GameInterfaceShown  Die Spieloberfläche wird angezeigt (Parameter: PlayerID)
-- @field GameInterfaceHidden Die Spieloberfläche wird ausgeblendet (Parameter: PlayerID)
-- @field ImageScreenShown    Der schwarze Hintergrund wird angezeigt (Parameter: PlayerID)
-- @field ImageScreenHidden   Der schwarze Hintergrund wird ausgeblendet (Parameter: PlayerID)
-- @field TypewriterStarted   Ein Schreibmaschineneffekt beginnt (Parameter: PlayerID, DataTable)
-- @field TypewriterEnded     Ein Schreibmaschineneffekt endet (Parameter: PlayerID, DataTable)
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

-- Just to be compatible with the old version.
function API.ActivateColoredScreen(_PlayerID, _Red, _Green, _Blue, _Alpha)
    API.ActivateImageScreen(_PlayerID, "", _Red or 0, _Green or 0, _Blue or 0, _Alpha);
end

-- Just to be compatible with the old version.
function API.DeactivateColoredScreen(_PlayerID)
    API.DeactivateImageScreen(_PlayerID)
end

---
-- Blendet eine Graphic über der Spielwelt aber hinter dem Interface ein.
-- Die Grafik muss im 16:9-Format sein. Bei 4:3-Auflösungen wird
-- links und rechts abgeschnitten.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=string] _Image Pfad zur Grafik
-- @param[type=number] _Red   (Optional) Rotwert (Standard: 255)
-- @param[type=number] _Green (Optional) Grünwert (Standard: 255)
-- @param[type=number] _Blue  (Optional) Blauwert (Standard: 255)
-- @param[type=number] _Alpha (Optional) Alphawert (Standard: 255)
-- @within Anwenderfunktionen
--
function API.ActivateImageScreen(_PlayerID, _Image, _Red, _Green, _Blue, _Alpha)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[ModuleGuiEffects.Local:InterfaceActivateImageBackground(%d, "%s", %d, %d, %d, %d)]],
            _PlayerID,
            _Image,
            (_Red ~= nil and _Red) or 255,
            (_Green ~= nil and _Green) or 255,
            (_Blue ~= nil and _Blue) or 255,
            (_Alpha ~= nil and _Alpha) or 255
        ));
        return;
    end
    ModuleGuiEffects.Local:InterfaceActivateImageBackground(_PlayerID, _Image, _Red, _Green, _Blue, _Alpha);
end

---
-- Deaktiviert ein angezeigtes Bild, wenn dieses angezeigt wird.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @within Anwenderfunktionen
--
function API.DeactivateImageScreen(_PlayerID)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            "ModuleGuiEffects.Local:InterfaceDeactivateImageBackground(%d)",
            _PlayerID
        ));
        return;
    end
    ModuleGuiEffects.Local:InterfaceDeactivateImageBackground(_PlayerID);
end

---
-- Zeigt das normale Interface an.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @within Anwenderfunktionen
--
function API.ActivateNormalInterface(_PlayerID)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            "ModuleGuiEffects.Local:InterfaceActivateNormalInterface(%d)",
            _PlayerID
        ));
        return;
    end
    ModuleGuiEffects.Local:InterfaceActivateNormalInterface(_PlayerID);
end

---
-- Blendet das normale Interface aus.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @within Anwenderfunktionen
--
function API.DeactivateNormalInterface(_PlayerID)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            "ModuleGuiEffects.Local:InterfaceDeactivateNormalInterface(%d)",
            _PlayerID
        ));
        return;
    end
    ModuleGuiEffects.Local:InterfaceDeactivateNormalInterface(_PlayerID);
end

---
-- Akliviert border Scroll wieder und löst die Fixierung auf ein Entity auf.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @within Anwenderfunktionen
--
function API.ActivateBorderScroll(_PlayerID)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            "ModuleGuiEffects.Local:InterfaceActivateBorderScroll(%d)",
            _PlayerID
        ));
        return;
    end
    ModuleGuiEffects.Local:InterfaceActivateBorderScroll(_PlayerID);
end

---
-- Deaktiviert Randscrollen und setzt die Kamera optional auf das Ziel
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Position (Optional) Entity auf das die Kamera schaut
-- @within Anwenderfunktionen
--
function API.DeactivateBorderScroll(_PlayerID, _Position)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    local PositionID;
    if _Position then
        PositionID = GetID(_Position);
    end
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            "ModuleGuiEffects.Local:InterfaceDeactivateBorderScroll(%d, %d)",
            _PlayerID,
            (PositionID or 0)
        ));
        return;
    end
    ModuleGuiEffects.Local:InterfaceDeactivateBorderScroll(_PlayerID, PositionID);
end

---
-- Propagiert den Beginn des Kinoevent und bindet es an den Spieler.
--
-- <b>Hinweis:</b>Während des aktiven Kinoevent kann nicht gespeichert werden.
--
-- @param[type=string] _Name     Bezeichner
-- @param[type=number] _PlayerID ID des Spielers
-- @within Anwenderfunktionen
--
function API.StartCinematicEvent(_Name, _PlayerID)
    if GUI then
        return;
    end
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    QSB.CinematicEvent[_PlayerID] = QSB.CinematicEvent[_PlayerID] or {};
    local ID = ModuleGuiEffects.Global:ActivateCinematicEvent(_PlayerID);
    QSB.CinematicEvent[_PlayerID][_Name] = ID;
end

---
-- Propagiert das Ende des Kinoevent.
--
-- @param[type=string] _Name     Bezeichner
-- @param[type=number] _PlayerID ID des Spielers
-- @within Anwenderfunktionen
--
function API.FinishCinematicEvent(_Name, _PlayerID)
    if GUI then
        return;
    end
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    QSB.CinematicEvent[_PlayerID] = QSB.CinematicEvent[_PlayerID] or {};
    if QSB.CinematicEvent[_PlayerID][_Name] then
        ModuleGuiEffects.Global:ConcludeCinematicEvent(QSB.CinematicEvent[_PlayerID][_Name], _PlayerID);
    end
end

---
-- Gibt den Zustand des Kinoevent zurück.
--
-- @param _Identifier            Bezeichner oder ID
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=number] Zustand des Kinoevent
-- @within Anwenderfunktionen
--
function API.GetCinematicEvent(_Identifier, _PlayerID)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    QSB.CinematicEvent[_PlayerID] = QSB.CinematicEvent[_PlayerID] or {};
    if type(_Identifier) == "number" then
        if GUI then
            return ModuleGuiEffects.Local:GetCinematicEventStatus(_Identifier);
        end
        return ModuleGuiEffects.Global:GetCinematicEventStatus(_Identifier);
    end
    if QSB.CinematicEvent[_PlayerID][_Identifier] then
        if GUI then
            return ModuleGuiEffects.Local:GetCinematicEventStatus(QSB.CinematicEvent[_PlayerID][_Identifier]);
        end
        return ModuleGuiEffects.Global:GetCinematicEventStatus(QSB.CinematicEvent[_PlayerID][_Identifier]);
    end
    return CinematicEvent.NotTriggered;
end

---
-- Prüft ob gerade ein Kinoevent für den Spieler aktiv ist.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=boolean] Kinoevent ist aktiv
-- @within Anwenderfunktionen
--
function API.IsCinematicEventActive(_PlayerID)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    QSB.CinematicEvent[_PlayerID] = QSB.CinematicEvent[_PlayerID] or {};
    for k, v in pairs(QSB.CinematicEvent[_PlayerID]) do
        if API.GetCinematicEvent(k, _PlayerID) == CinematicEvent.Active then
            return true;
        end
    end
    return false;
end

---
-- Blendet einen Text Zeichen für Zeichen ein.
--
-- Der Effekt startet erst, nachdem die Map geladen ist. Wenn ein anderes
-- Cinematic Event läuft, wird gewartet, bis es beendet ist. Wärhend der Effekt
-- läuft, können wiederrum keine Cinematic Events starten.
--
-- Mögliche Werte:
-- <table border="1">
-- <tr>
-- <td><b>Feldname</b></td>
-- <td><b>Typ</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>Text</td>
-- <td>string|table</td>
-- <td>Der anzuzeigene Text</td>
-- </tr>
-- <tr>
-- <td>PlayerID</td>
-- <td>number</td>
-- <td>(Optional) Spieler, dem der Effekt angezeigt wird (Default: Menschlicher Spieler)</td>
-- </tr>
-- <tr>
-- <td>Callback</td>
-- <td>function</td>
-- <td>(Optional) Funktion nach Abschluss der Textanzeige (Default: nil)</td>
-- </tr>
-- <tr>
-- <td>TargetEntity</td>
-- <td>string|number</td>
-- <td>(Optional) TargetEntity der Kamera (Default: nil)</td>
-- </tr>
-- <tr>
-- <td>CharSpeed</td>
-- <td>number</td>
-- <td>(Optional) Die Schreibgeschwindigkeit (Default: 1.0)</td>
-- </tr>
-- <tr>
-- <td>Waittime</td>
-- <td>number</td>
-- <td>(Optional) Initiale Wartezeigt bevor der Effekt startet</td>
-- </tr>
-- <tr>
-- <td>Opacity</td>
-- <td>number</td>
-- <td>(Optional) Durchsichtigkeit des Hintergrund (Default: 1)</td>
-- </tr>
-- <tr>
-- <td>Color</td>
-- <td>table</td>
-- <td>(Optional) Farbe des Hintergrund (Default: {R= 0, G= 0, B= 0}}</td>
-- </tr>
-- <tr>
-- <td>Image</td>
-- <td>string</td>
-- <td>(Optional) Pfad zur anzuzeigenden Grafik</td>
-- </tr>
-- </table>
--
-- <b>Hinweis</b>: Steuerzeichen wie {cr} oder {@color} werden als ein Token
-- gewertet und immer sofort eingeblendet. Steht z.B. {cr}{cr} im Text, werden
-- die Zeichen atomar behandelt, als seien sie ein einzelnes Zeichen.
-- Gibt es mehr als 1 Leerzeichen hintereinander, werden alle zusammenhängenden
-- Leerzeichen (vom Spiel) auf ein Leerzeichen reduziert!
--
-- @param[type=table] _Data Konfiguration
-- @return[type=string] Name des zugeordneten Event
--
-- @usage
-- local EventName = API.StartTypewriter {
--     PlayerID = 1,
--     Text     = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, "..
--                "sed diam nonumy eirmod tempor invidunt ut labore et dolore"..
--                "magna aliquyam erat, sed diam voluptua. At vero eos et"..
--                " accusam et justo duo dolores et ea rebum. Stet clita kasd"..
--                " gubergren, no sea takimata sanctus est Lorem ipsum dolor"..
--                " sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing"..
--                " elitr, sed diam nonumy eirmod tempor invidunt ut labore et"..
--                " dolore magna aliquyam erat, sed diam voluptua. At vero eos"..
--                " et accusam et justo duo dolores et ea rebum. Stet clita"..
--                " kasd gubergren, no sea takimata sanctus est Lorem ipsum"..
--                " dolor sit amet.",
--     Callback = function(_Data)
--         -- Hier kann was passieren
--     end
-- };
-- @within Anwenderfunktionen
--
function API.StartTypewriter(_Data)
    if Framework.IsNetworkGame() ~= true then
        _Data.PlayerID = _Data.PlayerID or QSB.HumanPlayerID;
    end
    if _Data.PlayerID == nil or (_Data.PlayerID < 1 or _Data.PlayerID > 8) then
        return;
    end
    _Data.Text = API.Localize(_Data.Text or "");
    _Data.Callback = _Data.Callback or function() end;
    _Data.CharSpeed = _Data.CharSpeed or 1;
    _Data.Waittime = (_Data.Waittime or 8) * 10;
    _Data.TargetEntity = GetID(_Data.TargetEntity or 0);
    _Data.Image = _Data.Image or "";
    _Data.Color = _Data.Color or {
        R = (_Data.Image and _Data.Image ~= "" and 255) or 0,
        G = (_Data.Image and _Data.Image ~= "" and 255) or 0,
        B = (_Data.Image and _Data.Image ~= "" and 255) or 0,
        A = 255
    };
    if _Data.Opacity and _Data.Opacity >= 0 and _Data.Opacity then
        _Data.Color.A = math.floor((255 * _Data.Opacity) + 0.5);
    end
    _Data.Delay = 15;
    _Data.Index = 0;
    return ModuleGuiEffects.Global:StartTypewriter(_Data);
end
API.SimpleTypewriter = API.StartTypewriter;

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleRequester = {
    Properties = {
        Name = "ModuleRequester",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {},
    Local  = {
        Chat = {
            Data = {},
            History = {},
            Visible = {},
            Widgets = {}
        },
        Requester = {
            ActionFunction = nil,
            ActionRequester = nil,
            Next = nil,
            Queue = {},
        },
    },

    Shared = {
        Text = {
            ChooseLanguage = {
                Title = {
                    de = "Wählt die Sprache",
                    en = "Chose your Tongue",
                    fr = "Sélectionnez la langue",
                },
                Text = {
                    de = "Wählt aus der Liste die Sprache aus, in die Handlungstexte übersetzt werden sollen.",
                    en = "Choose from the list below which language story texts shall be presented to you.",
                    fr = "Sélectionne dans la liste la langue dans laquelle les textes narratifs doivent être traduits.",
                }
            }
        };
    },
}

-- -------------------------------------------------------------------------- --
-- Global

function ModuleRequester.Global:OnGameStart()
end

function ModuleRequester.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --
-- Local

function ModuleRequester.Local:OnGameStart()
    for i= 1, 8 do
        self.Chat.Data[i] = {};
        self.Chat.History[i] = {};
        self.Chat.Visible[i] = false;
        self.Chat.Widgets[i] = {};
    end

    self:OverrideChatLog();
    self:DialogOverwriteOriginal();
    self:DialogAltF4Hotkey();
end

function ModuleRequester.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.SaveGameLoaded then
        self:DialogAltF4Hotkey();
    end
end

-- -------------------------------------------------------------------------- --
-- Requester

function ModuleRequester.Local:DialogAltF4Hotkey()
    StartSimpleJobEx(function ()
        if ModuleRequester.Local.LoadscreenClosed then
            Input.KeyBindDown(Keys.ModifierAlt + Keys.F4, "ModuleRequester.Local:DialogAltF4Action()", 2, false);
            return true;
        end
    end);
end

function ModuleRequester.Local:DialogAltF4Action()
    Input.KeyBindDown(Keys.ModifierAlt + Keys.F4, "", 30, false);
    self:OpenRequesterDialog(
        GUI.GetPlayerID(),
        XGUIEng.GetStringTableText("UI_Texts/MainMenuExitGame_center"),
        XGUIEng.GetStringTableText("UI_Texts/ConfirmQuitCurrentGame"),
        function (_Yes)
            if _Yes then
                Framework.ExitGame();
            end
            if not Framework.IsNetworkGame() then
                Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);
            end
            ModuleRequester.Local:DialogAltF4Hotkey();
        end
    );
end

function ModuleRequester.Local:Callback(_PlayerID)
    if self.Requester.ActionFunction then
        self.Requester.ActionFunction(CustomGame.Knight + 1, _PlayerID);
    end
    self:OnDialogClosed();
end

function ModuleRequester.Local:CallbackRequester(_yes, _PlayerID)
    if self.Requester.ActionRequester then
        self.Requester.ActionRequester(_yes, _PlayerID);
    end
    self:OnDialogClosed();
end

function ModuleRequester.Local:OnDialogClosed()
    if not self.SavingWasDisabled then
        API.DisableSaving(false);
    end
    self.SavingWasDisabled = false;
    self.DialogWindowShown = false;
    self:DialogQueueStartNext();
end

function ModuleRequester.Local:DialogQueueStartNext()
    self.Requester.Next = table.remove(self.Requester.Queue, 1);

    API.StartHiResJob(function()
        local Entry = ModuleRequester.Local.Requester.Next;
        if Entry and Entry[1] and Entry[2] then
            local Methode = Entry[1];
            ModuleRequester.Local[Methode](ModuleRequester.Local, unpack(Entry[2]));
            ModuleRequester.Local.Requester.Next = nil;
        end
        return true;
    end);
end

function ModuleRequester.Local:DialogQueuePush(_Methode, _Args)
    local Entry = {_Methode, _Args};
    table.insert(self.Requester.Queue, Entry);
end

function ModuleRequester.Local:OpenDialog(_PlayerID, _Title, _Text, _Action)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
        assert(type(_Title) == "string");
        assert(type(_Text) == "string");

        _Title = "{center}" .. Swift.Text:ConvertPlaceholders(_Title);
        _Text  = Swift.Text:ConvertPlaceholders(_Text);
        if string.len(_Text) < 35 then
            _Text = _Text .. "{cr}";
        end

        g_MapAndHeroPreview.SelectKnight = function(_Knight)
        end

        XGUIEng.ShowAllSubWidgets("/InGame/Dialog/BG",1);
        XGUIEng.ShowWidget("/InGame/Dialog/Backdrop",0);
        XGUIEng.ShowWidget(RequesterDialog,1);
        XGUIEng.ShowWidget(RequesterDialog_Yes,0);
        XGUIEng.ShowWidget(RequesterDialog_No,0);
        XGUIEng.ShowWidget(RequesterDialog_Ok,1);

        if type(_Action) == "function" then
            self.Requester.ActionFunction = _Action;
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; if not Framework.IsNetworkGame() then Game.GameTimeSetFactor(GUI.GetPlayerID(), 1) end";
            Action = Action .. "; XGUIEng.PopPage()";
            Action = Action .. "; ModuleRequester.Local.Callback(ModuleRequester.Local, GUI.GetPlayerID())";
            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);
        else
            self.Requester.ActionFunction = nil;
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; if not Framework.IsNetworkGame() then Game.GameTimeSetFactor(GUI.GetPlayerID(), 1) end";
            Action = Action .. "; XGUIEng.PopPage()";
            Action = Action .. "; ModuleRequester.Local.Callback(ModuleRequester.Local, GUI.GetPlayerID())";
            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);
        end

        XGUIEng.SetText(RequesterDialog_Message, "{center}" .. _Text);
        XGUIEng.SetText(RequesterDialog_Title, _Title);
        XGUIEng.SetText(RequesterDialog_Title.."White", _Title);
        XGUIEng.PushPage(RequesterDialog,false);

        if Swift.Save.SavingDisabled then
            self.SavingWasDisabled = true;
        end
        API.DisableSaving(true);
        self.DialogWindowShown = true;
    else
        self:DialogQueuePush("OpenDialog", {_PlayerID, _Title, _Text, _Action});
    end
end

function ModuleRequester.Local:OpenRequesterDialog(_PlayerID, _Title, _Text, _Action, _OkCancel)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
        assert(type(_Title) == "string");
        assert(type(_Text) == "string");
        _Title = "{center}" .. _Title;

        self:OpenDialog(_PlayerID, _Title, _Text, _Action);
        XGUIEng.ShowWidget(RequesterDialog_Yes,1);
        XGUIEng.ShowWidget(RequesterDialog_No,1);
        XGUIEng.ShowWidget(RequesterDialog_Ok,0);

        if _OkCancel then
            XGUIEng.SetText(RequesterDialog_Yes, XGUIEng.GetStringTableText("UI_Texts/Ok_center"));
            XGUIEng.SetText(RequesterDialog_No, XGUIEng.GetStringTableText("UI_Texts/Cancel_center"));
        else
            XGUIEng.SetText(RequesterDialog_Yes, XGUIEng.GetStringTableText("UI_Texts/Yes_center"));
            XGUIEng.SetText(RequesterDialog_No, XGUIEng.GetStringTableText("UI_Texts/No_center"));
        end

        self.Requester.ActionRequester = nil;
        if _Action then
            assert(type(_Action) == "function");
            self.Requester.ActionRequester = _Action;
        end
        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
        Action = Action .. "; if not Framework.IsNetworkGame() then Game.GameTimeSetFactor(GUI.GetPlayerID(), 1) end";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; ModuleRequester.Local.CallbackRequester(ModuleRequester.Local, true, GUI.GetPlayerID())"
        XGUIEng.SetActionFunction(RequesterDialog_Yes, Action);
        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)"
        Action = Action .. "; if not Framework.IsNetworkGame() then Game.GameTimeSetFactor(GUI.GetPlayerID(), 1) end";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; ModuleRequester.Local.CallbackRequester(ModuleRequester.Local, false, GUI.GetPlayerID())"
        XGUIEng.SetActionFunction(RequesterDialog_No, Action);
    else
        self:DialogQueuePush("OpenRequesterDialog", {_PlayerID, _Title, _Text, _Action, _OkCancel});
    end
end

function ModuleRequester.Local:OpenSelectionDialog(_PlayerID, _Title, _Text, _Action, _List)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
        self:OpenDialog(_PlayerID, _Title, _Text, _Action);

        local HeroComboBoxID = XGUIEng.GetWidgetID(CustomGame.Widget.KnightsList);
        XGUIEng.ListBoxPopAll(HeroComboBoxID);
        for i=1,#_List do
            XGUIEng.ListBoxPushItem(HeroComboBoxID, _List[i] );
        end
        XGUIEng.ListBoxSetSelectedIndex(HeroComboBoxID, 0);
        CustomGame.Knight = 0;

        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)"
        Action = Action .. "; if not Framework.IsNetworkGame() then Game.GameTimeSetFactor(GUI.GetPlayerID(), 1) end";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; ModuleRequester.Local.Callback(ModuleRequester.Local, GUI.GetPlayerID())";
        XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);

        local Container = "/InGame/Singleplayer/CustomGame/ContainerSelection/";
        XGUIEng.SetText(Container .. "HeroComboBoxMain/HeroComboBox", "");
        if _List[1] then
            XGUIEng.SetText(Container .. "HeroComboBoxMain/HeroComboBox", _List[1]);
        end
        XGUIEng.PushPage(Container .. "HeroComboBoxContainer", false);
        XGUIEng.PushPage(Container .. "HeroComboBoxMain",false);
        XGUIEng.ShowWidget(Container .. "HeroComboBoxContainer", 0);
        local screen = {GUI.GetScreenSize()};
        local x1, y1 = XGUIEng.GetWidgetScreenPosition(RequesterDialog_Ok);
        XGUIEng.SetWidgetScreenPosition(Container .. "HeroComboBoxMain", x1-25, y1-(90*(screen[2]/1080)));
        XGUIEng.SetWidgetScreenPosition(Container .. "HeroComboBoxContainer", x1-25, y1-(20*(screen[2]/1080)));
    else
        self:DialogQueuePush("OpenSelectionDialog", {_PlayerID, _Title, _Text, _Action, _List});
    end
end

function ModuleRequester.Local:DialogOverwriteOriginal()
    OpenDialog_Orig_Windows = OpenDialog;
    OpenDialog = function(_Message, _Title, _IsMPError)
        if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            OpenDialog_Orig_Windows(_Title, _Message);
        end
    end

    OpenRequesterDialog_Orig_Windows = OpenRequesterDialog;
    OpenRequesterDialog = function(_Message, _Title, action, _OkCancel, no_action)
        if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            XGUIEng.SetActionFunction(RequesterDialog_Yes, Action);
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            XGUIEng.SetActionFunction(RequesterDialog_No, Action);
            OpenRequesterDialog_Orig_Windows(_Message, _Title, action, _OkCancel, no_action);
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Chat Log

function ModuleRequester.Local:ShowTextWindow(_Data)
    _Data.PlayerID = _Data.PlayerID or 1;
    _Data.Button = _Data.Button or {};
    local PlayerID = GUI.GetPlayerID();
    if _Data.PlayerID ~= PlayerID then
        return;
    end
    if XGUIEng.IsWidgetShown("/InGame/Root/Normal/ChatOptions") == 1 then
        self:UpdateChatLogText(_Data);
        return;
    end
    self.Chat.Data[PlayerID] = _Data;
    self:CloseTextWindow(PlayerID);
    self:AlterChatLog();

    XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/ChatLog", _Data.Content);
    XGUIEng.SetText("/InGame/Root/Normal/MessageLog/Name","{center}" .._Data.Caption);
    if _Data.DisableClose then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/Exit",0);
    end
    self:ShouldShowSlider(_Data.Content);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions",1);
end

function ModuleRequester.Local:CloseTextWindow(_PlayerID)
    assert(_PlayerID ~= nil);
    local PlayerID = GUI.GetPlayerID();
    if _PlayerID ~= PlayerID then
        return;
    end
    GUI_Chat.CloseChatMenu();
end

function ModuleRequester.Local:UpdateChatLogText(_Data)
    XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/ChatLog", _Data.Content);
end

function ModuleRequester.Local:AlterChatLog()
    local PlayerID = GUI.GetPlayerID();
    if self.Chat.Visible[PlayerID] then
        return;
    end
    self.Chat.Visible[PlayerID] = true;
    self.Chat.History[PlayerID] = table.copy(g_Chat.ChatHistory);
    g_Chat.ChatHistory = {};
    self:AlterChatLogDisplay();
end

function ModuleRequester.Local:RestoreChatLog()
    local PlayerID = GUI.GetPlayerID();
    if not self.Chat.Visible[PlayerID] then
        return;
    end
    self.Chat.Visible[PlayerID] = false;
    g_Chat.ChatHistory = {};
    for i= 1, #self.Chat.History[PlayerID] do
        GUI_Chat.ChatlogAddMessage(self.Chat.History[PlayerID][i]);
    end
    self:RestoreChatLogDisplay();
    self.Chat.History[PlayerID] = {};
    self.Chat.Widgets[PlayerID] = {};
    self.Chat.Data[PlayerID] = {};
end

function ModuleRequester.Local:UpdateToggleWhisperTarget()
    local PlayerID = GUI.GetPlayerID();
    local MotherWidget = "/InGame/Root/Normal/ChatOptions/";
    if not self.Chat.Data[PlayerID] or not self.Chat.Data[PlayerID].Button
    or not self.Chat.Data[PlayerID].Button.Action then
        XGUIEng.ShowWidget(MotherWidget.. "ToggleWhisperTarget",0);
        return;
    end
    local ButtonText = self.Chat.Data[PlayerID].Button.Text;
    XGUIEng.SetText(MotherWidget.. "ToggleWhisperTarget","{center}" ..ButtonText);
end

function ModuleRequester.Local:ShouldShowSlider(_Text)
    local stringlen = string.len(_Text);
    local iterator  = 1;
    local carreturn = 0;
    while (true)
    do
        local s,e = string.find(_Text, "{cr}", iterator);
        if not e then
            break;
        end
        if e-iterator <= 58 then
            stringlen = stringlen + 58-(e-iterator);
        end
        iterator = e+1;
    end
    if (stringlen + (carreturn*55)) > 1000 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogSlider",1);
    end
end

function ModuleRequester.Local:OverrideChatLog()
    GUI_Chat.ChatlogAddMessage_Orig_Requester = GUI_Chat.ChatlogAddMessage;
    GUI_Chat.ChatlogAddMessage = function(_Message)
        local PlayerID = GUI.GetPlayerID();
        if not ModuleRequester.Local.Chat.Visible[PlayerID] then
            GUI_Chat.ChatlogAddMessage_Orig_Requester(_Message);
            return;
        end
        table.insert(ModuleRequester.Local.Chat.History[PlayerID], _Message);
    end

    GUI_Chat.DisplayChatLog_Orig_Requester = GUI_Chat.DisplayChatLog;
    GUI_Chat.DisplayChatLog = function()
        local PlayerID = GUI.GetPlayerID();
        if not ModuleRequester.Local.Chat.Visible[PlayerID] then
            GUI_Chat.DisplayChatLog_Orig_Requester();
        end
    end

    GUI_Chat.CloseChatMenu_Orig_Requester = GUI_Chat.CloseChatMenu;
    GUI_Chat.CloseChatMenu = function()
        local PlayerID = GUI.GetPlayerID();
        if not ModuleRequester.Local.Chat.Visible[PlayerID] then
            GUI_Chat.CloseChatMenu_Orig_Requester();
            return;
        end
        ModuleRequester.Local:RestoreChatLog();
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions",0);
    end

    GUI_Chat.ToggleWhisperTargetUpdate_Orig_Requester = GUI_Chat.ToggleWhisperTargetUpdate;
    GUI_Chat.ToggleWhisperTargetUpdate = function()
        local PlayerID = GUI.GetPlayerID();
        if not ModuleRequester.Local.Chat.Visible[PlayerID] then
            GUI_Chat.ToggleWhisperTargetUpdate_Orig_Requester();
            return;
        end
        ModuleRequester.Local:UpdateToggleWhisperTarget();
    end

    GUI_Chat.CheckboxMessageTypeWhisperUpdate_Orig_Requester = GUI_Chat.CheckboxMessageTypeWhisperUpdate;
    GUI_Chat.CheckboxMessageTypeWhisperUpdate = function()
        local PlayerID = GUI.GetPlayerID();
        if not ModuleRequester.Local.Chat.Visible[PlayerID] then
            GUI_Chat.CheckboxMessageTypeWhisperUpdate_Orig_Requester();
            return;
        end
    end

    GUI_Chat.ToggleWhisperTarget_Orig_Requester = GUI_Chat.ToggleWhisperTarget;
    GUI_Chat.ToggleWhisperTarget = function()
        local PlayerID = GUI.GetPlayerID();
        if not ModuleRequester.Local.Chat.Visible[PlayerID] then
            GUI_Chat.ToggleWhisperTarget_Orig_Requester();
            return;
        end
        if ModuleRequester.Local.Chat.Data[PlayerID].Button.Action then
            local Data = ModuleRequester.Local.Chat.Data[PlayerID];
            ModuleRequester.Local.Chat.Data[PlayerID].Button.Action(Data);
        end
    end
end

function ModuleRequester.Local:AlterChatLogDisplay()
    local PlayerID = GUI.GetPlayerID();

    local w,h,x,y;
    local Widget;
    local MotherWidget = "/InGame/Root/Normal/ChatOptions/";
    x,y = XGUIEng.GetWidgetLocalPosition(MotherWidget.. "ToggleWhisperTarget");
    w,h = XGUIEng.GetWidgetSize(MotherWidget.. "ToggleWhisperTarget");
    self.Chat.Widgets[PlayerID]["ToggleWhisperTarget"] = {X= x, Y= y, W= w, H= h};
    Widget = self.Chat.Widgets[PlayerID]["ToggleWhisperTarget"];

    x,y = XGUIEng.GetWidgetLocalPosition(MotherWidget.. "ChatLog");
    w,h = XGUIEng.GetWidgetSize(MotherWidget.. "ChatLog");
    self.Chat.Widgets[PlayerID]["ChatLog"] = {X= x, Y= y, W= w, H= h};
    Widget = self.Chat.Widgets[PlayerID]["ChatLog"];

    x,y = XGUIEng.GetWidgetLocalPosition(MotherWidget.. "ChatLogSlider");
    w,h = XGUIEng.GetWidgetSize(MotherWidget.. "ChatLogSlider");
    self.Chat.Widgets[PlayerID]["ChatLogSlider"] = {X= x, Y= y, W= w, H= h};
    Widget = self.Chat.Widgets[PlayerID]["ChatLogSlider"];

    XGUIEng.ShowWidget(MotherWidget.. "ChatModeAllPlayers",0);
    XGUIEng.ShowWidget(MotherWidget.. "ChatModeTeam",0);
    XGUIEng.ShowWidget(MotherWidget.. "ChatModeWhisper",0);
    XGUIEng.ShowWidget(MotherWidget.. "ChatChooseModeCaption",0);
    XGUIEng.ShowWidget(MotherWidget.. "Background/TitleBig",1);
    XGUIEng.ShowWidget(MotherWidget.. "Background/TitleBig/Info",0);
    XGUIEng.ShowWidget(MotherWidget.. "ChatLogCaption",0);
    XGUIEng.ShowWidget(MotherWidget.. "BGChoose",0);
    XGUIEng.ShowWidget(MotherWidget.. "BGChatLog",0);
    XGUIEng.ShowWidget(MotherWidget.. "ChatLogSlider",0);

    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog",1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/BG",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Close",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Slider",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Text",0);
    XGUIEng.SetText("/InGame/Root/Normal/MessageLog/Name","{center}Test");
    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/MessageLog",15,90);
    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/MessageLog/Name",0,0);
    XGUIEng.SetTextColor("/InGame/Root/Normal/MessageLog/Name",51,51,121,255);

    XGUIEng.SetWidgetSize(MotherWidget.. "ChatLogSlider",46,600);
    XGUIEng.SetWidgetLocalPosition(MotherWidget.. "ChatLogSlider",780,130);
    XGUIEng.SetWidgetSize(MotherWidget.. "Background/DialogBG/1 (2)/2",150,400);
    XGUIEng.SetWidgetPositionAndSize(MotherWidget.. "Background/DialogBG/1 (2)/3",400,500,350,400);
    XGUIEng.SetWidgetLocalPosition(MotherWidget.. "ToggleWhisperTarget",280,760);
    XGUIEng.SetWidgetLocalPosition(MotherWidget.. "ChatLog",140,150);
    XGUIEng.SetWidgetSize(MotherWidget.. "ChatLog",640,560);
end

function ModuleRequester.Local:RestoreChatLogDisplay()
    local PlayerID = GUI.GetPlayerID();

    local Widget;
    local MotherWidget = "/InGame/Root/Normal/ChatOptions/";
    Widget = self.Chat.Widgets[PlayerID]["ToggleWhisperTarget"];
    XGUIEng.SetWidgetLocalPosition(MotherWidget.. "ToggleWhisperTarget", Widget.X, Widget.Y);
    XGUIEng.SetWidgetSize(MotherWidget.. "ToggleWhisperTarget", Widget.W, Widget.H);
    Widget = self.Chat.Widgets[PlayerID]["ChatLog"];
    XGUIEng.SetWidgetLocalPosition(MotherWidget.. "ChatLog", Widget.X, Widget.Y);
    XGUIEng.SetWidgetSize(MotherWidget.. "ChatLog", Widget.W, Widget.H);
    Widget = self.Chat.Widgets[PlayerID]["ChatLogSlider"];
    XGUIEng.SetWidgetLocalPosition(MotherWidget.. "ChatLogSlider", Widget.X, Widget.Y);
    XGUIEng.SetWidgetSize(MotherWidget.. "ChatLogSlider", Widget.W, Widget.H);

    XGUIEng.ShowWidget(MotherWidget.. "ChatModeAllPlayers",1);
    XGUIEng.ShowWidget(MotherWidget.. "ChatModeTeam",1);
    XGUIEng.ShowWidget(MotherWidget.. "ChatModeWhisper",1);
    XGUIEng.ShowWidget(MotherWidget.. "ChatChooseModeCaption",1);
    XGUIEng.ShowWidget(MotherWidget.. "Background/TitleBig",1);
    XGUIEng.ShowWidget(MotherWidget.. "Background/TitleBig/Info",1);
    XGUIEng.ShowWidget(MotherWidget.. "ChatLogCaption",1);
    XGUIEng.ShowWidget(MotherWidget.. "BGChoose",1);
    XGUIEng.ShowWidget(MotherWidget.. "BGChatLog",1);
    XGUIEng.ShowWidget(MotherWidget.. "ChatLogSlider",1);
    XGUIEng.ShowWidget(MotherWidget.. "ToggleWhisperTarget",1);

    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog",0);
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleRequester);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Stellt verschiedene Dialog- oder Textfenster zur Verfügung.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Öffnet ein einfaches Textfenster mit dem angegebenen Text.
--
-- Die Länge des Textes ist nicht beschränkt. Überschreitet der Text die
-- Größe des Fensters, wird automatisch eine Bildlaufleiste eingeblendet.
--
-- <h5>Multiplayer</h5>
-- Im Multiplayer muss zwingend der Spieler angegeben werden, für den das
-- Fenster angezeigt werden soll.
--
-- @param[type=string] _Caption  Titel des Fenster
-- @param[type=string] _Content  Inhalt des Fenster
-- @param[type=number] _PlayerID Spieler, der das Fenster sieht
-- @within Anwenderfunktionen
--
-- @usage
-- local Text = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr,"..
--              " sed diam nonumy eirmod tempor invidunt ut labore et dolore"..
--              " magna aliquyam erat, sed diam voluptua. At vero eos et"..
--              " accusam et justo duo dolores et ea rebum. Stet clita kasd"..
--              " gubergren, no sea takimata sanctus est Lorem ipsum dolor"..
--              " sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing"..
--              " elitr, sed diam nonumy eirmod tempor invidunt ut labore et"..
--              " dolore magna aliquyam erat, sed diam voluptua. At vero eos"..
--              " et accusam et justo duo dolores et ea rebum. Stet clita"..
--              " kasd gubergren, no sea takimata sanctus est Lorem ipsum"..
--              " dolor sit amet.";
-- API.TextWindow("Überschrift", Text);
--
function API.TextWindow(_Caption, _Content, _PlayerID)
    _PlayerID = _PlayerID or 1;
    _Caption = API.Localize(_Caption);
    _Content = API.Localize(_Content);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.TextWindow("%s", "%s", %d)]],
            _Caption,
            _Content,
            _PlayerID
        ));
        return;
    end
    ModuleRequester.Local:ShowTextWindow {
        PlayerID = _PlayerID,
        Caption  = _Caption,
        Content  = _Content,
    };
end

---
-- Öffnet einen Info-Dialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- An die Action wird der Spieler übergeben, der den Dialog bestätigt hat.
--
-- <b>Hinweis</b>: Kann nicht aus dem globalen Skript heraus benutzt werden.
--
-- @param[type=string]   _PlayerID (Optional) Empfangender Spieler
-- @param[type=string]   _Title    Titel des Dialog
-- @param[type=string]   _Text     Text des Dialog
-- @param                _Action   Funktionsreferenz
-- @within Anwenderfunktionen
--
-- @usage
-- API.DialogInfoBox("Wichtige Information", "Diese Information ist Spielentscheidend!");
--
function API.DialogInfoBox(_PlayerID, _Title, _Text, _Action)
    if not GUI then
        return;
    end
    if type(_PlayerID) ~= "number" then
        _Action = _Text;
        _Text = _Title;
        _Title = _PlayerID;
        _PlayerID = GUI.GetPlayerID();
    end
    if type(_Title) == "table" then
        _Title = API.Localize(_Title);
    end
    if type(_Text) == "table" then
        _Text  = API.Localize(_Text);
    end
    return ModuleRequester.Local:OpenDialog(_PlayerID, _Title, _Text, _Action);
end

---
-- Öffnet einen Ja-Nein-Dialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- Um die Entscheigung des Spielers abzufragen, wird ein Callback benötigt.
-- Das Callback bekommt eine Boolean übergeben, sobald der Spieler die
-- Entscheidung getroffen hat, plus die ID des Spielers.
--
-- <b>Hinweis</b>: Kann nicht aus dem globalen Skript heraus benutzt werden.
--
-- @param[type=string]   _PlayerID (Optional) Empfangender Spieler
-- @param[type=string]   _Title    Titel des Dialog
-- @param[type=string]   _Text     Text des Dialog
-- @param                _Action   Funktionsreferenz
-- @param[type=boolean]  _OkCancel Okay/Abbrechen statt Ja/Nein
-- @within Anwenderfunktionen
--
-- @usage
-- function YesNoAction(_Yes, _PlayerID)
--     if _Yes then GUI.AddNote("Ja wurde gedrückt"); end
-- end
-- API.DialogRequestBox("Frage", "Möchtest du das wirklich tun?", YesNoAction, false);
--
function API.DialogRequestBox(_PlayerID, _Title, _Text, _Action, _OkCancel)
    if not GUI then
        return;
    end
    if type(_PlayerID) ~= "number" then
        _OkCancel = _Action;
        _Action = _Text;
        _Text = _Title;
        _Title = _PlayerID;
        _PlayerID = GUI.GetPlayerID();
    end
    if type(_Title) == "table" then
        _Title = API.Localize(_Title);
    end
    if type(_Text) == "table" then
        _Text  = API.Localize(_Text);
    end
    return ModuleRequester.Local:OpenRequesterDialog(_PlayerID, _Title, _Text, _Action, _OkCancel);
end

---
-- Öffnet einen Auswahldialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- In diesem Dialog wählt der Spieler eine Option aus einer Liste von Optionen
-- aus. Anschließend erhält das Callback den Index der selektierten Option und
-- die ID des Spielers, der den Dialog bestätigt hat.
--
-- <b>Hinweis</b>: Kann nicht aus dem globalen Skript heraus benutzt werden.
--
-- @param[type=string]   _PlayerID (Optional) Empfangender Spieler
-- @param[type=string]   _Title  Titel des Dialog
-- @param[type=string]   _Text   Text des Dialog
-- @param                _Action Funktionsreferenz
-- @param[type=table]    _List   Liste der Optionen
-- @within Anwenderfunktionen
--
-- @usage
-- function OptionsAction(_Idx, _PlayerID)
--     GUI.AddNote(_Idx.. " wurde ausgewählt!");
-- end
-- local List = {"Option A", "Option B", "Option C"};
-- API.DialogSelectBox("Auswahl", "Wähle etwas aus!", OptionsAction, List);
--
function API.DialogSelectBox(_PlayerID, _Title, _Text, _Action, _List)
    if not GUI then
        return;
    end
    if type(_PlayerID) ~= "number" then
        _List = _Action;
        _Action = _Text;
        _Text = _Title;
        _Title = _PlayerID;
        _PlayerID = GUI.GetPlayerID();
    end
    if type(_Title) == "table" then
        _Title = API.Localize(_Title);
    end
    if type(_Text) == "table" then
        _Text  = API.Localize(_Text);
    end
    _Text = _Text .. "{cr}";
    ModuleRequester.Local:OpenSelectionDialog(_PlayerID, _Title, _Text, _Action, _List);
end

---
-- Öffnet den Dialog für die Auswahl der Sprache. Deutsch, Englisch und
-- Französisch sind vorkonfiguriert.
--
-- @param[type=number] _PlayerID (optional) Nur für diesen Spieler anzeigen
-- @within Anwenderfunktionen
--
-- @usage
-- -- Für alle Spieler
-- API.DialogLanguageSelection();
-- -- Nur für Spieler 2 anzeigen
-- API.DialogLanguageSelection(2);
--
function API.DialogLanguageSelection(_PlayerID)
    _PlayerID = _PlayerID or -1
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.DialogLanguageSelection(%d)]],
            _PlayerID
        ));
        return;
    end
    if _PlayerID ~= -1 and GUI.GetPlayerID() ~= _PlayerID then
        return;
    end

    local DisplayedList = {};
    for i= 1, #Swift.Text.Languages do
        table.insert(DisplayedList, Swift.Text.Languages[i][2]);
    end
    local Action = function(_Selected)
        API.BroadcastScriptCommand(
            QSB.ScriptCommands.SetLanguageResult,
            GUI.GetPlayerID(),
            Swift.Text.Languages[_Selected][1]
        );
    end
    local Text = API.Localize(ModuleRequester.Shared.Text.ChooseLanguage);
    API.DialogSelectBox(GUI.GetPlayerID(), Text.Title, Text.Text, Action, DisplayedList);
end

---
-- Fügt eine neue Sprache zur Auswahl hinzu.
--
-- @param[type=string] _Shortcut Kürzel der Sprache (vgl. de, en, ...)
-- @param[type=string] _Name     Anzeigename der Sprache
-- @param[type=string] _Fallback Kürzel der Ausweichsprache
-- @within Anwenderfunktionen
--
-- @usage
-- API.DefineLanguage("sx", "Sächsich", "de")
--
function API.DefineLanguage(_Shortcut, _Name, _Fallback)
    assert(type(_Shortcut) == "string");
    assert(type(_Name) == "string");
    assert(type(_Fallback) == "string");
    for k, v in pairs(Swift.Text.Languages) do
        if v[1] == _Shortcut then
            return;
        end
    end
    table.insert(Swift.Text.Languages, {_Shortcut, _Name, _Fallback});
    Logic.ExecuteInLuaLocalState(string.format([[
        table.insert(Swift.Text.Languages, {"%s", "%s", "%s"})
    ]], _Shortcut, _Name, _Fallback));
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleEntityMovement = {
    Properties = {
        Name = "ModuleEntityMovement",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        PathMovingEntities = {},
    };
    Local = {},

    Shared = {},
};

-- -------------------------------------------------------------------------- --
-- Global Script

function ModuleEntityMovement.Global:OnGameStart()
    QSB.ScriptEvents.EntityArrived = API.RegisterScriptEvent("Event_EntityArrived");
    QSB.ScriptEvents.EntityStuck = API.RegisterScriptEvent("Event_EntityStuck");
    QSB.ScriptEvents.EntityAtCheckpoint = API.RegisterScriptEvent("Event_EntityAtCheckpoint");
    QSB.ScriptEvents.PathFindingFinished = API.RegisterScriptEvent("Event_PathFindingFinished");
    QSB.ScriptEvents.PathFindingFailed = API.RegisterScriptEvent("Event_PathFindingFailed");

    API.StartHiResJob(function()
        ModuleEntityMovement.Global.PathFinder:Controller();
    end);
end

function ModuleEntityMovement.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

function ModuleEntityMovement.Global:FillMovingEntityDataForController(_Entity, _Path, _LookAt, _Action, _IgnoreBlocking)
    -- FIXME: Should we check that the entity isn't already processed?
    local Index = #self.PathMovingEntities +1;
    self.PathMovingEntities[Index] = {
        Entity = GetID(_Entity),
        IgnoreBlocking = _IgnoreBlocking == true,
        LookAt = _LookAt,
        Callback = _Action,
        Index = 0
    };
    for i= 1, #_Path do
        table.insert(self.PathMovingEntities[Index], _Path[i]);
    end
    return Index;
end

function ModuleEntityMovement.Global:MoveEntityPathController(_Index)
    local Data = self.PathMovingEntities[_Index];

    local CanMove = true;
    if not IsExisting(Data.Entity) then
        CanMove = false;
    end

    if CanMove and Logic.IsEntityMoving(Data.Entity) == false then
        -- Arrived at waypoint
        if Data.Index > 0 then
            API.SendScriptEvent(QSB.ScriptEvents.EntityAtCheckpoint, Data.Entity, Data[Data.Index], _Index);
            local Target = tostring(Data[Data.Index]);
            if type(Data[Data.Index]) == "table" then
                Target = table.tostring(Data[Data.Index]);
            end
            Logic.ExecuteInLuaLocalState(string.format(
                [[API.SendScriptEvent(QSB.ScriptEvents.EntityAtCheckpoint, %d, %s, %d)]],
                Data.Entity, Target, _Index
            ));
        end
        self.PathMovingEntities[_Index].Index = Data.Index +1;

        -- Check entity arrived
        if #Data < Data.Index then
            if  Logic.IsSettler(Data.Entity) == 1
            and Logic.GetEntityType(Data.Entity) ~= Entities.D_X_TradeShip then
                Logic.SetTaskList(Data.Entity, TaskLists.TL_NPC_IDLE);
                if Data.LookAt then
                    API.LookAt(Data.Entity, Data.LookAt);
                end
                if Data.Callback then
                    Data:Callback();
                end
            end
            -- The event is send when the task is fully completed. That means
            -- look at and callback must be executed first!
            API.SendScriptEvent(QSB.ScriptEvents.EntityArrived, Data.Entity, Data[#Data], _Index);
            local Target = tostring(Data[#Data]);
            if type(Data[#Data]) == "table" then
                Target = table.tostring(Data[#Data]);
            end
            Logic.ExecuteInLuaLocalState(string.format(
                [[API.SendScriptEvent(QSB.ScriptEvents.EntityArrived, %d, %s, %d)]],
                Data.Entity, Target, _Index
            ));
            return true;
        end

        -- Check reachablility
        local x1,y1,z1 = Logic.EntityGetPos(Data.Entity);
        local x2,y2,z2;
        if type(Data[Data.Index]) == "table" then
            x2 = Data[Data.Index].X;
            y2 = Data[Data.Index].Y;
        else
            x2,y2,z2 = Logic.EntityGetPos(GetID(Data[Data.Index]));
        end
        local PlayerID = Logic.EntityGetPlayer(Data.Entity);
        local SectorType = Logic.GetEntityPlayerSectorType(Data.Entity);
        local Sector1 = Logic.GetPlayerSectorID(PlayerID, SectorType, x1, y1);
        local Sector2 = Logic.GetPlayerSectorID(PlayerID, SectorType, x2, y2);
        if Sector1 ~= Sector2 then
            if Logic.IsSettler(Data.Entity) == 1 then
                Logic.SetTaskList(Data.Entity, TaskLists.TL_NPC_IDLE);
            end
            CanMove = false;
        end

        -- Move entity
        if CanMove then
            if Data.IgnoreBlocking then
                if  Logic.IsSettler(Data.Entity) == 1
                and Logic.GetEntityType(Data.Entity) ~= Entities.D_X_TradeShip then
                    Logic.SetTaskList(Data.Entity, TaskLists.TL_NPC_WALK);
                end
                Logic.MoveEntity(Data.Entity, x2, y2);
            else
                Logic.MoveSettler(Data.Entity, x2, y2);
            end
        end
    end

    -- Send movement failed event
    if not CanMove then
        API.SendScriptEvent(QSB.ScriptEvents.EntityStuck, Data.Entity, Data[Data.Index], _Index);
        local Target = tostring(Data[Data.Index]);
        if type(Data[Data.Index]) == "table" then
            Target = table.tostring(Data[Data.Index]);
        end
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.EntityStuck, %d, %s, %d)]],
            Data.Entity, Target, _Index
        ));
        return true;
    end
end

-- -------------------------------------------------------------------------- --
-- Pathfinder Class

ModuleEntityMovement.Global.PathFinder = {
    NodeDistance = 300;
    StepsPerTurn = 1;

    PathSequence = 0;
    PathList = {};
    ProcessedPaths = {};
}

function ModuleEntityMovement.Global.PathFinder:Insert(_Start, _End, _NodeDistance, _StepsPerTick, _Filter, ...)
    local Start = self:GetClosestPositionOnNodeMap(_Start, _NodeDistance);
    if not Start then
        return 0;
    end
    local End = self:GetClosestPositionOnNodeMap(_End, _NodeDistance);
    if not _End then
        return 0;
    end

    self.PathSequence = self.PathSequence +1;
    self.ProcessedPaths[self.PathSequence] = {
        NodeDistance = _NodeDistance or 300,
        StepsPerTick = _StepsPerTick or 1,
        StartNode = Start,
        TargetNode = End,
        Suspended = false,
        Closed = {},
        ClosedMap = {},
        Open = {},
        OpenMap = {};
        AcceptMethode = _Filter,
        AcceptArgs = arg,
    };

    Start.ID = "ID_"..Start.X.."_"..Start.Y;
    table.insert(self.ProcessedPaths[self.PathSequence].Open, 1, Start);
    self.ProcessedPaths[self.PathSequence].OpenMap[Start.ID] = true;

    return self.PathSequence;
end

function ModuleEntityMovement.Global.PathFinder:Controller()
    for k, v in pairs(self.ProcessedPaths) do
        if v.Suspended == false then
            self:Step(k);
        end
    end
end

function ModuleEntityMovement.Global.PathFinder:SendPathingSucceedEvent(_Index)
    API.SendScriptEvent(QSB.ScriptEvents.PathFindingFinished, _Index);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.PathFindingFinished, %d)]],
        _Index
    ));
end

function ModuleEntityMovement.Global.PathFinder:SendPathingFailedEvent(_Index)
    API.SendScriptEvent(QSB.ScriptEvents.PathFindingFailed, _Index);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.PathFindingFailed, %d)]],
        _Index
    ))
end

function ModuleEntityMovement.Global.PathFinder:SetSuspended(_ID, _Flag)
    if self.ProcessedPaths[_ID] then
        self.ProcessedPaths[_ID].Suspended = _Flag == true;
    end
end

function ModuleEntityMovement.Global.PathFinder:Step(_Index)
    if not self.ProcessedPaths[_Index] then
        self.ProcessedPaths[_Index] = nil;
        self.PathList[_Index] = nil;
        self:SendPathingFailedEvent(_Index);
        return true;
    end
    for i= 1, self.ProcessedPaths[_Index].StepsPerTick, 1 do
        if #self.ProcessedPaths[_Index].Open == 0 then
            self.ProcessedPaths[_Index] = nil;
            self.PathList[_Index] = nil;
            self:SendPathingFailedEvent(_Index);
            return true;
        end
        local removed = table.remove(self.ProcessedPaths[_Index].Open, 1);
        self.ProcessedPaths[_Index].OpenMap[removed.ID] = nil;
        if  removed.X == self.ProcessedPaths[_Index].TargetNode.X
        and removed.Y == self.ProcessedPaths[_Index].TargetNode.Y then
            local LastNode = removed;
            local path = {}
            local prev = LastNode;
            while (prev) do
                table.insert(path, prev);
                local tmp = LastNode.Father;
                LastNode = prev;
                prev = self:GetNodeByID(_Index, tmp);
                if not prev.Father then
                    table.insert(path, prev);
                    break;
                end
            end
            self.PathList[_Index] = ModuleEntityMovement.Global.PathModel:New(path);
            self.ProcessedPaths[_Index] = nil;
            self:SendPathingSucceedEvent(_Index);
            return true;
        else
            self:Expand(_Index, removed);
        end
    end
    return false;
end

function ModuleEntityMovement.Global.PathFinder:Expand(_Index, _Node)
    local x = _Node.X;
    local y = _Node.Y;

    -- Regular nodes
    local FatherNodeID = _Node.ID;
    local SuccessorNodes = {};
    local Distance = self.ProcessedPaths[_Index].NodeDistance;
    for i= x-Distance, x+Distance, Distance do
        for j= y-Distance, y+Distance, Distance do
            if not (i == x and j == y) then
                if  not self.ProcessedPaths[_Index].OpenMap["ID_"..i.."_"..j] 
                and not self.ProcessedPaths[_Index].ClosedMap["ID_"..i.."_"..j] then
                    -- Insert node
                    table.insert(SuccessorNodes, {
                        ID = "ID_"..i.."_"..j,
                        X = i,
                        Y = j,
                        Father = FatherNodeID,
                        Distance1 = API.GetDistance(_Node, self.ProcessedPaths[_Index].TargetNode),
                        Distance2 = API.GetDistance(self.ProcessedPaths[_Index].StartNode, _Node)
                    });
                end
            end
        end
    end

    -- Check successor nodes and put into open list
    self:AcceptSuccessors(_Index, SuccessorNodes);
    -- Sort open list
    self:SortOpenList(_Index);
    -- Insert current node to closed list
    table.insert(self.ProcessedPaths[_Index].Closed, _Node);
    self.ProcessedPaths[_Index].OpenMap[_Node.ID] = true;
end

function ModuleEntityMovement.Global.PathFinder:AcceptSuccessors(_Index, _SuccessorList)
    local SuccessorList = {};
    for k,v in pairs(_SuccessorList) do
        if not self.ProcessedPaths[_Index].ClosedMap["ID_"..v.X.."_"..v.Y] then
            if not self.ProcessedPaths[_Index].OpenMap["ID_"..v.X.."_"..v.Y] then
                table.insert(SuccessorList, v);
            end
        end
    end
    for k,v in pairs(SuccessorList) do
        local useNode = true;
        if self.ProcessedPaths[_Index].AcceptMethode then
            useNode = useNode and self.ProcessedPaths[_Index].AcceptMethode(
                v, SuccessorList, unpack(self.ProcessedPaths[_Index].AcceptArgs)
            );
        end
        if useNode then
            table.insert(self.ProcessedPaths[_Index].Open, v);
            self.ProcessedPaths[_Index].OpenMap[v.ID] = true;
            -- Make visible (debug only)
            -- Logic.CreateEntity(Entities.XD_CoordinateEntity, v.X, v.Y, 0, 0);
        end
    end
end

function ModuleEntityMovement.Global.PathFinder:SortOpenList(_Index)
    local comp = function(v,w)
        return v.Distance1 < w.Distance1 and v.Distance2 < w.Distance2;
    end
    table.sort(self.ProcessedPaths[_Index].Open, comp);
end

function ModuleEntityMovement.Global.PathFinder:GetClosestPositionOnNodeMap(_Position, _NodeDistance)
    if type(_Position) ~= "table" then
        _Position = API.GetPosition(_Position);
    end
    local Distance = _NodeDistance;
    local X = math.floor(_Position.X + 0.5);
    local XMod = (X % Distance);
    local bx = (XMod > Distance/2 and (X + (Distance - XMod))) or X - XMod;
    local Y = math.floor(_Position.Y + 0.5);
    local YMod = (Y % Distance);
    local by = (YMod > Distance/2 and (Y + (Distance - YMod))) or Y - YMod;
    return {X= bx, Y= by};
end

function ModuleEntityMovement.Global.PathFinder:GetNodeByID(_Index, _ID)
    local node;
    for i=1, #self.ProcessedPaths[_Index].Closed do
        if self.ProcessedPaths[_Index].Closed[i].ID == _ID then
            node = self.ProcessedPaths[_Index].Closed[i];
        end
    end
    return node;
end

function ModuleEntityMovement.Global.PathFinder:IsPathExisting(_ID)
    return self.PathList[_ID] ~= nil;
end

function ModuleEntityMovement.Global.PathFinder:IsPathStillCalculated(_ID)
    return self.ProcessedPaths[_ID] ~= nil;
end

function ModuleEntityMovement.Global.PathFinder:GetPath(_ID)
    if self:IsPathExisting(_ID) then
        return table.copy(self.PathList[_ID]);
    end
end

-- -------------------------------------------------------------------------- --
-- Path Model Class

ModuleEntityMovement.Global.PathModel = {
    Nodes = {};
};

function ModuleEntityMovement.Global.PathModel:New(_Nodes)
    local Instance = table.copy(self);
    Instance.Nodes = _Nodes;
    return Instance;
end

function ModuleEntityMovement.Global.PathModel:FromList(_List)
    local path = ModuleEntityMovement.Global.PathModel:New({});
    local father = nil;

    local Start = _List[1];
    local End   = _List[#_List];

    for i= 1, #_List, 1 do
        local ID = GetID(_List[i]);
        local x,y,z = Logic.EntityGetPos(ID);
        table.insert(path.Nodes, {
            ID        = "ID_" ..ID,
            Marker    = 0,
            Father    = father,
            Visited   = false,
            X         = x,
            Y         = y,
            Distance1 = API.GetDistance(ID, End),
            Distance2 = API.GetDistance(Start, ID),
        });
        father = "ID_" ..ID;
    end
    return path;
end

function ModuleEntityMovement.Global.PathModel:AddNode(_Node)
    local n = #self.Nodes;
    if n > 1 then
        _Node.Father = self.Nodes[n-1].ID;
    else
        _Node.Father = nil;
    end
    table.insert(self.Nodes, _Node);
end

function ModuleEntityMovement.Global.PathModel:Merge(_Other)
    if _Other and #_Other.Nodes > 0 and #self.Nodes > 0 then
        _Other.Nodes[1].Father = self.Nodes[#self.Nodes].ID;
        for i= 1, #_Other.Nodes, 1 do
            table.insert(self.Nodes, _Other.Nodes[i]);
        end
    end
end

function ModuleEntityMovement.Global.PathModel:Reduce(_By)
    local Reduced = table.copy(self);
    local n = #Reduced.Nodes;
    for i= n, 1, -1 do
        if i ~= 1 and i ~= n and i % _By ~= 0 then
            Reduced.Nodes[i+1].Father = Reduced.Nodes[i-1].Father;
            table.remove(Reduced.Nodes, i);
        end
    end
    return Reduced;
end

function ModuleEntityMovement.Global.PathModel:Reset()
    for k,v in pairs(self.Nodes) do
        self.Nodes[k].Visited = false;
    end
end

function ModuleEntityMovement.Global.PathModel:Reverse()
    return ModuleEntityMovement.Global.PathModel:New(table.invert(self.Nodes));
end

function ModuleEntityMovement.Global.PathModel:Next()
    local Node, ID = self:GetCurrentWaypoint();
    if Node then
        self.Nodes[ID].Visited = true;
    end
end

function ModuleEntityMovement.Global.PathModel:GetCurrentWaypoint()
    local lastWP;
    local id = 1;
    repeat
        lastWP = self.Nodes[id];
        id = id +1;
    until ((not self.Nodes[id]) or self.Nodes[id].Visited == false);
    if not self.Nodes[id] then
        id = id -1;
    end
    return lastWP, id;
end

function ModuleEntityMovement.Global.PathModel:Convert()
    if #self.Nodes > 0 then
        local nodes = {};
        for i=1, #self.Nodes do
            local eID = Logic.CreateEntity(
                Entities.XD_ScriptEntity,
                self.Nodes[i].X,
                self.Nodes[i].Y,
                0,
                0
            );
            table.insert(nodes, eID);
        end
        return nodes;
    end
end

function ModuleEntityMovement.Global.PathModel:Show()
    if #self.Nodes > 0 then
        for i=1, #self.Nodes do
            local ID = Logic.CreateEntity(
                Entities.XD_ScriptEntity,
                self.Nodes[i].X,
                self.Nodes[i].Y,
                0,
                0
            );
            Logic.SetModel(ID, Models.Doodads_D_X_Flag);
            Logic.SetVisible(ID, true);
            self.Nodes[i].Marker = ID;
        end
    end
end

function ModuleEntityMovement.Global.PathModel:Hide()
    for k, v in pairs(self.Nodes) do
        DestroyEntity(v.Marker);
        self.Nodes[k].Marker = 0;
    end
end

-- -------------------------------------------------------------------------- --
-- Local Script

function ModuleEntityMovement.Local:OnGameStart()
    QSB.ScriptEvents.EntityArrived = API.RegisterScriptEvent("Event_EntityArrived");
    QSB.ScriptEvents.EntityStuck = API.RegisterScriptEvent("Event_EntityStuck");
    QSB.ScriptEvents.EntityAtCheckpoint = API.RegisterScriptEvent("Event_EntityAtCheckpoint");
    QSB.ScriptEvents.PathFindingFinished = API.RegisterScriptEvent("Event_PathFindingFinished");
    QSB.ScriptEvents.PathFindingFailed = API.RegisterScriptEvent("Event_PathFindingFailed");
end

function ModuleEntityMovement.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleEntityMovement);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Ermoglicht die Bewegung von Entities und Berechnung von Pfaden.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field EntityArrived       Ein Entity hat das Ziel erreicht. (Parameter: EntityID, Position, DataIndex)
-- @field EntityStuck         Ein Entity kann das Ziel nicht erreichen. (Parameter: EntityID, Position, DataIndex)
-- @field EntityAtCheckpoint  Ein Entity hat einen Wegpunkt erreicht. (Parameter: EntityID, Position, DataIndex)
-- @field PathFindingFinished Ein Pfad wurde erfolgreich gefunden (Parameter: PathID)
-- @field PathFindingFailed   Ein Pfad konnte nicht ermittelt werden (Parameter: PathID)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Bewegt ein Entity zum Zielpunkt.
--
-- Wenn das Ziel zu irgend einem Zeitpunkt nicht erreicht werden kann, wird die
-- Bewegung abgebrochen und das Event QSB.ScriptEvents.EntityStuck geworfen.
--
-- Das Ziel gilt als erreicht, sobald sich das Entity nicht mehr bewegt. Dann
-- wird das Event QSB.ScriptEvents.EntityArrived geworfen.
--
-- @param               _Entity         Bewegtes Entity (Skriptname oder ID)
-- @param               _Target         Ziel (Skriptname, ID oder Position)
-- @param[type=boolean] _IgnoreBlocking Direkten Weg benutzen
-- @within Bewegung
--
-- @usage
-- -- Beispiel #1: Normale Bewegung
-- API.MoveEntity("Marcus", "Target");
--
-- @usage
-- -- Beispiel #2: Schiff bewegen
-- API.MoveEntity("Ship", "Harbor", true);
--
function API.MoveEntity(_Entity, _Target, _IgnoreBlocking)
    if not IsExisting(_Entity) then
        error("API.MoveEntity: entity '" ..tostring(_Entity).. "' does not exist!");
        return;
    end
    if type(_Target) == "table" then
        if not API.IsValidPosition(_Target) then
            error("API.MoveEntity: position '" ..tostring(_Target).. "' is invaid!");
            return;
        end
    else
        if not IsExisting(_Target) then
            error("API.MoveEntity: entity '" ..tostring(_Target).. "' does not exist!");
            return;
        end
    end
    local Index = ModuleEntityMovement.Global:FillMovingEntityDataForController(
        _Entity, {_Target}, nil, nil, _IgnoreBlocking
    );
    API.StartHiResJob(function(_Index)
        return ModuleEntityMovement.Global:MoveEntityPathController(_Index);
    end, Index);
    return Index;
end

---
-- Bewegt ein Entity zum Zielpunkt und lässt es das Ziel anschauen.
--
-- Wenn das Ziel zu irgend einem Zeitpunkt nicht erreicht werden kann, wird die
-- Bewegung abgebrochen und das Event QSB.ScriptEvents.EntityStuck geworfen.
--
-- Das Ziel gilt als erreicht, sobald sich das Entity nicht mehr bewegt. Dann
-- wird das Event QSB.ScriptEvents.EntityArrived geworfen.
--
-- @param               _Entity         Bewegtes Entity (Skriptname oder ID)
-- @param               _Target         Ziel (Skriptname, ID oder Position)
-- @param               _LookAt         Angeschaute Position (Skriptname, ID oder Position)
-- @param[type=boolean] _IgnoreBlocking Direkten Weg benutzen
-- @within Bewegung
--
-- @usage
-- API.MoveEntityAndLookAt("Marcus", "Target", "Alandra");
--
function API.MoveEntityAndLookAt(_Entity, _Target, _LookAt, _IgnoreBlocking)
    if not IsExisting(_Entity) then
        error("API.MoveEntityAndLookAt: entity '" ..tostring(_Entity).. "' does not exist!");
        return;
    end
    if type(_Target) == "table" then
        if not API.IsValidPosition(_Target) then
            error("API.MoveEntityAndLookAt: position '" ..tostring(_Target).. "' is invaid!");
            return;
        end
    else
        if not IsExisting(_Target) then
            error("API.MoveEntityAndLookAt: entity '" ..tostring(_Target).. "' does not exist!");
            return;
        end
    end
    local Index = ModuleEntityMovement.Global:FillMovingEntityDataForController(
        _Entity, {_Target}, _LookAt, nil, _IgnoreBlocking
    );
    API.StartHiResJob(function(_Index)
        return ModuleEntityMovement.Global:MoveEntityPathController(_Index);
    end, Index);
    return Index;
end

---
-- Bewegt ein Entity relativ zu einer Position.
--
-- Wenn das Ziel zu irgend einem Zeitpunkt nicht erreicht werden kann, wird die
-- Bewegung abgebrochen und das Event QSB.ScriptEvents.EntityStuck geworfen.
--
-- Das Ziel gilt als erreicht, sobald sich das Entity nicht mehr bewegt. Dann
-- wird das Event QSB.ScriptEvents.EntityArrived geworfen.
--
-- @param                _Entity         Bewegtes Entity (Skriptname oder ID)
-- @param                _Target         Ziel (Skriptname, ID oder Position)
-- @param[type=number]  _Distance        Entfernung zum Ziel
-- @param[type=number]  _Angle           Winkel zum Ziel
-- @within Bewegung
--
-- @usage
-- API.MoveEntityToPosition("Marcus", "Target", 1000, 90);
--
function API.MoveEntityToPosition(_Entity, _Target, _Distance, _Angle, _IgnoreBlocking)
    if not IsExisting(_Entity) then
        error("API.MoveEntityToPosition: entity '" ..tostring(_Entity).. "' does not exist!");
        return;
    end
    if type(_Target) == "table" then
        if not API.IsValidPosition(_Target) then
            error("API.MoveEntityToPosition: position '" ..tostring(_Target).. "' is invaid!");
            return;
        end
    else
        if not IsExisting(_Target) then
            error("API.MoveEntityToPosition: entity '" ..tostring(_Target).. "' does not exist!");
            return;
        end
    end
    local Target = API.GetCirclePosition(_Target, _Distance, _Angle);
    if not API.IsValidPosition(Target) then
        return;
    end
    local Index = ModuleEntityMovement.Global:FillMovingEntityDataForController(
        _Entity, {Target}, nil, nil, _IgnoreBlocking
    );
    API.StartHiResJob(function(_Index)
        return ModuleEntityMovement.Global:MoveEntityPathController(_Index);
    end, Index);
    return Index;
end

---
-- Bewegt ein Entity zum Zielpunkt und führt die Funktion aus.
--
-- Wenn das Ziel zu irgend einem Zeitpunkt nicht erreicht werden kann, wird die
-- Bewegung abgebrochen und das Event QSB.ScriptEvents.EntityStuck geworfen.
--
-- Das Ziel gilt als erreicht, sobald sich das Entity nicht mehr bewegt. Dann
-- wird das Event QSB.ScriptEvents.EntityArrived geworfen.
--
-- @param                _Entity         Bewegtes Entity (Skriptname oder ID)
-- @param                _Target         Ziel (Skriptname, ID oder Position)
-- @param[type=function] _Action         Funktion wenn Entity ankommt
-- @param[type=boolean]  _IgnoreBlocking Direkten Weg benutzen
-- @within Bewegung
--
-- @usage
-- API.MoveEntityAndExecute("Marcus", "Target", function()
--     Logic.DEBUG_AddNote("Marcus ist angekommen!");
-- end);
--
function API.MoveEntityAndExecute(_Entity, _Target, _Action, _IgnoreBlocking)
    if not IsExisting(_Entity) then
        error("API.MoveEntityAndExecute: entity '" ..tostring(_Entity).. "' does not exist!");
        return;
    end
    if type(_Target) == "table" then
        if not API.IsValidPosition(_Target) then
            error("API.MoveEntityAndExecute: position '" ..tostring(_Target).. "' is invaid!");
            return;
        end
    else
        if not IsExisting(_Target) then
            error("API.MoveEntityAndExecute: entity '" ..tostring(_Target).. "' does not exist!");
            return;
        end
    end
    local Index = ModuleEntityMovement.Global:FillMovingEntityDataForController(
        _Entity, {_Target}, nil, _Action, _IgnoreBlocking
    );
    API.StartHiResJob(function(_Index)
        return ModuleEntityMovement.Global:MoveEntityPathController(_Index);
    end, Index);
    return Index;
end

---
-- Bewegt ein Entity über den angegebenen Pfad.
--
-- Wenn das Ziel zu irgend einem Zeitpunkt nicht erreicht werden kann, wird die
-- Bewegung abgebrochen und das Event QSB.ScriptEvents.EntityStuck geworfen.
--
-- Jedes Mal wenn das Entity einen Wegpunkt erreicht hat, wird das Event
-- QSB.ScriptEvents.EntityAtCheckpoint geworfen.
--
-- Das Ziel gilt als erreicht, sobald sich das Entity nicht mehr bewegt. Dann
-- wird das Event QSB.ScriptEvents.EntityArrived geworfen.
--
-- @param                _Entity         Bewegtes Entity (Skriptname oder ID)
-- @param                _WaypointList   Liste mit Wegpunkten
-- @param[type=boolean]  _IgnoreBlocking Direkten Weg benutzen
-- @within Bewegung
--
-- @usage
-- API.MoveEntityOnCheckpoints("Marcus", {"WP1", "WP2", "WP3", "Target"});
--
function API.MoveEntityOnCheckpoints(_Entity, _WaypointList, _IgnoreBlocking)
    if not IsExisting(_Entity) then
        error("API.MoveEntityOnCheckpoints: entity '" ..tostring(_Entity).. "' does not exist!");
        return;
    end
    if type(_WaypointList) ~= "table" then
        error("API.MoveEntityOnCheckpoints: target list must be a table!");
        return;
    end
    local Index = ModuleEntityMovement.Global:FillMovingEntityDataForController(
        _Entity, _WaypointList, nil, nil, _IgnoreBlocking
    );
    API.StartHiResJob(function(_Index)
        return ModuleEntityMovement.Global:MoveEntityPathController(_Index);
    end, Index);
    return Index;
end

---
-- Positioniert ein Entity und lässt es einen Ort ansehen.
--
-- @param _Entity Bewegtes Entity (Skriptname oder ID)
-- @param _Target Ziel (Skriptname, ID oder Position)
-- @param _LookAt Angeschaute Position (Skriptname, ID oder Position)
-- @within Bewegung
--
-- @usage
-- API.PlaceEntityAndLookAt("Marcus", "Target", "Alandra");
--
function API.PlaceEntityAndLookAt(_Entity, _Target, _LookAt)
    if not IsExisting(_Entity) then
        error("API.PlaceEntityAndLookAt: entity '" ..tostring(_Entity).. "' does not exist!");
        return;
    end
    if type(_Target) == "table" then
        if not API.IsValidPosition(_Target) then
            error("API.PlaceEntityAndLookAt: position '" ..tostring(_Target).. "' is invaid!");
            return;
        end
    else
        if not IsExisting(_Target) then
            error("API.PlaceEntityAndLookAt: entity '" ..tostring(_Target).. "' does not exist!");
            return;
        end
    end
    API.SetPosition(_Entity, _Target);
    API.LookAt(_Entity, _LookAt);
end

---
-- Positioniert ein Entity relativ zu einer Position.
--
-- @param               _Entity  Bewegtes Entity (Skriptname oder ID)
-- @param               _Target  Ziel (Skriptname, ID oder Position)
-- @param[type=number] _Distance Entfernung zum Ziel
-- @param[type=number] _Angle    Winkel zum Ziel
-- @within Bewegung
--
-- @usage
-- API.PlaceEntityAndLookAt("Marcus", "Target", 1000, 90);
--
function API.PlaceEntityToPosition(_Entity, _Target, _Distance, _Angle)
    if not IsExisting(_Entity) then
        error("API.PlaceEntityToPosition: entity '" ..tostring(_Entity).. "' does not exist!");
        return;
    end
    if type(_Target) == "table" then
        if not API.IsValidPosition(_Target) then
            error("API.PlaceEntityToPosition: position '" ..tostring(_Target).. "' is invaid!");
            return;
        end
    else
        if not IsExisting(_Target) then
            error("API.PlaceEntityToPosition: entity '" ..tostring(_Target).. "' does not exist!");
            return;
        end
    end
    local Target = API.GetCirclePosition(_Target, _Distance, _Angle);
    if not API.IsValidPosition(Target) then
        return;
    end
    API.SetPosition(_Entity, Target);
end

---
-- Beginnt die Wegsuche zwischen zwei Punkten.
--
-- Der Pfad wird nicht sofort zurückgegeben. Stattdessen eine ID. Der Pfad wird
-- asynchron gesucht, damit das Spiel nicht einfriert. Wenn die Pfadsuche
-- abgeschlossen wird, werden entsprechende Events ausgelöst.
--
-- <ul>
-- <li><b>QSB.ScriptEvents.PathFindingFinished</b><br/>
-- Ein Pfad zwischen den Punkten wurde gefunden.</li>
-- <li><b>QSB.ScriptEvents.PathFindingFailed</b><br/>
-- Es konnte kein Pfad gefunden werden.</li>
-- </ul>
--
-- Wird der Node Filter weggelassen, wird automatisch eine Funktion erstellt,
-- die alle Positionen ausschließt, die geblockt sind.
--
-- @param                _StartPosition Beginn des Pfad (Position, Skriptname oder ID)
-- @param                _EndPosition   Ende des Pfad (Position, Skriptname oder ID)
-- @param[type=function] _NodeFilter    (Optional) Filterfunktion für Wegpunkte
-- @retun[type=number] ID des Pfad
-- @within Pfadsuche
--
-- @usage
-- -- Beispiel #1: Standard Wegsuche
-- MyPathID = API.StartPathfinding("Start", "End");
--
-- @usage
-- -- Beispiel #2: Wegsuche mit Filter
-- MyPathID = API.StartPathfinding("Start", "End", function(_CurrentNode, _AdjacentNodes)
--     -- Position verwerfen, wenn sie im Blocking ist
--     if Logic.DEBUG_GetSectorAtPosition(_CurrentNode.X, _CurrentNode.Y) == 0 then
--         return false;
--     end
--     -- Position verwerfen, wenn sie auf Territorium 16 liegt
--     if Logic.GetTerritoryAtPosition(_CurrentNode.X, _CurrentNode.Y) == 16 then
--         return false;
--     end
--     -- Position akzeptieren
--     return true;
-- end);
--
function API.StartPathfinding(_StartPosition, _EndPosition, _NodeFilter)
    if type(_StartPosition) ~= "table" then
        _StartPosition = API.GetPosition(_StartPosition);
    end
    if type(_EndPosition) ~= "table" then
        _EndPosition = API.GetPosition(_EndPosition);
    end

    _NodeFilter = _NodeFilter or function(_CurrentNode, _AdjacentNodes)
        if Logic.DEBUG_GetSectorAtPosition(_CurrentNode.X, _CurrentNode.Y) == 0 then
            return false;
        end
        return true;
    end
    if type(_NodeFilter) ~= "function" then
        error("API.StartPathfinding: node filter must be a function!");
        return;
    end
    return ModuleEntityMovement.Global.PathFinder:Insert(
        _EndPosition, _StartPosition, 750, 3, _NodeFilter
    );
end

---
-- Prüft ob ein Pfad mit der ID existiert.
--
-- @param[type=number]  _ID ID des Pfad
-- @retun[type=boolean] Der Pfad existiert
-- @within Pfadsuche
--
-- @usage
-- if API.IsPathExisting(MyPathID) then
--     -- Mach was
-- end
--
function API.IsPathExisting(_ID)
    return ModuleEntityMovement.Global.PathFinder:IsPathExisting(_ID);
end

---
-- Prüft ob ein Pfad mit der ID noch gesucht wird.
--
-- @param[type=number]  _ID ID des Pfad
-- @retun[type=boolean] Der Pfad wird gesucht
-- @within Pfadsuche
--
-- @usage
-- if API.IsPathBeingCalculated(MyPathID) then
--     -- Mach was
-- end
--
function API.IsPathBeingCalculated(_ID)
    return ModuleEntityMovement.Global.PathFinder:IsPathStillCalculated(_ID);
end

---
-- Gibt den Pfad mit der ID als Liste von Entity-IDs zurück.
--
-- @param[type=number]  _ID ID des Pfad
-- @retun[type=table] Liste mit IDs
-- @within Pfadsuche
--
-- @usage
-- WaypointList = API.RetrievePath(MyPathID);
--
function API.RetrievePath(_ID)
    if not API.IsPathExisting(_ID) then
        error("API.StartPathfinding: no path is existing for id " .._ID.. "!");
        return;
    end
    if API.IsPathBeingCalculated(_ID) then
        error("API.StartPathfinding: the path " .._ID.. " is still being calculated!");
        return;
    end
    local Path = ModuleEntityMovement.Global.PathFinder:GetPath(_ID);
    return Path:Reduce(5):Convert();
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleSound = {
    Properties = {
        Name = "ModuleSound",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {},
    Local = {
        SoundBackup = {},
    },
}

-- Global Script ---------------------------------------------------------------

function ModuleSound.Global:OnGameStart()
end

function ModuleSound.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- Local Script ----------------------------------------------------------------

function ModuleSound.Local:OnGameStart()
end

function ModuleSound.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

function ModuleSound.Local:AdjustSound(_Global, _Music, _Voice, _Atmo, _UI)
    self:SaveSound();
    if _Global then
        Sound.SetGlobalVolume(_Global);
    end
    if _Music then
        Sound.SetMusicVolume(_Music);
    end
    if _Voice then
        Sound.SetSpeechVolume(_Voice);
    end
    if _Atmo then
        Sound.SetFXSoundpointVolume(_Atmo);
        Sound.SetFXAtmoVolume(_Atmo);
    end
    if _UI then
        Sound.Set2DFXVolume(_UI);
        Sound.SetFXVolume(_UI);
    end
end

function ModuleSound.Local:SaveSound()
    if not self.SoundBackup.Saved then
        self.SoundBackup.Saved = true;
        self.SoundBackup.FXSP = Sound.GetFXSoundpointVolume();
        self.SoundBackup.FXAtmo = Sound.GetFXAtmoVolume();
        self.SoundBackup.FXVol = Sound.GetFXVolume();
        self.SoundBackup.Sound = Sound.GetGlobalVolume();
        self.SoundBackup.Music = Sound.GetMusicVolume();
        self.SoundBackup.Voice = Sound.GetSpeechVolume();
        self.SoundBackup.UI = Sound.Get2DFXVolume();
    end
end

function ModuleSound.Local:RestoreSound()
    if self.SoundBackup.Saved then
        Sound.SetFXSoundpointVolume(self.SoundBackup.FXSP);
        Sound.SetFXAtmoVolume(self.SoundBackup.FXAtmo);
        Sound.SetFXVolume(self.SoundBackup.FXVol);
        Sound.SetGlobalVolume(self.SoundBackup.Sound);
        Sound.SetMusicVolume(self.SoundBackup.Music);
        Sound.SetSpeechVolume(self.SoundBackup.Voice);
        Sound.Set2DFXVolume(self.SoundBackup.UI);
        self.SoundBackup = {};
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleSound);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

---
-- Ermöglicht die Steuerung der Laufstärke und Ausgabe von Sounds.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- </ul>
--
-- @within Modulbeschreibung
-- @set sort=true
--

---
-- Startet eine Playlist, welche als XML angegeben ist.
--
-- Eine als XML definierte Playlist wird nicht als Voice abgespielt sondern
-- als Music. Als Musik werden MP3-Dateien verwendet. Diese können entweder
-- im Spiel vorhanden sein oder im Ordner <i>music/</i> im Root-Verzeichnis
-- des Spiels gespeichert werden. Die Playlist gehört ebenfalls ins Root-
-- Verzeichnis nach <i>config/sound/</i>.
--
-- Verzeichnisstruktur für eigene Musik:
-- <pre>map_xyz.s6xmap.unpacked
--|-- music/*
--|-- config/sound/*
--|-- maps/externalmap/map_xyz/*
--|-- ...</pre>
--
-- In der QSB sind bereits die Variablen <i>gvMission.MusicRootPath</i> und
-- <i>gvMission.PlaylistRootPath</i> mit den entsprechenden Pfaden vordefiniert.
--
-- Wenn du eigene Musik verwendest, achte darauf, einen möglichst eindeutigen
-- Namen zu verwenden. Und natürlich auch auf Urheberrecht!
--
-- Beispiel für eine Playlist:
-- <pre>
--&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
--&lt;PlayList&gt;
-- &lt;PlayListEntry&gt;
--   &lt;FileName&gt;Music\some_music_file.mp3&lt;/FileName&gt;
--   &lt;Type&gt;Loop&lt;/Type&gt;
-- &lt;/PlayListEntry&gt;
-- &lt;!-- Hier können weitere Einträge folgen. --&gt;
--&lt;/PlayList&gt;
--</pre>
-- Als Typ können "Loop" oder "Normal" gewählt werden. Normale Musik wird
-- einmalig abgespielt. Ein Loop läuft endlos weiter.
--
-- Außerdem kann zusätzlich zum Typ eine Abspielwahrscheinlichkeit mit
-- angegeben werden:
-- <pre>&lt;Chance&gt;10&lt;/Chance&gt;</pre>
-- Es sind Zahlen von 1 bis 100 möglich.
--
-- @param _Playlist Pfad zur Playlist
-- @param _PlayerID (Optional) ID des menschlichen Spielers
-- @within Anwenderfunktionen
--
-- @usage
-- API.StartEventPlaylist(gvMission.PlaylistRootPath .."my_playlist.xml");
--
function API.StartEventPlaylist(_Playlist, _PlayerID)
    _PlayerID = _PlayerID or 1;
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.StartEventPlaylist('%s', %d)", _Playlist, _PlayerID));
        return;
    end
    if _PlayerID == GUI.GetPlayerID() then
        Sound.MusicStartEventPlaylist(_Playlist)
    end
end

---
-- Beendet eine Event Playlist.
--
-- @param _Playlist Pfad zur Playlist
-- @param _PlayerID (Optional) ID des menschlichen Spielers
-- @within Anwenderfunktionen
--
-- @usage
-- API.StopEventPlaylist("config/sound/my_playlist.xml");
--
function API.StopEventPlaylist(_Playlist, _PlayerID)
    _PlayerID = _PlayerID or 1;
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.StopEventPlaylist('%s', %d)", _Playlist, _PlayerID));
        return;
    end
    if _PlayerID == GUI.GetPlayerID() then
        Sound.MusicStopEventPlaylist(_Playlist)
    end
end

---
-- Spielt einen 2D-Sound aus dem Spiel ab.
--
-- Ein 2D-Sound ist nicht positionsgebunden und ist immer zu hören, egal an
-- welcher Stelle auf der Map sich die Kamera befindet.
--
-- Wenn eigene Sounds verwendet werden sollen, müssen sie im WAV-Format
-- vorliegen und in die zwei Verzeichnisse für niedrige und hohe Qualität
-- kopiert werden.
--
-- Verzeichnisstruktur für eigene Sounds:
-- <pre>map_xyz.s6xmap.unpacked
--|-- sounds/high/ui/*
--|-- sounds/low/ui/*
--|-- maps/externalmap/map_xyz/*
--|-- ...</pre>
--
-- @param _Sound    Pfad des Sound
-- @param _PlayerID (Optional) ID des menschlichen Spielers
-- @within Anwenderfunktionen
--
-- @usage
-- API.Play2DSound("ui/menu_left_gold_pay");
--
function API.Play2DSound(_Sound, _PlayerID)
    _PlayerID = _PlayerID or 1;
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.Play2DSound("%s", %d)]],
            _Sound,
            _PlayerID
        ));
        return;
    end
    if _PlayerID == GUI.GetPlayerID() then
        Sound.FXPlay2DSound(_Sound:gsub("/", "\\"));
    end
end
API.PlaySound = API.Play2DSound;

---
-- Spielt einen 3D-Sound aus dem Spiel ab.
--
-- Ein 3D-Sound wird an einer bestimmten Position abgespielt und ist nur in
-- einem begrenzten Bereich um die Position höhrbar.
--
-- Wenn eigene Sounds verwendet werden sollen, müssen sie im WAV-Format
-- vorliegen und in die zwei Verzeichnisse für niedrige und hohe Qualität
-- kopiert werden.
--
-- Verzeichnisstruktur für eigene Sounds:
-- <pre>map_xyz.s6xmap.unpacked
--|-- sounds/high/ui/*
--|-- sounds/low/ui/*
--|-- maps/externalmap/map_xyz/*
--|-- ...</pre>
--
-- @param _Sound    Pfad des Sound
-- @param _X        X-Position des Sound
-- @param _Y        Y-Position des Sound
-- @param _Z        Z-Position des Sound
-- @param _PlayerID (Optional) ID des menschlichen Spielers
-- @within Anwenderfunktionen
--
-- @usage
-- API.Play3DSound("Animals/cow_disease", 8500, 35800, 2000);
--
function API.Play3DSound(_Sound, _X, _Y, _Z, _PlayerID)
    _PlayerID = _PlayerID or 1;
    _X = _X or 1;
    _Y = _Y or 1
    _Z = _Z or 0
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.Play3DSound("%s", %f, %f, %d)]],
            _Sound,
            _X,
            _Y,
            _PlayerID
        ));
        return;
    end
    if _PlayerID == GUI.GetPlayerID() then
        Sound.FXPlay3DSound(_Sound:gsub("/", "\\"), _X, _Y, _Z);
    end
end

---
-- Setzt die allgemeine Lautstärke. Die allgemeine Lautstärke beeinflusst alle
-- anderen Laufstärkeregler.
--
-- <b>Hinweis:</b> Es wird automatisch ein Backup der Einstellungen angelegt
-- wenn noch keins angelegt wurde.
--
-- @param _Volume Lautstärke
-- @within Anwenderfunktionen
--
-- @usage
-- API.SoundSetVolume(100);
--
function API.SoundSetVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.SoundSetVolume(%d)", _Volume));
        return;
    end
    ModuleSound.Local:AdjustSound(_Volume, nil, nil, nil, nil);
end

---
-- Setzt die Lautstärke der Musik.
--
-- <b>Hinweis:</b> Es wird automatisch ein Backup der Einstellungen angelegt
-- wenn noch keins angelegt wurde.
--
-- @param _Volume Lautstärke
-- @within Anwenderfunktionen
--
-- @usage
-- API.SoundSetMusicVolume(100);
--
function API.SoundSetMusicVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.SoundSetMusicVolume(%d)", _Volume));
        return;
    end
    ModuleSound.Local:AdjustSound(nil, _Volume, nil, nil, nil);
end

---
-- Setzt die Lautstärke der Stimmen.
--
-- <b>Hinweis:</b> Es wird automatisch ein Backup der Einstellungen angelegt
-- wenn noch keins angelegt wurde.
--
-- @param _Volume Lautstärke
-- @within Anwenderfunktionen
--
-- @usage
-- API.SoundSetVoiceVolume(100);
--
function API.SoundSetVoiceVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.SoundSetVoiceVolume(%d)", _Volume));
        return;
    end
    ModuleSound.Local:AdjustSound(nil, nil, _Volume, nil, nil);
end

---
-- Setzt die Lautstärke der Umgebung.
--
-- <b>Hinweis:</b> Es wird automatisch ein Backup der Einstellungen angelegt
-- wenn noch keins angelegt wurde.
--
-- @param _Volume Lautstärke
-- @within Anwenderfunktionen
--
-- @usage
-- API.SoundSetAtmoVolume(100);
--
function API.SoundSetAtmoVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.SoundSetAtmoVolume(%d)", _Volume));
        return;
    end
    ModuleSound.Local:AdjustSound(nil, nil, nil, _Volume, nil);
end

---
-- Setzt die Lautstärke des Interface.
--
-- <b>Hinweis:</b> Es wird automatisch ein Backup der Einstellungen angelegt
-- wenn noch keins angelegt wurde.
--
-- @param _Volume Lautstärke
-- @within Anwenderfunktionen
--
-- @usage
-- API.SoundSetUIVolume(100);
--
function API.SoundSetUIVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.SoundSetUIVolume(%d)", _Volume));
        return;
    end
    ModuleSound.Local:AdjustSound(nil, nil, nil, nil, _Volume);
end

---
-- Erstellt ein Backup der Soundeinstellungen, wenn noch keins erstellt wurde.
--
-- @within Anwenderfunktionen
-- @local
--
-- @usage
-- API.SoundSave();
--
function API.SoundSave()
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.SoundSave()");
        return;
    end
    ModuleSound.Local:SaveSound();
end

---
-- Stellt den Sound wieder her, sofern ein Backup erstellt wurde.
--
-- @within Anwenderfunktionen
--
-- @usage
-- API.SoundRestore();
--
function API.SoundRestore()
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.SoundRestore()");
        return;
    end
    ModuleSound.Local:RestoreSound();
end

---
-- Gibt eine MP3-Datei als Stimme wieder. Diese Funktion kann auch benutzt
-- werden um Geräusche abzuspielen.
--
-- @param[type=string] _File Abzuspielende Datei
-- @within Anwenderfunktionen
--
-- @usage
-- API.PlayVoice("music/puhdys_alt_wie_ein_baum.mp3");
--
function API.PlayVoice(_File)
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.PlayVoice('%s')", _File));
        return;
    end
    API.StopVoice();
    Sound.PlayVoice("ImportantStuff", _File);
end

---
-- Stoppt alle als Stimme abgespielten aktiven Sounds.
--
-- @within Anwenderfunktionen
--
-- @usage
-- API.StopVoice();
--
function API.StopVoice()
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.StopVoice()");
        return;
    end
    Sound.StopVoice("ImportantStuff");
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleTrade = {
    Properties = {
        Name = "ModuleTrade",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        Analysis = {
            PlayerOffersAmount = {
                [1] = {}, [2] = {}, [3] = {}, [4] = {},
                [5] = {}, [6] = {}, [7] = {}, [8] = {},
            };
        },
        Lambda = {},
        Event = {},
    },
    Local = {
        Lambda = {
            PurchaseTraderAbility = {},
            PurchaseBasePrice     = {},
            PurchaseInflation     = {},
            PurchaseAllowed       = {},
            SaleTraderAbility     = {},
            SaleBasePrice         = {},
            SaleDeflation         = {},
            SaleAllowed           = {},
        },
        ShowKnightTraderAbility = true;
    },

    Shared = {},
};

QSB.TraderTypes = {
    GoodTrader        = 0,
    MercenaryTrader   = 1,
    EntertainerTrader = 2,
    Unknown           = 3,
};

-- Global ------------------------------------------------------------------- --

function ModuleTrade.Global:OnGameStart()
    QSB.ScriptEvents.GoodsSold = API.RegisterScriptEvent("Event_GoodsSold");
    QSB.ScriptEvents.GoodsPurchased = API.RegisterScriptEvent("Event_GoodsPurchased");
    self:OverwriteBasePricesAndRefreshRates();
end

function ModuleTrade.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.GoodsPurchased then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.GoodsPurchased, %d, %d, %d, %d, %d, %d, %d)]],
            arg[1], arg[2], arg[3], arg[4], arg[5], arg[6], arg[7]
        ))
        self:PerformFakeTrade(arg[1], arg[2], arg[3], arg[4], arg[5], arg[6], arg[7]);
    elseif _ID == QSB.ScriptEvents.GoodsSold then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.GoodsSold, %d, %d, %d, %d, %d, %d)]],
            arg[1], arg[2], arg[3], arg[4], arg[5], arg[6]
        ))
    end
end

function ModuleTrade.Global:OverwriteBasePricesAndRefreshRates()
    MerchantSystem.BasePrices[Entities.U_CatapultCart] = MerchantSystem.BasePrices[Entities.U_CatapultCart] or 1000;
    MerchantSystem.BasePrices[Entities.U_BatteringRamCart] = MerchantSystem.BasePrices[Entities.U_BatteringRamCart] or 450;
    MerchantSystem.BasePrices[Entities.U_SiegeTowerCart] = MerchantSystem.BasePrices[Entities.U_SiegeTowerCart] or 600;
    MerchantSystem.BasePrices[Entities.U_AmmunitionCart] = MerchantSystem.BasePrices[Entities.U_AmmunitionCart] or 150;
    MerchantSystem.BasePrices[Entities.U_MilitarySword_RedPrince] = MerchantSystem.BasePrices[Entities.U_MilitarySword_RedPrince] or 200;
    MerchantSystem.BasePrices[Entities.U_MilitarySword] = MerchantSystem.BasePrices[Entities.U_MilitarySword] or 200;
    MerchantSystem.BasePrices[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.BasePrices[Entities.U_MilitaryBow_RedPrince] or 350;
    MerchantSystem.BasePrices[Entities.U_MilitaryBow] = MerchantSystem.BasePrices[Entities.U_MilitaryBow] or 350;

    MerchantSystem.RefreshRates[Entities.U_CatapultCart] = MerchantSystem.RefreshRates[Entities.U_CatapultCart] or 270;
    MerchantSystem.RefreshRates[Entities.U_BatteringRamCart] = MerchantSystem.RefreshRates[Entities.U_BatteringRamCart] or 190;
    MerchantSystem.RefreshRates[Entities.U_SiegeTowerCart] = MerchantSystem.RefreshRates[Entities.U_SiegeTowerCart] or 220;
    MerchantSystem.RefreshRates[Entities.U_AmmunitionCart] = MerchantSystem.RefreshRates[Entities.U_AmmunitionCart] or 150;
    MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.RefreshRates[Entities.U_MilitarySword_RedPrince] or 150;
    MerchantSystem.RefreshRates[Entities.U_MilitarySword] = MerchantSystem.RefreshRates[Entities.U_MilitarySword] or 150;
    MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] or 150;
    MerchantSystem.RefreshRates[Entities.U_MilitaryBow] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow] or 150;

    if g_GameExtraNo >= 1 then
        MerchantSystem.BasePrices[Entities.U_MilitaryBow_Khana] = MerchantSystem.BasePrices[Entities.U_MilitaryBow_Khana] or 350;
        MerchantSystem.BasePrices[Entities.U_MilitarySword_Khana] = MerchantSystem.BasePrices[Entities.U_MilitarySword_Khana] or 200;

        MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] or 150;
        MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] = MerchantSystem.RefreshRates[Entities.U_MilitarySword_Khana] or 150;
    end
end

function ModuleTrade.Global:PerformFakeTrade(_OfferID, _TraderType, _Good, _Amount, _Price, _P1, _P2)
    local StoreHouse1 = Logic.GetStoreHouse(_P1);
    local StoreHouse2 = Logic.GetStoreHouse(_P2);

    -- Perform transaction
    local Orientation = Logic.GetEntityOrientation(StoreHouse2) - 90;
    if _TraderType == 0 then
        if Logic.GetGoodCategoryForGoodType(_Good) ~= GoodCategories.GC_Animal then
            API.SendCart(StoreHouse2, _P1, _Good, _Amount, nil, false);
        else
            StartSimpleJobEx(function(_Time, _SHID, _Good, _PlayerID)
                if Logic.GetTime() > _Time+5 then
                    return true;
                end
                local x,y = Logic.GetBuildingApproachPosition(_SHID);
                local Type = (_Good ~= Goods.G_Cow and Entities.A_X_Sheep01) or Entities.A_X_Cow01;
                Logic.CreateEntityOnUnblockedLand(Type, x, y, 0, _PlayerID);
            end, Logic.GetTime(), StoreHouse2, _Good, _P1);
        end
    elseif _TraderType == 1 then
        local x,y = Logic.GetBuildingApproachPosition(StoreHouse2);
        local ID  = Logic.CreateBattalionOnUnblockedLand(_Good, x, y, Orientation, _P1);
        Logic.MoveSettler(ID, x, y, -1);
    else
        local x,y = Logic.GetBuildingApproachPosition(StoreHouse2);
        Logic.HireEntertainer(_Good, _P1, x, y);
    end
    API.SendCart(StoreHouse1, _P2, Goods.G_Gold, _Price, nil, false);
    AddGood(Goods.G_Gold, (-1) * _Price, _P1);

    -- Alter offer amount
    local NewAmount = 0;
    local OfferInfo = self:GetStorehouseInformation(_P2);
    for i= 1, #OfferInfo[1] do
        if OfferInfo[1][i][3] == _Good and OfferInfo[1][i][5] > 0 then
            NewAmount = OfferInfo[1][i][5] -1;
        end
    end
    self:ModifyTradeOffer(_P2, _Good, NewAmount);

    -- Update local
    Logic.ExecuteInLuaLocalState(string.format(
        "GameCallback_MerchantInteraction(%d, %d, %d)",
        StoreHouse2,
        _P1,
        _OfferID
    ))
end

function ModuleTrade.Global:GetStorehouseInformation(_PlayerID)
    local BuildingID = Logic.GetStoreHouse(_PlayerID);

    local StorehouseData = {
        Player      = _PlayerID,
        Storehouse  = BuildingID,
        OfferCount  = 0,
        {},
    };

    local NumberOfMerchants = Logic.GetNumberOfMerchants(Logic.GetStoreHouse(_PlayerID));
    local AmountOfOffers = 0;

    if BuildingID ~= 0 then
        for Index = 0, NumberOfMerchants, 1 do
            local Offers = {Logic.GetMerchantOfferIDs(BuildingID, Index, _PlayerID)};
            for i= 1, #Offers, 1 do
                local type, goodAmount, offerAmount, prices = 0, 0, 0, 0;
                if Logic.IsGoodTrader(BuildingID, Index) then
                    type, goodAmount, offerAmount, prices = Logic.GetGoodTraderOffer(BuildingID, Offers[i], _PlayerID);
                    if type == Goods.G_Sheep or type == Goods.G_Cow then
                        goodAmount = 5;
                    end
                elseif Logic.IsMercenaryTrader(BuildingID, Index) then
                    type, goodAmount, offerAmount, prices = Logic.GetMercenaryOffer(BuildingID, Offers[i], _PlayerID);
                elseif Logic.IsEntertainerTrader(BuildingID, Index) then
                    type, goodAmount, offerAmount, prices = Logic.GetEntertainerTraderOffer(BuildingID, Offers[i], _PlayerID);
                end

                AmountOfOffers = AmountOfOffers +1;
                local OfferData = {Index, Offers[i], type, goodAmount, offerAmount, prices};
                table.insert(StorehouseData[1], OfferData);
            end
        end
    end

    StorehouseData.OfferCount = AmountOfOffers;
    return StorehouseData;
end

function ModuleTrade.Global:GetOfferCount(_PlayerID)
    local Offers = self:GetStorehouseInformation(_PlayerID);
    if Offers then
        return Offers.OfferCount;
    end
    return 0;
end

function ModuleTrade.Global:GetOfferAndTrader(_PlayerID, _GoodOrEntityType)
    local Info = self:GetStorehouseInformation(_PlayerID);
    if Info then
        for j=1, #Info[1], 1 do
            if Info[1][j][3] == _GoodOrEntityType then
                return Info[1][j][2], Info[1][j][1], Info.Storehouse;
            end
        end
    end
    return -1, -1, -1;
end

function ModuleTrade.Global:GetTraderType(_BuildingID, _TraderID)
    if Logic.IsGoodTrader(_BuildingID, _TraderID) == true then
        return QSB.TraderTypes.GoodTrader;
    elseif Logic.IsMercenaryTrader(_BuildingID, _TraderID) == true then
        return QSB.TraderTypes.MercenaryTrader;
    elseif Logic.IsEntertainerTrader(_BuildingID, _TraderID) == true then
        return QSB.TraderTypes.EntertainerTrader;
    else
        return QSB.TraderTypes.Unknown;
    end
end

function ModuleTrade.Global:RemoveTradeOffer(_PlayerID, _GoodOrEntityType)
    local OfferID, TraderID, BuildingID = self:GetOfferAndTrader(_PlayerID, _GoodOrEntityType);
    if not IsExisting(BuildingID) then
        return;
    end
    -- Trader IDs are mixed up in Logic.RemoveOffer
    local MappedTraderID = (TraderID == 1 and 2) or (TraderID == 2 and 1) or 0;
    Logic.RemoveOffer(BuildingID, MappedTraderID, OfferID);
end

function ModuleTrade.Global:RemoveTradeOfferByData(_Data, _Index)
    local OfferID = _Data[1][_Index][2];
    local TraderID = _Data[1][_Index][1];
    local BuildingID = _Data.Storehouse;
    if not IsExisting(BuildingID) then
        return;
    end
    -- Trader IDs are mixed up in Logic.RemoveOffer
    local MappedTraderID = (TraderID == 1 and 2) or (TraderID == 2 and 1) or 0;
    Logic.RemoveOffer(BuildingID, MappedTraderID, OfferID);
end

function ModuleTrade.Global:ModifyTradeOffer(_PlayerID, _GoodOrEntityType, _NewAmount)
    local OfferID, TraderID, BuildingID = self:GetOfferAndTrader(_PlayerID, _GoodOrEntityType);
    if not IsExisting(BuildingID) then
        return;
    end

    -- Amount == -1 or amount == nil means maximum
    if _NewAmount == nil or _NewAmount == -1 then
        _NewAmount = self.Analysis.PlayerOffersAmount[_PlayerID][_GoodOrEntityType];
    end
    -- Values greater than the maximum will not respawn!
    if self.Analysis.PlayerOffersAmount[_PlayerID][_GoodOrEntityType] and self.Analysis.PlayerOffersAmount[_PlayerID][_GoodOrEntityType] < _NewAmount then
        _NewAmount = self.Analysis.PlayerOffersAmount[_PlayerID][_GoodOrEntityType];
    end
    Logic.ModifyTraderOffer(BuildingID, OfferID, _NewAmount, TraderID);
end

-- Local -------------------------------------------------------------------- --

function ModuleTrade.Local:OnGameStart()
    QSB.ScriptEvents.GoodsSold = API.RegisterScriptEvent("Event_GoodsSold");
    QSB.ScriptEvents.GoodsPurchased = API.RegisterScriptEvent("Event_GoodsPurchased");

    g_Merchant.BuyFromPlayer = {};

    if API.IsHistoryEditionNetworkGame() then
        return;
    end
    self:OverrideMerchantComputePurchasePrice();
    self:OverrideMerchantComputeSellingPrice();
    self:OverrideMerchantSellGoodsClicked();
    self:OverrideMerchantPurchaseOfferUpdate();
    self:OverrideMerchantPurchaseOfferClicked();
end

function ModuleTrade.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

function ModuleTrade.Local:GetTraderType(_BuildingID, _TraderID)
    if Logic.IsGoodTrader(_BuildingID, _TraderID) == true then
        return QSB.TraderTypes.GoodTrader;
    elseif Logic.IsMercenaryTrader(_BuildingID, _TraderID) == true then
        return QSB.TraderTypes.MercenaryTrader;
    elseif Logic.IsEntertainerTrader(_BuildingID, _TraderID) == true then
        return QSB.TraderTypes.EntertainerTrader;
    else
        return QSB.TraderTypes.Unknown;
    end
end

function ModuleTrade.Local:OverrideMerchantPurchaseOfferUpdate()
    GUI_Merchant.OfferUpdate = function(_ButtonIndex)
        local CurrentWidgetID   = XGUIEng.GetCurrentWidgetID();
        local CurrentWidgetMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);
        local PlayerID          = GUI.GetPlayerID();
        local BuildingID        = g_Merchant.ActiveMerchantBuilding;
        if BuildingID == 0
        or Logic.IsEntityDestroyed(BuildingID) == true then
            return;
        end
        if g_Merchant.Offers[_ButtonIndex] == nil then
            XGUIEng.ShowWidget(CurrentWidgetMotherID,0);
            return;
        else
            XGUIEng.ShowWidget(CurrentWidgetMotherID,1);
        end
        local TraderType = g_Merchant.Offers[_ButtonIndex].TraderType;
        local OfferIndex = g_Merchant.Offers[_ButtonIndex].OfferIndex;
        local GoodType, OfferGoodAmount, OfferAmount, AmountPrices = 0,0,0,0;
        if TraderType == g_Merchant.GoodTrader then
            GoodType, OfferGoodAmount, OfferAmount, AmountPrices = Logic.GetGoodTraderOffer(BuildingID,OfferIndex,PlayerID);
            if GoodType == Goods.G_Sheep
            or GoodType == Goods.G_Cow then
                OfferGoodAmount = 5;
            end
            SetIcon(CurrentWidgetID, g_TexturePositions.Goods[GoodType]);
        elseif TraderType == g_Merchant.MercenaryTrader then
            GoodType, OfferGoodAmount, OfferAmount, AmountPrices = Logic.GetMercenaryOffer(BuildingID,OfferIndex,PlayerID);
            local TypeName = Logic.GetEntityTypeName(GoodType);
            if GoodType == Entities.U_Thief then
                OfferGoodAmount = 1;
            elseif string.find(TypeName, "U_MilitarySword")
            or     string.find(TypeName, "U_MilitaryBow") then
                OfferGoodAmount = 6;
            elseif string.find(TypeName, "Cart") then
                OfferGoodAmount = 1;
            else
                OfferGoodAmount = OfferGoodAmount;
            end
            SetIcon(CurrentWidgetID, g_TexturePositions.Entities[GoodType]);
        elseif TraderType == g_Merchant.EntertainerTrader then
            GoodType, OfferGoodAmount, OfferAmount, AmountPrices = Logic.GetEntertainerTraderOffer(BuildingID,OfferIndex,PlayerID);
            if not (Logic.CanHireEntertainer(PlayerID) == true
            and Logic.EntertainerIsOnTheMap(GoodType) == false) then
                OfferAmount = 0;
            end
            SetIcon(CurrentWidgetID, g_TexturePositions.Entities[GoodType]);
        end

        local OfferAmountWidget = XGUIEng.GetWidgetPathByID(CurrentWidgetMotherID) .. "/OfferAmount";
        XGUIEng.SetText(OfferAmountWidget, "{center}" .. OfferAmount);
        local OfferGoodAmountWidget = XGUIEng.GetWidgetPathByID(CurrentWidgetMotherID) .. "/OfferGoodAmount";
        XGUIEng.SetText(OfferGoodAmountWidget, "{center}" .. OfferGoodAmount);

        if OfferAmount == 0 then
            XGUIEng.DisableButton(CurrentWidgetID,1);
        else
            XGUIEng.DisableButton(CurrentWidgetID,0);
        end
    end
end

function ModuleTrade.Local:OverrideMerchantPurchaseOfferClicked()
    -- Set special conditions
    local PurchaseAllowedLambda = function(_Type, _Good, _Amount, _Price, _P1, _P2)
        return true;
    end
    self.Lambda.PurchaseAllowed.Default = PurchaseAllowedLambda;

    local BuyLock = {Locked = false};

    GameCallback_MerchantInteraction = function(_BuildingID, _PlayerID, _OfferID)
        if _PlayerID == GUI.GetPlayerID() then
            BuyLock.Locked = false;
        end
    end

    GUI_Merchant.OfferClicked = function(_ButtonIndex)
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local PlayerID   = GUI.GetPlayerID();
        local BuildingID = g_Merchant.ActiveMerchantBuilding;
        if BuildingID == 0 or BuyLock.Locked then
            return;
        end
        local PlayersMarketPlaceID  = Logic.GetMarketplace(PlayerID);
        local TraderPlayerID        = Logic.EntityGetPlayer(BuildingID);
        local TraderType            = g_Merchant.Offers[_ButtonIndex].TraderType;
        local OfferIndex            = g_Merchant.Offers[_ButtonIndex].OfferIndex;

        local CanBeBought = true;
        local GoodType, OfferGoodAmount, OfferAmount, AmountPrices = 0,0,0,0;
        if TraderType == g_Merchant.GoodTrader then
            GoodType, OfferGoodAmount, OfferAmount, AmountPrices = Logic.GetGoodTraderOffer(BuildingID, OfferIndex, PlayerID);
            if Logic.GetGoodCategoryForGoodType(GoodType) == GoodCategories.GC_Resource then
                if Logic.GetPlayerUnreservedStorehouseSpace(PlayerID) < OfferGoodAmount then
                    CanBeBought = false;
                    local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_MerchantStorehouseSpace");
                    Message(MessageText);
                end
            elseif Logic.GetGoodCategoryForGoodType(GoodType) == GoodCategories.GC_Animal then
                CanBeBought = true;
            else
                if Logic.CanFitAnotherMerchantOnMarketplace(PlayersMarketPlaceID) == false then
                    CanBeBought = false;
                    local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_MerchantMarketplaceFull");
                    Message(MessageText);
                end
            end
        elseif TraderType == g_Merchant.EntertainerTrader then
            GoodType, OfferGoodAmount, OfferAmount, AmountPrices = Logic.GetEntertainerTraderOffer(BuildingID, OfferIndex, BuildingID);
            if Logic.CanFitAnotherEntertainerOnMarketplace(PlayersMarketPlaceID) == false then
                CanBeBought = false;
                local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_MerchantMarketplaceFull");
                Message(MessageText);
            end
        elseif TraderType == g_Merchant.MercenaryTrader then
            GoodType, OfferGoodAmount, OfferAmount, AmountPrices = Logic.GetMercenaryOffer(BuildingID, OfferIndex, PlayerID);
            local GoodTypeName        = Logic.GetEntityTypeName(GoodType);
            local CurrentSoldierCount = Logic.GetCurrentSoldierCount(PlayerID);
            local CurrentSoldierLimit = Logic.GetCurrentSoldierLimit(PlayerID);
            local SoldierSize;
            if GoodType == Entities.U_Thief then
                SoldierSize = 1;
            elseif string.find(GoodTypeName, "U_MilitarySword")
            or     string.find(GoodTypeName, "U_MilitaryBow") then
                SoldierSize = 6;
            elseif string.find(GoodTypeName, "Cart") then
                SoldierSize = 0;
            else
                SoldierSize = OfferGoodAmount;
            end
            if (CurrentSoldierCount + SoldierSize) > CurrentSoldierLimit then
                CanBeBought = false;
                local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_SoldierLimitReached");
                Message(MessageText);
            end
        end

        -- Special sales conditions
        if CanBeBought then
            if ModuleTrade.Local.Lambda.PurchaseAllowed[TraderPlayerID] then
                CanBeBought = ModuleTrade.Local.Lambda.PurchaseAllowed[TraderPlayerID](TraderType, GoodType, OfferGoodAmount, PlayerID, TraderPlayerID);
            else
                CanBeBought = ModuleTrade.Local.Lambda.PurchaseAllowed.Default(TraderType, GoodType, OfferGoodAmount, PlayerID, TraderPlayerID);
            end
            if not CanBeBought then
                local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_GenericNotReadyYet");
                Message(MessageText);
                return;
            end
        end

        if CanBeBought == true then
            local Price = ComputePrice( BuildingID, OfferIndex, PlayerID, TraderType);
            local GoldAmountInCastle = GetPlayerGoodsInSettlement(Goods.G_Gold, PlayerID);
            local PlayerSectorType = PlayerSectorTypes.Civil;
            local IsReachable = CanEntityReachTarget(PlayerID, Logic.GetStoreHouse(TraderPlayerID), Logic.GetStoreHouse(PlayerID), nil, PlayerSectorType);
            if IsReachable == false then
                local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_GenericUnreachable");
                Message(MessageText);
                return;
            end
            if Price <= GoldAmountInCastle then
                BuyLock.Locked = true;
                GUI.ChangeMerchantOffer(BuildingID, PlayerID, OfferIndex, Price);
                Sound.FXPlay2DSound("ui\\menu_click");
                if ModuleTrade.Local.ShowKnightTraderAbility then
                    StartKnightVoiceForPermanentSpecialAbility(Entities.U_KnightTrading);
                end

                -- Manually log in local state
                g_Merchant.BuyFromPlayer[TraderPlayerID] = g_Merchant.BuyFromPlayer[TraderPlayerID] or {};
                g_Merchant.BuyFromPlayer[TraderPlayerID][GoodType] = (g_Merchant.BuyFromPlayer[TraderPlayerID][GoodType] or 0) +1;

                API.BroadcastScriptEventToGlobal(
                    "GoodsPurchased",
                    OfferIndex,
                    TraderType,
                    GoodType,
                    OfferGoodAmount,
                    Price,
                    PlayerID,
                    TraderPlayerID
                );
            else
                local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_G_Gold");
                Message(MessageText);
            end
        end
    end
end

function ModuleTrade.Local:OverrideMerchantSellGoodsClicked()
    -- Set special conditions
    local SaleAllowedLambda = function(_Type, _Good, _Amount, _Price, _P1, _P2)
        return true;
    end
    self.Lambda.SaleAllowed.Default = SaleAllowedLambda;

    GUI_Trade.SellClicked = function()
        Sound.FXPlay2DSound( "ui\\menu_click");
        if g_Trade.GoodAmount == 0 then
            return;
        end
        local PlayerID = GUI.GetPlayerID();
        local ButtonIndex = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetWidgetsMotherID(XGUIEng.GetCurrentWidgetID())));
        local TargetID = g_Trade.TargetPlayers[ButtonIndex];
        local PlayerSectorType = PlayerSectorTypes.Civil;
        if g_Trade.GoodType == Goods.G_Gold then
            PlayerSectorType = PlayerSectorTypes.Thief;
        end
        local IsReachable = CanEntityReachTarget(TargetID, Logic.GetStoreHouse(PlayerID), Logic.GetStoreHouse(TargetID), nil, PlayerSectorType);
        if IsReachable == false then
            local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_GenericUnreachable");
            Message(MessageText);
            return;
        end
        if g_Trade.GoodType == Goods.G_Gold then
            -- FIXME: check for treasury space in castle?
        elseif Logic.GetGoodCategoryForGoodType(g_Trade.GoodType) == GoodCategories.GC_Resource then
            local SpaceForNewGoods = Logic.GetPlayerUnreservedStorehouseSpace(TargetID);
            if SpaceForNewGoods < g_Trade.GoodAmount then
                local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_TargetFactionStorehouseSpace");
                Message(MessageText);
                return;
            end
        else
            if Logic.GetNumberOfTradeGatherers(PlayerID) >= 1 then
                local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_TradeGathererUnderway");
                Message(MessageText);
                return;
            end
            if Logic.CanFitAnotherMerchantOnMarketplace(Logic.GetMarketplace(TargetID)) == false then
                local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_TargetFactionMarketplaceFull");
                Message(MessageText);
                return;
            end
        end

        -- Special sales conditions
        local CanBeSold = true;
        if ModuleTrade.Local.Lambda.SaleAllowed[TargetID] then
            CanBeSold = ModuleTrade.Local.Lambda.SaleAllowed[TargetID](g_Merchant.GoodTrader, g_Trade.GoodType, g_Trade.GoodAmount, PlayerID, TargetID);
        else
            CanBeSold = ModuleTrade.Local.Lambda.SaleAllowed.Default(g_Merchant.GoodTrader, g_Trade.GoodType, g_Trade.GoodAmount, PlayerID, TargetID);
        end
        if not CanBeSold then
            local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_GenericNotReadyYet");
            Message(MessageText);
            return;
        end

        local Price;
        local PricePerUnit;
        if Logic.PlayerGetIsHumanFlag(TargetID) then
            Price = 0;
            PricePerUnit = 0;
        else
            Price = GUI_Trade.ComputeSellingPrice(TargetID, g_Trade.GoodType, g_Trade.GoodAmount);
            PricePerUnit = Price / g_Trade.GoodAmount;
        end

        GUI.StartTradeGoodGathering(PlayerID, TargetID, g_Trade.GoodType, g_Trade.GoodAmount, PricePerUnit);
        GUI_FeedbackSpeech.Add("SpeechOnly_CartsSent", g_FeedbackSpeech.Categories.CartsUnderway, nil, nil);
        StartKnightVoiceForPermanentSpecialAbility(Entities.U_KnightTrading);

        if PricePerUnit ~= 0 then
            if g_Trade.SellToPlayers[TargetID] == nil then
                g_Trade.SellToPlayers[TargetID] = {};
            end
            if g_Trade.SellToPlayers[TargetID][g_Trade.GoodType] == nil then
                g_Trade.SellToPlayers[TargetID][g_Trade.GoodType] = g_Trade.GoodAmount;
            else
                g_Trade.SellToPlayers[TargetID][g_Trade.GoodType] = g_Trade.SellToPlayers[TargetID][g_Trade.GoodType] + g_Trade.GoodAmount;
            end
            API.BroadcastScriptEventToGlobal(
                "GoodsSold",
                g_Merchant.GoodTrader,
                g_Trade.GoodType,
                g_Trade.GoodAmount,
                Price,
                PlayerID,
                TargetID
            );
        end
    end
end

function ModuleTrade.Local:OverrideMerchantComputePurchasePrice()
    -- Override factor of hero ability
    local AbilityTraderLambda = function(_TraderType, _OfferType, _BasePrice, _PlayerID, _TraderPlayerID)
        local Modifier = Logic.GetKnightTraderAbilityModifier(_PlayerID);
        return math.ceil(_BasePrice / Modifier);
    end
    self.Lambda.PurchaseTraderAbility.Default = AbilityTraderLambda;

    -- Override base price calculation
    local BasePriceLambda = function(_TraderType, _OfferType, _PlayerID, _TraderPlayerID)
        local BasePrice = MerchantSystem.BasePrices[_OfferType];
        return (BasePrice == nil and 3) or BasePrice;
    end
    self.Lambda.PurchaseBasePrice.Default = BasePriceLambda;

    -- Override max inflation
    local InflationLambda = function(_TraderType, _GoodType, _OfferCount, _Price, _PlayerID, _TraderPlayerID)
        _OfferCount = (_OfferCount > 8 and 8) or _OfferCount;
        local Result = _Price + (math.ceil(_Price / 4) * _OfferCount);
        return (Result < _Price and _Price) or Result;
    end
    self.Lambda.PurchaseInflation.Default = InflationLambda;

    -- Override function
    ComputePrice = function(BuildingID, OfferID, PlayerID, TraderType)
        local TraderPlayerID = Logic.EntityGetPlayer(BuildingID);
        local Type = Logic.GetGoodOfOffer(BuildingID, OfferID, PlayerID, TraderType);

        -- Calculate the base price
        local BasePrice;
        if ModuleTrade.Local.Lambda.PurchaseBasePrice[TraderPlayerID] then
            BasePrice = ModuleTrade.Local.Lambda.PurchaseBasePrice[TraderPlayerID](TraderType, Type, PlayerID, TraderPlayerID)
        else
            BasePrice = ModuleTrade.Local.Lambda.PurchaseBasePrice.Default(TraderType, Type, PlayerID, TraderPlayerID)
        end

        -- Calculate price
        local Price
        if ModuleTrade.Local.Lambda.PurchaseTraderAbility[TraderPlayerID] then
            Price = ModuleTrade.Local.Lambda.PurchaseTraderAbility[TraderPlayerID](TraderType, Type, BasePrice, PlayerID, TraderPlayerID)
        else
            Price = ModuleTrade.Local.Lambda.PurchaseTraderAbility.Default(TraderType, Type, BasePrice, PlayerID, TraderPlayerID)
        end

        -- Invoke price inflation
        local OfferCount = 0;
        if g_Merchant.BuyFromPlayer[TraderPlayerID] and g_Merchant.BuyFromPlayer[TraderPlayerID][Type] then
            OfferCount = g_Merchant.BuyFromPlayer[TraderPlayerID][Type];
        end
        local FinalPrice;
        if ModuleTrade.Local.Lambda.PurchaseInflation[TraderPlayerID] then
            FinalPrice = ModuleTrade.Local.Lambda.PurchaseInflation[TraderPlayerID](TraderType, Type, OfferCount, Price, PlayerID, TraderPlayerID);
        else
            FinalPrice = ModuleTrade.Local.Lambda.PurchaseInflation.Default(TraderType, Type, OfferCount, Price, PlayerID, TraderPlayerID);
        end
        return FinalPrice;
    end
end

function ModuleTrade.Local:OverrideMerchantComputeSellingPrice()
    -- Override factor of hero ability
    local AbilityTraderLambda = function(_TraderType, _OfferType, _BasePrice, _PlayerID, _TraderPlayerID)
        -- No change by default
        return _BasePrice;
    end
    self.Lambda.SaleTraderAbility.Default = AbilityTraderLambda;

    -- Override base price calculation
    local BasePriceLambda = function(_TraderType, _OfferType, _PlayerID, _TargetPlayerID)
        local BasePrice = MerchantSystem.BasePrices[_OfferType];
        return (BasePrice == nil and 3) or BasePrice;
    end
    self.Lambda.SaleBasePrice.Default = BasePriceLambda;

    -- Override max deflation
    local DeflationLambda = function(_TraderType, _OfferType, _WagonsSold, _Price, _PlayerID, _TargetPlayerID)
        return _Price - math.ceil(_Price / 4);
    end
    self.Lambda.SaleDeflation.Default = DeflationLambda;

    GUI_Trade.ComputeSellingPrice = function(_TargetPlayerID, _GoodType, _GoodAmount)
        if _GoodType == Goods.G_Gold then
            return 0;
        end
        local PlayerID = GUI.GetPlayerID();
        local Waggonload = MerchantSystem.Waggonload;

        -- Calculate the base price
        local BasePrice;
        if ModuleTrade.Local.Lambda.SaleBasePrice[_TargetPlayerID] then
            BasePrice = ModuleTrade.Local.Lambda.SaleBasePrice[_TargetPlayerID](g_Merchant.GoodTrader, _GoodType, PlayerID, _TargetPlayerID);
        else
            BasePrice = ModuleTrade.Local.Lambda.SaleBasePrice.Default(g_Merchant.GoodTrader, _GoodType, PlayerID, _TargetPlayerID);
        end

        -- Calculate price
        local Price = BasePrice;
        if ModuleTrade.Local.Lambda.SaleTraderAbility[_TargetPlayerID] then
            Price = ModuleTrade.Local.Lambda.SaleTraderAbility[_TargetPlayerID](g_Merchant.GoodTrader, _GoodType, BasePrice, PlayerID, _TargetPlayerID)
        else
            Price = ModuleTrade.Local.Lambda.SaleTraderAbility.Default(g_Merchant.GoodTrader, _GoodType, BasePrice, PlayerID, _TargetPlayerID)
        end

        local GoodsSoldToTargetPlayer = 0
        if  g_Trade.SellToPlayers[_TargetPlayerID] ~= nil
        and g_Trade.SellToPlayers[_TargetPlayerID][_GoodType] ~= nil then
            GoodsSoldToTargetPlayer = g_Trade.SellToPlayers[_TargetPlayerID][_GoodType];
        end
        local Modifier = math.ceil(Price / 4);
        local WaggonsToSell = math.ceil(_GoodAmount / Waggonload);
        local WaggonsSold = math.ceil(GoodsSoldToTargetPlayer / Waggonload);

        -- Calculate the max deflation
        local MaxToSubstract
        if ModuleTrade.Local.Lambda.SaleDeflation[_TargetPlayerID] then
            MaxToSubstract = ModuleTrade.Local.Lambda.SaleDeflation[_TargetPlayerID](g_Merchant.GoodTrader, _GoodType, WaggonsSold, Price, PlayerID, _TargetPlayerID);
        else
            MaxToSubstract = ModuleTrade.Local.Lambda.SaleDeflation.Default(g_Merchant.GoodTrader, _GoodType, WaggonsSold, Price, PlayerID, _TargetPlayerID);
        end

        local PriceToSubtract = 0;
        for i = 1, WaggonsToSell do
            PriceToSubtract = PriceToSubtract + math.min(WaggonsSold * Modifier, MaxToSubstract);
            WaggonsSold = WaggonsSold + 1;
        end

        return (WaggonsToSell * BasePrice) - PriceToSubtract;
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleTrade);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

---
-- Es kann in den Ablauf von Kauf und Verkauf eingegriffen werden.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field GoodsPurchased Güter werden bei einem Händler gekauft (Parameter: OfferID, TraderType, GoodType, OfferGoodAmount, Price, PlayerID, TraderPlayerID)
-- @field GoodsSold      Güter werden im eigenen Lagerhaus verkauft (Parameter: TraderType, GoodType, GoodAmount, Price, PlayerID, TargetPlayerID)
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Typen der Händler
--
-- @field GoodTrader        Es werden Güter verkauft
-- @field MercenaryTrader   Es werden Söldner verkauft
-- @field EntertainerTrader Es werden Entertainer verkauft
-- @field Unknown           Unbekannter Typ (Fehler)
--
QSB.TraderTypes = QSB.TraderTypes or {};

---
-- Setzt die Funktion zur Kalkulation des Einkaufspreisfaktors des Helden. Die
-- Änderung betrifft nur den angegebenen Spieler.
-- Die Funktion muss den angepassten Preis zurückgeben.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_BasePrice</td><td>number</td><td></td>Basispreis</tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Käufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Verkäufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- <b>Hinweis</b>: Um den Standard wiederherzustellen, muss nil als Funktion
-- übergeben werden.
--
-- @param[type=number] _PlayerID Player ID des Händlers
-- @param[type=number] _Function Kalkulationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.PurchaseSetTraderAbilityForPlayer(2, MyCalculationFunction);
--
function API.PurchaseSetTraderAbilityForPlayer(_PlayerID, _Function)
    if not GUI then
        return;
    end
    if _PlayerID then
        ModuleTrade.Local.Lambda.PurchaseTraderAbility[_PlayerID] = _Function;
    else
        ModuleTrade.Local.Lambda.PurchaseTraderAbility.Default = _Function;
    end
end

---
-- Setzt die allgemeine Funktion zur Kalkulation des Einkaufspreisfaktors des
-- Helden. Die Funktion muss den angepassten Preis zurückgeben.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_BasePrice</td><td>number</td><td></td>Basispreis</tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Käufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Verkäufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _Function Kalkulationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.PurchaseSetDefaultTraderAbility(MyCalculationFunction);
--
function API.PurchaseSetDefaultTraderAbility(_Function)
    API.PurchaseSetTraderAbilityForPlayer(nil, _Function);
end

---
-- Setzt die Funktion zur Bestimmung des Basispreis. Die Änderung betrifft nur
-- den angegebenen Spieler.
-- Die Funktion muss den Basispreis der Ware zurückgeben.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Käufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Verkäufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- <b>Hinweis</b>: Um den Standard wiederherzustellen, muss nil als Funktion
-- übergeben werden.
--
-- @param[type=number] _PlayerID Player ID des Händlers
-- @param[type=number] _Function Kalkulationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.PurchaseSetBasePriceForPlayer(2, MyCalculationFunction);
--
function API.PurchaseSetBasePriceForPlayer(_PlayerID, _Function)
    if not GUI then
        return;
    end
    if _PlayerID then
        ModuleTrade.Local.Lambda.PurchaseBasePrice[_PlayerID] = _Function;
    else
        ModuleTrade.Local.Lambda.PurchaseBasePrice.Default = _Function;
    end
end

---
-- Setzt die Funktion zur Bestimmung des Basispreis.
-- Die Funktion muss den Basispreis der Ware zurückgeben.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Käufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Verkäufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _Function Kalkulationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.PurchaseSetDefaultBasePrice(MyCalculationFunction);
--
function API.PurchaseSetDefaultBasePrice(_Function)
    API.PurchaseSetBasePriceForPlayer(nil, _Function);
end

---
-- Setzt die Funktion zur Berechnung der Preisinflation. Die Änderung betrifft
-- nur den angegebenen Spieler.
-- Die Funktion muss den von der Inflation beeinflussten Preis zurückgeben.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_Amount</td><td>number</td><td>Anzahl bereits gekaufter Angebote</td></tr>
-- <tr><td>_Price</td><td>number</td><td></td>Einkaufspreis</tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Käufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Verkäufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- <b>Hinweis</b>: Um den Standard wiederherzustellen, muss nil als Funktion
-- übergeben werden.
--
-- @param[type=number] _PlayerID Player ID des Händlers
-- @param[type=number] _Function Kalkulationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.PurchaseSetInflationForPlayer(2, MyCalculationFunction);
--
function API.PurchaseSetInflationForPlayer(_PlayerID, _Function)
    if not GUI then
        return;
    end
    if _PlayerID then
        ModuleTrade.Local.Lambda.PurchaseInflation[_PlayerID] = _Function;
    else
        ModuleTrade.Local.Lambda.PurchaseInflation.Default = _Function;
    end
end

---
-- Setzt die Funktion zur Berechnung der Preisinflation.
-- Die Funktion muss den von der Inflation beeinflussten Preis zurückgeben.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_Amount</td><td>number</td><td>Anzahl bereits gekaufter Angebote</td></tr>
-- <tr><td>_Price</td><td>number</td><td></td>Einkaufspreis</tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Käufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Verkäufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _Function Kalkulationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.PurchaseSetDefaultInflation(MyCalculationFunction);
--
function API.PurchaseSetDefaultInflation(_Function)
    API.PurchaseSetInflationForPlayer(nil, _Function)
end

---
-- Setzt eine Funktion zur Festlegung spezieller Ankaufsbedingungen. Diese
-- Bedingungen betreffen nur den angegebenen Spieler.
-- Die Funktion muss true zurückgeben, wenn gekauft werden darf.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_Amount</td><td>number</td><td>Verkaufte Menge</td></tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Käufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Verkäufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- <b>Hinweis</b>: Um den Standard wiederherzustellen, muss nil als Funktion
-- übergeben werden.
--
-- @param[type=number] _PlayerID Player ID des Händlers
-- @param[type=number] _Function Evaluationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.PurchaseSetConditionForPlayer(2, MyCalculationFunction);
--
function API.PurchaseSetConditionForPlayer(_PlayerID, _Function)
    if not GUI then
        return;
    end
    if _PlayerID then
        ModuleTrade.Local.Lambda.PurchaseAllowed[_PlayerID] = _Function;
    else
        ModuleTrade.Local.Lambda.PurchaseAllowed.Default = _Function;
    end
end

---
-- Setzt eine Funktion zur Festlegung spezieller Verkaufsbedingungen.
-- Die Funktion muss true zurückgeben, wenn verkauft werden darf.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_Amount</td><td>number</td><td>Verkaufte Menge</td></tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Käufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Verkäufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _Function Evaluationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.PurchaseSetDefaultCondition(MyCalculationFunction);
--
function API.PurchaseSetDefaultCondition(_Function)
    API.PurchaseSetConditionForPlayer(nil, _Function)
end

---
-- Setzt die Funktion zur Kalkulation des Verkreisfaktors des Helden. Die
-- Änderung betrifft nur den angegebenen Spieler.
-- Die Funktion muss den angepassten Preis zurückgeben.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td></td>Typ des Händlers</tr>
-- <tr><td>_Good</td><td>number</td><td></td>Typ des Angebot</tr>
-- <tr><td>_BasePrice</td><td>number</td><td></td>Basispreis</tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Käufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Verkäufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- <b>Hinweis</b>: Um den Standard wiederherzustellen, muss nil als Funktion
-- übergeben werden.
--
-- @param[type=number] _PlayerID Player ID des Händlers
-- @param[type=number] _Function Kalkulationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.SaleSetTraderAbilityForPlayer(2, MyCalculationFunction);
--
function API.SaleSetTraderAbilityForPlayer(_PlayerID, _Function)
    if not GUI then
        return;
    end
    if _PlayerID then
        ModuleTrade.Local.Lambda.SaleTraderAbility[_PlayerID] = _Function;
    else
        ModuleTrade.Local.Lambda.SaleTraderAbility.Default = _Function;
    end
end

---
-- Setzt die allgemeine Funktion zur Kalkulation des Verkreisfaktors des Helden.
-- Die Funktion muss den angepassten Preis zurückgeben.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td></td>Typ des Händlers</tr>
-- <tr><td>_Good</td><td>number</td><td></td>Typ des Angebot</tr>
-- <tr><td>_BasePrice</td><td>number</td><td></td>Basispreis</tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Käufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Verkäufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _Function Kalkulationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.SaleSetDefaultTraderAbility(MyCalculationFunction);
--
function API.SaleSetDefaultTraderAbility(_Function)
    API.SaleSetTraderAbilityForPlayer(nil, _Function);
end

---
-- Setzt die Funktion zur Bestimmung des Basispreis. Die Änderung betrifft nur
-- den angegebenen Spieler.
-- Die Funktion muss den Basispreis der Ware zurückgeben.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Verkäufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Käufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- <b>Hinweis</b>: Um den Standard wiederherzustellen, muss nil als Funktion
-- übergeben werden.
--
-- @param[type=number] _PlayerID Player ID des Händlers
-- @param[type=number] _Function Kalkulationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.SaleSetBasePriceForPlayer(2, MyCalculationFunction);
--
function API.SaleSetBasePriceForPlayer(_PlayerID, _Function)
    if not GUI then
        return;
    end
    if _PlayerID then
        ModuleTrade.Local.Lambda.SaleBasePrice[_PlayerID] = _Function;
    else
        ModuleTrade.Local.Lambda.SaleBasePrice.Default = _Function;
    end
end

---
-- Setzt die Funktion zur Bestimmung des Basispreis.
-- Die Funktion muss den Basispreis der Ware zurückgeben.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Verkäufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Käufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _Function Kalkulationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.SaleSetDefaultBasePrice(MyCalculationFunction);
--
function API.SaleSetDefaultBasePrice(_Function)
    API.SaleSetBasePriceForPlayer(nil, _Function);
end

---
-- Setzt die Funktion zur Berechnung des minimalen Verkaufserlös. Die Änderung
-- betrifft nur den angegebenen Spieler.
-- Die Funktion muss den von der Deflation beeinflussten Erlös zurückgeben.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_SaleCount</td><td>number</td><td>Amount of sold waggons</td></tr>
-- <tr><td>_Price</td><td>number</td><td>Verkaufspreis</td></tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Verkäufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Käufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- <b>Hinweis</b>: Um den Standard wiederherzustellen, muss nil als Funktion
-- übergeben werden.
--
-- @param[type=number] _PlayerID Player ID des Händlers
-- @param[type=number] _Function Kalkulationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.SaleSetDeflationForPlayer(2, MyCalculationFunction);
--
function API.SaleSetDeflationForPlayer(_PlayerID, _Function)
    if not GUI then
        return;
    end
    if _PlayerID then
        ModuleTrade.Local.Lambda.SaleDeflation[_PlayerID] = _Function;
    else
        ModuleTrade.Local.Lambda.SaleDeflation.Default = _Function;
    end
end

---
-- Setzt die Funktion zur Berechnung des minimalen Verkaufserlös.
-- Die Funktion muss den von der Deflation beeinflussten Erlös zurückgeben.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_SaleCount</td><td>number</td><td>Amount of sold waggons</td></tr>
-- <tr><td>_Price</td><td>number</td><td>Verkaufspreis</td></tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Verkäufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Käufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _Function Kalkulationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.SaleSetDefaultDeflation(MyCalculationFunction);
--
function API.SaleSetDefaultDeflation(_Function)
    API.SaleSetDeflationForPlayer(nil, _Function);
end

---
-- Setzt eine Funktion zur Festlegung spezieller Verkaufsbedingungen. Diese
-- Bedingungen betreffen nur den angegebenen Spieler.
-- Die Funktion muss true zurückgeben, wenn verkauft werden darf.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_Amount</td><td>number</td><td>Verkaufte Menge</td></tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Verkäufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Käufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- <b>Hinweis</b>: Um den Standard wiederherzustellen, muss nil als Funktion
-- übergeben werden.
--
-- @param[type=number] _PlayerID Player ID des Händlers
-- @param[type=number] _Function Evaluationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.SaleSetConditionForPlayer(2, MyCalculationFunction);
--
function API.SaleSetConditionForPlayer(_PlayerID, _Function)
    if not GUI then
        return;
    end
    if _PlayerID then
        ModuleTrade.Local.Lambda.SaleAllowed[_PlayerID] = _Function;
    else
        ModuleTrade.Local.Lambda.SaleAllowed.Default = _Function;
    end
end

---
-- Setzt eine Funktion zur Festlegung spezieller Verkaufsbedingungen.
-- Die Funktion muss true zurückgeben, wenn verkauft werden darf.
--
-- Parameter der Funktion:
-- <table border="1">
-- <tr><th><b>Parameter</b></th><th><b>Typ</b></th><th><b>Beschreibung</b></th></tr>
-- <tr><td>_Type</td><td>number</td><td>Typ des Händler</td></tr>
-- <tr><td>_Good</td><td>number</td><td>Typ des Angebot</td></tr>
-- <tr><td>_Amount</td><td>number</td><td>Verkaufte Menge</td></tr>
-- <tr><td>_PlayerID1</td><td>number</td><td>ID des Verkäufers</td></tr>
-- <tr><td>_PlayerID2</td><td>number</td><td>ID des Käufers</td></tr>
-- </table>
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _Function Evaluationsfunktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.SaleSetDefaultCondition(MyCalculationFunction);
--
function API.SaleSetDefaultCondition(_Function)
    API.SaleSetConditionForPlayer(nil, _Function);
end

---
-- Lässt einen NPC-Spieler Waren anbieten.
--
-- @param[type=number] _VendorID    Spieler-ID des Verkäufers
-- @param[type=number] _OfferType   Typ der Angebote
-- @param[type=number] _OfferAmount Menge an Angeboten
-- @param[type=number] _RefreshRate (Optional) Regenerationsrate des Angebot
-- @within Anwenderfunktionen
-- @local
--
-- @usage
-- -- Spieler 2 bietet Brot an
-- API.AddGoodOffer(2, Goods.G_Bread, 1, 2);
--
function API.AddGoodOffer(_VendorID, _OfferType, _OfferAmount, _RefreshRate)
    _OfferType = (type(_OfferType) == "string" and Goods[_OfferType]) or _OfferType;
    local OfferID, TraderID = ModuleTrade.Global:GetOfferAndTrader(_VendorID, _OfferType);
    if OfferID ~= -1 and TraderID ~= -1 then
        warn(string.format(
            "Good offer for type %s already exists for player %d!",
            Logic.GetGoodTypeName(_OfferType),
            _VendorID
        ));
        return;
    end

    local VendorStoreID = Logic.GetStoreHouse(_VendorID);
    AddGoodToTradeBlackList(_VendorID, _OfferType);

    -- Good cart type
    local MarketerType = Entities.U_Marketer;
    if _OfferType == Goods.G_Medicine then
        MarketerType = Entities.U_Medicus;
    end
    -- Refresh rate
    if _RefreshRate == nil then
        _RefreshRate = MerchantSystem.RefreshRates[_OfferType] or 0;
    end

    local LogicOfferID = Logic.AddGoodTraderOffer(
        VendorStoreID,
        _OfferAmount,
        Goods.G_Gold,
        0,
        _OfferType,
        MerchantSystem.Waggonload,
        1,
        _RefreshRate,
        MarketerType,
        Entities.U_ResourceMerchant
    );
    Logic.ExecuteInLuaLocalState(string.format(
        "GameCallback_CloseNPCInteraction(GUI.GetPlayerID(), %d)",
        VendorStoreID
    ));
    return LogicOfferID;
end
-- Compability option
function AddOffer(_Merchant, _NumberOfOffers, _GoodType, _RefreshRate)
    local VendorID = Logic.EntityGetPlayer(GetID(_Merchant));
    return API.AddGoodOffer(VendorID, _GoodType, _NumberOfOffers, _RefreshRate);
end

---
-- Lässt einen NPC-Spieler Söldner anbieten.
--
-- <b>Hinweis</b>: Stadtlagerhäuser können keine Söldner anbieten!
--
-- @param[type=number] _VendorID    Spieler-ID des Verkäufers
-- @param[type=number] _OfferType   Typ der Söldner
-- @param[type=number] _OfferAmount Menge an Söldnern
-- @param[type=number] _RefreshRate (Optional) Regenerationsrate des Angebot
-- @within Anwenderfunktionen
-- @local
--
-- @usage
-- -- Spieler 2 bietet Sölder an
-- API.AddMercenaryOffer(2, Entities.U_MilitaryBandit_Melee_SE, 1, 3);
--
function API.AddMercenaryOffer(_VendorID, _OfferType, _OfferAmount, _RefreshRate)
    _OfferType = (type(_OfferType) == "string" and Entities[_OfferType]) or _OfferType;
    local OfferID, TraderID = ModuleTrade.Global:GetOfferAndTrader(_VendorID, _OfferType);
    if OfferID ~= -1 and TraderID ~= -1 then
        warn(string.format(
            "Mercenary offer for type %s already exists for player %d!",
            Logic.GetEntityTypeName(_OfferType),
            _VendorID
        ));
        return;
    end

    local VendorStoreID = Logic.GetStoreHouse(_VendorID);

    -- Refresh rate
    if _RefreshRate == nil then
        _RefreshRate = MerchantSystem.RefreshRates[_OfferType] or 0;
    end
    -- Soldier count (Display hack for unusual mercenaries)
    local SoldierCount = 3;
    local TypeName = Logic.GetEntityTypeName(_OfferType);
    if string.find(TypeName, "MilitaryBow") or string.find(TypeName, "MilitarySword") then
        SoldierCount = 6;
    elseif string.find(TypeName,"Cart") then
        SoldierCount = 0;
    end

    local LogicOfferID = Logic.AddMercenaryTraderOffer(
        VendorStoreID,
        _OfferAmount,
        Goods.G_Gold,
        0,
        _OfferType,
        SoldierCount,
        1,
        _RefreshRate
    );
    Logic.ExecuteInLuaLocalState(string.format(
        "GameCallback_CloseNPCInteraction(GUI.GetPlayerID(), %d)",
        VendorStoreID
    ));
    return LogicOfferID;
end
-- Compability option
function AddMercenaryOffer(_Mercenary, _Amount, _Type, _RefreshRate)
    local VendorID = Logic.EntityGetPlayer(GetID(_Mercenary));
    return API.AddMercenaryOffer(VendorID, _Type, _Amount, _RefreshRate);
end

---
-- Lässt einen NPC-Spieler einen Entertainer anbieten.
--
-- @param[type=number] _VendorID    Spieler-ID des Verkäufers
-- @param[type=number] _OfferType   Typ des Entertainer
-- @within Anwenderfunktionen
-- @local
--
-- @usage
-- -- Spieler 2 bietet einen Feuerschlucker an
-- API.AddEntertainerOffer(2, Entities.U_Entertainer_NA_FireEater);
--
function API.AddEntertainerOffer(_VendorID, _OfferType)
    _OfferType = (type(_OfferType) == "string" and Entities[_OfferType]) or _OfferType;
    local OfferID, TraderID = ModuleTrade.Global:GetOfferAndTrader(_VendorID, _OfferType);
    if OfferID ~= -1 and TraderID ~= -1 then
        warn(string.format(
            "Entertainer offer for type %s already exists for player %d!",
            Logic.GetEntityTypeName(_OfferType),
            _VendorID
        ));
        return;
    end

    local VendorStoreID = Logic.GetStoreHouse(_VendorID);
    local LogicOfferID = Logic.AddEntertainerTraderOffer(
        VendorStoreID,
        1,
        Goods.G_Gold,
        0,
        _OfferType,
        1,
        0
    );
    Logic.ExecuteInLuaLocalState(string.format(
        "GameCallback_CloseNPCInteraction(GUI.GetPlayerID(), %d)",
        VendorStoreID
    ));
    return LogicOfferID;
end
-- Compability option
function AddEntertainerOffer(_Merchant, _EntertainerType)
    local VendorID = Logic.EntityGetPlayer(GetID(_Merchant));
    return API.AddEntertainerOffer(VendorID, _EntertainerType);
end

---
-- Gibt die Angebotsinformationen des Spielers aus. In dem Table stehen
-- ID des Spielers, ID des Lagerhaus, Menge an Angeboten insgesamt und
-- alle Angebote der Händlertypen.
--
-- @param[type=number] _PlayerID Player ID
-- @return[type=table] Angebotsinformationen
-- @within Anwenderfunktionen
-- @local
--
-- @usage
-- local Info = API.GetOfferInformation(2);
--
-- -- Info enthält:
-- -- Info = {
-- --      Player = 2,
-- --      Storehouse = 26796.
-- --      OfferCount = 2,
-- --      {
-- --          Händler-ID, Angebots-ID, Angebotstyp, Wagenladung, Angebotsmenge
-- --          {0, 0, Goods.G_Gems, 9, 2},
-- --          {0, 1, Goods.G_Milk, 9, 4},
-- --      },
-- -- };
--
function API.GetOfferInformation(_PlayerID)
    if GUI then
        return;
    end
    return ModuleTrade.Global:GetStorehouseInformation(_PlayerID);
end

---
-- Gibt die Menge an Angeboten im Lagerhaus des Spielers zurück. Wenn
-- der Spieler kein Lagerhaus hat, wird 0 zurückgegeben.
--
-- @param[type=number] _PlayerID Player ID
-- @return[type=number] Anzahl angebote
-- @within Anwenderfunktionen
-- @local
--
-- @usage
-- -- Angebote von Spieler 5 zählen
-- local Count = API.GetOfferCount(5);
--
function API.GetOfferCount(_PlayerID)
    if GUI then
        return;
    end
    return ModuleTrade.Global:GetOfferCount(_PlayerID);
end

---
-- Gibt zurück, ob das Angebot vom angegebenen Spieler im Lagerhaus zum
-- Verkauf angeboten wird.
--
-- @param[type=number] _PlayerID Player ID
-- @param[type=number] _GoodOrEntityType Warentyp oder Entitytyp
-- @return[type=boolean] Ware wird angeboten
-- @within Anwenderfunktionen
-- @local
--
-- @usage
-- -- Wird die Ware angeboten?
-- if API.IsGoodOrUnitOffered(4, Goods.G_Bread) then
--     Logic.DEBUG_AddNote("Brot wird von Spieler 4 angeboten.");
-- end
--
function API.IsGoodOrUnitOffered(_PlayerID, _GoodOrEntityType)
    if GUI then
        return;
    end
    local OfferID, TraderID = ModuleTrade.Global:GetOfferAndTrader(_PlayerID, _GoodOrEntityType);
    return OfferID ~= 1 and TraderID ~= 1;
end

---
-- Gibt die aktuelle Anzahl an Angeboten des Typs zurück.
--
-- @param[type=number] _PlayerID Player ID
-- @param[type=number] _GoodOrEntityType Warentyp oder Entitytyp
-- @return[type=number] Menge an Angeboten
-- @within Anwenderfunktionen
-- @local
--
-- @usage
-- -- Wie viel wird aktuell angeboten?
-- local CurrentAmount = API.IsGoodOrUnitOffered(4, Goods.G_Bread);
--
function API.GetTradeOfferWaggonAmount(_PlayerID, _GoodOrEntityType)
    local Amount = -1;
    local OfferInfo = ModuleTrade.Global:GetStorehouseInformation(_PlayerID);
    for i= 1, #OfferInfo[4] do
        if OfferInfo[4][i][3] == _GoodOrEntityType and OfferInfo[4][i][5] > 0 then
            Amount = OfferInfo[4][i][5];
        end
    end
    return Amount;
end

---
-- Entfernt das Angebot vom Lagerhaus des Spielers, wenn es vorhanden
-- ist. Es wird immer nur das erste Angebot des Typs entfernt.
--
-- @param[type=number] _PlayerID Player ID
-- @param[type=number] _GoodOrEntityType Warentyp oder Entitytyp
-- @within Anwenderfunktionen
--
-- @usage
-- -- Keinen Käse mehr verkaufen
-- API.RemoveTradeOffer(7, Goods.G_Cheese);
--
function API.RemoveTradeOffer(_PlayerID, _GoodOrEntityType)
    if GUI then
        return;
    end
    return ModuleTrade.Global:RemoveTradeOffer(_PlayerID, _GoodOrEntityType);
end

---
-- Ändert die aktuelle Menge des Angebots im Händelrgebäude.
--
-- Es kann ein beliebiger positiver Wert gesetzt werden. Es gibt keine
-- Beschränkungen.
--
-- <b>Hinweis</b>: Wird eine höherer Wert gesetzt, als das ursprüngliche
-- Maximum, regenerieren sich die Angebote nicht, bis die zusätzlichen
-- Angebote verkauft wurden.
--
-- @param[type=number] _PlayerID Player ID
-- @param[type=number] _GoodOrEntityType ID des Händlers im Gebäude
-- @param[type=number] _NewAmount Neue Menge an Angeboten
-- @within Anwenderfunktionen
--
-- @usage
-- -- Beispiel #1: Angebote voll auffüllen
-- API.ModifyTradeOffer(7, Goods.G_Cheese, -1);
--
-- @usage
-- -- Beispiel #2: Angebote auffüllen
-- API.ModifyTradeOffer(7, Goods.G_Dye, 2);
--
function API.ModifyTradeOffer(_PlayerID, _GoodOrEntityType, _NewAmount)
    if GUI then
        return;
    end
    return ModuleTrade.Global:ModifyTradeOffer(_PlayerID, _GoodOrEntityType, _NewAmount);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleBuildRestriction = {
    Properties = {
        Name = "ModuleBuildRestriction",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {},
    Local = {
        LastSelectedBuildingType = 0,
        LastSelectedRoadType = 0,
        RestrictionSequence = 0,
        ProtectionSequence = 0,
        ConstructionRestrictions = {},
        ConstructionFeedbackText = nil,
        KnockdownProtection = {},
        KnockdownFeedbackText = nil,
    },
    Shared = {
        Text = {
            NoBuilding = {
                de = "Kann hier nicht gebaut werden!",
                en = "This can not be placed here!",
                fr = "Cela ne peut pas être placé ici!"
            },
            NoBuildingInTerritory = {
                de = "Das kann in diesem Territorium nicht gebaut werden!",
                en = "This can not be placed in this territory!",
                fr = "Cela ne peut pas être construit sur le territoire!"
            },
            NoBuildingInArea = {
                de = "Das kann in diesem Bereich nicht gebaut werden!",
                en = "This can not be placed in this area!",
                fr = "Cela ne peut pas être construit dans ce domaine!"
            },

            NoKnockdown = {
                de = "Das kann nicht abgerissen werden!",
                en = "This building can not be demolished!",
                fr = "Cela ne peut pas être démoli!"
            },
            NoKnockdownInTerritory = {
                de = "Das kann in diesem Territorium nicht abgerissen werden!",
                en = "Demolishing this building is not allowed in this territory!",
                fr = "Cela ne peut pas être démoli dans ce territoire!"
            },
            NoKnockdownInArea = {
                de = "Das kann in diesem Bereich nicht abgerissen werden!",
                en = "Demolishing this building is not allowed in this area!",
                fr = "Cela ne peut pas être démoli dans ce domaine!"
            },

            NoTrailInTerritory = {
                de = "Pfade können in diesem Territorium nicht gebaut werden!",
                en = "The placement of trails is not allowed in this territory!",
                fr = "Les chemins ne peuvent pas être construits sur ce territoire!"
            },
            NoTrailInArea = {
                de = "Pfade können in diesem Bereich nicht gebaut werden!",
                en = "The placement of trails is not allowed in this area!",
                fr = "Les chemins ne peuvent pas être construits dans cette zone!"
            },
            NoStreetInTerritory = {
                de = "Straßen können in diesem Territorium nicht gebaut werden!",
                en = "The placement of streets is not allowed in this territory!",
                fr = "Les routes ne peuvent pas être construites sur ce territoire!"
            },
            NoStreetInArea = {
                de = "Straßen können in diesem Bereich nicht gebaut werden!",
                en = "The placement of streets is not allowed in this area!",
                fr = "Les routes ne peuvent pas être construites dans cette zone!"
            },
        }
    }
}

-- Global ------------------------------------------------------------------- --

function ModuleBuildRestriction.Global:OnGameStart()
end

function ModuleBuildRestriction.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- Local -------------------------------------------------------------------- --

function ModuleBuildRestriction.Local:OnGameStart()
    for i= 1, 8 do
        -- All knockdown protections
        self.KnockdownProtection[i] = {
            NoKnockdownCustomFunction = {},
            NoKnockdownCategoryInArea = {},
            NoKnockdownCategoryInTerritory = {},
            NoKnockdownTypeInArea = {},
            NoKnockdownTypeInTerritory = {},
            NoKnockdownScriptName = {},
        };
        -- All construction restrictions
        self.ConstructionRestrictions[i] = {
            NoConstructCustomFunction = {},
            NoConstructCategoryInArea = {},
            NoConstructCategoryInTerritory = {},
            NoConstructTypeInArea = {},
            NoConstructTypeInTerritory = {},
            NoRoadCustomFunction = {},
            NoTrailInArea = {},
            NoTrailInTerritory = {},
            NoStreetInArea = {},
            NoStreetInTerritory = {},
        };
    end
    self:OverrideDeleteEntityStateBuilding();
    self:OverrideBuildButtonClicked();
    self:OverridePlacementUpdate();
end

function ModuleBuildRestriction.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

function ModuleBuildRestriction.Local:GetNewRestrictionID()
    self.RestrictionSequence = self.RestrictionSequence +1;
    return self.RestrictionSequence;
end

function ModuleBuildRestriction.Local:GetNewProtectionID()
    self.ProtectionSequence = self.ProtectionSequence +1;
    return self.ProtectionSequence;
end

function ModuleBuildRestriction.Local:InsertRestriction(_PlayerID, _ID, _Type, _Data)
    _ID = ((_ID == 0 or _ID == nil) and self:GetNewRestrictionID()) or _ID;
    _Data.ID = _ID;
    if _PlayerID == -1 then
        for i= 1, 8 do
            if self.ConstructionRestrictions[i][_Type] then
                table.insert(self.ConstructionRestrictions[i][_Type], _Data);
            end
        end
    else
        if self.ConstructionRestrictions[_PlayerID] and self.ConstructionRestrictions[_PlayerID][_Type] then
            table.insert(self.ConstructionRestrictions[_PlayerID][_Type], _Data);
        end
    end
    return _ID;
end

function ModuleBuildRestriction.Local:InsertProtection(_PlayerID, _ID, _Type, _Data)
    _ID = ((_ID == 0 or _ID == nil) and self:GetNewProtectionID()) or _ID;
    _Data.ID = _ID;
    if _PlayerID == -1 then
        for i= 1, 8 do
            if self.KnockdownProtection[i][_Type] then
                table.insert(self.KnockdownProtection[i][_Type], _Data);
            end
        end
    else
        if self.KnockdownProtection[_PlayerID] and self.KnockdownProtection[_PlayerID][_Type] then
            table.insert(self.KnockdownProtection[_PlayerID][_Type], _Data);
        end
    end
    return _ID;
end

function ModuleBuildRestriction.Local:DeleteRestriction(_ID)
    for i= 1, 8 do
        for k, v in pairs(self.ConstructionRestrictions[i]) do
            for j= #v, 1, -1 do
                if v[j].ID == _ID then
                    table.remove(self.ConstructionRestrictions[i][k], j);
                end
            end
        end
    end
end

function ModuleBuildRestriction.Local:DeleteProtection(_ID)
    for i= 1, 8 do
        for k, v in pairs(self.KnockdownProtection[i]) do
            for j= #v, 1, -1 do
                if v[j].ID == _ID then
                    table.remove(self.KnockdownProtection[i][k], j);
                end
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

function ModuleBuildRestriction.Local:OverrideDeleteEntityStateBuilding()
    GameCallback_GUI_DeleteEntityStateBuilding_Orig_ConstructionControl = GameCallback_GUI_DeleteEntityStateBuilding;
    GameCallback_GUI_DeleteEntityStateBuilding = function(_BuildingID, _State)
        GameCallback_GUI_DeleteEntityStateBuilding_Orig_ConstructionControl(_BuildingID, _State);
        ModuleBuildRestriction.Local:CheckCanKnockdownBuilding(_BuildingID, _State);
    end
end

function ModuleBuildRestriction.Local:OverrideBuildButtonClicked()
    GUI_Construction.BuildClicked_Orig_ConstructionControl = GUI_Construction.BuildClicked;
    GUI_Construction.BuildClicked = function(_BuildingType)
        ModuleBuildRestriction.Local.LastSelectedBuildingType = _BuildingType;
        GUI_Construction.BuildClicked_Orig_ConstructionControl(_BuildingType);
    end

    GUI_Construction.BuildStreetClicked_Orig_ConstructionControl = GUI_Construction.BuildStreetClicked;
    GUI_Construction.BuildStreetClicked = function(_IsTrail)
        _IsTrail = (_IsTrail ~= nil and _IsTrail) or false;
        ModuleBuildRestriction.Local.LastSelectedRoadType = _IsTrail;
        GUI_Construction.BuildStreetClicked_Orig_ConstructionControl(_IsTrail);
    end

    GUI_Construction.BuildWallClicked_Orig_ConstructionControl = GUI_Construction.BuildWallClicked;
    GUI_Construction.BuildWallClicked = function(_BuildingType)
        if _BuildingType == nil then
            _BuildingType = GetUpgradeCategoryForClimatezone("WallSegment");
        end
        ModuleBuildRestriction.Local.LastSelectedBuildingType = _BuildingType;
        GUI_Construction.BuildWallClicked_Orig_ConstructionControl(_BuildingType);
    end

    GUI_Construction.BuildWallGateClicked_Orig_ConstructionControl = GUI_Construction.BuildWallGateClicked;
    GUI_Construction.BuildWallGateClicked = function(_BuildingType)
        if _BuildingType == nil then
            _BuildingType = GetUpgradeCategoryForClimatezone("WallSegment");
        end
        ModuleBuildRestriction.Local.LastSelectedBuildingType = _BuildingType;
        GUI_Construction.BuildWallGateClicked_Orig_ConstructionControl(_BuildingType);
    end

    GUI_BuildingButtons.PlaceFieldClicked_Orig_ConstructionControl = GUI_BuildingButtons.PlaceFieldClicked;
    GUI_BuildingButtons.PlaceFieldClicked = function()
        local EntityType = Logic.GetEntityType(GUI.GetSelectedEntity());
        ModuleBuildRestriction.Local.LastSelectedBuildingType = EntityType;
        GUI_BuildingButtons.PlaceFieldClicked_Orig_ConstructionControl();
    end
end

function ModuleBuildRestriction.Local:OverridePlacementUpdate()
    GUI_Construction.PlacementUpdate_Orig_ConstructionControl = GUI_Construction.PlacementUpdate;
    GUI_Construction.PlacementUpdate = function()
        ModuleBuildRestriction.Local:CancleConstructionState(GUI.GetPlayerID());
        GUI_Construction.PlacementUpdate_Orig_ConstructionControl();
    end
end

function ModuleBuildRestriction.Local:CancelState(_Message)
    local Text = _Message or ModuleBuildRestriction.Shared.Text.NoBuilding;
    API.Message(API.Localize(Text));
    GUI.CancelState();
end

function ModuleBuildRestriction.Local:CancelKnockdown(_EntityID, _Message)
    local Text = _Message or ModuleBuildRestriction.Shared.Text.NoKnockdown;
    API.Message(API.Localize(Text));
    GUI.CancelBuildingKnockDown(_EntityID);
end

function ModuleBuildRestriction.Local:CancleConstructionState(_PlayerID)
    if not self.ConstructionRestrictions[_PlayerID] then
        return;
    end
    local x,y = GUI.Debug_GetMapPositionUnderMouse();
    local Territory = Logic.GetTerritoryAtPosition(x or 1, y or 1);
    local Text = ModuleBuildRestriction.Shared.Text;

    -- Check placing roads
    if g_Construction.CurrentPlacementType == 1 then
        -- Check custom function
        for k, v in pairs(self.ConstructionRestrictions[_PlayerID].NoRoadCustomFunction) do
            if v.Function and v.Function(_PlayerID, ModuleBuildRestriction.Local.LastSelectedRoadType, x, y) then
                return self:CancelState(v.Message);
            end
        end
        if ModuleBuildRestriction.Local.LastSelectedRoadType then
            -- Check road in area
            for k, v in pairs(self.ConstructionRestrictions[_PlayerID].NoTrailInArea) do
                if API.GetDistance(v.Position, {X= x, Y= y}) <= v.Area then
                    return self:CancelState(Text.NoTrailInArea);
                end
            end
            -- Check road in territory
            for k, v in pairs(self.ConstructionRestrictions[_PlayerID].NoTrailInTerritory) do
                if Territory == v.Territory then
                    return self:CancelState(Text.NoTrailInTerritory);
                end
            end
        else
            -- Check street in area
            for k, v in pairs(self.ConstructionRestrictions[_PlayerID].NoStreetInArea) do
                if API.GetDistance(v.Position, {X= x, Y= y}) <= v.Area then
                    return self:CancelState(Text.NoStreetInArea);
                end
            end
            -- Check street in territory
            for k, v in pairs(self.ConstructionRestrictions[_PlayerID].NoStreetInTerritory) do
                if Territory == v.Territory then
                    return self:CancelState(Text.NoStreetInTerritory);
                end
            end
        end
    end

    -- Check placing buildings
    if g_Construction.CurrentPlacementType ~= 1 then
        local UpgradeCategory = ModuleBuildRestriction.Local.LastSelectedBuildingType;
        local n, Type = Logic.GetBuildingTypesInUpgradeCategory(UpgradeCategory);
        local CategoryList = ModuleBuildRestriction.Local:GetEntityTypeCategoyList(Type);

        -- Check custom function
        for k, v in pairs(self.ConstructionRestrictions[_PlayerID].NoConstructCustomFunction) do
            if v.Function and v.Function(_PlayerID, Type, x, y) then
                return self:CancelState(v.Message);
            end
        end
        -- Check type in area
        for k, v in pairs(self.ConstructionRestrictions[_PlayerID].NoConstructTypeInArea) do
            if API.GetDistance(v.Position, {X= x, Y= y}) <= v.Area and v.Type == Type then
                return self:CancelState(Text.NoBuildingInArea);
            end
        end
        -- Check type in territory
        for k, v in pairs(self.ConstructionRestrictions[_PlayerID].NoConstructTypeInTerritory) do
            if Territory == v.Territory and v.Type == Type then
                return self:CancelState(Text.NoBuildingInTerritory);
            end
        end
        -- Check category in area
        for k, v in pairs(self.ConstructionRestrictions[_PlayerID].NoConstructCategoryInArea) do
            if API.GetDistance(v.Position, {X= x, Y= y}) <= v.Area and table.contains(CategoryList, v.Category) then
                return self:CancelState(Text.NoBuildingInArea);
            end
        end
        -- Check category in territory
        for k, v in pairs(self.ConstructionRestrictions[_PlayerID].NoConstructCategoryInTerritory) do
            if Territory == v.Territory and table.contains(CategoryList, v.Category) then
                return self:CancelState(Text.NoBuildingInTerritory);
            end
        end
    end
end

function ModuleBuildRestriction.Local:CheckCanKnockdownBuilding(_BuildingID, _State)
    local PlayerID = Logic.EntityGetPlayer(_BuildingID);
    local x,y,z = Logic.EntityGetPos(_BuildingID);
    local ScriptName = Logic.GetEntityName(_BuildingID);
    local Territory = Logic.GetTerritoryAtPosition(x or 1, y or 1);
    local Type = Logic.GetEntityType(_BuildingID);
    local CategoryList = ModuleBuildRestriction.Local:GetEntityTypeCategoyList(Type);

    if Logic.IsConstructionComplete(_BuildingID) == 0 then
        return;
    end
    local Text = ModuleBuildRestriction.Shared.Text;
    if self.KnockdownProtection[PlayerID] then
        -- Check custom function
        for k, v in pairs(self.KnockdownProtection[PlayerID].NoKnockdownCustomFunction) do
            if v.Function and v.Function(PlayerID, _BuildingID, x, y) then
                return self:CancelKnockdown(_BuildingID, v.Message);
            end
        end
        -- Check scriptname
        for k, v in pairs(self.KnockdownProtection[PlayerID].NoKnockdownScriptName) do
            if ScriptName == v.ScriptName then
                return self:CancelKnockdown(_BuildingID, Text.NoKnockdown);
            end
        end
        -- Check type in area
        for k, v in pairs(self.KnockdownProtection[PlayerID].NoKnockdownTypeInArea) do
            if API.GetDistance(v.Position, {X= x, Y= y}) <= v.Area and v.Type == Type then
                return self:CancelKnockdown(_BuildingID, Text.NoKnockdownInArea);
            end
        end
        -- Check type in territory
        for k, v in pairs(self.KnockdownProtection[PlayerID].NoKnockdownTypeInTerritory) do
            if Territory == v.Territory and v.Type == Type then
                return self:CancelKnockdown(_BuildingID, Text.NoKnockdownInTerritory);
            end
        end
        -- Check category in area
        for k, v in pairs(self.KnockdownProtection[PlayerID].NoKnockdownCategoryInArea) do
            if API.GetDistance(v.Position, {X= x, Y= y}) <= v.Area and table.contains(CategoryList, v.Category) then
                return self:CancelKnockdown(_BuildingID, Text.NoKnockdownInArea);
            end
        end
        -- Check category in territory
        for k, v in pairs(self.KnockdownProtection[PlayerID].NoKnockdownCategoryInTerritory) do
            if Territory == v.Territory and table.contains(CategoryList, v.Category) then
                return self:CancelKnockdown(_BuildingID, Text.NoKnockdownInTerritory);
            end
        end
    end
end

-- Helper for getting the categories a type is in.
function ModuleBuildRestriction.Local:GetEntityTypeCategoyList(_Type)
    local CategoryList = {};
    for k, v in pairs(EntityCategories) do
        if Logic.IsEntityTypeInCategory(_Type, v) == 1 then
            table.insert(CategoryList, v);
        end
    end
    return CategoryList;
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleBuildRestriction);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Ermöglicht Abriss und Bau für den Spieler einzuschränken.
-- 
-- <p><b>Hinweis</b>: Jegliche Enschränkungen funktionieren nur für menschlische
-- Spieler. Die KI wird sie alle ignorieren!</p>
-- 
-- <p>Eine Baubeschränkung oder ein Abrissschutz geben eine ID zurück, über die
-- seibiger dann gelöscht werden kann.</p>
--
-- Es gibt zudem eine Hierarchie, nach der die einzelnen Checks durchgeführt
-- werden. Dabei wird nach Art des betroffenen Bereiches und nach Art des
-- betroffenen Subjektes unterschieden.
--
-- Nach Art des Bereiches:
-- <ol>
-- <li>Custom-Funktionen</li>
-- <li>Durch Umkreise definierte Bereiche</li>
-- <li>Durch Territorien definierte Bereiche</li>
-- </ol>
--
-- Nach Art des Gebäudes:
-- <ol>
-- <li>Custom-Funktionen</li>
-- <li>Skriptnamen</li>
-- <li>Entity Types</li>
-- <li>Entity Categories</li>
-- </ol>
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Verhindert den Bau Gebäuden anhand der übergebenen Funktion.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- Die angegebene Funktion muss eine Funktion im lokalen Skript sein. Es ist
-- möglich Funktionen innerhalb Tables anzugeben. Die self-Referenz wird
-- allerdings nicht unterstützt.
--
-- Eine Funktion muss true zurückgeben, wenn der Bau geblockt werden soll.
-- Die gleiche Funktion kann für alle Spieler benutzt werden, wenn als PlayerID
-- -1 angegeben wird. Für welchen Spieler sie ausgeführt wird, wird stets als 
-- Parameter übergeben.
--
-- @param[type=number]   _PlayerID ID des Spielers
-- @param[type=function] _Function Funktion im lokalen Skript
-- @param                _Message  (Optional) Nachricht für Bau gesperrt (String, Table)
-- @return[type=number] ID der Einschränkung
-- @within Baubeschränkung
--
-- @usage
-- local MyCustomRestriction = function(_PlayerID, _Type, _X, _Y)
--    if AnythingIWant then
--        return true;
--    end
-- end
-- MyRestrictionID = API.RestrictBuildingCustomFunction(1, MyCustomRestriction);
--
function API.RestrictBuildingCustomFunction(_PlayerID, _Function, _Message)
    if not GUI then
        return 0;
    end
    local ID = ModuleBuildRestriction.Local:InsertRestriction(_PlayerID, 0, "NoConstructCustomFunction", {
        Function = _Function,
        Message = _Message
    });
    return ID;
end

---
-- Verhindert den Bau von Gebäuden des Typs in dem Territorium.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param[type=number] _Type      Entity-Typ
-- @param              _Territory ID oder Name des Territorium
-- @return[type=number] ID der Einschränkung
-- @within Baubeschränkung
--
-- @usage
-- MyRestrictionID = API.RestrictBuildingTypeInTerritory(1, Entities.B_Bakery, 1);
--
function API.RestrictBuildingTypeInTerritory(_PlayerID, _Type, _Territory)
    if not GUI then
        return 0;
    end
    if type(_Territory) == "string" then
        _Territory = GetTerritoryIDByName(_Territory);
    end
    local ID = ModuleBuildRestriction.Local:InsertRestriction(_PlayerID, 0, "NoConstructTypeInTerritory", {
        Territory = _Territory,
        Type = _Type,
    });
    return ID;
end

---
-- Verhindert den Bau von Gebäuden des Typs innerhalb des Gebietes.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param[type=number] _Type      Entity-Typ
-- @param              _Position  Position oder Skriptname
-- @param[type=number] _Area      Größe des Gebiets
-- @return[type=number] ID der Einschränkung
-- @within Baubeschränkung
--
-- @usage
-- MyRestrictionID = API.RestrictBuildingTypeInArea(1, Entities.B_Bakery, "GiveMeMeatInstead", 3000);
--
function API.RestrictBuildingTypeInArea(_PlayerID, _Type, _Position, _Area)
    if not GUI then
        return 0;
    end
    local ID = ModuleBuildRestriction.Local:InsertRestriction(_PlayerID, 0, "NoConstructTypeInArea", {
        Position = API.GetPosition(_Position),
        Area = _Area,
        Type = _Type,
    });
    return ID;
end

---
-- Verhindert den Bau von Gebäuden der Kategorie in dem Territorium.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param[type=number] _Category  Entity-Kategorie
-- @param              _Territory ID oder Name des Territorium
-- @return[type=number] ID der Einschränkung
-- @within Baubeschränkung
--
-- @usage
-- MyRestrictionID = API.RestrictBuildingCategoryInTerritory(1, EntityCategories.CityBuilding, 1);
--
function API.RestrictBuildingCategoryInTerritory(_PlayerID, _Category, _Territory)
    if not GUI then
        return 0;
    end
    if type(_Territory) == "string" then
        _Territory = GetTerritoryIDByName(_Territory);
    end
    local ID = ModuleBuildRestriction.Local:InsertRestriction(_PlayerID, 0, "NoConstructCategoryInTerritory", {
        Territory = _Territory,
        Category = _Category,
    });
    return ID;
end

---
-- Verhindert den Bau von Gebäuden der Kategorie innerhalb des Gebietes.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param[type=number] _Category  Entity-Kategorie
-- @param              _Position  Position oder Skriptname
-- @param[type=number] _Area      Größe des Gebiets
-- @return[type=number] ID der Einschränkung
-- @within Baubeschränkung
--
-- @usage
-- MyRestrictionID = API.RestrictBuildingCategoryInArea(1, EntityCategories.OuterRimBuilding, "NoOuterRim", 3000);
--
function API.RestrictBuildingCategoryInArea(_PlayerID, _Category, _Position, _Area)
    if not GUI then
        return 0;
    end
    local ID = ModuleBuildRestriction.Local:InsertRestriction(_PlayerID, 0, "NoConstructCategoryInArea", {
        Position = API.GetPosition(_Position),
        Area = _Area,
        Category = _Category,
    });
    return ID;
end

---
-- Verhindert den Bau von Pfaden oder Straßen anhand der übergebenen Funktion.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- Die angegebene Funktion muss eine Funktion im lokalen Skript sein. Es ist
-- möglich Funktionen innerhalb Tables anzugeben. Die self-Referenz wird
-- allerdings nicht unterstützt.
--
-- Eine Funktion muss true zurückgeben, wenn der Bau geblockt werden soll.
-- Die gleiche Funktion kann für alle Spieler benutzt werden, wenn als PlayerID
-- -1 angegeben wird. Für welchen Spieler sie ausgeführt wird, wird stets als
-- Parameter übergeben.
--
-- @param[type=number]   _PlayerID ID des Spielers
-- @param[type=function] _Function Funktion im lokalen Skript
-- @param                _Message  (Optional) Nachricht für Bau gesperrt (String, Table)
-- @return[type=number] ID der Einschränkung
-- @within Baubeschränkung
--
-- @usage
-- local MyCustomRestriction = function(_PlayerID, _IsTrail, _X, _Y)
--    if AnythingIWant then
--        return true;
--    end
-- end
-- MyRestrictionID = API.RestrictRoadCustomFunction(1, MyCustomRestriction);
--
function API.RestrictRoadCustomFunction(_PlayerID, _Function, _Message)
    if not GUI then
        return 0;
    end
    local ID = ModuleBuildRestriction.Local:InsertRestriction(_PlayerID, 0, "NoRoadCustomFunction", {
        Function = _Function,
        Message = _Message,
    });
    return ID;
end

---
-- Verhindert den Bau von Pfaden in dem Territorium.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param              _Territory ID oder Name des Territorium
-- @return[type=number] ID der Einschränkung
-- @within Baubeschränkung
--
-- @usage
-- MyRestrictionID = API.RestrictTrailInTerritory(1, 1);
--
function API.RestrictTrailInTerritory(_PlayerID, _Territory)
    if not GUI then
        return 0;
    end
    if type(_Territory) == "string" then
        _Territory = GetTerritoryIDByName(_Territory);
    end
    local ID = ModuleBuildRestriction.Local:InsertRestriction(_PlayerID, 0, "NoTrailInTerritory", {
        Territory = _Territory,
    });
    return ID;
end

---
-- Verhindert den Bau von Pfaden innerhalb des Gebiets.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param              _Position  Position oder Skriptname
-- @param[type=number] _Area      Größe des Gebiets
-- @return[type=number] ID der Einschränkung
-- @within Baubeschränkung
--
-- @usage
-- MyRestrictionID = API.RestrictTrailInArea(1, "NoMansLand", 3000);
--
function API.RestrictTrailInArea(_PlayerID, _Position, _Area)
    if not GUI then
        return 0;
    end
    local ID = ModuleBuildRestriction.Local:InsertRestriction(_PlayerID, 0, "NoTrailInArea", {
        Position = API.GetPosition(_Position),
        Area = _Area,
    });
    return ID;
end

---
-- Verhindert den Bau von Straßen in dem Territorium.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param              _Territory ID oder Name des Territorium
-- @return[type=number] ID der Einschränkung
-- @within Baubeschränkung
--
-- @usage
-- MyRestrictionID = API.RestrictStreetInTerritory(1, 1);
--
function API.RestrictStreetInTerritory(_PlayerID, _Territory)
    if not GUI then
        return 0;
    end
    if type(_Territory) == "string" then
        _Territory = GetTerritoryIDByName(_Territory);
    end
    local ID = ModuleBuildRestriction.Local:InsertRestriction(_PlayerID, 0, "NoStreetInTerritory", {
        Territory = _Territory,
    });
    return ID;
end

---
-- Verhindert den Bau von Straßen innerhalb des Gebiets.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param              _Position  Position oder Skriptname
-- @param[type=number] _Area      Größe des Gebiets
-- @return[type=number] ID der Einschränkung
-- @within Baubeschränkung
--
-- @usage
-- MyRestrictionID = API.RestrictStreetInArea(1, "NoMansLand", 3000);
--
function API.RestrictStreetInArea(_PlayerID, _Position, _Area)
    if not GUI then
        return 0;
    end
    local ID = ModuleBuildRestriction.Local:InsertRestriction(_PlayerID, 0, "NoStreetInArea", {
        Position = API.GetPosition(_Position),
        Area = _Area,
    });
    return ID;
end

---
-- Löscht eine Baueinschränkung mit der angegebenen ID.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _ID  ID der Einschränkung
-- @within Baubeschränkung
--
-- @usage
-- API.DeleteRestriction(MyRestrictionID);
--
function API.DeleteRestriction(_ID)
    if not GUI then
        return;
    end
    ModuleBuildRestriction.Local:DeleteRestriction(_ID);
end

---
-- Verhindert den Abriss von Gebäuden anhand der übergebenen Funktion.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- Die angegebene Funktion muss eine Funktion im lokalen Skript sein. Es ist
-- möglich Funktionen innerhalb Tables anzugeben. Die self-Referenz wird
-- allerdings nicht unterstützt.
--
-- Eine Funktion muss true zurückgeben, wenn der Abriss geblockt werden soll.
-- Die gleiche Funktion kann für alle Spieler benutzt werden, wenn als PlayerID
-- -1 angegeben wird. Für welchen Spieler sie ausgeführt wird, wird stets als
-- Parameter übergeben.
--
-- @param[type=number]   _PlayerID ID des Spielers
-- @param[type=function] _Function Funktion im lokalen Skript
-- @param                _Message  (Optional) Nachricht für Abriss gesperrt (String, Table)
-- @return[type=number] ID der Protektion
-- @within Abrissbeschränkung
--
-- @usage
-- local MyCustomProtection = function(_PlayerID, _BuildingID, _X, _Y)
--    if AnythingIWant then
--        return true;
--    end
-- end
-- MyProtectionID = API.ProtectBuildingCustomFunction(1, MyCustomProtection);
--
function API.ProtectBuildingCustomFunction(_PlayerID, _Function, _Message)
    if not GUI then
        return 0;
    end
    local ID = ModuleBuildRestriction.Local:InsertProtection(_PlayerID, 0, "NoKnockdownCustomFunction", {
        Function = _Function,
        Message = _Message,
    });
    return ID;
end

---
-- Verhindert den Abriss aller Gebäude des Typs in dem Territorium.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param[type=number] _Type      Entity-Typ
-- @param              _Territory ID oder Name des Territorium
-- @return[type=number] ID der Protektion
-- @within Abrissbeschränkung
--
-- @usage
-- MyProtectionID = API.ProtectBuildingTypeInTerritory(1, Entities.B_Bakery, 1);
--
function API.ProtectBuildingTypeInTerritory(_PlayerID, _Type, _Territory)
    if not GUI then
        return 0;
    end
    if type(_Territory) == "string" then
        _Territory = GetTerritoryIDByName(_Territory);
    end
    local ID = ModuleBuildRestriction.Local:InsertProtection(_PlayerID, 0, "NoKnockdownTypeInTerritory", {
        Territory = _Territory,
        Type = _Type,
    });
    return ID;
end

---
-- Verhindert den Abriss aller Gebäude des Typs innerhalb des Gebiets.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param[type=number] _Type      Entity-Typ
-- @param              _Position  Position oder Skriptname
-- @param[type=number] _Area      Größe des Gebiets
-- @return[type=number] ID der Protektion
-- @within Abrissbeschränkung
--
-- @usage
-- MyProtectionID = API.ProtectBuildingTypeInArea(1, Entities.B_Bakery, "AreaCenter", 3000);
--
function API.ProtectBuildingTypeInArea(_PlayerID, _Type, _Position, _Area)
    if not GUI then
        return 0;
    end
    local ID = ModuleBuildRestriction.Local:InsertProtection(_PlayerID, 0, "NoKnockdownTypeInArea", {
        Position = API.GetPosition(_Position),
        Area = _Area,
        Type = _Type,
    });
    return ID;
end

---
-- Verhindert den Abriss aller Gebäude in der Kategorie in dem Territorium.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param[type=number] _Category  Entity-Kategorie
-- @param              _Territory ID oder Name des Territorium
-- @return[type=number] ID der Protektion
-- @within Abrissbeschränkung
--
-- @usage
-- MyProtectionID = API.ProtectBuildingCategoryInTerritory(1, EntityCategories.CityBuilding, 1);
--
function API.ProtectBuildingCategoryInTerritory(_PlayerID, _Category, _Territory)
    if not GUI then
        return 0;
    end
    if type(_Territory) == "string" then
        _Territory = GetTerritoryIDByName(_Territory);
    end
    local ID = ModuleBuildRestriction.Local:InsertProtection(_PlayerID, 0, "NoKnockdownCategoryInTerritory", {
        Territory = _Territory,
        Category = _Category,
    });
    return ID;
end

---
-- Verhindert den Abriss aller Gebäude in der Kategorie innerhalb des Gebiets.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param[type=number] _Category  Entity-Kategorie
-- @param              _Position  Position oder Skriptname
-- @param[type=number] _Area      Größe des Gebiets
-- @return[type=number] ID der Protektion
-- @within Abrissbeschränkung
--
-- @usage
-- MyProtectionID = API.ProtectBuildingCategoryInArea(1, EntityCategories.CityBuilding, "AreaCenter", 3000);
--
function API.ProtectBuildingCategoryInArea(_PlayerID, _Category, _Position, _Area)
    if not GUI then
        return 0;
    end
    local ID = ModuleBuildRestriction.Local:InsertProtection(_PlayerID, 0, "NoKnockdownCategoryInArea", {
        Position = API.GetPosition(_Position),
        Area = _Area,
        Category = _Category,
    });
    return ID;
end

---
-- Verhindert den Abriss eines benannten Gebäudes.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=String] _ScriptName Skriptname des Entity
-- @return[type=number] ID der Protektion
-- @within Abrissbeschränkung
--
-- @usage
-- MyProtectionID = API.ProtectNamedBuilding(1, "Denkmalschutz");
--
function API.ProtectNamedBuilding(_PlayerID, _ScriptName)
    if not GUI then
        return 0;
    end
    local ID = ModuleBuildRestriction.Local:InsertProtection(_PlayerID, 0, "NoKnockdownScriptName", {
        ScriptName = _ScriptName,
    });
    return ID;
end

---
-- Löscht einen Abrissschutz mit der angegebenen ID.
--
-- <b>Hinweis:</b> Die Funktion kann nur im lokalen Skript verwendet werden!
--
-- @param[type=number] _ID ID der Protektion
-- @within Abrissbeschränkung
--
-- @usage
-- API.DeleteProtection(MyProtectionID);
--
function API.DeleteProtection(_ID)
    if not GUI then
        return;
    end
    ModuleBuildRestriction.Local:DeleteProtection(_ID);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleBuildingButtons = {
    Properties = {
        Name = "ModuleBuildingButtons",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {},
    Local = {
        BuildingButtons = {
            BindingCounter = 0,
            Bindings = {},
            Configuration = {
                ["BuyAmmunitionCart"] = {
                    TypeExclusion = "^B_.*StoreHouse",
                    OriginalPosition = nil,
                    Bind = nil,
                },
                ["BuyBattallion"] = {
                    TypeExclusion = "^B_[CB]a[sr][tr][la][ec]",
                    OriginalPosition = nil,
                    Bind = nil,
                },
                ["PlaceField"] = {
                    TypeExclusion = "^B_.*[BFH][aei][erv][kme]",
                    OriginalPosition = nil,
                    Bind = nil,
                },
                ["StartFestival"] = {
                    TypeExclusion = "^B_Marketplace",
                    OriginalPosition = nil,
                    Bind = nil,
                },
                ["StartTheatrePlay"] = {
                    TypeExclusion = "^B_Theatre",
                    OriginalPosition = nil,
                    Bind = nil,
                },
                ["UpgradeTurret"] = {
                    TypeExclusion = "^B_WallTurret",
                    OriginalPosition = nil,
                    Bind = nil,
                },
                ["BuyBatteringRamCart"] = {
                    TypeExclusion = "^B_SiegeEngineWorkshop",
                    OriginalPosition = nil,
                    Bind = nil,
                },
                ["BuyCatapultCart"] = {
                    TypeExclusion = "^B_SiegeEngineWorkshop",
                    OriginalPosition = nil,
                    Bind = nil,
                },
                ["BuySiegeTowerCart"] = {
                    TypeExclusion = "^B_SiegeEngineWorkshop",
                    OriginalPosition = nil,
                    Bind = nil,
                },
            },
        },
    },

    Shared = {};
}

-- Global ------------------------------------------------------------------- --

function ModuleBuildingButtons.Global:OnGameStart()
    QSB.ScriptEvents.UpgradeCanceled = API.RegisterScriptEvent("Event_UpgradeCanceled");
    QSB.ScriptEvents.UpgradeStarted = API.RegisterScriptEvent("Event_UpgradeStarted");
    QSB.ScriptEvents.FestivalStarted = API.RegisterScriptEvent("Event_FestivalStarted");
    QSB.ScriptEvents.SermonStarted = API.RegisterScriptEvent("Event_SermonStarted");
    QSB.ScriptEvents.TheatrePlayStarted = API.RegisterScriptEvent("Event_TheatrePlayStarted");

    -- Building upgrade started event
    API.RegisterScriptCommand("Cmd_StartBuildingUpgrade", function(_BuildingID, _PlayerID)
        if Logic.IsBuildingBeingUpgraded(_BuildingID) then
            ModuleBuildingButtons.Global:SendStartBuildingUpgradeEvent(_BuildingID, _PlayerID);
        end
    end);
    -- Building upgrade canceled event
    API.RegisterScriptCommand("Cmd_CancelBuildingUpgrade", function(_BuildingID, _PlayerID)
        if not Logic.IsBuildingBeingUpgraded(_BuildingID) then
            ModuleBuildingButtons.Global:SendCancelBuildingUpgradeEvent(_BuildingID, _PlayerID);
        end
    end);
    -- Theatre play started event
    API.RegisterScriptCommand("Cmd_StartTheatrePlay", function(_BuildingID, _PlayerID)
        if Logic.GetTheatrePlayProgress(_BuildingID) ~= 0 then
            ModuleBuildingButtons.Global:SendTheatrePlayEvent(_BuildingID, _PlayerID);
        end
    end);
    -- Festival started event
    API.RegisterScriptCommand("Cmd_StartRegularFestival", function(_PlayerID)
        if Logic.IsFestivalActive(_PlayerID) == true then
            ModuleBuildingButtons.Global:SendStartRegularFestivalEvent(_PlayerID);
        end
    end);
    -- Sermon started event
    API.RegisterScriptCommand("Cmd_StartSermon", function(_PlayerID)
        if Logic.IsSermonActive(_PlayerID) == true then
            ModuleBuildingButtons.Global:SendStartSermonEvent(_PlayerID);
        end
    end);
end

function ModuleBuildingButtons.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

function ModuleBuildingButtons.Global:SendStartBuildingUpgradeEvent(_BuildingID, _PlayerID)
    API.SendScriptEvent(QSB.ScriptEvents.UpgradeStarted, _BuildingID, _PlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.UpgradeStarted, %d, %d)]],
        _BuildingID,
        _PlayerID
    ));
end

function ModuleBuildingButtons.Global:SendCancelBuildingUpgradeEvent(_BuildingID, _PlayerID)
    API.SendScriptEvent(QSB.ScriptEvents.UpgradeCanceled, _BuildingID, _PlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.UpgradeCanceled, %d, %d)]],
        _BuildingID,
        _PlayerID
    ));
end

function ModuleBuildingButtons.Global:SendTheatrePlayEvent(_BuildingID, _PlayerID)
    API.SendScriptEvent(QSB.ScriptEvents.TheatrePlayStarted, _BuildingID, _PlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.TheatrePlayStarted, %d, %d)]],
        _BuildingID,
        _PlayerID
    ));
end

function ModuleBuildingButtons.Global:SendStartRegularFestivalEvent(_PlayerID)
    API.SendScriptEvent(QSB.ScriptEvents.FestivalStarted, _PlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.FestivalStarted, %d)]],
        _PlayerID
    ));
end

function ModuleBuildingButtons.Global:SendStartSermonEvent(_PlayerID)
    API.SendScriptEvent(QSB.ScriptEvents.SermonStarted, _PlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.SermonStarted, %d)]],
        _PlayerID
    ));
end

-- Local -------------------------------------------------------------------- --

function ModuleBuildingButtons.Local:OnGameStart()
    QSB.ScriptEvents.UpgradeCanceled = API.RegisterScriptEvent("Event_UpgradeCanceled");
    QSB.ScriptEvents.UpgradeStarted = API.RegisterScriptEvent("Event_UpgradeStarted");
    QSB.ScriptEvents.FestivalStarted = API.RegisterScriptEvent("Event_FestivalStarted");
    QSB.ScriptEvents.SermonStarted = API.RegisterScriptEvent("Event_SermonStarted");
    QSB.ScriptEvents.TheatrePlayStarted = API.RegisterScriptEvent("Event_TheatrePlayStarted");

    self:InitBackupPositions();
    self:OverrideOnSelectionChanged();
    self:OverrideBuyAmmunitionCart();
    self:OverrideBuyBattalion();
    self:OverrideBuySiegeEngineCart();
    self:OverridePlaceField();
    self:OverrideStartFestival();
    self:OverrideStartTheatrePlay();
    self:OverrideUpgradeTurret();
    self:OverrideUpgradeBuilding();
    self:OverrideStartSermon();
end

function ModuleBuildingButtons.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

function ModuleBuildingButtons.Local:OverrideOnSelectionChanged()
    GameCallback_GUI_SelectionChanged_Orig_Interface = GameCallback_GUI_SelectionChanged;
    GameCallback_GUI_SelectionChanged = function(_Source)
        GameCallback_GUI_SelectionChanged_Orig_Interface(_Source);
        ModuleBuildingButtons.Local:UnbindButtons();
        ModuleBuildingButtons.Local:BindButtons(GUI.GetSelectedEntity());
    end
end

function ModuleBuildingButtons.Local:OverrideBuyAmmunitionCart()
    GUI_BuildingButtons.BuyAmmunitionCartClicked_Orig_Interface = GUI_BuildingButtons.BuyAmmunitionCartClicked;
    GUI_BuildingButtons.BuyAmmunitionCartClicked = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return GUI_BuildingButtons.BuyAmmunitionCartClicked_Orig_Interface();
        end
        Button.Action(WidgetID, EntityID);
    end

    GUI_BuildingButtons.BuyAmmunitionCartUpdate_Orig_Interface = GUI_BuildingButtons.BuyAmmunitionCartUpdate;
    GUI_BuildingButtons.BuyAmmunitionCartUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            SetIcon(WidgetID, {10, 4});
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return GUI_BuildingButtons.BuyAmmunitionCartUpdate_Orig_Interface();
        end
        Button.Update(WidgetID, EntityID);
    end
end

function ModuleBuildingButtons.Local:OverrideBuyBattalion()
    GUI_BuildingButtons.BuyBattalionClicked_Orig_Interface = GUI_BuildingButtons.BuyBattalionClicked;
    GUI_BuildingButtons.BuyBattalionClicked = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return GUI_BuildingButtons.BuyBattalionClicked_Orig_Interface();
        end
        Button.Action(WidgetID, EntityID);
    end

    GUI_BuildingButtons.BuyBattalionMouseOver_Orig_Interface = GUI_BuildingButtons.BuyBattalionMouseOver;
    GUI_BuildingButtons.BuyBattalionMouseOver = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button;
        if ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName] then
            Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        end
        if not Button then
            return GUI_BuildingButtons.BuyBattalionMouseOver_Orig_Interface();
        end
        Button.Tooltip(WidgetID, EntityID);
    end

    GUI_BuildingButtons.BuyBattalionUpdate_Orig_Interface = GUI_BuildingButtons.BuyBattalionUpdate;
    GUI_BuildingButtons.BuyBattalionUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return GUI_BuildingButtons.BuyBattalionUpdate_Orig_Interface();
        end
        Button.Update(WidgetID, EntityID);
    end
end

function ModuleBuildingButtons.Local:OverridePlaceField()
    GUI_BuildingButtons.PlaceFieldClicked_Orig_Interface = GUI_BuildingButtons.PlaceFieldClicked;
    GUI_BuildingButtons.PlaceFieldClicked = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return GUI_BuildingButtons.PlaceFieldClicked_Orig_Interface();
        end
        Button.Action(WidgetID, EntityID);
    end

    GUI_BuildingButtons.PlaceFieldMouseOver_Orig_Interface = GUI_BuildingButtons.PlaceFieldMouseOver;
    GUI_BuildingButtons.PlaceFieldMouseOver = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return GUI_BuildingButtons.PlaceFieldMouseOver_Orig_Interface();
        end
        Button.Tooltip(WidgetID, EntityID);
    end

    GUI_BuildingButtons.PlaceFieldUpdate_Orig_Interface = GUI_BuildingButtons.PlaceFieldUpdate;
    GUI_BuildingButtons.PlaceFieldUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return GUI_BuildingButtons.PlaceFieldUpdate_Orig_Interface();
        end
        Button.Update(WidgetID, EntityID);
    end
end

function ModuleBuildingButtons.Local:OverrideStartFestival()
    GUI_BuildingButtons.StartFestivalClicked = function(_FestivalIndex)
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            local PlayerID = GUI.GetPlayerID();
            local Costs = {Logic.GetFestivalCost(PlayerID, _FestivalIndex)};
            local CanBuyBoolean, CanNotBuyString = AreCostsAffordable(Costs);
            if EntityID ~= Logic.GetMarketplace(PlayerID) then
                return;
            end
            if CanBuyBoolean == true then
                Sound.FXPlay2DSound("ui\\menu_click");
                GUI.StartFestival(PlayerID, _FestivalIndex);
                StartEventMusic(MusicSystem.EventFestivalMusic, PlayerID);
                StartKnightVoiceForPermanentSpecialAbility(Entities.U_KnightSong);
                GUI.AddBuff(Buffs.Buff_Festival);
                API.BroadcastScriptCommand(QSB.ScriptCommands.StartRegularFestival, PlayerID);
            else
                Message(CanNotBuyString);
            end
            return;
        end
        Button.Action(WidgetID, EntityID);
    end

    GUI_BuildingButtons.StartFestivalMouseOver_Orig_Interface = GUI_BuildingButtons.StartFestivalMouseOver;
    GUI_BuildingButtons.StartFestivalMouseOver = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return GUI_BuildingButtons.StartFestivalMouseOver_Orig_Interface();
        end
        Button.Tooltip(WidgetID, EntityID);
    end

    GUI_BuildingButtons.StartFestivalUpdate_Orig_Interface = GUI_BuildingButtons.StartFestivalUpdate;
    GUI_BuildingButtons.StartFestivalUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            SetIcon(WidgetID, {4, 15});
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return GUI_BuildingButtons.StartFestivalUpdate_Orig_Interface();
        end
        Button.Update(WidgetID, EntityID);
    end
end

function ModuleBuildingButtons.Local:OverrideStartTheatrePlay()
    GUI_BuildingButtons.StartTheatrePlayClicked = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            local PlayerID = GUI.GetPlayerID();
            local GoodType = Logic.GetGoodTypeOnOutStockByIndex(EntityID, 0);
            local Amount = Logic.GetMaxAmountOnStock(EntityID);
            local Costs = {GoodType, Amount};
            local CanBuyBoolean, CanNotBuyString = AreCostsAffordable(Costs);
            if Logic.CanStartTheatrePlay(EntityID) == true then
                Sound.FXPlay2DSound("ui\\menu_click");
                GUI.StartTheatrePlay(EntityID);
                API.BroadcastScriptCommand(QSB.ScriptCommands.StartTheatrePlay, PlayerID);
            elseif CanBuyBoolean == false then
                Message(CanNotBuyString);
            end
            return;
        end
        Button.Action(WidgetID, EntityID);
    end

    GUI_BuildingButtons.StartTheatrePlayMouseOver_Orig_Interface = GUI_BuildingButtons.StartTheatrePlayMouseOver;
    GUI_BuildingButtons.StartTheatrePlayMouseOver = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return GUI_BuildingButtons.StartTheatrePlayMouseOver_Orig_Interface();
        end
        Button.Tooltip(WidgetID, EntityID);
    end

    GUI_BuildingButtons.StartTheatrePlayUpdate_Orig_Interface = GUI_BuildingButtons.StartTheatrePlayUpdate;
    GUI_BuildingButtons.StartTheatrePlayUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            SetIcon(WidgetID, {16, 2});
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return GUI_BuildingButtons.StartTheatrePlayUpdate_Orig_Interface();
        end
        Button.Update(WidgetID, EntityID);
    end
end

function ModuleBuildingButtons.Local:OverrideUpgradeTurret()
    GUI_BuildingButtons.UpgradeTurretClicked_Orig_Interface = GUI_BuildingButtons.UpgradeTurretClicked;
    GUI_BuildingButtons.UpgradeTurretClicked = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return GUI_BuildingButtons.UpgradeTurretClicked_Orig_Interface();
        end
        Button.Action(WidgetID, EntityID);
    end

    GUI_BuildingButtons.UpgradeTurretMouseOver_Orig_Interface = GUI_BuildingButtons.UpgradeTurretMouseOver;
    GUI_BuildingButtons.UpgradeTurretMouseOver = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return GUI_BuildingButtons.UpgradeTurretMouseOver_Orig_Interface();
        end
        Button.Tooltip(WidgetID, EntityID);
    end

    GUI_BuildingButtons.UpgradeTurretUpdate_Orig_Interface = GUI_BuildingButtons.UpgradeTurretUpdate;
    GUI_BuildingButtons.UpgradeTurretUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return GUI_BuildingButtons.UpgradeTurretUpdate_Orig_Interface();
        end
        Button.Update(WidgetID, EntityID);
    end
end

function ModuleBuildingButtons.Local:OverrideBuySiegeEngineCart()
    GUI_BuildingButtons.BuySiegeEngineCartClicked_Orig_Interface = GUI_BuildingButtons.BuySiegeEngineCartClicked;
    GUI_BuildingButtons.BuySiegeEngineCartClicked = function(_EntityType)
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button;
        if WidgetName == "BuyCatapultCart"
        or WidgetName == "BuySiegeTowerCart"
        or WidgetName == "BuyBatteringRamCart" then
            Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        end
        if not Button then
            return GUI_BuildingButtons.BuySiegeEngineCartClicked_Orig_Interface(_EntityType);
        end
        Button.Action(WidgetID, EntityID);
    end

    GUI_BuildingButtons.BuySiegeEngineCartMouseOver_Orig_Interface = GUI_BuildingButtons.BuySiegeEngineCartMouseOver;
    GUI_BuildingButtons.BuySiegeEngineCartMouseOver = function(_EntityType, _Right)
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button;
        if WidgetName == "BuyCatapultCart"
        or WidgetName == "BuySiegeTowerCart"
        or WidgetName == "BuyBatteringRamCart" then
            Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        end
        if not Button then
            return GUI_BuildingButtons.BuySiegeEngineCartMouseOver_Orig_Interface(_EntityType, _Right);
        end
        Button.Tooltip(WidgetID, EntityID);
    end

    GUI_BuildingButtons.BuySiegeEngineCartUpdate_Orig_Interface = GUI_BuildingButtons.BuySiegeEngineCartUpdate;
    GUI_BuildingButtons.BuySiegeEngineCartUpdate = function(_EntityType)
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button;
        if WidgetName == "BuyCatapultCart"
        or WidgetName == "BuySiegeTowerCart"
        or WidgetName == "BuyBatteringRamCart" then
            Button = ModuleBuildingButtons.Local.BuildingButtons.Configuration[WidgetName].Bind;
        end
        if not Button then
            if WidgetName == "BuyBatteringRamCart" then
                SetIcon(WidgetID, {9, 2});
            elseif WidgetName == "BuySiegeTowerCart" then
                SetIcon(WidgetID, {9, 3});
            elseif WidgetName == "BuyCatapultCart" then
                SetIcon(WidgetID, {9, 1});
            end
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return GUI_BuildingButtons.BuySiegeEngineCartUpdate_Orig_Interface(_EntityType);
        end
        Button.Update(WidgetID, EntityID);
    end
end

function ModuleBuildingButtons.Local:OverrideUpgradeBuilding()
    GUI_BuildingButtons.UpgradeClicked = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        if Logic.CanCancelUpgradeBuilding(EntityID) then
            Sound.FXPlay2DSound("ui\\menu_click");
            GUI.CancelBuildingUpgrade(EntityID);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/BuildingButtons", 1);
            API.BroadcastScriptCommand(QSB.ScriptCommands.CancelBuildingUpgrade, EntityID, GUI.GetPlayerID());
            return;
        end
        local Costs = GUI_BuildingButtons.GetUpgradeCosts();
        local CanBuyBoolean, CanNotBuyString = AreCostsAffordable(Costs);
        if CanBuyBoolean == true then
            Sound.FXPlay2DSound("ui\\menu_click");
            GUI.UpgradeBuilding(EntityID, nil);
            StartKnightVoiceForPermanentSpecialAbility(Entities.U_KnightWisdom);
            if WidgetID ~= 0 then
                SaveButtonPressed(WidgetID);
            end
            API.BroadcastScriptCommand(QSB.ScriptCommands.StartBuildingUpgrade, EntityID, GUI.GetPlayerID());
        else
            Message(CanNotBuyString);
        end
    end
end

function ModuleBuildingButtons.Local:OverrideStartSermon()
    function GUI_BuildingButtons.StartSermonClicked()
        local PlayerID = GUI.GetPlayerID();
        if Logic.CanSermonBeActivated(PlayerID) then
            GUI.ActivateSermon(PlayerID);
            StartKnightVoiceForPermanentSpecialAbility(Entities.U_KnightHealing);
            GUI.AddBuff(Buffs.Buff_Sermon);
            local CathedralID = Logic.GetCathedral(PlayerID);
            local x, y = Logic.GetEntityPosition(CathedralID);
            local z = 0;
            Sound.FXPlay3DSound("buildings\\building_start_sermon", x, y, z);
            API.BroadcastScriptCommand(QSB.ScriptCommands.StartSermon, GUI.GetPlayerID());
        end
    end
end

-- -------------------------------------------------------------------------- --

function ModuleBuildingButtons.Local:InitBackupPositions()
    for k, v in pairs(self.BuildingButtons.Configuration) do
        local x, y = XGUIEng.GetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/" ..k);
        self.BuildingButtons.Configuration[k].OriginalPosition = {x, y};
    end
end

function ModuleBuildingButtons.Local:GetButtonsForOverwrite(_ID, _Amount)
    local Buttons = {};
    local Type = Logic.GetEntityType(_ID);
    local TypeName = Logic.GetEntityTypeName(Type);
    for k, v in pairs(self.BuildingButtons.Configuration) do
        if #Buttons == _Amount then
            break;
        end
        if not TypeName:find(v.TypeExclusion) then
            table.insert(Buttons, k);
        end
    end
    assert(#Buttons == _Amount);
    table.sort(Buttons);
    return Buttons;
end

function ModuleBuildingButtons.Local:AddButtonBinding(_Type, _X, _Y, _ActionFunction, _TooltipController, _UpdateController)
    if not self.BuildingButtons.Bindings[_Type] then
        self.BuildingButtons.Bindings[_Type] = {};
    end
    if #self.BuildingButtons.Bindings[_Type] < 6 then
        self.BuildingButtons.BindingCounter = self.BuildingButtons.BindingCounter +1;
        table.insert(self.BuildingButtons.Bindings[_Type], {
            ID       = self.BuildingButtons.BindingCounter,
            Position = {_X, _Y},
            Action   = _ActionFunction,
            Tooltip  = _TooltipController,
            Update   = _UpdateController,
        });
        return self.BuildingButtons.BindingCounter;
    end
    return 0;
end

function ModuleBuildingButtons.Local:RemoveButtonBinding(_Type, _ID)
    if not self.BuildingButtons.Bindings[_Type] then
        self.BuildingButtons.Bindings[_Type] = {};
    end
    for i= #self.BuildingButtons.Bindings[_Type], 1, -1 do
        if self.BuildingButtons.Bindings[_Type][i].ID == _ID then
            table.remove(self.BuildingButtons.Bindings[_Type], i);
        end
    end
end

function ModuleBuildingButtons.Local:BindButtons(_ID)
    if _ID == nil or _ID == 0 or (Logic.IsBuilding(_ID) == 0 and not Logic.IsWall(_ID)) then
        return self:UnbindButtons();
    end
    local Name = Logic.GetEntityName(_ID);
    local Type = Logic.GetEntityType(_ID);

    local WidgetsForOverride = self:GetButtonsForOverwrite(_ID, 6);
    local ButtonOverride = {};
    -- Add buttons for named entity
    if self.BuildingButtons.Bindings[Name] and #self.BuildingButtons.Bindings[Name] > 0 then
        for i= 1, #self.BuildingButtons.Bindings[Name] do
            table.insert(ButtonOverride, self.BuildingButtons.Bindings[Name][i]);
        end
    end
    -- Add buttons for named entity
    if self.BuildingButtons.Bindings[Type] and #self.BuildingButtons.Bindings[Type] > 0 then
        for i= 1, #self.BuildingButtons.Bindings[Type] do
            table.insert(ButtonOverride, self.BuildingButtons.Bindings[Type][i]);
        end
    end
    -- Add buttons for named entity
    if self.BuildingButtons.Bindings[0] and #self.BuildingButtons.Bindings[0] > 0 then
        for i= 1, #self.BuildingButtons.Bindings[0] do
            table.insert(ButtonOverride, self.BuildingButtons.Bindings[0][i]);
        end
    end

    -- Place first six buttons (if present)
    for i= 1, #ButtonOverride do
        if i > 6 then
            break;
        end
        local ButtonName = WidgetsForOverride[i];
        self.BuildingButtons.Configuration[ButtonName].Bind = ButtonOverride[i];
        XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/" ..ButtonName, 1);
        XGUIEng.DisableButton("/InGame/Root/Normal/BuildingButtons/" ..ButtonName, 0);
        local X = ButtonOverride[i].Position[1];
        local Y = ButtonOverride[i].Position[2];
        if not X or not Y then
            local AnchorPosition = {12, 296};
            X = AnchorPosition[1] + (64 * (i-1));
            Y = AnchorPosition[2];
        end
        XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/" ..ButtonName, X, Y);
    end
end

function ModuleBuildingButtons.Local:UnbindButtons()
    for k, v in pairs(self.BuildingButtons.Configuration) do
        local Position = self.BuildingButtons.Configuration[k].OriginalPosition;
        if Position then
            XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/" ..k, Position[1], Position[2]);
        end
        self.BuildingButtons.Configuration[k].Bind = nil;
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleBuildingButtons);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Ermöglicht es zusätzliche Buttons im Gebäudemenü platzieren.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(0) Anzeigesteuerung</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field UpgradeStarted     Ein Ausbau wurde gestartet. (Parameter: EntityID, PlayerID)
-- @field UpgradeCanceled    Ein Ausbau wurde abgebrochen. (Parameter: EntityID, PlayerID)
-- @field FestivalStarted    Ein Fest wurde gestartet. (Parameter: PlayerID)
-- @field SermonStarted      Eine Predigt wurde gestartet. (Parameter: PlayerID)
-- @field TheatrePlayStarted Ein Schauspiel wurde abgebrochen. (Parameter: EntityID, PlayerID)
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Fügt einen allgemeinen Gebäudeschalter an der Position hinzu.
--
-- Einem Gebäude können maximal 6 Buttons zugewiesen werden! Auf diese Weise
-- hinzugefügte Buttons sind prinzipiell immer sichtbar, abhängig von ihrer
-- Update-Funktion.
--
-- Die Position wird lokal zur linken oberen Ecke des Fensters angegeben.
--
-- @param[type=number]   _X       X-Position des Button
-- @param[type=number]   _Y       Y-Position des Button
-- @param[type=function] _Action  Funktion für die Aktion beim Klicken
-- @param[type=function] _Tooltip Funktion für die angezeigte Beschreibung
-- @param[type=function] _Update  Funktion für Anzeige und Verfügbarkeit
-- @return[type=number] ID des Bindung
-- @within Anwenderfunktionen
--
-- @usage
-- SpecialButtonID = API.AddBuildingButton(
--     -- Position (X, Y)
--     230, 180,
--     -- Aktion
--     function(_WidgetID, _BuildingID)
--         GUI.AddNote("Hier passiert etwas!");
--     end,
--     -- Tooltip
--     function(_WidgetID, _BuildingID)
--         -- Es MUSS ein Kostentooltip verwendet werden.
--         API.SetTooltipCosts("Beschreibung", "Das ist die Beschreibung!");
--     end,
--     -- Update
--     function(_WidgetID, _BuildingID)
--         -- Ausblenden, wenn noch in Bau
--         if Logic.IsConstructionComplete(_BuildingID) == 0 then
--             XGUIEng.ShowWidget(_WidgetID, 0);
--             return;
--         end
--         -- Deaktivieren, wenn ausgebaut wird.
--         if Logic.IsBuildingBeingUpgraded(_BuildingID) then
--             XGUIEng.DisableButton(_WidgetID, 1);
--         end
--         SetIcon(_WidgetID, {1, 1});
--     end
-- );
--
function API.AddBuildingButtonAtPosition(_X, _Y, _Action, _Tooltip, _Update)
    return ModuleBuildingButtons.Local:AddButtonBinding(0, _X, _Y, _Action, _Tooltip, _Update);
end

---
-- Fügt einen allgemeinen Gebäudeschalter hinzu.
--
-- Einem Gebäude können maximal 6 Buttons zugewiesen werden! Auf diese Weise
-- hinzugefügte Buttons sind prinzipiell immer sichtbar, abhängig von ihrer
-- Update-Funktion.
--
-- @param[type=function] _Action  Funktion für die Aktion beim Klicken
-- @param[type=function] _Tooltip Funktion für die angezeigte Beschreibung
-- @param[type=function] _Update  Funktion für Anzeige und Verfügbarkeit
-- @return[type=number] ID des Bindung
-- @within Anwenderfunktionen
--
-- @usage
-- SpecialButtonID = API.AddBuildingButton(
--     -- Aktion
--     function(_WidgetID, _BuildingID)
--         GUI.AddNote("Hier passiert etwas!");
--     end,
--     -- Tooltip
--     function(_WidgetID, _BuildingID)
--         -- Es MUSS ein Kostentooltip verwendet werden.
--         API.SetTooltipCosts("Beschreibung", "Das ist die Beschreibung!");
--     end,
--     -- Update
--     function(_WidgetID, _BuildingID)
--         -- Ausblenden, wenn noch in Bau
--         if Logic.IsConstructionComplete(_BuildingID) == 0 then
--             XGUIEng.ShowWidget(_WidgetID, 0);
--             return;
--         end
--         -- Deaktivieren, wenn ausgebaut wird.
--         if Logic.IsBuildingBeingUpgraded(_BuildingID) then
--             XGUIEng.DisableButton(_WidgetID, 1);
--         end
--         SetIcon(_WidgetID, {1, 1});
--     end
-- );
--
function API.AddBuildingButton(_Action, _Tooltip, _Update)
    return API.AddBuildingButtonAtPosition(nil, nil, _Action, _Tooltip, _Update);
end

---
-- Fügt einen Gebäudeschalter für den Entity-Typ hinzu.
--
-- Einem Gebäude können maximal 6 Buttons zugewiesen werden! Auf diese Weise
-- hinzugefügte Buttons sind prinzipiell immer sichtbar, abhängig von ihrer
-- Update-Funktion. Wenn ein Typ einen Button zugewiesen bekommt, werden alle 
-- allgemeinen Buttons für den Typ ignoriert.
--
-- @param[type=number]   _Type    Typ des Gebäudes
-- @param[type=number]   _X       X-Position des Button
-- @param[type=number]   _Y       Y-Position des Button
-- @param[type=function] _Action  Funktion für die Aktion beim Klicken
-- @param[type=function] _Tooltip Funktion für die angezeigte Beschreibung
-- @param[type=function] _Update  Funktion für Anzeige und Verfügbarkeit
-- @return[type=number] ID des Bindung
-- @within Anwenderfunktionen
-- @see API.AddBuildingButton
--
function API.AddBuildingButtonByTypeAtPosition(_Type, _X, _Y, _Action, _Tooltip, _Update)
    return ModuleBuildingButtons.Local:AddButtonBinding(_Type, _X, _Y, _Action, _Tooltip, _Update);
end

---
-- Fügt einen Gebäudeschalter für den Entity-Typ hinzu.
--
-- Einem Gebäude können maximal 6 Buttons zugewiesen werden! Auf diese Weise
-- hinzugefügte Buttons sind prinzipiell immer sichtbar, abhängig von ihrer
-- Update-Funktion. Wenn ein Typ einen Button zugewiesen bekommt, werden alle 
-- allgemeinen Buttons für den Typ ignoriert.
--
-- @param[type=number]   _Type    Typ des Gebäudes
-- @param[type=function] _Action  Funktion für die Aktion beim Klicken
-- @param[type=function] _Tooltip Funktion für die angezeigte Beschreibung
-- @param[type=function] _Update  Funktion für Anzeige und Verfügbarkeit
-- @return[type=number] ID des Bindung
-- @within Anwenderfunktionen
-- @see API.AddBuildingButton
--
function API.AddBuildingButtonByType(_Type, _Action, _Tooltip, _Update)
    return API.AddBuildingButtonByTypeAtPosition(_Type, nil, nil, _Action, _Tooltip, _Update);
end

---
-- Fügt einen Gebäudeschalter für das Entity hinzu.
--
-- Einem Gebäude können maximal 6 Buttons zugewiesen werden! Auf diese Weise
-- hinzugefügte Buttons sind prinzipiell immer sichtbar, abhängig von ihrer
-- Update-Funktion. Wenn ein Entity einen Button zugewiesen bekommt, werden
-- alle allgemeinen Buttons und alle Buttons für Typen für das Entity ignoriert.
--
-- @param[type=function] _ScriptName Scriptname des Entity
-- @param[type=number]   _X          X-Position des Button
-- @param[type=number]   _Y          Y-Position des Button
-- @param[type=function] _Action     Funktion für die Aktion beim Klicken
-- @param[type=function] _Tooltip    Funktion für die angezeigte Beschreibung
-- @param[type=function] _Update     Funktion für Anzeige und Verfügbarkeit
-- @return[type=number] ID des Bindung
-- @within Anwenderfunktionen
-- @see API.AddBuildingButton
--
function API.AddBuildingButtonByEntityAtPosition(_ScriptName, _X, _Y, _Action, _Tooltip, _Update)
    return ModuleBuildingButtons.Local:AddButtonBinding(_ScriptName, _X, _Y, _Action, _Tooltip, _Update);
end

---
-- Fügt einen Gebäudeschalter für das Entity hinzu.
--
-- Einem Gebäude können maximal 6 Buttons zugewiesen werden! Auf diese Weise
-- hinzugefügte Buttons sind prinzipiell immer sichtbar, abhängig von ihrer
-- Update-Funktion. Wenn ein Entity einen Button zugewiesen bekommt, werden
-- alle allgemeinen Buttons und alle Buttons für Typen für das Entity ignoriert.
--
-- @param[type=function] _ScriptName Scriptname des Entity
-- @param[type=function] _Action     Funktion für die Aktion beim Klicken
-- @param[type=function] _Tooltip    Funktion für die angezeigte Beschreibung
-- @param[type=function] _Update     Funktion für Anzeige und Verfügbarkeit
-- @return[type=number] ID des Bindung
-- @within Anwenderfunktionen
-- @see API.AddBuildingButton
--
function API.AddBuildingButtonByEntity(_ScriptName, _Action, _Tooltip, _Update)
    return API.AddBuildingButtonByEntityAtPosition(_ScriptName, nil, nil, _Action, _Tooltip, _Update);
end

---
-- Entfernt einen allgemeinen Gebäudeschalter.
--
-- @param[type=number] _ID ID des Bindung
-- @within Anwenderfunktionen
-- @usage
-- API.DropBuildingButton(SpecialButtonID);
--
function API.DropBuildingButton(_ID)
    return ModuleBuildingButtons.Local:RemoveButtonBinding(0, _ID);
end

---
-- Entfernt einen Gebäudeschalter vom Gebäudetypen.
--
-- @param[type=number] _Type Typ des Gebäudes
-- @param[type=number] _ID   ID des Bindung
-- @within Anwenderfunktionen
-- @usage
-- API.DropBuildingButtonFromType(Entities.B_Bakery, SpecialButtonID);
--
function API.DropBuildingButtonFromType(_Type, _ID)
    return ModuleBuildingButtons.Local:RemoveButtonBinding(_Type, _ID);
end

---
-- Entfernt einen Gebäudeschalter vom benannten Gebäude.
--
-- @param[type=string] _ScriptName Skriptname des Entity
-- @param[type=number] _ID         ID des Bindung
-- @within Anwenderfunktionen
-- @usage
-- API.DropBuildingButtonFromEntity("Bakery", SpecialButtonID);
--
function API.DropBuildingButtonFromEntity(_ScriptName, _ID)
    return ModuleBuildingButtons.Local:RemoveButtonBinding(_ScriptName, _ID);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleCamera = {
    Properties = {
        Name = "ModuleCamera",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {},
    Local = {
        ExtendedZoomHotKeyID = 0,
        ExtendedZoomAllowed = true,
    },

    Shared = {
        Text = {
            Shortcut = {
                Hotkey = {
                    de = "STRG + UMSCHALT + K",
                    en = "CTRL + SHIFT + K",
                    fr = "CTRL + SHIFT + K",
                },
                Description = {
                    de = "Alternativen Zoom ein/aus",
                    en = "Alternative zoom on/off",
                    fr = "Zoom alternatif On/Off",
                }
            }
        },
    };
}

-- -------------------------------------------------------------------------- --
-- Global Script

function ModuleCamera.Global:OnGameStart()
end

function ModuleCamera.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --
-- Local Script

function ModuleCamera.Local:OnGameStart()
    self:RegisterExtendedZoomHotkey();
    self:ActivateExtendedZoomHotkey();
end

function ModuleCamera.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.SaveGameLoaded then
        if self.ExtendedZoomActive then
            self:ActivateExtendedZoom();
        end
        self:ActivateExtendedZoomHotkey();
    end
end

function ModuleCamera.Local:SetCameraToEntity(_Entity, _Rotation, _ZoomFactor)
    local pos = GetPosition(_Entity);
    local rotation = (_Rotation or -45);
    local zoomFactor = (_ZoomFactor or 0.5);
    Camera.RTS_SetLookAtPosition(pos.X, pos.Y);
    Camera.RTS_SetRotationAngle(rotation);
    Camera.RTS_SetZoomFactor(zoomFactor);
end

-- Utility Functions -------------------------------------------------------- --

function ModuleCamera.Local:RegisterExtendedZoomHotkey()
    self:UnregisterExtendedZoomHotkey();
    if self.ExtendedZoomHotKeyID == 0 then
        self.ExtendedZoomHotKeyID = API.AddShortcutEntry(
            ModuleCamera.Shared.Text.Shortcut.Hotkey,
            ModuleCamera.Shared.Text.Shortcut.Description
        );
    end
end

function ModuleCamera.Local:UnregisterExtendedZoomHotkey()
    if self.ExtendedZoomHotKeyID ~= 0 then
        API.RemoveShortcutEntry(self.ExtendedZoomHotKeyID);
        self.ExtendedZoomHotKeyID = 0;
    end
end

function ModuleCamera.Local:ActivateExtendedZoomHotkey()
    Input.KeyBindDown(
        Keys.ModifierControl + Keys.ModifierShift + Keys.K,
        "ModuleCamera.Local:ToggleExtendedZoom()",
        2
    );
end

function ModuleCamera.Local:ToggleExtendedZoom()
    if self.ExtendedZoomAllowed then
        if self.ExtendedZoomActive then
            self:DeactivateExtendedZoom();
        else
            self:ActivateExtendedZoom();
        end
    end
end

function ModuleCamera.Local:ActivateExtendedZoom()
    self.ExtendedZoomActive = true;
    Camera.RTS_SetZoomFactorMax(0.870001);
    Camera.RTS_SetZoomFactor(0.870000);
    Camera.RTS_SetZoomFactorMin(0.099999);
end

function ModuleCamera.Local:DeactivateExtendedZoom()
    self.ExtendedZoomActive = false;
    Camera.RTS_SetZoomFactor(0.500000);
    Camera.RTS_SetZoomFactorMax(0.500001);
    Camera.RTS_SetZoomFactorMin(0.099999);
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleCamera);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Stellt Funktionen für die RTS-Camera bereit.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- <li><a href="modules.QSB_1_GuiEffects.QSB_1_GuiEffects.html">(1) Anzeigeeffekte</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Aktiviert oder deaktiviert den erweiterten Zoom.
--
-- Der maximale Zoom wird erweitert. Dabei entsteht eine fast völlige 
-- Draufsicht. Dies kann nütztlich sein, wenn der Spieler ein größeres 
-- Sichtfeld benötigt.
--
-- @param[type=boolean] _Flag Erweiterter Zoom gestattet
-- @within Anwenderfunktionen
--
-- @usage
-- -- Erweitere Kamera einschalten
-- API.AllowExtendedZoom(true);
-- -- Erweitere Kamera abschalten
-- API.AllowExtendedZoom(false);
--
function API.AllowExtendedZoom(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.AllowExtendedZoom(%s)]],
            tostring(_Flag)
        ))
        return;
    end
    ModuleCamera.Local.ExtendedZoomAllowed = _Flag == true;
    if _Flag == true then
        ModuleCamera.Local:RegisterExtendedZoomHotkey();
    else
        ModuleCamera.Local:UnregisterExtendedZoomHotkey();
        ModuleCamera.Local:DeactivateExtendedZoom();
    end
end

---
-- Fokusiert die Kamera auf dem Primärritter des Spielers.
--
-- @param[type=number] _Player Partei
-- @param[type=number] _Rotation Kamerawinkel
-- @param[type=number] _ZoomFactor Zoomfaktor
-- @within Anwenderfunktionen
--
-- @usage
-- -- Zentriert die Kamera über den Helden von Spieler 3.
-- API.FocusCameraOnKnight(3, 90, 0.5);
--
function API.FocusCameraOnKnight(_Player, _Rotation, _ZoomFactor)
    API.FocusCameraOnEntity(Logic.GetKnightID(_Player), _Rotation, _ZoomFactor)
end

---
-- Fokusiert die Kamera auf dem Entity.
--
-- @param _Entity Entity (Skriptname oder ID)
-- @param[type=number] _Rotation Kamerawinkel
-- @param[type=number] _ZoomFactor Zoomfaktor
-- @within Anwenderfunktionen
--
-- @usage
-- -- Zentriert die Kamera über dem Entity mit dem Skriptnamen "HansWurst".
-- API.FocusCameraOnKnight("HansWurst", -45, 0.2);
--
function API.FocusCameraOnEntity(_Entity, _Rotation, _ZoomFactor)
    if not GUI then
        local Subject = (type(_Entity) ~= "string" and _Entity) or ("'" .._Entity.. "'");
        Logic.ExecuteInLuaLocalState("API.FocusCameraOnEntity(" ..Subject.. ", " ..tostring(_Rotation).. ", " ..tostring(_ZoomFactor).. ")");
        return;
    end
    if type(_Rotation) ~= "number" then
        error("API.FocusCameraOnEntity: Rotation is wrong!");
        return;
    end
    if type(_ZoomFactor) ~= "number" then
        error("API.FocusCameraOnEntity: Zoom factor is wrong!");
        return;
    end
    if not IsExisting(_Entity) then
        error("API.FocusCameraOnEntity: Entity " ..tostring(_Entity).." does not exist!");
        return;
    end
    return ModuleCamera.Local:SetCameraToEntity(_Entity, _Rotation, _ZoomFactor);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleBehaviorCollection = {
    Properties = {
        Name = "ModuleBehaviorCollection",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        SoldierKillsCounter = {},
        VictoryWithPartyEntities = {},
    },
    Local = {},

    Shared = {},
};

-- Global ------------------------------------------------------------------- --

function ModuleBehaviorCollection.Global:OnGameStart()
    for i= 0, 8 do
        self.SoldierKillsCounter[i] = {};
    end
    self:OverrideIsObjectiveCompleted();
    self:OverrideOnQuestTriggered();
end

function ModuleBehaviorCollection.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.ThiefInfiltratedBuilding then
        self:OnThiefInfiltratedBuilding(arg[1], arg[2], arg[3], arg[4]);
    elseif _ID == QSB.ScriptEvents.ThiefDeliverEarnings then
        self:OnThiefDeliverEarnings(arg[1], arg[2], arg[3], arg[4], arg[5]);
    elseif _ID == QSB.ScriptEvents.EntityKilled then
        self:OnEntityKilled(arg[1], arg[2], arg[3], arg[4]);
    end
end

function ModuleBehaviorCollection.Global:OverrideOnQuestTriggered()
    QuestTemplate.Trigger_Orig_QSB_NewBehaviors = QuestTemplate.Trigger;
    QuestTemplate.Trigger = function(self)
        for b= 1, #self.Objectives, 1 do
            if self.Objectives[b] then
                -- Special Objective.DestroyEntities for spawners
                if self.Objectives[b].Type == Objective.DestroyEntities and self.Objectives[b].Data[1] == 3 then
                    -- Refill spawner once at quest start
                    if self.Objectives[b].Data[5] ~= true then
                        local SpawnPoints = self.Objectives[b].Data[2][0];
                        local SpawnAmount = self.Objectives[b].Data[3];
                        -- Delete remaining entities
                        for i=1, SpawnPoints, 1 do
                            local ID = GetID(self.Objectives[b].Data[2][i]);
                            local SpawnedEntities = {Logic.GetSpawnedEntities(ID)};
                            for j= 1, #SpawnedEntities, 1 do
                                DestroyEntity(SpawnedEntities[j]);
                            end
                        end
                        -- Spawn new entities and distribute them equally over
                        -- all spawner entities
                        while (SpawnAmount > 0) do
                            for i=1, SpawnPoints, 1 do
                                if SpawnAmount < 1 then
                                    break;
                                end
                                local ID = GetID(self.Objectives[b].Data[2][i]);
                                Logic.RespawnResourceEntity_Spawn(ID);
                                SpawnAmount = SpawnAmount -1;
                            end
                        end
                        -- Set icon
                        local CategoryDefinigEntity = Logic.GetSpawnedEntities(self.Objectives[b].Data[2][1]);
                        if not self.Objectives[b].Data[6] then
                            self.Objectives[b].Data[6] = {7, 12};
                            if Logic.IsEntityInCategory(CategoryDefinigEntity, EntityCategories.AttackableAnimal) == 1 then
                                self.Objectives[b].Data[6] = {13, 8};
                            end
                        end
                        self.Objectives[b].Data[5] = true;
                    end
                end
            end
        end
        self:Trigger_Orig_QSB_NewBehaviors();
    end
end

function ModuleBehaviorCollection.Global:OverrideIsObjectiveCompleted()
    QuestTemplate.IsObjectiveCompleted_Orig_QSB_NewBehaviors = QuestTemplate.IsObjectiveCompleted;
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        local objectiveType = objective.Type;
        if objective.Completed ~= nil then
            if objectiveType == Objective.DestroyEntities and objective.Data[1] == 3 then
                objective.Data[5] = nil;
            end
            return objective.Completed;
        end

        if objectiveType == Objective.DestroyEntities then
            if objective.Data[1] == 3 then
                objective.Completed = self:AreSpawnedQuestEntitiesDestroyed(objective);
            else
                return self:IsObjectiveCompleted_Orig_QSB_NewBehaviors(objective);
            end
        else
            return self:IsObjectiveCompleted_Orig_QSB_NewBehaviors(objective);
        end
    end

    QuestTemplate.AreSpawnedQuestEntitiesDestroyed = function(self, _Objective)
        if _Objective.Data[1] == 3 then
            local AllSpawnedEntities = {};
            for i=1, _Objective.Data[2][0], 1 do
                local ID = GetID(_Objective.Data[2][i]);
                AllSpawnedEntities = Array_Append(
                    AllSpawnedEntities,
                    {Logic.GetSpawnedEntities(ID)}
                );
            end
            if #AllSpawnedEntities == 0 then
                return true;
            end
        end
    end
end

function ModuleBehaviorCollection.Global:GetPossibleModels()
    local Data = {};
    -- Add generic models
    for k, v in pairs(Models) do
        if  not string.find(k, "Animals_")
        and not string.find(k, "MissionMap_")
        and not string.find(k, "R_Fish")
        and not string.find(k, "^[GEHUVXYZgt][ADSTfm]*")
        and not string.find(string.lower(k), "goods|tools_") then
            table.insert(Data, k);
        end
    end
    -- Add specific models
    table.insert(Data, "Effects_Dust01");
    table.insert(Data, "Effects_E_DestructionSmoke");
    table.insert(Data, "Effects_E_DustLarge");
    table.insert(Data, "Effects_E_DustSmall");
    table.insert(Data, "Effects_E_Firebreath");
    table.insert(Data, "Effects_E_Fireworks01");
    table.insert(Data, "Effects_E_Flies01");
    table.insert(Data, "Effects_E_Grasshopper03");
    table.insert(Data, "Effects_E_HealingFX");
    table.insert(Data, "Effects_E_Knight_Chivalry_Aura");
    table.insert(Data, "Effects_E_Knight_Plunder_Aura");
    table.insert(Data, "Effects_E_Knight_Song_Aura");
    table.insert(Data, "Effects_E_Knight_Trader_Aura");
    table.insert(Data, "Effects_E_Knight_Wisdom_Aura");
    table.insert(Data, "Effects_E_KnightFight");
    table.insert(Data, "Effects_E_NA_BlowingSand01");
    table.insert(Data, "Effects_E_NE_BlowingSnow01");
    table.insert(Data, "Effects_E_Oillamp");
    table.insert(Data, "Effects_E_SickBuilding");
    table.insert(Data, "Effects_E_Splash");
    table.insert(Data, "Effects_E_Torch");
    table.insert(Data, "Effects_Fire01");
    table.insert(Data, "Effects_FX_Lantern");
    table.insert(Data, "Effects_FX_SmokeBIG");
    table.insert(Data, "Effects_XF_BuildingSmoke");
    table.insert(Data, "Effects_XF_BuildingSmokeLarge");
    table.insert(Data, "Effects_XF_BuildingSmokeMedium");
    table.insert(Data, "Effects_XF_HouseFire");
    table.insert(Data, "Effects_XF_HouseFireLo");
    table.insert(Data, "Effects_XF_HouseFireMedium");
    table.insert(Data, "Effects_XF_HouseFireSmall");
    if g_GameExtraNo > 0 then
        table.insert(Data, "Effects_E_KhanaTemple_Fire");
        table.insert(Data, "Effects_E_Knight_Saraya_Aura");
    end
    -- Sort list
    table.sort(Data);
    return Data;
end

function ModuleBehaviorCollection.Global:OnThiefInfiltratedBuilding(_ThiefID, _PlayerID, _BuildingID, _BuildingPlayerID)
    for i=1, Quests[0] do
        if Quests[i] and Quests[i].State == QuestState.Active and Quests[i].ReceivingPlayer == _PlayerID then
            for j=1, Quests[i].Objectives[0] do
                if Quests[i].Objectives[j].Type == Objective.Custom2 then
                    if Quests[i].Objectives[j].Data[1].Name == "Goal_SpyOnBuilding" then
                        if GetID(Quests[i].Objectives[j].Data[1].Building) == _BuildingID then
                            Quests[i].Objectives[j].Data[1].Infiltrated = true;
                            if Quests[i].Objectives[j].Data[1].Delete then
                                DestroyEntity(_ThiefID);
                            end
                        end

                    elseif Quests[i].Objectives[j].Data[1].Name == "Goal_StealFromBuilding" then
                        local found;
                        local isCathedral = Logic.IsEntityInCategory(_BuildingID, EntityCategories.Cathedrals) == 1;
                        local isWarehouse = Logic.GetEntityType(_BuildingID) == Entities.B_StoreHouse;
                        if isWarehouse or isCathedral then
                            Quests[i].Objectives[j].Data[1].SuccessfullyStohlen = true;
                        else
                            for k=1, #Quests[i].Objectives[j].Data[1].RobberList do
                                local stohlen = Quests[i].Objectives[j].Data[1].RobberList[k];
                                if stohlen[1] == _BuildingID and stohlen[2] == _ThiefID then
                                    found = true;
                                    break;
                                end
                            end
                        end
                        if not found then
                            table.insert(Quests[i].Objectives[j].Data[1].RobberList, {_BuildingID, _ThiefID});
                        end
                    end
                end
            end
        end
    end
end

function ModuleBehaviorCollection.Global:OnThiefDeliverEarnings(_ThiefID, _PlayerID, _BuildingID, _BuildingPlayerID, _GoldAmount)
    for i=1, Quests[0] do
        if Quests[i] and Quests[i].State == QuestState.Active and Quests[i].ReceivingPlayer == _PlayerID then
            for j=1, Quests[i].Objectives[0] do
                if Quests[i].Objectives[j].Type == Objective.Custom2 then
                    if Quests[i].Objectives[j].Data[1].Name == "Goal_StealFromBuilding" then
                        for k=1, #Quests[i].Objectives[j].Data[1].RobberList do
                            local stohlen = Quests[i].Objectives[j].Data[1].RobberList[k];
                            if stohlen[1] == GetID(Quests[i].Objectives[j].Data[1].Building) and stohlen[2] == _ThiefID then
                                Quests[i].Objectives[j].Data[1].SuccessfullyStohlen = true;
                                break;
                            end
                        end

                    elseif Quests[i].Objectives[j].Data[1].Name == "Goal_StealGold" then
                        local CurrentObjective = Quests[i].Objectives[j].Data[1];
                        if CurrentObjective.Target == -1 or CurrentObjective.Target == _BuildingPlayerID then
                            Quests[i].Objectives[j].Data[1].StohlenGold = Quests[i].Objectives[j].Data[1].StohlenGold + _GoldAmount;
                            if CurrentObjective.Printout then
                                API.Note(string.format(
                                    "%d/%d %s",
                                    CurrentObjective.StohlenGold,
                                    CurrentObjective.Amount,
                                    API.Localize({de = "Talern gestohlen",en = "gold stolen",})
                                ));
                            end
                        end
                    end
                end
            end
        end
    end
end

function ModuleBehaviorCollection.Global:OnEntityKilled(_KilledEntityID, _KilledPlayerID, _KillerEntityID, _KillerPlayerID)
    if _KilledPlayerID ~= 0 and _KillerPlayerID ~= 0 then
        self.SoldierKillsCounter[_KillerPlayerID][_KilledPlayerID] = self.SoldierKillsCounter[_KillerPlayerID][_KilledPlayerID] or 0
        if Logic.IsEntityInCategory(_KilledEntityID, EntityCategories.Soldier) == 1 then
            self.SoldierKillsCounter[_KillerPlayerID][_KilledPlayerID] = self.SoldierKillsCounter[_KillerPlayerID][_KilledPlayerID] +1
        end
    end
end

function ModuleBehaviorCollection.Global:GetEnemySoldierKillsOfPlayer(_PlayerID1, _PlayerID2)
    return self.SoldierKillsCounter[_PlayerID1][_PlayerID2] or 0;
end

-- Local -------------------------------------------------------------------- --

function ModuleBehaviorCollection.Local:OnGameStart()
    self:DisplayQuestObjective();
    self:GetEntitiesOrTerritoryList();
    self:OverrideSaveQuestEntityTypes();
end

function ModuleBehaviorCollection.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

function ModuleBehaviorCollection.Local:DisplayQuestObjective()
    GUI_Interaction.DisplayQuestObjective_Orig_NewBehavior = GUI_Interaction.DisplayQuestObjective;
    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)
        local QuestIndexTemp = tonumber(_QuestIndex);
        if QuestIndexTemp then
            _QuestIndex = QuestIndexTemp;
        end
        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";
        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);

        if QuestType == Objective.DestroyEntities and Quest.Objectives[1].Data[1] == 3 then
            local QuestObjectiveContainer = QuestObjectivesPath .. "/GroupEntityType";
            local QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestDestroy");
            local EntitiesList = GUI_Interaction.GetEntitiesOrTerritoryListForQuest( Quest, QuestType );
            local EntitiesAmount = #EntitiesList;
            if not Quest.Objectives[1].Data[5] and #EntitiesList == 0 then
                EntitiesAmount = Quest.Objectives[1].Data[2][0] * Quest.Objectives[1].Data[3];
            end

            XGUIEng.ShowWidget(QuestObjectiveContainer .. "/AdditionalCaption", 0);
            XGUIEng.ShowWidget(QuestObjectiveContainer .. "/AdditionalCondition", 0);
            SetIcon(QuestObjectiveContainer .. "/Icon", Quest.Objectives[1].Data[6]);
            XGUIEng.SetText(QuestObjectiveContainer .. "/Number", "{center}" .. EntitiesAmount);

            XGUIEng.SetText(QuestObjectiveContainer .. "/Caption", "{center}" .. QuestTypeCaption);
            XGUIEng.ShowWidget(QuestObjectiveContainer, 1);
            GUI_Interaction.SetQuestTypeIcon(QuestObjectiveContainer .. "/QuestTypeIcon", _QuestIndex);
            if Quest.State == QuestState.Over then
                if Quest.Result == QuestResult.Success then
                    XGUIEng.ShowWidget(QuestObjectivesPath .. "/QuestOverSuccess", 1);
                elseif Quest.Result == QuestResult.Failure then
                    XGUIEng.ShowWidget(QuestObjectivesPath .. "/QuestOverFailure", 1);
                end
            end
            return;
        end
        GUI_Interaction.DisplayQuestObjective_Orig_NewBehavior(_QuestIndex, _MessageKey);
    end
end

function ModuleBehaviorCollection.Local:GetEntitiesOrTerritoryList()
    GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_NewBehavior = GUI_Interaction.GetEntitiesOrTerritoryListForQuest;
    GUI_Interaction.GetEntitiesOrTerritoryListForQuest = function(_Quest, _QuestType)
        local IsEntity = true;
        local EntityOrTerritoryList = {};
        if _QuestType == Objective.DestroyEntities then
            if _Quest.Objectives[1].Data and _Quest.Objectives[1].Data[1] == 3 then
                for i=1, _Quest.Objectives[1].Data[2][0], 1 do
                    local ID = GetID(_Quest.Objectives[1].Data[2][i]);
                    EntityOrTerritoryList = Array_Append(EntityOrTerritoryList, {Logic.GetSpawnedEntities(ID)});
                end
                return EntityOrTerritoryList, IsEntity;
            end
        end
        return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_NewBehavior(_Quest, _QuestType);
    end
end

function ModuleBehaviorCollection.Local:OverrideSaveQuestEntityTypes()
    GUI_Interaction.SaveQuestEntityTypes_Orig_NewBehavior = GUI_Interaction.SaveQuestEntityTypes;
    GUI_Interaction.SaveQuestEntityTypes = function(_QuestIndex)
        if g_Interaction.SavedQuestEntityTypes[_QuestIndex] ~= nil then
            return;
        end
        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        if QuestType == Objective.DestroyEntities and Quest.Objectives[1].Data[1] == 3 then
            local EntitiesList = GUI_Interaction.GetEntitiesOrTerritoryListForQuest(Quest, QuestType);
            EntitiesList[0] = #EntitiesList;
            if EntitiesList ~= nil then
                g_Interaction.SavedQuestEntityTypes[_QuestIndex] = {};
                for i = 1, EntitiesList[0], 1 do
                    if Logic.IsEntityAlive(EntitiesList[i]) then
                        local EntityType = Logic.GetEntityType(GetID(EntitiesList[i]));
                        table.insert(g_Interaction.SavedQuestEntityTypes[_QuestIndex], i, EntityType);
                    end
                end
                return;
            end
        end
        GUI_Interaction.SaveQuestEntityTypes_Orig_NewBehavior(_QuestIndex)
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleBehaviorCollection);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Dieses Modul fügt neue Behavior für den Editor hinzu.
--
-- <p><b>Vorausgesetzte Module:</b></p>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- <li><a href="modules.QSB_1_Entity.QSB_1_Entity.html">(1) Entitätensteuerung</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Die neuen Behavior für den Editor.
--
-- @set sort=true
--

-- -------------------------------------------------------------------------- --

---
-- Ein Entity muss sich zu einem Ziel bewegen und eine Distanz unterschreiten.
--
-- Optional kann das Ziel mit einem Marker markiert werden.
--
-- @param[type=string]  _ScriptName Skriptname des Entity
-- @param[type=string]  _Target     Skriptname des Ziels
-- @param[type=number]  _Distance   Entfernung
-- @param[type=boolean] _UseMarker  Ziel markieren
--
-- @within Goal
--
function Goal_MoveToPosition(...)
    return B_Goal_MoveToPosition:new(...);
end

B_Goal_MoveToPosition = {
    Name = "Goal_MoveToPosition",
    Description = {
        en = "Goal: A entity have to moved as close as the distance to another entity. The target can be marked with a static marker.",
        de = "Ziel: Ein Entity muss sich einer anderen bis auf eine bestimmte Distanz nähern. Die Lupe wird angezeigt, das Ziel kann markiert werden.",
        fr = "Objectif: une entité doit s'approcher d'une autre à une distance donnée. La loupe est affichée, la cible peut être marquée.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",   de = "Entity",         fr = "Entité" },
        { ParameterType.ScriptName, en = "Target",   de = "Ziel",           fr = "Cible" },
        { ParameterType.Number,     en = "Distance", de = "Entfernung",     fr = "Distance" },
        { ParameterType.Custom,     en = "Marker",   de = "Ziel markieren", fr = "Marquer la cible" },
    },
}

function B_Goal_MoveToPosition:GetGoalTable()
    return {Objective.Distance, self.Entity, self.Target, self.Distance, self.Marker}
end

function B_Goal_MoveToPosition:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity = _Parameter
    elseif (_Index == 1) then
        self.Target = _Parameter
    elseif (_Index == 2) then
        self.Distance = _Parameter * 1
    elseif (_Index == 3) then
        self.Marker = API.ToBoolean(_Parameter)
    end
end

function B_Goal_MoveToPosition:GetCustomData( _Index )
    local Data = {};
    if _Index == 3 then
        Data = {"true", "false"}
    end
    return Data
end

Swift:RegisterBehavior(B_Goal_MoveToPosition);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss einen bestimmten Quest abschließen.
--
-- @param[type=string] _QuestName Name des Quest
--
-- @within Goal
--
function Goal_WinQuest(...)
    return B_Goal_WinQuest:new(...);
end

B_Goal_WinQuest = {
    Name = "Goal_WinQuest",
    Description = {
        en = "Goal: The player has to win a given quest.",
        de = "Ziel: Der Spieler muss eine angegebene Quest erfolgreich abschliessen.",
        fr = "Objectif: Le joueur doit réussir une quête indiquée.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name",  de = "Questname", fr = "Nom de la quête" },
    },
}

function B_Goal_WinQuest:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_WinQuest:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Quest = _Parameter;
    end
end

function B_Goal_WinQuest:CustomFunction(_Quest)
    local quest = Quests[GetQuestID(self.Quest)];
    if quest then
        if quest.Result == QuestResult.Failure then
            return false;
        end
        if quest.Result == QuestResult.Success then
            return true;
        end
    end
    return nil;
end

function B_Goal_WinQuest:Debug(_Quest)
    if Quests[GetQuestID(self.Quest)] == nil then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Quest '"..self.Quest.."' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Goal_WinQuest);

-- -------------------------------------------------------------------------- --

---
-- Es muss eine Menge an Munition in der Kriegsmaschine erreicht werden.
--
-- <u>Relationen</u>
-- <ul>
-- <li>>= - Anzahl als Mindestmenge</li>
-- <li>< - Weniger als Anzahl</li>
-- </ul>
--
-- @param[type=string] _ScriptName  Name des Kriegsgerät
-- @param[type=string] _Relation    Mengenrelation
-- @param[type=number] _Amount      Menge an Munition
--
-- @within Goal
--
function Goal_AmmunitionAmount(...)
    return B_Goal_AmmunitionAmount:new(...);
end

B_Goal_AmmunitionAmount = {
    Name = "Goal_AmmunitionAmount",
    Description = {
        en = "Goal: Reach a smaller or bigger value than the given amount of ammunition in a war machine.",
        de = "Ziel: Über- oder unterschreite die angegebene Anzahl Munition in einem Kriegsgerät.",
        fr = "Objectif : Dépasser ou ne pas dépasser le nombre de munitions indiqué dans un engin de guerre.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname",  fr = "Nom de l'entité" },
        { ParameterType.Custom,     en = "Relation",    de = "Relation",    fr = "Relation" },
        { ParameterType.Number,     en = "Amount",      de = "Menge",       fr = "Quantité" },
    },
}

function B_Goal_AmmunitionAmount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_AmmunitionAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Scriptname = _Parameter
    elseif (_Index == 1) then
        self.bRelSmallerThan = tostring(_Parameter) == "true" or _Parameter == "<"
    elseif (_Index == 2) then
        self.Amount = _Parameter * 1
    end
end

function B_Goal_AmmunitionAmount:CustomFunction()
    local EntityID = GetID(self.Scriptname);
    if not IsExisting(EntityID) then
        return false;
    end
    local HaveAmount = Logic.GetAmmunitionAmount(EntityID);
    if ( self.bRelSmallerThan and HaveAmount < self.Amount ) or ( not self.bRelSmallerThan and HaveAmount >= self.Amount ) then
        return true;
    end
    return nil;
end

function B_Goal_AmmunitionAmount:Debug(_Quest)
    if self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Amount is negative");
        return true
    end
end

function B_Goal_AmmunitionAmount:GetCustomData( _Index )
    if _Index == 1 then
        return {"<", ">="};
    end
end

Swift:RegisterBehavior(B_Goal_AmmunitionAmount);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss mindestens den angegebenen Ruf erreichen. Der Ruf muss
-- in Prozent angegeben werden (ohne %-Zeichen).
--
-- @param[type=number] _Reputation Benötigter Ruf
--
-- @within Goal
--
function Goal_CityReputation(...)
    return B_Goal_CityReputation:new(...);
end

B_Goal_CityReputation = {
    Name = "Goal_CityReputation",
    Description = {
        en = "Goal: The reputation of the quest receivers city must at least reach the desired hight.",
        de = "Ziel: Der Ruf der Stadt des Empfängers muss mindestens so hoch sein, wie angegeben.",
        fr = "Objectif: la réputation de la ville du receveur doit être au moins aussi élevée que celle indiquée.",
    },
    Parameter = {
        { ParameterType.Number, en = "City reputation", de = "Ruf der Stadt", fr = "Réputation de la ville" },
    },
    Text = {
        de = "RUF DER STADT{cr}{cr}Hebe den Ruf der Stadt durch weise Herrschaft an!{cr}Benötigter Ruf: %d",
        en = "CITY REPUTATION{cr}{cr}Raise your reputation by fair rulership!{cr}Needed reputation: %d",
        fr = "RÉPUTATION DE LA VILLE{cr}{cr} Augmente la réputation de la ville en la gouvernant sagement!{cr}Réputation requise : %d",
    }
}

function B_Goal_CityReputation:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_CityReputation:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Reputation = _Parameter * 1;
    end
end

function B_Goal_CityReputation:CustomFunction(_Quest)
    self:SetCaption(_Quest);
    local CityReputation = Logic.GetCityReputation(_Quest.ReceivingPlayer) * 100;
    if CityReputation >= self.Reputation then
        return true;
    end
end

function B_Goal_CityReputation:SetCaption(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local Text = string.format(API.Localize(self.Text), self.Reputation);
        Swift.Quest:ChangeCustomQuestCaptionText(Text .."%", _Quest);
    end
end

function B_Goal_CityReputation:GetIcon()
    return {5, 14};
end

function B_Goal_CityReputation:Debug(_Quest)
    if type(self.Reputation) ~= "number" or self.Reputation < 0 or self.Reputation > 100 then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Reputation must be between 0 and 100!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Goal_CityReputation);

-- -------------------------------------------------------------------------- --

---
-- Eine Menge an Entities des angegebenen Spawnpoint muss zerstört werden.
--
-- <b>Hinweis</b>: Eignet sich vor allem für Raubtiere!
--
-- Wenn die angegebene Anzahl zu Beginn des Quest nicht mit der Anzahl an
-- bereits gespawnten Entities übereinstimmt, wird dies automatisch korrigiert.
-- (Neue Entities gespawnt bzw. überschüssige gelöscht)
--
-- Wenn _Prefixed gesetzt ist, wird anstatt des Namen Entities mit einer
-- fortlaufenden Nummer gesucht, welche mit dem Namen beginnen. Bei der
-- ersten Nummer, zu der kein Entity existiert, wird abgebrochen.
--
-- @param[type=string] _SpawnPoint Skriptname des Spawnpoint
-- @param[type=number] _Amount     Menge zu zerstörender Entities
-- @param[type=number] _Prefixed   Skriptname ist Präfix
--
-- @within Goal
--
function Goal_DestroySpawnedEntities(...)
    return B_Goal_DestroySpawnedEntities:new(...);
end

B_Goal_DestroySpawnedEntities = {
    Name = "Goal_DestroySpawnedEntities",
    Description = {
        en = "Goal: Destroy all entities spawned at the spawnpoint.",
        de = "Ziel: Zerstöre alle Entitäten, die bei dem Spawnpoint erzeugt wurde.",
        fr = "Objectif: Détruire toutes les entités créées au point d'apparition.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Spawnpoint",       de = "Spawnpoint",         fr = "Point d'émergence" },
        { ParameterType.Number,     en = "Amount",           de = "Menge",              fr = "Quantité" },
        { ParameterType.Custom,     en = "Name is prefixed", de = "Name ist Präfix",    fr = "Le nom est un préfixe" },
    },
};

function B_Goal_DestroySpawnedEntities:GetGoalTable()
    -- Zur Erzeugungszeit Spawnpoint konvertieren
    -- Hinweis: Entities müssen zu diesem Zeitpunkt existieren und müssen
    -- Spawnpoints sein!
    if self.Prefixed then
        local Parameter = table.remove(self.SpawnPoint);
        local i = 1;
        while (IsExisting(Parameter .. i)) do
            table.insert(self.SpawnPoint, Parameter .. i);
            i = i +1;
        end
        -- Hard Error!
        assert(#self.SpawnPoint > 0, "No spawnpoints found!");
    end
    -- Behavior zurückgeben
    return {Objective.DestroyEntities, 3, self.SpawnPoint, self.Amount};
end

function B_Goal_DestroySpawnedEntities:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SpawnPoint = {_Parameter};
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or "false";
        self.Prefixed = API.ToBoolean(_Parameter);
    end
end

function B_Goal_DestroySpawnedEntities:GetMsgKey()
    local ID = GetID(self.SpawnPoint[1]);
    if ID ~= 0 then
        local TypeName = Logic.GetEntityTypeName(Logic.GetEntityType(ID));
        if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
            return "Quest_Destroy_Leader";
        elseif TypeName:find("Bear") or TypeName:find("Lion") or TypeName:find("Tiger") or TypeName:find("Wolf") then
            return "Quest_DestroyEntities_Predators";
        elseif TypeName:find("Military") or TypeName:find("Cart") then
            return "Quest_DestroyEntities_Unit";
        end
    end
    return "Quest_DestroyEntities";
end

function B_Goal_DestroySpawnedEntities:GetCustomData(_Index)
    if _Index == 2 then
        return {"false", "true"};
    end
end

Swift:RegisterBehavior(B_Goal_DestroySpawnedEntities);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss eine bestimmte Menge Gold mit Dieben stehlen.
--
-- Dabei ist es egal von welchem Spieler. Diebe können Gold nur aus
-- Stadtgebäude stehlen und nur von feindlichen Spielern.
--
-- <b>Hinweis</b>: Es können nur Stadtgebäude mit einem Dieb um Gold
-- erleichtert werden!
--
-- @param[type=number]  _Amount         Menge an Gold
-- @param[type=number]  _TargetPlayerID Zielspieler (-1 für alle)
-- @param[type=boolean] _CheatEarnings  Einnahmen generieren
-- @param[type=boolean] _ShowProgress   Fortschritt ausgeben
--
-- @within Goal
--
function Goal_StealGold(...)
    return B_Goal_StealGold:new(...)
end

B_Goal_StealGold = {
    Name = "Goal_StealGold",
    Description = {
        en = "Goal: Steal an explicit amount of gold from a players or any players city buildings.",
        de = "Ziel: Diebe sollen eine bestimmte Menge Gold aus feindlichen Stadtgebäuden stehlen.",
        fr = "Objectif: les voleurs doivent dérober une certaine quantité d'or dans les bâtiments urbains ennemis.",
    },
    Parameter = {
        { ParameterType.Number,   en = "Amount on Gold", de = "Zu stehlende Menge",             fr = "Quantité à voler" },
        { ParameterType.Custom,   en = "Target player",  de = "Spieler von dem gestohlen wird", fr = "Joueur à qui l'on vole" },
        { ParameterType.Custom,   en = "Cheat earnings", de = "Einnahmen generieren",           fr = "Générer des revenus" },
        { ParameterType.Custom,   en = "Print progress", de = "Fortschritt ausgeben",           fr = "Afficher les progrès" },
    },
}

function B_Goal_StealGold:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_StealGold:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 1) then
        local PlayerID = tonumber(_Parameter) or -1;
        self.Target = PlayerID * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or "false"
        self.CheatEarnings = API.ToBoolean(_Parameter);
    elseif (_Index == 3) then
        _Parameter = _Parameter or "true"
        self.Printout = API.ToBoolean(_Parameter);
    end
    self.StohlenGold = 0;
end

function B_Goal_StealGold:GetCustomData(_Index)
    if _Index == 1 then
        return { "-", 1, 2, 3, 4, 5, 6, 7, 8 };
    elseif _Index == 2 then
        return { "true", "false" };
    end
end

function B_Goal_StealGold:SetDescriptionOverwrite(_Quest)
    local TargetPlayerName = API.Localize({
        de = " anderen Spielern ",
        en = " different parties ",
        fr = " d'autres joueurs ",
    });

    if self.Target ~= -1 then
        TargetPlayerName = API.GetPlayerName(self.Target);
        if TargetPlayerName == nil or TargetPlayerName == "" then
            TargetPlayerName = " PLAYER_NAME_MISSING ";
        end
    end

    -- Cheat earnings
    if self.CheatEarnings then
        local PlayerIDs = {self.Target};
        if self.Target == -1 then
            PlayerIDs = {1, 2, 3, 4, 5, 6, 7, 8};
        end
        for i= 1, #PlayerIDs, 1 do
            if i ~= _Quest.ReceivingPlayer and Logic.GetStoreHouse(i) ~= 0 then
                local CityBuildings = {Logic.GetPlayerEntitiesInCategory(i, EntityCategories.CityBuilding)};
                for j= 1, #CityBuildings, 1 do
                    local CurrentEarnings = Logic.GetBuildingProductEarnings(CityBuildings[j]);
                    if CurrentEarnings < 45 and Logic.GetTime() % 5 == 0 then
                        Logic.SetBuildingEarnings(CityBuildings[j], CurrentEarnings +1);
                    end
                end
            end
        end
    end

    local amount = self.Amount - self.StohlenGold;
    amount = (amount > 0 and amount) or 0;
    local text = {
        de = "Gold von %s stehlen {cr}{cr}Aus Stadtgebäuden zu stehlende Goldmenge: %d",
        en = "Steal gold from %s {cr}{cr}Amount on gold to steal from city buildings: %d",
        fr = "Voler l'or de %s {cr}{cr}Quantité d'or à voler dans les bâtiments de la ville : %d",
    };
    return "{center}" ..string.format(API.Localize(text), TargetPlayerName, amount);
end

function B_Goal_StealGold:CustomFunction(_Quest)
    Swift.Quest:ChangeCustomQuestCaptionText(self:SetDescriptionOverwrite(_Quest), _Quest);
    if self.StohlenGold >= self.Amount then
        return true;
    end
    return nil;
end

function B_Goal_StealGold:GetIcon()
    return {5,13};
end

function B_Goal_StealGold:Debug(_Quest)
    if tonumber(self.Amount) == nil and self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

function B_Goal_StealGold:Reset(_Quest)
    self.StohlenGold = 0;
end

Swift:RegisterBehavior(B_Goal_StealGold)

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss ein bestimmtes Stadtgebäude bestehlen.
--
-- Eine Kirche wird immer Sabotiert. Ein Lagerhaus verhält sich ähnlich zu
-- einer Burg.
--
-- <b>Hinweis</b>: Ein Dieb kann nur von einem Spezialgebäude oder einem
-- Stadtgebäude stehlen!
--
-- @param[type=string] _ScriptName Skriptname des Gebäudes
-- @param[type=boolean] _CheatEarnings  Einnahmen generieren
--
-- @within Goal
--
function Goal_StealFromBuilding(...)
    return B_Goal_StealFromBuilding:new(...)
end

B_Goal_StealFromBuilding = {
    Name = "Goal_StealFromBuilding",
    Description = {
        en = "Goal: The player has to steal from a building. Not a castle and not a village storehouse!",
        de = "Ziel: Der Spieler muss ein bestimmtes Gebäude bestehlen. Dies darf keine Burg und kein Dorflagerhaus sein!",
        fr = "Objectif: Le joueur doit voler un bâtiment spécifique. Il ne peut s'agir ni d'un château ni d'un entrepôt de village !",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Building",        de = "Gebäude",              fr = "Bâtiment" },
        { ParameterType.Custom,     en = "Cheat earnings",  de = "Einnahmen generieren", fr = "Générer des revenus" },
    },
}

function B_Goal_StealFromBuilding:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_StealFromBuilding:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Building = _Parameter
    elseif (_Index == 1) then
        _Parameter = _Parameter or "false"
        self.CheatEarnings = API.ToBoolean(_Parameter);
    end
    self.RobberList = {};
end

function B_Goal_StealFromBuilding:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" };
    end
end

function B_Goal_StealFromBuilding:SetDescriptionOverwrite(_Quest)
    local isCathedral = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Cathedrals) == 1;
    local isWarehouse = Logic.GetEntityType(GetID(self.Building)) == Entities.B_StoreHouse;
    local isCistern = Logic.GetEntityType(GetID(self.Building)) == Entities.B_Cistern;
    local text;

    if isCathedral then
        text = {
            de = "Sabotage {cr}{cr} Sendet einen Dieb und sabotiert die markierte Kirche.",
            en = "Sabotage {cr}{cr} Send a thief to sabotage the marked chapel.",
            fr = "Sabotage {cr}{cr} Envoyez un voleur pour saboter la chapelle marquée.",
        };
    elseif isWarehouse then
        text = {
            de = "Lagerhaus bestehlen {cr}{cr} Sendet einen Dieb in das markierte Lagerhaus.",
            en = "Steal from storehouse {cr}{cr} Steal from the marked storehouse.",
            fr = "Voler un entrepôt {cr}{cr} Envoie un voleur dans l'entrepôt marqué.",
        };
    elseif isCistern then
        text = {
            de = "Sabotage {cr}{cr} Sendet einen Dieb und sabotiert den markierten Brunnen.",
            en = "Sabotage {cr}{cr} Send a thief and break the marked well of the enemy.",
            fr = "Sabotage {cr}{cr} Envoie un voleur et sabote le puits marqué.",
        };
    else
        text = {
            de = "Gebäude bestehlen {cr}{cr} Sendet einen Dieb und bestehlt das markierte Gebäude.",
            en = "Steal from building {cr}{cr} Send a thief to steal from the marked building.",
            fr = "Voler un bâtiment {cr}{cr} Envoie un voleur et vole le bâtiment marqué.",
        };
    end
    return "{center}" .. API.Localize(text);
end

function B_Goal_StealFromBuilding:CustomFunction(_Quest)
    if not IsExisting(self.Building) then
        if self.Marker then
            Logic.DestroyEffect(self.Marker);
        end
        return false;
    end

    if not self.Marker then
        local pos = GetPosition(self.Building);
        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);
    end

    -- Cheat earnings
    if self.CheatEarnings then
        local BuildingID = GetID(self.Building);        
        local CurrentEarnings = Logic.GetBuildingProductEarnings(BuildingID);
        if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1
        and CurrentEarnings < 45 and Logic.GetTime() % 5 == 0 then
            Logic.SetBuildingEarnings(BuildingID, CurrentEarnings +1);
        end
    end

    if self.SuccessfullyStohlen then
        Logic.DestroyEffect(self.Marker);
        return true;
    end
    return nil;
end

function B_Goal_StealFromBuilding:GetIcon()
    return {5,13};
end

function B_Goal_StealFromBuilding:Debug(_Quest)
    local eTypeName = Logic.GetEntityTypeName(Logic.GetEntityType(GetID(self.Building)));
    local IsHeadquarter = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Headquarters) == 1;
    if Logic.IsBuilding(GetID(self.Building)) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is not a building");
        return true;
    elseif not IsExisting(self.Building) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is destroyed :(");
        return true;
    elseif string.find(eTypeName, "B_NPC_BanditsHQ") or string.find(eTypeName, "B_NPC_Cloister") or string.find(eTypeName, "B_NPC_StoreHouse") then
        error(_Quest.Identifier.. ": " ..self.Name .. ": village storehouses are not allowed!");
        return true;
    elseif IsHeadquarter then
        error(_Quest.Identifier.. ": " ..self.Name .. ": use Goal_StealInformation for headquarters!");
        return true;
    end
    return false;
end

function B_Goal_StealFromBuilding:Reset(_Quest)
    self.SuccessfullyStohlen = false;
    self.RobberList = {};
    self.Marker = nil;
end

function B_Goal_StealFromBuilding:Interrupt(_Quest)
    Logic.DestroyEffect(self.Marker);
end

Swift:RegisterBehavior(B_Goal_StealFromBuilding)

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss ein Gebäude mit einem Dieb ausspoinieren.
--
-- Der Quest ist erfolgreich, sobald der Dieb in das Gebäude eindringt. Es
-- muss sich um ein Gebäude handeln, das bestohlen werden kann (Burg, Lager,
-- Kirche, Stadtgebäude mit Einnahmen)!
--
-- Optional kann der Dieb nach Abschluss gelöscht werden. Diese Option macht
-- es einfacher ihn durch z.B. einen Abfahrenden U_ThiefCart zu "ersetzen".
--
-- <b>Hinweis</b>: Ein Dieb kann nur in Spezialgebäude oder Stadtgebäude
-- eindringen!
--
-- @param[type=string]  _ScriptName  Skriptname des Gebäudes
-- @param[type=boolean] _CheatEarnings  Einnahmen generieren
-- @param[type=boolean] _DeleteThief Dieb nach Abschluss löschen
--
-- @within Goal
--
function Goal_SpyOnBuilding(...)
    return B_Goal_SpyOnBuilding:new(...)
end

B_Goal_SpyOnBuilding = {
    Name = "Goal_SpyOnBuilding",
    IconOverwrite = {5,13},
    Description = {
        en = "Goal: Infiltrate a building with a thief. A thief must be able to steal from the target building.",
        de = "Ziel: Infiltriere ein Gebäude mit einem Dieb. Nur mit Gebaueden möglich, die bestohlen werden koennen.",
        fr = "Objectif: Infiltrer un bâtiment avec un voleur. Seulement possible avec des bâtiments qui peuvent être volés.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target Building", de = "Zielgebäude",           fr = "Bâtiment cible" },
        { ParameterType.Custom,     en = "Cheat earnings",  de = "Einnahmen generieren",  fr = "Générer des revenus" },
        { ParameterType.Custom,     en = "Destroy Thief",   de = "Dieb löschen",          fr = "Supprimer le voleur" },
    },
}

function B_Goal_SpyOnBuilding:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_SpyOnBuilding:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Building = _Parameter
    elseif (_Index == 1) then
        _Parameter = _Parameter or "false"
        self.CheatEarnings = API.ToBoolean(_Parameter);
    elseif (_Index == 2) then
        _Parameter = _Parameter or "true"
        self.Delete = API.ToBoolean(_Parameter)
    end
end

function B_Goal_SpyOnBuilding:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" };
    end
end

function B_Goal_SpyOnBuilding:SetDescriptionOverwrite(_Quest)
    if not _Quest.QuestDescription then
        local text = {
            de = "Gebäude infriltrieren {cr}{cr}Spioniere das markierte Gebäude mit einem Dieb aus!",
            en = "Infiltrate building {cr}{cr}Spy on the highlighted buildings with a thief!",
            fr = "Infiltrer un bâtiment {cr}{cr}Espionner le bâtiment marqué avec un voleur!",
        };
        return API.Localize(text);
    else
        return _Quest.QuestDescription;
    end
end

function B_Goal_SpyOnBuilding:CustomFunction(_Quest)
    if not IsExisting(self.Building) then
        if self.Marker then
            Logic.DestroyEffect(self.Marker);
        end
        return false;
    end

    if not self.Marker then
        local pos = GetPosition(self.Building);
        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);
    end

    -- Cheat earnings
    if self.CheatEarnings then
        local BuildingID = GetID(self.Building);
        if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1
        and Logic.GetBuildingEarnings(BuildingID) < 5 then
            Logic.SetBuildingEarnings(BuildingID, 5);
        end
    end

    if self.Infiltrated then
        Logic.DestroyEffect(self.Marker);
        return true;
    end
    return nil;
end

function B_Goal_SpyOnBuilding:GetIcon()
    return self.IconOverwrite;
end

function B_Goal_SpyOnBuilding:Debug(_Quest)
    if Logic.IsBuilding(GetID(self.Building)) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is not a building");
        return true;
    elseif not IsExisting(self.Building) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is destroyed :(");
        return true;
    end
    return false;
end

function B_Goal_SpyOnBuilding:Reset(_Quest)
    self.Infiltrated = false;
    self.Marker = nil;
end

function B_Goal_SpyOnBuilding:Interrupt(_Quest)
    Logic.DestroyEffect(self.Marker);
end

Swift:RegisterBehavior(B_Goal_SpyOnBuilding);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss eine Anzahl an Gegenständen finden, die bei den angegebenen
-- Positionen platziert werden.
--
-- @param[type=string] _Positions Präfix aller durchnummerierten Enttities
-- @param[type=string] _Model     Model für alle Gegenstände
-- @param[type=number] _Distance  Aktivierungsdistanz (0 = Default = 300)
--
-- @within Goal
--
function Goal_FetchItems(...)
    return B_Goal_FetchItems:new(...);
end

B_Goal_FetchItems = {
    Name = "Goal_FetchItems",
    Description = {
        en = "Goal: ",
        de = "Ziel: ",
        fr = "Objectif: ",
    },
    Parameter = {
        { ParameterType.Default, en = "Search points",          de = "Suchpunkte",              fr = "Points de recherche" },
        { ParameterType.Custom,  en = "Shared model",           de = "Gemeinsames Modell",      fr = "Modèle commun" },
        { ParameterType.Number,  en = "Distance (0 = Default)", de = "Enternung (0 = Default)", fr = "Distance (0 = Default)" },
    },

    Text = {
        {
            de = "%d/%d Gegenstände gefunden",
            en = "%d/%d Items gefunden",
            fr = "%d/%d objets trouvés",
        },
        {
            de = "GEGENSTÄNDE FINDEN {br}{br}Findet die verloren gegangenen Gegenstände.",
            en = "FIND VALUABLES {br}{br}Find the missing items and return them.",
            fr = "TROUVER LES OBJETS {br}{br}Trouve les objets perdus.",
        },
    },

    Tools = {
        Models.Doodads_D_X_Sacks,
        Models.Tools_T_BowNet01,
        Models.Tools_T_Hammer02,
        Models.Tools_T_Cushion01,
        Models.Tools_T_Knife02,
        Models.Tools_T_Scythe01,
        Models.Tools_T_SiegeChest01,
    },

    Distance = 300,
    Finished = false,
    Positions = {},
    Marker = {},
}

function B_Goal_FetchItems:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_FetchItems:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SearchPositions = _Parameter;
    elseif (_Index == 1) then
        self.Model = _Parameter;
    elseif (_Index == 2) then
        if _Parameter == nil then
            _Parameter = self.Distance;
        end
        self.Distance = _Parameter * 1;
        if self.Distance == 0 then
            self.Distance = 300;
        end
    end
end

function B_Goal_FetchItems:CustomFunction(_Quest)
    Swift.Quest:ChangeCustomQuestCaptionText("{center}" ..API.Localize(self.Text[2]), _Quest);
    if not self.Finished then
        self:GetPositions(_Quest);
        self:CreateMarker(_Quest);
        self:CheckPositions(_Quest);
        if #self.Marker > 0 then
            return;
        end
        self.Finished = true;
    end
    return true;
end

function B_Goal_FetchItems:GetPositions(_Quest)
    if #self.Positions == 0 then
        -- Position is a table (script only feature)
        if type(self.SearchPositions) == "table" then
            self.Positions = self.SearchPositions;
        -- Search positions by prefix
        else
            local Index = 1;
            while (IsExisting(self.SearchPositions .. Index)) do
                table.insert(self.Positions, GetPosition(self.SearchPositions .. Index));
                Index = Index +1;
            end
        end
    end
end

function B_Goal_FetchItems:CreateMarker(_Quest)
    if #self.Marker == 0 then
        for i= 1, #self.Positions, 1 do
            local ID = Logic.CreateEntityOnUnblockedLand(Entities.XD_ScriptEntity, self.Positions[i].X, self.Positions[i].Y, 0, 0);
            if self.Model ~= nil and self.Model ~= "-" then
                Logic.SetModel(ID, Models[self.Model]);
            else
                Logic.SetModel(ID, self.Tools[math.random(1, #self.Tools)]);
            end
            Logic.SetVisible(ID, true);
            table.insert(self.Marker, ID);
        end
    end
end

function B_Goal_FetchItems:CheckPositions(_Quest)
    local Heroes = {};
    Logic.GetKnights(_Quest.ReceivingPlayer, Heroes);
    for i= #self.Marker, 1, -1 do
        for j= 1, #Heroes, 1 do
            if IsNear(self.Marker[i], Heroes[j], self.Distance) then
                DestroyEntity(table.remove(self.Marker, i));
                local Max = #self.Positions;
                local Now = Max - #self.Marker;
                API.Note(string.format(API.Localize(self.Text[1]), Now, Max));
                break;
            end
        end
    end
end

function B_Goal_FetchItems:Reset(_Quest)
    self:Interrupt(_Quest);
end

function B_Goal_FetchItems:Interrupt(_Quest)
    self.Finished = false;
    self.Positions = {};
    for i= 1, #self.Marker, 1 do
        DestroyEntity(self.Marker[i]);
    end
    self.Marker = {};
end

function B_Goal_FetchItems:GetCustomData(_Index)
    if _Index == 1 then
        local Data = ModuleBehaviorCollection.Global:GetPossibleModels();
        table.insert(Data, 1, "-");
        return Data;
    end
end

function B_Goal_FetchItems:Debug(_Quest)
    return false;
end

Swift:RegisterBehavior(B_Goal_FetchItems);

-- -------------------------------------------------------------------------- --

---
-- Ein beliebiger Spieler muss Soldaten eines anderen Spielers zerstören.
--
-- Dieses Behavior kann auch in versteckten Quests bentutzt werden, wenn die
-- Menge an zerstörten Soldaten durch einen Feind des Spielers gefragt ist oder
-- wenn ein Verbündeter oder Feind nach X Verlusten aufgeben soll.
--
-- @param _PlayerA Angreifende Partei
-- @param _PlayerB Zielpartei
-- @param _Amount Menga an Soldaten
--
-- @within Goal
--
function Goal_DestroySoldiers(...)
    return B_Goal_DestroySoldiers:new(...);
end

B_Goal_DestroySoldiers = {
    Name = "Goal_DestroySoldiers",
    Description = {
        en = "Goal: Destroy a given amount of enemy soldiers",
        de = "Ziel: Zerstöre eine Anzahl gegnerischer Soldaten",
        fr = "Objectif: Détruire un certain nombre de soldats ennemis",
    },
    Parameter = {
        {ParameterType.PlayerID, en = "Attacking Player",   de = "Angreifer",   fr = "Attaquant", },
        {ParameterType.PlayerID, en = "Defending Player",   de = "Verteidiger", fr = "Défenseur", },
        {ParameterType.Number,   en = "Amount",             de = "Anzahl",      fr = "Quantité", },
    },

    Text = {
        de = "{center}SOLDATEN ZERSTÖREN {cr}{cr}von der Partei: %s{cr}{cr}Anzahl: %d",
        en = "{center}DESTROY SOLDIERS {cr}{cr}from faction: %s{cr}{cr}Amount: %d",
        fr = "{center}DESTRUIRE DES SOLDATS {cr}{cr}de la faction: %s{cr}{cr}Nombre : %d",
    }
}

function B_Goal_DestroySoldiers:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_DestroySoldiers:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AttackingPlayer = _Parameter * 1
    elseif (_Index == 1) then
        self.AttackedPlayer = _Parameter * 1
    elseif (_Index == 2) then
        self.KillsNeeded = _Parameter * 1
    end
end

function B_Goal_DestroySoldiers:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local PlayerName = GetPlayerName(self.AttackedPlayer) or ("Player " ..self.AttackedPlayer);
        Swift.Quest:ChangeCustomQuestCaptionText(
            string.format(
                Swift.Text:Localize(self.Text),
                PlayerName, self.KillsNeeded
            ),
            _Quest
        );
    end
    if self.KillsNeeded <= ModuleBehaviorCollection.Global:GetEnemySoldierKillsOfPlayer(self.AttackingPlayer, self.AttackedPlayer) then
        return true;
    end
end

function B_Goal_DestroySoldiers:Debug(_Quest)
    if Logic.GetStoreHouse(self.AttackingPlayer) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AttackinPlayer .. " is dead :-(")
        return true
    elseif Logic.GetStoreHouse(self.AttackedPlayer) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AttackedPlayer .. " is dead :-(")
        return true
    elseif self.KillsNeeded < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Amount negative")
        return true
    end
end

function B_Goal_DestroySoldiers:GetIcon()
    return {7,12}
end

Swift:RegisterBehavior(B_Goal_DestroySoldiers);

-- -------------------------------------------------------------------------- --
-- Reprisals                                                                  --
-- -------------------------------------------------------------------------- --

---
-- Ändert die Position eines Siedlers oder eines Gebäudes.
--
-- Optional kann das Entity in einem bestimmten Abstand zum Ziel platziert
-- werden und das Ziel anschauen. Die Entfernung darf nicht kleiner sein als 50!
--
-- @param[type=string]  _ScriptName Skriptname des Entity
-- @param[type=string]  _Target     Skriptname des Ziels
-- @param[type=boolean] _LookAt     Gegenüberstellen
-- @param[type=number]  _Distance   Relative Entfernung (nur mit _LookAt)
--
-- @within Reprisal
--
function Reprisal_SetPosition(...)
    return B_Reprisal_SetPosition:new(...);
end

B_Reprisal_SetPosition = {
    Name = "Reprisal_SetPosition",
    Description = {
        en = "Reprisal: Places an entity relative to the position of another. The entity can look the target.",
        de = "Vergeltung: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.",
        fr = "Rétribution: place une Entity vis-à-vis de l'emplacement d'une autre. L'entité peut être orientée vers la cible.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",          de = "Entity",          fr = "Entité", },
        { ParameterType.ScriptName, en = "Target position", de = "Zielposition",    fr = "Position cible", },
        { ParameterType.Custom,     en = "Face to face",    de = "Ziel ansehen",    fr = "Voir la cible", },
        { ParameterType.Number,     en = "Distance",        de = "Zielentfernung",  fr = "Distance de la cible", },
    },
}

function B_Reprisal_SetPosition:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_SetPosition:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Target = _Parameter;
    elseif (_Index == 2) then
        self.FaceToFace = API.ToBoolean(_Parameter)
    elseif (_Index == 3) then
        self.Distance = (_Parameter ~= nil and tonumber(_Parameter)) or 100;
    end
end

function B_Reprisal_SetPosition:CustomFunction(_Quest)
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        return;
    end

    local entity = GetID(self.Entity);
    local target = GetID(self.Target);
    local x,y,z = Logic.EntityGetPos(target);
    if Logic.IsBuilding(target) == 1 then
        x,y = Logic.GetBuildingApproachPosition(target);
    end
    local ori = Logic.GetEntityOrientation(target)+90;

    if self.FaceToFace then
        x = x + self.Distance * math.cos( math.rad(ori) );
        y = y + self.Distance * math.sin( math.rad(ori) );
        Logic.DEBUG_SetSettlerPosition(entity, x, y);
        LookAt(self.Entity, self.Target);
    else
        if Logic.IsBuilding(target) == 1 then
            x,y = Logic.GetBuildingApproachPosition(target);
        end
        Logic.DEBUG_SetSettlerPosition(entity, x, y);
    end
end

function B_Reprisal_SetPosition:GetCustomData(_Index)
    if _Index == 2 then
        return { "true", "false" }
    end
end

function B_Reprisal_SetPosition:Debug(_Quest)
    if self.FaceToFace then
        if tonumber(self.Distance) == nil or self.Distance < 50 then
            error(_Quest.Identifier.. ": " ..self.Name.. ": Distance is nil or to short!");
            return true;
        end
    end
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Mover entity or target entity does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_SetPosition);

-- -------------------------------------------------------------------------- --

---
-- Ändert den Eigentümer des Entity oder des Battalions.
--
-- @param[type=string] _ScriptName Skriptname des Entity
-- @param[type=number] _NewOwner   PlayerID des Eigentümers
--
-- @within Reprisal
--
function Reprisal_ChangePlayer(...)
    return B_Reprisal_ChangePlayer:new(...)
end

B_Reprisal_ChangePlayer = {
    Name = "Reprisal_ChangePlayer",
    Description = {
        en = "Reprisal: Changes the owner of the entity or a battalion.",
        de = "Vergeltung: Aendert den Besitzer einer Entity oder eines Battalions.",
        fr = "Rétribution : Change le propriétaire d'une entité ou d'un bataillon.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",     de = "Entity",   fr = "Entité", },
        { ParameterType.Custom,     en = "Player",     de = "Spieler",  fr = "Joueur", },
    },
}

function B_Reprisal_ChangePlayer:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_ChangePlayer:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Player = tostring(_Parameter);
    end
end

function B_Reprisal_ChangePlayer:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    if Logic.IsLeader(eID) == 1 then
        Logic.ChangeSettlerPlayerID(eID, self.Player);
    else
        Logic.ChangeEntityPlayerID(eID, self.Player);
    end
end

function B_Reprisal_ChangePlayer:GetCustomData(_Index)
    if _Index == 1 then
        return {"0", "1", "2", "3", "4", "5", "6", "7", "8"}
    end
end

function B_Reprisal_ChangePlayer:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_ChangePlayer);

-- -------------------------------------------------------------------------- --

---
-- Ändert die Sichtbarkeit eines Entity.
--
-- @param[type=string]  _ScriptName Skriptname des Entity
-- @param[type=boolean] _Visible    Sichtbarkeit an/aus
--
-- @within Reprisal
--
function Reprisal_SetVisible(...)
    return B_Reprisal_SetVisible:new(...)
end

B_Reprisal_SetVisible = {
    Name = "Reprisal_SetVisible",
    Description = {
        en = "Reprisal: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.",
        de = "Vergeltung: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.",
        fr = "Rétribution: fixe la visibilité d'une Entité. S'il s'agit d'un spawn, les Entities spawnées sont également affectées.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",      de = "Entity",   fr = "Entité", },
        { ParameterType.Custom,     en = "Visible",     de = "Sichtbar", fr = "Visible", },
    },
}

function B_Reprisal_SetVisible:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_SetVisible:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Visible = API.ToBoolean(_Parameter)
    end
end

function B_Reprisal_SetVisible:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end

    local eID = GetID(self.Entity);
    local pID = Logic.EntityGetPlayer(eID);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);

    if string.find(tName, "^S_") or string.find(tName, "^B_NPC_Bandits")
    or string.find(tName, "^B_NPC_Barracks") then
        local spawned = {Logic.GetSpawnedEntities(eID)};
        for i=1, #spawned do
            if Logic.IsLeader(spawned[i]) == 1 then
                local soldiers = {Logic.GetSoldiersAttachedToLeader(spawned[i])};
                for j=2, #soldiers do
                    Logic.SetVisible(soldiers[j], self.Visible);
                end
            else
                Logic.SetVisible(spawned[i], self.Visible);
            end
        end
    else
        if Logic.IsLeader(eID) == 1 then
            local soldiers = {Logic.GetSoldiersAttachedToLeader(eID)};
            for j=2, #soldiers do
                Logic.SetVisible(soldiers[j], self.Visible);
            end
        else
            Logic.SetVisible(eID, self.Visible);
        end
    end
end

function B_Reprisal_SetVisible:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" }
    end
end

function B_Reprisal_SetVisible:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_SetVisible);

-- -------------------------------------------------------------------------- --

---
-- Macht das Entity verwundbar oder unverwundbar.
--
-- Bei einem Battalion wirkt sich das Behavior auf alle Soldaten und den
-- (unsichtbaren) Leader aus. Wird das Behavior auf ein Spawner Entity 
-- angewendet, werden die gespawnten Entities genommen.
--
-- @param[type=string]  _ScriptName Skriptname des Entity
-- @param[type=boolean] _Vulnerable Verwundbarkeit an/aus
--
-- @within Reprisal
--
function Reprisal_SetVulnerability(...)
    return B_Reprisal_SetVulnerability:new(...);
end

B_Reprisal_SetVulnerability = {
    Name = "Reprisal_SetVulnerability",
    Description = {
        en = "Reprisal: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.",
        de = "Vergeltung: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen.",
        fr = "Rétribution: rend une Entité vulnérable ou invulnérable. S'il s'agit d'un spawn, les Entities spawnées sont affectées.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",             de = "Entity",     fr = "Entité", },
        { ParameterType.Custom,     en = "Vulnerability",      de = "Verwundbar", fr = "Vulnérabilité", },
    },
}

function B_Reprisal_SetVulnerability:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_SetVulnerability:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Vulnerability = API.ToBoolean(_Parameter)
    end
end

function B_Reprisal_SetVulnerability:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);
    local EntitiesToCheck = {eID};
    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")
    or string.find(tName, "B_NPC_Barracks") then
        EntitiesToCheck = {Logic.GetSpawnedEntities(eID)};
    end
    local MethodToUse = "MakeInvulnerable";
    if self.Vulnerability then
        MethodToUse = "MakeVulnerable";
    end
    for i= 1, #EntitiesToCheck, 1 do
        if Logic.IsLeader(EntitiesToCheck[i]) == 1 then
            local Soldiers = {Logic.GetSoldiersAttachedToLeader(EntitiesToCheck[i])};
            for j=2, #Soldiers, 1 do
                _G[MethodToUse](Soldiers[j]);
            end
        end
        _G[MethodToUse](EntitiesToCheck[i]);
    end
end

function B_Reprisal_SetVulnerability:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" }
    end
end

function B_Reprisal_SetVulnerability:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_SetVulnerability);

-- -------------------------------------------------------------------------- --

---
-- Ändert das Model eines Entity.
--
-- In Verbindung mit Reward_SetVisible oder Reprisal_SetVisible können
-- Script Entites ein neues Model erhalten und sichtbar gemacht werden.
-- Das hat den Vorteil, das Script Entities nicht überbaut werden können.
--
-- @param[type=string] _ScriptName Skriptname des Entity
-- @param[type=string] _Model      Neues Model
--
-- @within Reprisal
--
function Reprisal_SetModel(...)
    return B_Reprisal_SetModel:new(...);
end

B_Reprisal_SetModel = {
    Name = "Reprisal_SetModel",
    Description = {
        en = "Reprisal: Changes the model of the entity. Be careful, some models crash the game.",
        de = "Vergeltung: Ändert das Model einer Entity. Achtung: Einige Modelle führen zum Absturz.",
        fr = "Rétribution: modifie le modèle d'une entité. Attention: certains modèles entraînent un crash.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",    de = "Entity", fr = "Entité", },
        { ParameterType.Custom,     en = "Model",     de = "Model",  fr = "Modèle", },
    },
}

function B_Reprisal_SetModel:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_SetModel:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Model = _Parameter;
    end
end

function B_Reprisal_SetModel:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    Logic.SetModel(eID, Models[self.Model]);
end

-- Hinweis: Kann nicht durch Aufruf der Methode von B_Goal_FetchItems
-- vereinfacht werden, weil man im Editor keine Methoden aufrufen kann!
function B_Reprisal_SetModel:GetCustomData(_Index)
    if _Index == 1 then
        return ModuleBehaviorCollection.Global:GetPossibleModels();
    end
end

function B_Reprisal_SetModel:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    if not Models[self.Model] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": model '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_SetModel);

-- -------------------------------------------------------------------------- --
-- Rewards                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Ändert die Position eines Siedlers oder eines Gebäudes.
--
-- Optional kann das Entity in einem bestimmten Abstand zum Ziel platziert
-- werden und das Ziel anschauen. Die Entfernung darf nicht kleiner sein
-- als 50!
--
-- @param[type=string] _ScriptName Skriptname des Entity
-- @param[type=string] _Target     Skriptname des Ziels
-- @param[type=number] _LookAt     Gegenüberstellen
-- @param[type=number] _Distance   Relative Entfernung (nur mit _LookAt)
--
-- @within Reward
--
function Reward_SetPosition(...)
    return B_Reward_SetPosition:new(...);
end

B_Reward_SetPosition = Swift.LuaBase:CopyTable(B_Reprisal_SetPosition);
B_Reward_SetPosition.Name = "Reward_SetPosition";
B_Reward_SetPosition.Description.en = "Reward: Places an entity relative to the position of another. The entity can look the target.";
B_Reward_SetPosition.Description.de = "Lohn: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.";
B_Reward_SetPosition.Description.fr = "Récompense: Définit une Entity vis-à-vis de la position d'une autre. L'entité peut être orientée vers la cible.";
B_Reward_SetPosition.GetReprisalTable = nil;

B_Reward_SetPosition.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Swift:RegisterBehavior(B_Reward_SetPosition);

-- -------------------------------------------------------------------------- --

---
-- Ändert den Eigentümer des Entity oder des Battalions.
--
-- @param[type=string] _ScriptName Skriptname des Entity
-- @param[type=number] _NewOwner   PlayerID des Eigentümers
--
-- @within Reward
--
function Reward_ChangePlayer(...)
    return B_Reward_ChangePlayer:new(...);
end

B_Reward_ChangePlayer = Swift.LuaBase:CopyTable(B_Reprisal_ChangePlayer);
B_Reward_ChangePlayer.Name = "Reward_ChangePlayer";
B_Reward_ChangePlayer.Description.en = "Reward: Changes the owner of the entity or a battalion.";
B_Reward_ChangePlayer.Description.de = "Lohn: Ändert den Besitzer einer Entity oder eines Battalions.";
B_Reward_ChangePlayer.Description.fr = "Récompense: Change le propriétaire d'une entité ou d'un bataillon.";
B_Reward_ChangePlayer.GetReprisalTable = nil;

B_Reward_ChangePlayer.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Swift:RegisterBehavior(B_Reward_ChangePlayer);

-- -------------------------------------------------------------------------- --

---
-- Bewegt einen Siedler relativ zu einem Zielpunkt.
--
-- Der Siedler wird sich zum Ziel ausrichten und in der angegeben Distanz
-- und dem angegebenen Winkel Position beziehen.
--
-- <p><b>Hinweis:</b> Funktioniert ähnlich wie MoveEntityToPositionToAnotherOne.
-- </p>
--
-- @param[type=string] _ScriptName  Skriptname des Entity
-- @param[type=string] _Destination Skriptname des Ziels
-- @param[type=number] _Distance    Entfernung
-- @param[type=number] _Angle       Winkel
--
-- @within Reward
--
function Reward_MoveToPosition(...)
    return B_Reward_MoveToPosition:new(...);
end

B_Reward_MoveToPosition = {
    Name = "Reward_MoveToPosition",
    Description = {
        en = "Reward: Moves an entity relative to another entity. If angle is zero the entities will be standing directly face to face.",
        de = "Lohn: Bewegt eine Entity relativ zur Position einer anderen. Wenn Winkel 0 ist, stehen sich die Entities direkt gegenüber.",
        fr = "Récompense: Déplace une entité par rapport à la position d'une autre. Si l'angle est égal à 0, les entités sont directement opposées.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Settler",     de = "Siedler",     fr = "Settler" },
        { ParameterType.ScriptName, en = "Destination", de = "Ziel",        fr = "Destination" },
        { ParameterType.Number,     en = "Distance",    de = "Entfernung",  fr = "Distance" },
        { ParameterType.Number,     en = "Angle",       de = "Winkel",      fr = "Angle" },
    },
}

function B_Reward_MoveToPosition:GetRewardTable()
    return { Reward.Custom, {self, self.CustomFunction} }
end

function B_Reward_MoveToPosition:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Target = _Parameter;
    elseif (_Index == 2) then
        self.Distance = _Parameter * 1;
    elseif (_Index == 3) then
        self.Angle = _Parameter * 1;
    end
end

function B_Reward_MoveToPosition:CustomFunction(_Quest)
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        return;
    end
    self.Angle = self.Angle or 0;

    local entity = GetID(self.Entity);
    local target = GetID(self.Target);
    local orientation = Logic.GetEntityOrientation(target);
    local x,y,z = Logic.EntityGetPos(target);
    if Logic.IsBuilding(target) == 1 then
        x, y = Logic.GetBuildingApproachPosition(target);
        orientation = orientation -90;
    end
    x = x + self.Distance * math.cos( math.rad(orientation+self.Angle) );
    y = y + self.Distance * math.sin( math.rad(orientation+self.Angle) );
    Logic.MoveSettler(entity, x, y);
    self.EntityMovingJob = API.StartJob( function(_entityID, _targetID)
        if Logic.IsEntityMoving(_entityID) == false then
            LookAt(_entityID, _targetID);
            return true;
        end
    end, entity, target);
end

function B_Reward_MoveToPosition:Reset(_Quest)
    if self.EntityMovingJob then
        API.EndJob(self.EntityMovingJob);
    end
end

function B_Reward_MoveToPosition:Debug(_Quest)
    if tonumber(self.Distance) == nil or self.Distance < 50 then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Distance is nil or to short!");
        return true;
    elseif not IsExisting(self.Entity) or not IsExisting(self.Target) then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Mover entity or target entity does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_MoveToPosition);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler gewinnt das Spiel mit einem animierten Siegesfest.
--
-- Wenn nach dem Sieg weiter gespielt wird, wird das Fest gelöscht.
--
-- <h5>Multiplayer</h5>
-- Nicht für Multiplayer geeignet.
--
-- @within Reward
--
function Reward_VictoryWithParty()
    return B_Reward_VictoryWithParty:new();
end

B_Reward_VictoryWithParty = {
    Name = "Reward_VictoryWithParty",
    Description = {
        en = "Reward: (Singleplayer) The player wins the game with an animated festival on the market. Continue playing deleates the festival.",
        de = "Lohn: (Einzelspieler) Der Spieler gewinnt das Spiel mit einer animierten Siegesfeier. Bei weiterspielen wird das Fest gelöscht.",
        fr = "Récompense: (Joueur unique) Le joueur gagne la partie avec une fête de la victoire animée. Si le joueur continue à jouer, la fête est effacée.",
    },
    Parameter = {}
};

function B_Reward_VictoryWithParty:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction}};
end

function B_Reward_VictoryWithParty:AddParameter(_Index, _Parameter)
end

function B_Reward_VictoryWithParty:CustomFunction(_Quest)
    if Framework.IsNetworkGame() then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Can not be used in multiplayer!");
        return;
    end
    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);
    local pID = _Quest.ReceivingPlayer;

    local market = Logic.GetMarketplace(pID);
    if IsExisting(market) then
        local pos = GetPosition(market)
        Logic.CreateEffect(EGL_Effects.FXFireworks01,pos.X,pos.Y,0);
        Logic.CreateEffect(EGL_Effects.FXFireworks02,pos.X,pos.Y,0);

        local Generated = self:GenerateParty(pID);
        ModuleBehaviorCollection.Global.VictoryWithPartyEntities[pID] = Generated;

        Logic.ExecuteInLuaLocalState(string.format(
            [[
            if IsExisting(%d) then
                CameraAnimation.AllowAbort = false
                CameraAnimation.QueueAnimation(CameraAnimation.SetCameraToEntity, %d)
                CameraAnimation.QueueAnimation(CameraAnimation.StartCameraRotation, 5)
                CameraAnimation.QueueAnimation(CameraAnimation.Stay ,9999)
            end

            GUI_Window.ContinuePlayingClicked_Orig_Reward_VictoryWithParty = GUI_Window.ContinuePlayingClicked
            GUI_Window.ContinuePlayingClicked = function()
                GUI_Window.ContinuePlayingClicked_Orig_Reward_VictoryWithParty()
                
                local PlayerID = GUI.GetPlayerID()
                GUI.SendScriptCommand("B_Reward_VictoryWithParty:ClearParty(" ..PlayerID.. ")")

                CameraAnimation.AllowAbort = true
                CameraAnimation.Abort()
            end
            ]],
            market,
            market
        ));
    end
end

function B_Reward_VictoryWithParty:ClearParty(_PlayerID)
    if ModuleBehaviorCollection.Global.VictoryWithPartyEntities[_PlayerID] then
        for k, v in pairs(ModuleBehaviorCollection.Global.VictoryWithPartyEntities[_PlayerID]) do
            DestroyEntity(v);
        end
        ModuleBehaviorCollection.Global.VictoryWithPartyEntities[_PlayerID] = nil;
    end
end

function B_Reward_VictoryWithParty:GenerateParty(_PlayerID)
    local GeneratedEntities = {};
    local Marketplace = Logic.GetMarketplace(_PlayerID);
    if Marketplace ~= nil and Marketplace ~= 0 then
        local MarketX, MarketY = Logic.GetEntityPosition(Marketplace);
        local ID = Logic.CreateEntity(Entities.D_X_Garland, MarketX, MarketY, 0, _PlayerID)
        table.insert(GeneratedEntities, ID);
        for j=1, 10 do
            for k=1,10 do
                local SettlersX = MarketX -700+ (j*150);
                local SettlersY = MarketY -700+ (k*150);
                
                local rand = Logic.GetRandom(100);
                
                if rand > 70 then
                    local SettlerType = API.GetRandomSettlerType();
                    local Orientation = Logic.GetRandom(360);
                    local WorkerID = Logic.CreateEntityOnUnblockedLand(SettlerType, SettlersX, SettlersY, Orientation, _PlayerID);
                    Logic.SetTaskList(WorkerID, TaskLists.TL_WORKER_FESTIVAL_APPLAUD_SPEECH);
                    table.insert(GeneratedEntities, WorkerID);
                end
            end
        end
    end
    return GeneratedEntities;
end

function B_Reward_VictoryWithParty:Debug(_Quest)
    return false;
end

Swift:RegisterBehavior(B_Reward_VictoryWithParty);

-- -------------------------------------------------------------------------- --

---
-- Ändert die Sichtbarkeit eines Entity.
--
-- @param[type=string]  _ScriptName Skriptname des Entity
-- @param[type=boolean] _Visible    Sichtbarkeit an/aus
--
-- @within Reprisal
--
function Reward_SetVisible(...)
    return B_Reward_SetVisible:new(...)
end

B_Reward_SetVisible = Swift.LuaBase:CopyTable(B_Reprisal_SetVisible);
B_Reward_SetVisible.Name = "Reward_SetVisible";
B_Reward_SetVisible.Description.en = "Reward: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.";
B_Reward_SetVisible.Description.de = "Lohn: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.";
B_Reward_SetVisible.Description.fr = "Récompense: Définit la visibilité d'une Entity. S'il s'agit d'un spawn, les entités spawnées sont également influencées.";
B_Reward_SetVisible.GetReprisalTable = nil;

B_Reward_SetVisible.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

Swift:RegisterBehavior(B_Reward_SetVisible);

-- -------------------------------------------------------------------------- --

---
-- Macht das Entity verwundbar oder unverwundbar.
--
-- Bei einem Battalion wirkt sich das Behavior auf alle Soldaten und den
-- (unsichtbaren) Leader aus. Wird das Behavior auf ein Spawner Entity 
-- angewendet, werden die gespawnten Entities genommen.
--
-- @param[type=string]  _ScriptName Skriptname des Entity
-- @param[type=boolean] _Vulnerable Verwundbarkeit an/aus
--
-- @within Reward
--
function Reward_SetVulnerability(...)
    return B_Reward_SetVulnerability:new(...);
end

B_Reward_SetVulnerability = Swift.LuaBase:CopyTable(B_Reprisal_SetVulnerability);
B_Reward_SetVulnerability.Name = "Reward_SetVulnerability";
B_Reward_SetVulnerability.Description.en = "Reward: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.";
B_Reward_SetVulnerability.Description.de = "Lohn: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen.";
B_Reward_SetVulnerability.Description.fr = "Récompense: Rend une Entité vulnérable ou invulnérable. S'il s'agit d'un spawn, les entités spawnées sont affectées.";
B_Reward_SetVulnerability.GetReprisalTable = nil;

B_Reward_SetVulnerability.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

Swift:RegisterBehavior(B_Reward_SetVulnerability);

-- -------------------------------------------------------------------------- --

---
-- Ändert das Model eines Entity.
--
-- In Verbindung mit Reward_SetVisible oder Reprisal_SetVisible können
-- Script Entites ein neues Model erhalten und sichtbar gemacht werden.
-- Das hat den Vorteil, das Script Entities nicht überbaut werden können.
--
-- @param[type=string] _ScriptName Skriptname des Entity
-- @param[type=string] _Model      Neues Model
--
-- @within Reward
--
function Reward_SetModel(...)
    return B_Reward_SetModel:new(...);
end

B_Reward_SetModel = Swift.LuaBase:CopyTable(B_Reprisal_SetModel);
B_Reward_SetModel.Name = "Reward_SetModel";
B_Reward_SetModel.Description.en = "Reward: Changes the model of the entity. Be careful, some models crash the game.";
B_Reward_SetModel.Description.de = "Lohn: Ändert das Model einer Entity. Achtung: Einige Modelle führen zum Absturz.";
B_Reward_SetModel.Description.fr = "Récompense: Modifie le modèle d'une entité. Attention : certains modèles entraînent un plantage.";
B_Reward_SetModel.GetReprisalTable = nil;

B_Reward_SetModel.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

Swift:RegisterBehavior(B_Reward_SetModel);

-- -------------------------------------------------------------------------- --

---
-- Gibt oder entzieht einem KI-Spieler die Kontrolle über ein Entity.
--
-- @param[type=string]  _ScriptName Skriptname des Entity
-- @param[type=boolean] _Controlled Durch KI kontrollieren an/aus
--
-- @within Reward
--
function Reward_AI_SetEntityControlled(...)
    return B_Reward_AI_SetEntityControlled:new(...);
end

B_Reward_AI_SetEntityControlled = {
    Name = "Reward_AI_SetEntityControlled",
    Description = {
        en = "Reward: Bind or Unbind an entity or a battalion to/from an AI player. The AI player must be activated!",
        de = "Lohn: Die KI kontrolliert die Entity oder der KI die Kontrolle entziehen. Die KI muss aktiv sein!",
        fr = "Récompense: L'IA contrôle l'entité ou retirer le contrôle à l'IA. L'IA doit être active !",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",            de = "Entity",                 fr = "Entité", },
        { ParameterType.Custom,     en = "AI control entity", de = "KI kontrolliert Entity", fr = "L'IA contrôle l'entité", },
    },
}

function B_Reward_AI_SetEntityControlled:GetRewardTable()
    return { Reward.Custom, { self, self.CustomFunction } }
end

function B_Reward_AI_SetEntityControlled:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Hidden = API.ToBoolean(_Parameter)
    end
end

function B_Reward_AI_SetEntityControlled:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    local pID = Logic.EntityGetPlayer(eID);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);
    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")
    or string.find(tName, "B_NPC_Barracks") then
        local spawned = {Logic.GetSpawnedEntities(eID)};
        for i=1, #spawned do
            if Logic.IsLeader(spawned[i]) == 1 then
                AICore.HideEntityFromAI(pID, spawned[i], not self.Hidden);
            end
        end
    else
        AICore.HideEntityFromAI(pID, eID, not self.Hidden);
    end
end

function B_Reward_AI_SetEntityControlled:GetCustomData(_Index)
    if _Index == 1 then
        return { "false", "true" }
    end
end

function B_Reward_AI_SetEntityControlled:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reward_AI_SetEntityControlled);

-- -------------------------------------------------------------------------- --
-- Trigger                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald mindestens X von Y Quests fehlgeschlagen sind.
--
-- @param[type=number] _MinAmount Mindestens zu verlieren (max. 5)
-- @param[type=number] _QuestAmount Anzahl geprüfter Quests (max. 5 und >= _MinAmount)
-- @param[type=string] _Quest1      Name des 1. Quest
-- @param[type=string] _Quest2      Name des 2. Quest
-- @param[type=string] _Quest3      Name des 3. Quest
-- @param[type=string] _Quest4      Name des 4. Quest
-- @param[type=string] _Quest5      Name des 5. Quest
--
-- @within Trigger
--
function Trigger_OnAtLeastXOfYQuestsFailed(...)
    return B_Trigger_OnAtLeastXOfYQuestsFailed:new(...);
end

B_Trigger_OnAtLeastXOfYQuestsFailed = {
    Name = "Trigger_OnAtLeastXOfYQuestsFailed",
    Description = {
        en = "Trigger: if at least X of Y given quests has been finished successfully.",
        de = "Auslöser: wenn X von Y angegebener Quests fehlgeschlagen sind.",
        fr = "Déclencheur: lorsque X des Y quêtes indiquées ont échoué.",
    },
    Parameter = {
        { ParameterType.Custom,    en = "Least Amount", de = "Mindest Anzahl",  fr = "Nombre minimum" },
        { ParameterType.Custom,    en = "Quest Amount", de = "Quest Anzahl",    fr = "Nombre de quêtes" },
        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1",     fr = "Nom de la quête 1" },
        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2",     fr = "Nom de la quête 2" },
        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3",     fr = "Nom de la quête 3" },
        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4",     fr = "Nom de la quête 4" },
        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5",     fr = "Nom de la quête 5" },
    },
}

function B_Trigger_OnAtLeastXOfYQuestsFailed:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnAtLeastXOfYQuestsFailed:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.LeastAmount = tonumber(_Parameter)
    elseif (_Index == 1) then
        self.QuestAmount = tonumber(_Parameter)
    elseif (_Index == 2) then
        self.QuestName1 = _Parameter
    elseif (_Index == 3) then
        self.QuestName2 = _Parameter
    elseif (_Index == 4) then
        self.QuestName3 = _Parameter
    elseif (_Index == 5) then
        self.QuestName4 = _Parameter
    elseif (_Index == 6) then
        self.QuestName5 = _Parameter
    end
end

function B_Trigger_OnAtLeastXOfYQuestsFailed:CustomFunction()
    local least = 0
    for i = 1, self.QuestAmount do
		local QuestID = GetQuestID(self["QuestName"..i]);
        if IsValidQuest(QuestID) then
			if (Quests[QuestID].Result == QuestResult.Failure) then
				least = least + 1
				if least >= self.LeastAmount then
					return true
				end
			end
        end
    end
    return false
end

function B_Trigger_OnAtLeastXOfYQuestsFailed:Debug(_Quest)
    local leastAmount = self.LeastAmount
    local questAmount = self.QuestAmount
    if leastAmount <= 0 or leastAmount >5 then
        error(_Quest.Identifier .. ":" .. self.Name .. ": LeastAmount is wrong")
        return true
    elseif questAmount <= 0 or questAmount > 5 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": QuestAmount is wrong")
        return true
    elseif leastAmount > questAmount then
        error(_Quest.Identifier.. ": " ..self.Name .. ": LeastAmount is greater than QuestAmount")
        return true
    end
    for i = 1, questAmount do
        if not IsValidQuest(self["QuestName"..i]) then
            error(_Quest.Identifier.. ": " ..self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")
            return true
        end
    end
    return false
end

function B_Trigger_OnAtLeastXOfYQuestsFailed:GetCustomData(_Index)
    if (_Index == 0) or (_Index == 1) then
        return {"1", "2", "3", "4", "5"}
    end
end

Swift:RegisterBehavior(B_Trigger_OnAtLeastXOfYQuestsFailed)

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald die Munition in der Kriegsmaschine erschöpft ist.
--
-- @param[type=string] _ScriptName Skriptname des Entity
--
-- @within Trigger
--
function Trigger_AmmunitionDepleted(...)
    return B_Trigger_AmmunitionDepleted:new(...);
end

B_Trigger_AmmunitionDepleted = {
    Name = "Trigger_AmmunitionDepleted",
    Description = {
        en = "Trigger: if the ammunition of the entity is depleted.",
        de = "Auslöser: wenn die Munition der Entity aufgebraucht ist.",
        fr = "Déclencheur: lorsque les munitions de l'entité sont épuisées.",
    },
    Parameter = {
        { ParameterType.Scriptname, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Trigger_AmmunitionDepleted:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_AmmunitionDepleted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Scriptname = _Parameter
    end
end

function B_Trigger_AmmunitionDepleted:CustomFunction()
    if not IsExisting(self.Scriptname) then
        return false;
    end

    local EntityID = GetID(self.Scriptname);
    if Logic.GetAmmunitionAmount(EntityID) > 0 then
        return false;
    end

    return true;
end

function B_Trigger_AmmunitionDepleted:Debug(_Quest)
    if not IsExisting(self.Scriptname) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": '"..self.Scriptname.."' is destroyed!");
        return true
    end
    return false
end

Swift:RegisterBehavior(B_Trigger_AmmunitionDepleted)

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, wenn exakt einer von beiden Quests erfolgreich ist.
--
-- @param[type=string] _QuestName1 Name des ersten Quest
-- @param[type=string] _QuestName2 Name des zweiten Quest
--
-- @within Trigger
--
function Trigger_OnExactOneQuestIsWon(...)
    return B_Trigger_OnExactOneQuestIsWon:new(...);
end

B_Trigger_OnExactOneQuestIsWon = {
    Name = "Trigger_OnExactOneQuestIsWon",
    Description = {
        en = "Trigger: if one of two given quests has been finished successfully, but NOT both.",
        de = "Auslöser: wenn eine von zwei angegebenen Quests (aber NICHT beide) erfolgreich abgeschlossen wurde.",
        fr = "Déclencheur: lorsque l'une des deux quêtes indiquées (mais PAS les deux) a été accomplie avec succès.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1", fr = "Nom de la quête 1", },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2", fr = "Nom de la quête 2", },
    },
}

function B_Trigger_OnExactOneQuestIsWon:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_OnExactOneQuestIsWon:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function B_Trigger_OnExactOneQuestIsWon:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if Quest2 and Quest1 then
        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success);
        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success);
        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then
            return true;
        end
    end
    return false;
end

function B_Trigger_OnExactOneQuestIsWon:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        error(_Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_OnExactOneQuestIsWon);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, wenn exakt einer von beiden Quests fehlgeschlagen ist.
--
-- @param[type=string] _QuestName1 Name des ersten Quest
-- @param[type=string] _QuestName2 Name des zweiten Quest
--
-- @within Trigger
--
function Trigger_OnExactOneQuestIsLost(...)
    return B_Trigger_OnExactOneQuestIsLost:new(...);
end

B_Trigger_OnExactOneQuestIsLost = {
    Name = "Trigger_OnExactOneQuestIsLost",
    Description = {
        en = "Trigger: If one of two given quests has been lost, but NOT both.",
        de = "Auslöser: Wenn einer von zwei angegebenen Quests (aber NICHT beide) fehlschlägt.",
        fr = "Déclencheur: Si l'une des deux quêtes indiquées (mais PAS les deux) échoue.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1", fr = "Nom de la quête 1", },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2", fr = "Nom de la quête 2", },
    },
}

function B_Trigger_OnExactOneQuestIsLost:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_OnExactOneQuestIsLost:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function B_Trigger_OnExactOneQuestIsLost:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if Quest2 and Quest1 then
        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure);
        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure);
        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then
            return true;
        end
    end
    return false;
end

function B_Trigger_OnExactOneQuestIsLost:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        error(_Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_OnExactOneQuestIsLost);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleNpcInteraction = {
    Properties = {
        Name = "ModuleNpcInteraction",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        Interactions = {},
        NPC = {},
        UseMarker = true,
    };
    Local  = {};
    -- This is a shared structure but the values are asynchronous!
    Shared = {
        Text = {
            StartConversation = {
                de = "Gespräch beginnen",
                en = "Start conversation",
                fr = "Commencer la conversation",
            }
        }
    };
};

QSB.Npc = {
    LastNpcEntityID = 0,
    LastHeroEntityID = 0,
}

-- Global Script ------------------------------------------------------------ --

function ModuleNpcInteraction.Global:OnGameStart()
    QSB.ScriptEvents.NpcInteraction = API.RegisterScriptEvent("Event_NpcInteraction");

    self:OverrideQuestFunctions();

    API.StartHiResJob(function()
        if Logic.GetTime() > 1 then
            ModuleNpcInteraction.Global:InteractionTriggerController();
        end
    end);
    API.StartJob(function()
        ModuleNpcInteraction.Global:InteractableMarkerController();
    end);
end

function ModuleNpcInteraction.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.NpcInteraction then
        QSB.Npc.LastNpcEntityID = arg[1];
        QSB.Npc.LastHeroEntityID = arg[2];
        self.Interactions[arg[1]] = self.Interactions[arg[1]] or {};
        if self.Interactions[arg[1]][arg[2]] then
            if Logic.GetCurrentTurn() <= self.Interactions[arg[1]][arg[2]] + 5 then
                return;
            end
        end
        self.Interactions[arg[1]][arg[2]] = Logic.GetCurrentTurn();
        self:PerformNpcInteraction(arg[3]);
    end
end

function ModuleNpcInteraction.Global:CreateNpc(_Data)
    self.NPC[_Data.Name] = {
        Name              = _Data.Name,
        Active            = true,
        Type              = _Data.Type or 1,
        Player            = _Data.Player or {1, 2, 3, 4, 5, 6, 7, 8},
        WrongPlayerAction = _Data.WrongPlayerAction,
        Hero              = _Data.Hero,
        WrongHeroAction   = _Data.WrongHeroAction,
        Distance          = _Data.Distance or 350,
        Condition         = _Data.Condition,
        Callback          = _Data.Callback,
        UseMarker         = self.UseMarker == true,
        MarkerID          = 0
    }
    self:UpdateNpc(_Data);
    return self.NPC[_Data.Name];
end

function ModuleNpcInteraction.Global:DestroyNpc(_Data)
    _Data.Active = false;
    self:UpdateNpc(_Data);
    self:DestroyMarker(_Data.Name);
    self.NPC[_Data.Name] = nil;
end

function ModuleNpcInteraction.Global:GetNpc(_ScriptName)
    return self.NPC[_ScriptName];
end

function ModuleNpcInteraction.Global:UpdateNpc(_Data)
    if not IsExisting(_Data.Name) then
        return;
    end
    if not self.NPC[_Data.Name] then
        local EntityID = GetID(_Data.Name);
        Logic.SetOnScreenInformation(EntityID, 0);
        return;
    end
    for k, v in pairs(_Data) do
        self.NPC[_Data.Name][k] = v;
    end
    self:CreateMarker(_Data.Name);
    if self.NPC[_Data.Name].Active then
        local EntityID = GetID(_Data.Name);
        Logic.SetOnScreenInformation(EntityID, self.NPC[_Data.Name].Type);
    else
        local EntityID = GetID(_Data.Name);
        Logic.SetOnScreenInformation(EntityID, 0);
    end
end

function ModuleNpcInteraction.Global:PerformNpcInteraction(_PlayerID)
    local ScriptName = Logic.GetEntityName(QSB.Npc.LastNpcEntityID);
    if self.NPC[ScriptName] then
        local Data = self.NPC[ScriptName];
        self:RotateActorsToEachother(_PlayerID);
        self:AdjustHeroTalkingDistance(Data.Distance);

        if not self:InteractionIsAppropriatePlayer(ScriptName, _PlayerID, QSB.Npc.LastHeroEntityID) then
            return;
        end
        Data.TalkedTo = QSB.Npc.LastHeroEntityID;

        if not self:InteractionIsAppropriateHero(ScriptName) then
            return;
        end

        if Data.Condition == nil or Data:Condition(_PlayerID, QSB.Npc.LastHeroEntityID) then
            Data.Active = false;
            if Data.Callback then
                Data:Callback(_PlayerID, QSB.Npc.LastHeroEntityID);
            end
        else
            Data.TalkedTo = 0;
        end

        self:UpdateNpc(Data);
    end
end

function ModuleNpcInteraction.Global:InteractionIsAppropriatePlayer(_ScriptName, _PlayerID, _HeroID)
    local Appropriate = true;
    if self.NPC[_ScriptName] then
        local Data = self.NPC[_ScriptName];
        if Data.Player ~= nil then
            if type(Data.Player) == "table" then
                Appropriate = table.contains(Data.Player, _PlayerID);
            else
                Appropriate = Data.Player == _PlayerID;
            end

            if not Appropriate then
                local LastTime = (Data.WrongHeroTick or 0) +1;
                local CurrentTime = Logic.GetTime();
                if Data.WrongPlayerAction and LastTime < CurrentTime then
                    self.NPC[_ScriptName].LastWongPlayerTick = CurrentTime;
                    Data:WrongPlayerAction(_PlayerID);
                end
            end
        end
    end
    return Appropriate;
end

function ModuleNpcInteraction.Global:InteractionIsAppropriateHero(_ScriptName)
    local Appropriate = true;
    if self.NPC[_ScriptName] then
        local Data = self.NPC[_ScriptName];
        if Data.Hero ~= nil then
            if type(Data.Hero) == "table" then
                Appropriate = table.contains(Data.Hero, Logic.GetEntityName(QSB.Npc.LastHeroEntityID));
            end
            Appropriate = Data.Hero == Logic.GetEntityName(QSB.Npc.LastHeroEntityID);

            if not Appropriate then
                local LastTime = (Data.WrongHeroTick or 0) +1;
                local CurrentTime = Logic.GetTime();
                if Data.WrongHeroAction and LastTime < CurrentTime then
                    self.NPC[_ScriptName].WrongHeroTick = CurrentTime;
                    Data:WrongHeroAction(QSB.Npc.LastHeroEntityID);
                end
            end
        end
    end
    return Appropriate;
end

function ModuleNpcInteraction.Global:GetEntityMovementTarget(_EntityID)
    local X = API.GetFloat(_EntityID, QSB.ScriptingValue.Destination.X);
    local Y = API.GetFloat(_EntityID, QSB.ScriptingValue.Destination.Y);
    return {X= X, Y= Y};
end

function ModuleNpcInteraction.Global:RotateActorsToEachother(_PlayerID)
    local PlayerKnights = {};
    Logic.GetKnights(_PlayerID, PlayerKnights);
    for k, v in pairs(PlayerKnights) do
        local Target = self:GetEntityMovementTarget(v);
        local x, y, z = Logic.EntityGetPos(QSB.Npc.LastNpcEntityID);
        if math.floor(Target.X) == math.floor(x) and math.floor(Target.Y) == math.floor(y) then
            x, y, z = Logic.EntityGetPos(v);
            Logic.MoveEntity(v, x, y);
            API.LookAt(v, QSB.Npc.LastNpcEntityID);
        end
    end
    API.LookAt(QSB.Npc.LastHeroEntityID, QSB.Npc.LastNpcEntityID);
    API.LookAt(QSB.Npc.LastNpcEntityID, QSB.Npc.LastHeroEntityID);
end

function ModuleNpcInteraction.Global:AdjustHeroTalkingDistance(_Distance)
    local Distance = _Distance * API.GetFloat(QSB.Npc.LastNpcEntityID, QSB.ScriptingValue.Size);
    if API.GetDistance(QSB.Npc.LastHeroEntityID, QSB.Npc.LastNpcEntityID) <= Distance * 0.7 then
        local Orientation = Logic.GetEntityOrientation(QSB.Npc.LastNpcEntityID);
        local x1, y1, z1 = Logic.EntityGetPos(QSB.Npc.LastHeroEntityID);
        local x2 = x1 + ((Distance * 0.5) * math.cos(math.rad(Orientation)));
        local y2 = y1 + ((Distance * 0.5) * math.sin(math.rad(Orientation)));
        local ID = Logic.CreateEntityOnUnblockedLand(Entities.XD_ScriptEntity, x2, y2, 0, 0);
        local x3, y3, z3 = Logic.EntityGetPos(ID);
        Logic.MoveSettler(QSB.Npc.LastHeroEntityID, x3, y3);
        API.StartHiResJob( function(_HeroID, _NPCID, _Time)
            if Logic.GetTime() > _Time +0.5 and Logic.IsEntityMoving(_HeroID) == false then
                API.LookAt(_HeroID, _NPCID);
                API.LookAt(_NPCID, _HeroID);
                return true;
            end
        end, QSB.Npc.LastHeroEntityID, QSB.Npc.LastNpcEntityID, Logic.GetTime());
    end
end

function ModuleNpcInteraction.Global:OverrideQuestFunctions()
    GameCallback_OnNPCInteraction_Orig_QSB_ModuleNpcInteraction = GameCallback_OnNPCInteraction;
    GameCallback_OnNPCInteraction = function(_EntityID, _PlayerID, _KnightID)
        GameCallback_OnNPCInteraction_Orig_QSB_ModuleNpcInteraction(_EntityID, _PlayerID, _KnightID);

        local ClosestKnightID = _KnightID or ModuleNpcInteraction.Global:GetClosestKnight(_EntityID, _PlayerID);
        API.SendScriptEvent(QSB.ScriptEvents.NpcInteraction, _EntityID, ClosestKnightID, _PlayerID);
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.NpcInteraction, %d, %d, %d)]],
            _EntityID,
            ClosestKnightID,
            _PlayerID
        ));
    end

    QuestTemplate.RemoveQuestMarkers_Orig_ModuleNpcInteraction = QuestTemplate.RemoveQuestMarkers
    QuestTemplate.RemoveQuestMarkers = function(self)
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[1] ~= -65565 then
                    QuestTemplate.RemoveQuestMarkers_Orig_ModuleNpcInteraction(self);
                else
                    if self.Objectives[i].Data[4] then
                        API.NpcDispose(self.Objectives[i].Data[4].NpcInstance);
                        self.Objectives[i].Data[4].NpcInstance = nil;
                    end
                end
            else
                QuestTemplate.RemoveQuestMarkers_Orig_ModuleNpcInteraction(self);
            end
        end
    end

    QuestTemplate.ShowQuestMarkers_Orig_ModuleNpcInteraction = QuestTemplate.ShowQuestMarkers
    QuestTemplate.ShowQuestMarkers = function(self)
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[1] ~= -65565 then
                    QuestTemplate.ShowQuestMarkers_Orig_ModuleNpcInteraction(self);
                else
                    if not self.Objectives[i].Data[4].NpcInstance then
                        self.Objectives[i].Data[4].NpcInstance = API.NpcCompose {
                            Name   = self.Objectives[i].Data[3],
                            Hero   = self.Objectives[i].Data[2],
                            Player = self.ReceivingPlayer,
                        }
                    end
                end
            end
        end
    end

    QuestTemplate.IsObjectiveCompleted_Orig_ModuleNpcInteraction = QuestTemplate.IsObjectiveCompleted;
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        local objectiveType = objective.Type;
        local data = objective.Data;
        if objective.Completed ~= nil then
            return objective.Completed;
        end

        if objectiveType ~= Objective.Distance then
            return self:IsObjectiveCompleted_Orig_ModuleNpcInteraction(objective);
        else
            if data[1] == -65565 then
                if not IsExisting(data[3]) then
                    error(data[3].. " is dead! :(");
                    objective.Completed = false;
                else
                    if API.NpcTalkedTo(data[4].NpcInstance, data[2], self.ReceivingPlayer) then
                        objective.Completed = true;
                    end
                end
            else
                return self:IsObjectiveCompleted_Orig_ModuleNpcInteraction(objective);
            end
        end
    end
end

function ModuleNpcInteraction.Global:GetClosestKnight(_EntityID, _PlayerID)
    local KnightIDs = {};
    Logic.GetKnights(_PlayerID, KnightIDs);
    return API.GetClosestToTarget(_EntityID, KnightIDs);
end

function ModuleNpcInteraction.Global:ToggleMarkerUsage(_Flag)
    self.UseMarker = _Flag == true;
    for k, v in pairs(self.NPC) do
        self.NPC[k].UseMarker = _Flag == true;
        self:HideMarker(k);
    end
end

function ModuleNpcInteraction.Global:CreateMarker(_ScriptName)
    if self.NPC[_ScriptName] then
        local x,y,z = Logic.EntityGetPos(GetID(_ScriptName));
        local MarkerID = Logic.CreateEntity(Entities.XD_ScriptEntity, x, y, 0, 0);
        DestroyEntity(self.NPC[_ScriptName].MarkerID);
        self.NPC[_ScriptName].MarkerID = MarkerID;
        self:HideMarker(_ScriptName);
    end
end

function ModuleNpcInteraction.Global:DestroyMarker(_ScriptName)
    if self.NPC[_ScriptName] then
        DestroyEntity(self.NPC[_ScriptName].MarkerID);
        self.NPC[_ScriptName].MarkerID = 0;
    end
end

function ModuleNpcInteraction.Global:HideMarker(_ScriptName)
    if self.NPC[_ScriptName] then
        if IsExisting(self.NPC[_ScriptName].MarkerID) then
            Logic.SetModel(self.NPC[_ScriptName].MarkerID, Models.Effects_E_NullFX);
            Logic.SetVisible(self.NPC[_ScriptName].MarkerID, false);
        end
    end
end

function ModuleNpcInteraction.Global:ShowMarker(_ScriptName)
    if self.NPC[_ScriptName] then
        if self.NPC[_ScriptName].UseMarker == true and IsExisting(self.NPC[_ScriptName].MarkerID) then
            local Size = API.GetFloat(_ScriptName, QSB.ScriptingValue.Size);
            API.SetFloat(self.NPC[_ScriptName].MarkerID, QSB.ScriptingValue.Size, Size);
            Logic.SetModel(self.NPC[_ScriptName].MarkerID, Models.Effects_E_Wealth);
            Logic.SetVisible(self.NPC[_ScriptName].MarkerID, true);
        end
    end
end

function ModuleNpcInteraction.Global:GetEntityMovingTarget(_EntityID)
    local x = API.GetFloat(_EntityID, QSB.ScriptingValue.Destination.X);
    local y = API.GetFloat(_EntityID, QSB.ScriptingValue.Destination.Y);
    return {X= x, Y= y};
end

function ModuleNpcInteraction.Global:InteractionTriggerController()
    for PlayerID = 1, 8, 1 do
        local PlayersKnights = {};
        Logic.GetKnights(PlayerID, PlayersKnights);
        for i= 1, #PlayersKnights, 1 do
            if Logic.GetCurrentTaskList(PlayersKnights[i]) == "TL_NPC_INTERACTION" then
                for k, v in pairs(self.NPC) do
                    if v.Distance >= 350 then
                        local Target = self:GetEntityMovementTarget(PlayersKnights[i]);
                        local x2, y2 = Logic.EntityGetPos(GetID(k));
                        if math.floor(Target.X) == math.floor(x2) and math.floor(Target.Y) == math.floor(y2) then
                            if IsExisting(k) and IsNear(PlayersKnights[i], k, v.Distance) then
                                GameCallback_OnNPCInteraction(GetID(k), PlayerID, PlayersKnights[i]);
                                return;
                            end
                        end
                    end
                end
            end
        end
    end
end

function ModuleNpcInteraction.Global:InteractableMarkerController()
    for k, v in pairs(self.NPC) do
        if v.Active then
            if  v.UseMarker and IsExisting(v.MarkerID)
            and API.GetInteger(v.MarkerID, QSB.ScriptingValue.Visible) == 801280 then
                self:HideMarker(k);
            else
                self:ShowMarker(k);
            end
            local x1,y1,z1 = Logic.EntityGetPos(v.MarkerID);
            local x2,y2,z2 = Logic.EntityGetPos(GetID(k));
            if math.abs(x1-x2) > 20 or math.abs(y1-y2) > 20 then
                Logic.DEBUG_SetPosition(v.MarkerID, x2, y2);
            end
        end
    end
end

-- Local Script ------------------------------------------------------------- --

function ModuleNpcInteraction.Local:OnGameStart()
    QSB.ScriptEvents.NpcInteraction = API.RegisterScriptEvent("Event_NpcInteraction");

    self:OverrideQuestFunctions();
end

function ModuleNpcInteraction.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.NpcInteraction then
        QSB.Npc.LastNpcEntityID = arg[1];
        QSB.Npc.LastHeroEntityID = arg[2];
    end
end

function ModuleNpcInteraction.Local:OverrideQuestFunctions()
    GUI_Interaction.DisplayQuestObjective_Orig_ModuleNpcInteraction = GUI_Interaction.DisplayQuestObjective
    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)
        local QuestIndexTemp = tonumber(_QuestIndex);
        if QuestIndexTemp then
            _QuestIndex = QuestIndexTemp;
        end

        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";
        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);
        local QuestObjectiveContainer;
        local QuestTypeCaption;

        g_CurrentDisplayedQuestID = _QuestIndex;

        if QuestType == Objective.Distance then
            QuestObjectiveContainer = QuestObjectivesPath .. "/List";
            QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestInteraction");
            local ObjectList = {};

            if Quest.Objectives[1].Data[1] == -65565 then
                QuestObjectiveContainer = QuestObjectivesPath .. "/Distance";
                QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestMoveHere");
                SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{7,10});

                local MoverEntityID = GetID(Quest.Objectives[1].Data[2]);
                local MoverEntityType = Logic.GetEntityType(MoverEntityID);
                local MoverIcon = g_TexturePositions.Entities[MoverEntityType];
                if not MoverIcon then
                    MoverIcon = {7, 9};
                end
                SetIcon(QuestObjectiveContainer .. "/IconMover", MoverIcon);

                local TargetEntityID = GetID(Quest.Objectives[1].Data[3]);
                local TargetEntityType = Logic.GetEntityType(TargetEntityID);
                local TargetIcon = g_TexturePositions.Entities[TargetEntityType];
                if not TargetIcon then
                    TargetIcon = {14, 10};
                end

                local IconWidget = QuestObjectiveContainer .. "/IconTarget";
                local ColorWidget = QuestObjectiveContainer .. "/TargetPlayerColor";

                SetIcon(IconWidget, TargetIcon);
                XGUIEng.SetMaterialColor(ColorWidget, 0, 255, 255, 255, 0);

                SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{16,12});
                local caption = ModuleNpcInteraction.Shared.Text.StartConversation;
                QuestTypeCaption = API.Localize(caption);

                XGUIEng.SetText(QuestObjectiveContainer.."/Caption","{center}"..QuestTypeCaption);
                XGUIEng.ShowWidget(QuestObjectiveContainer, 1);
            else
                GUI_Interaction.DisplayQuestObjective_Orig_ModuleNpcInteraction(_QuestIndex, _MessageKey);
            end
        else
            GUI_Interaction.DisplayQuestObjective_Orig_ModuleNpcInteraction(_QuestIndex, _MessageKey);
        end
    end

    GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_ModuleNpcInteraction = GUI_Interaction.GetEntitiesOrTerritoryListForQuest
    GUI_Interaction.GetEntitiesOrTerritoryListForQuest = function( _Quest, _QuestType )
        local EntityOrTerritoryList = {}
        local IsEntity = true

        if _QuestType == Objective.Distance then
            if _Quest.Objectives[1].Data[1] == -65565 then
                local Entity = GetID(_Quest.Objectives[1].Data[3]);
                table.insert(EntityOrTerritoryList, Entity);
            else
                return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_ModuleNpcInteraction(_Quest, _QuestType);
            end

        else
            return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_ModuleNpcInteraction(_Quest, _QuestType);
        end
        return EntityOrTerritoryList, IsEntity
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleNpcInteraction);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Ermöglicht die Interaktion mit NPC-Charakteren.
--
-- Ein NPC ist ein Charakter, der durch den Helden eines Spielers angesprochen
-- werden kann. Auf das Ansprechen kann eine beliebige Aktion folgen. Mittels
-- einer Bedingung kann festgelegt werden, wer mit dem NPC sprechen kann und
-- unter welchen Umständen es nicht möglich ist.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field NpcInteraction  (Parameter: NpcEntityID, HeroEntityID)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Erstellt einen neuen NPC für den angegebenen Siedler.
--
-- Mögliche Einstellungen für den NPC:
-- <table border="1">
-- <tr>
-- <th><b>Eigenschaft</b></th>
-- <th><b>Beschreibung</b></th>
-- </tr>
-- <tr>
-- <td>Name</td>
-- <td>(string) Skriptname des NPC. Dieses Attribut wird immer benötigt!</td>
-- </tr>
-- <tr>
-- <td>Type</td>
-- <td>(number) Typ des NPC. Zahl zwischen 1 und 4 möglich. Bestimmt, falls
-- vorhanden, den Anzeigemodus des NPC Icon.</td>
-- </tr>
-- <tr>
-- <td>Condition</td>
-- <td>(function) Bedingung, um die Konversation auszuführen. Muss boolean zurückgeben.</td>
-- </tr>
-- <tr>
-- <td>Callback</td>
-- <td>(function) Funktion, die bei erfolgreicher Aktivierung ausgeführt wird.</td>
-- </tr>
-- <tr>
-- <td>Player</td>
-- <td>(number|table) Spieler, der/die mit dem NPC sprechen kann/können.</td>
-- </tr>
-- <tr>
-- <td>WrongPlayerAction</td>
-- <td>(function) Funktion, die für einen falschen Spieler ausgeführt wird.</td>
-- </tr>
-- <tr>
-- <td>Hero</td>
-- <td>(string) Skriptnamen von Helden, die mit dem NPC sprechen können.</td>
-- </tr>
-- <tr>
-- <td>WrongHeroAction</td>
-- <td>(function) Funktion, die für einen falschen Helden ausgeführt wird.</td>
-- </tr>
-- </table>
--
-- @param[type=table]  _Data Definition des NPC
-- @return[type=table] NPC Table
-- @within Anwenderfunktionen
--
-- @usage
-- -- Beispiel #1: Einfachen NPC erstellen
-- MyNpc = API.NpcCompose {
--     Name     = "HansWurst",
--     Callback = function(_Data)
--         local HeroID = QSB.LastHeroEntityID;
--         local NpcID = GetID(_Data.Name);
--         -- mach was tolles
--     end
-- }
--
-- @usage
-- -- Beispiel #2: NPC mit Bedingung erstellen
-- MyNpc = API.NpcCompose {
--     Name      = "HansWurst",
--     Condition = function(_Data)
--         local NpcID = GetID(_Data.Name);
--         -- prüfe irgend was
--         return MyConditon == true;
--     end
--     Callback  = function(_Data)
--         local HeroID = QSB.LastHeroEntityID;
--         local NpcID = GetID(_Data.Name);
--         -- mach was tolles
--     end
-- }
--
-- @usage
-- -- Beispiel #3: NPC auf Spieler beschränken
-- MyNpc = API.NpcCompose {
--     Name              = "HansWurst",
--     Player            = {1, 2},
--     WrongPlayerAction = function(_Data)
--         API.Note("Ich rede nicht mit Euch!");
--     end,
--     Callback          = function(_Data)
--         local HeroID = QSB.LastHeroEntityID;
--         local NpcID = GetID(_Data.Name);
--         -- mach was tolles
--     end
-- }
--
function API.NpcCompose(_Data)
    if GUI or not type(_Data) == "table" or not _Data.Name then
        return;
    end
    if not IsExisting(_Data.Name) then
        error("API.NpcCompose: '" .._Data.Name.. "' NPC does not exist!");
        return;
    end
    local Npc = ModuleNpcInteraction.Global:GetNpc(_Data.Name);
    if Npc ~= nil and Npc.Active then
        error("API.NpcCompose: '" .._Data.Name.. "' is already composed as NPC!");
        return;
    end
    if _Data.Type and (not type(_Data.Type) == "number" or (_Data.Type < 1 or _Data.Type > 4)) then
        error("API.NpcCompose: Type must be a value between 1 and 4!");
        return;
    end
    return ModuleNpcInteraction.Global:CreateNpc(_Data);
end

---
-- Entfernt den NPC komplett vom Entity. Das Entity bleibt dabei erhalten.
--
-- @param[type=table] _Data NPC Table
-- @within Anwenderfunktionen
-- @usage
-- API.NpcDispose(MyNpc);
--
function API.NpcDispose(_Data)
    if GUI then
        return;
    end
    if not IsExisting(_Data.Name) then
        error("API.NpcDispose: '" .._Data.Name.. "' NPC does not exist!");
        return;
    end
    if ModuleNpcInteraction.Global:GetNpc(_Data.Name) ~= nil then
        error("API.NpcDispose: '" .._Data.Name.. "' NPC must first be composed!");
        return;
    end

    ModuleNpcInteraction.Global:DestroyNpc(_Data);
end

---
-- Aktualisiert die Daten des NPC.
--
-- Mögliche Einstellungen für den NPC:
-- <table border="1">
-- <tr>
-- <th><b>Eigenschaft</b></th>
-- <th><b>Beschreibung</b></th>
-- </tr>
-- <tr>
-- <td>Name</td>
-- <td>(string) Skriptname des NPC. Dieses Attribut wird immer benötigt!</td>
-- </tr>
-- <tr>
-- <td>Type</td>
-- <td>(number) Typ des NPC. Zahl zwischen 1 und 4 möglich. Bestimmt, falls
-- vorhanden, den Anzeigemodus des NPC Icon.</td>
-- </tr>
-- <tr>
-- <td>Condition</td>
-- <td>(function) Bedingung, um die Konversation auszuführen. Muss boolean zurückgeben.</td>
-- </tr>
-- <tr>
-- <td>Callback</td>
-- <td>(function) Funktion, die bei erfolgreicher Aktivierung ausgeführt wird.</td>
-- </tr>
-- <tr>
-- <td>Player</td>
-- <td>(number) Spieler, die mit dem NPC sprechen können.</td>
-- </tr>
-- <tr>
-- <td>WrongPlayerAction</td>
-- <td>(function) Funktion, die für einen falschen Spieler ausgeführt wird.</td>
-- </tr>
-- <tr>
-- <td>Hero</td>
-- <td>(string) Skriptnamen von Helden, die mit dem NPC sprechen können.</td>
-- </tr>
-- <tr>
-- <td>WrongHeroAction</td>
-- <td>(function) Funktion, die für einen falschen Helden ausgeführt wird.</td>
-- </tr>
-- <tr>
-- <td>Active</td>
-- <td>(boolean) Steuert, ob der NPC aktiv ist.</td>
-- </tr>
-- </table>
--
-- @param[type=table] _Data NPC Table
-- @within Anwenderfunktionen
-- @usage
-- -- Einen NPC wieder aktivieren
-- MyNpc.Active = true;
-- MyNpc.TalkedTo = 0;
-- -- Die Aktion ändern
-- MyNpc.Callback = function(_Data)
--     -- mach was hier
-- end;
-- API.NpcUpdate(MyNpc);
--
function API.NpcUpdate(_Data)
    if GUI then
        return;
    end
    if not IsExisting(_Data.Name) then
        error("API.NpcUpdate: '" .._Data.Name.. "' NPC does not exist!");
        return;
    end
    if ModuleNpcInteraction.Global:GetNpc(_Data.Name) == nil then
        error("API.NpcUpdate: '" .._Data.Name.. "' NPC must first be composed!");
        return;
    end

    ModuleNpcInteraction.Global:UpdateNpc(_Data);
end

---
-- Prüft, ob der NPC gerade aktiv ist.
--
-- @param[type=table] _Data NPC Table
-- @return[type=boolean] NPC ist aktiv
-- @within Anwenderfunktionen
-- @usage
-- if API.NpcIsActive(MyNpc) then
--
function API.NpcIsActive(_Data)
    if GUI then
        return;
    end
    if not IsExisting(_Data.Name) then
        error("API.NpcIsActive: '" .._Data.Name.. "' NPC does not exist!");
        return;
    end
    local NPC = ModuleNpcInteraction.Global:GetNpc(_Data.Name);
    if NPC == nil then
        error("API.NpcIsActive: '" .._Data.Name.. "' NPC must first be composed!");
        return;
    end

    return NPC.Active == true and API.IsEntityActiveNpc(_Data.Name);
end

---
-- Prüft, ob ein NPC schon gesprochen hat und optional auch mit wem.
--
-- @param[type=table]  _Data     NPC Table
-- @param[type=string] _Hero     (Optional) Skriptname des Helden
-- @param[type=number] _PlayerID (Optional) Spieler ID
-- @within Anwenderfunktionen
-- 
-- @usage
-- -- Beispiel #1: Wurde mit NPC gesprochen
-- if API.NpcTalkedTo(MyNpc) then
-- 
-- @usage
-- -- Beispiel #2: Spieler hat mit NPC gesprochen
-- if API.NpcTalkedTo(MyNpc, nil, 1) then
-- 
-- @usage
-- -- Beispiel #3: Held des Spielers hat mit NPC gesprochen
-- if API.NpcTalkedTo(MyNpc, "Marcus", 1) then
--
function API.NpcTalkedTo(_Data, _Hero, _PlayerID)
    if GUI then
        return;
    end
    if not IsExisting(_Data.Name) then
        error("API.NpcTalkedTo: '" .._Data.Name.. "' NPC does not exist!");
        return;
    end
    if ModuleNpcInteraction.Global:GetNpc(_Data.Name) == nil then
        error("API.NpcTalkedTo: '" .._Data.Name.. "' NPC must first be composed!");
        return;
    end

    local NPC = ModuleNpcInteraction.Global:GetNpc(_Data.Name);
    local TalkedTo = NPC.TalkedTo ~= nil and NPC.TalkedTo ~= 0;
    if _Hero and TalkedTo then
        TalkedTo = NPC.TalkedTo == GetID(_Hero);
    end
    if _PlayerID and TalkedTo then
        TalkedTo = Logic.EntityGetPlayer(NPC.TalkedTo) == _PlayerID;
    end
    return TalkedTo;
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

--
-- Stellt neue Behavior für NPC.
--

---
-- Der Held muss einen Nichtspielercharakter ansprechen.
--
-- Es wird automatisch ein NPC erzeugt und überwacht, sobald der Quest
-- aktiviert wurde. Ein NPC darf nicht auf geblocktem Gebiet stehen oder
-- seine Enity-ID verändern.
--
-- <b>Hinweis</b>: Jeder Siedler kann zu jedem Zeitpunkt nur <u>einen</u> NPC 
-- haben. Wird ein weiterer NPC zugewiesen, wird der alte überschrieben und
-- der verknüpfte Quest funktioniert nicht mehr!
--
-- @param[type=string] _NpcName  Skriptname des NPC
-- @param[type=string] _HeroName (optional) Skriptname des Helden
-- @within Goal
--
function Goal_NPC(...)
    return B_Goal_NPC:new(...);
end

B_Goal_NPC = {
    Name             = "Goal_NPC",
    Description     = {
        en = "Goal: The hero has to talk to a non-player character.",
        de = "Ziel: Der Held muss einen Nichtspielercharakter ansprechen.",
        fr = "Objectif: le héros doit interpeller un personnage non joueur.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "NPC",  de = "NPC",  fr = "NPC" },
        { ParameterType.ScriptName, en = "Hero", de = "Held", fr = "Héro" },
    },
}

function B_Goal_NPC:GetGoalTable()
    return {Objective.Distance, -65565, self.Hero, self.NPC, self}
end

function B_Goal_NPC:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.NPC = _Parameter
    elseif (_Index == 1) then
        self.Hero = _Parameter
        if self.Hero == "-" then
            self.Hero = nil
        end
   end
end

function B_Goal_NPC:GetIcon()
    return {14,10}
end

Swift:RegisterBehavior(B_Goal_NPC);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleObjectInteraction = {
    Properties = {
        Name = "ModuleObjectInteraction",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        SlaveSequence = 0,
    };
    Local  = {};

    Shared = {
        Text = {}
    };
};

QSB.IO = {
    LastHeroEntityID = 0,
    LastObjectEntityID = 0
};

-- Global Script ------------------------------------------------------------ --

function ModuleObjectInteraction.Global:OnGameStart()
    QSB.ScriptEvents.ObjectClicked = API.RegisterScriptEvent("Event_ObjectClicked");
    QSB.ScriptEvents.ObjectInteraction = API.RegisterScriptEvent("Event_ObjectInteraction");
    QSB.ScriptEvents.ObjectReset = API.RegisterScriptEvent("Event_ObjectReset");
    QSB.ScriptEvents.ObjectDelete = API.RegisterScriptEvent("Event_ObjectDelete");

    IO = {};
    IO_UserDefindedNames = {};
    IO_SlaveToMaster = {};
    IO_SlaveState = {};

    self:OverrideObjectInteraction();
    self:StartObjectDestructionController();
    self:StartObjectConditionController();
    self:CreateDefaultObjectNames();
end

function ModuleObjectInteraction.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.ObjectInteraction then
        self:OnObjectInteraction(arg[1], arg[2], arg[3]);
    elseif _ID == QSB.ScriptEvents.ChatClosed then
        if arg[3] then
            self:ProcessChatInput(arg[1]);
        end
    end
end

function ModuleObjectInteraction.Global:OnObjectInteraction(_ScriptName, _KnightID, _PlayerID)
    QSB.IO.LastObjectEntityID = GetID(_ScriptName);
    QSB.IO.LastHeroEntityID = _KnightID;

    if IO_SlaveToMaster[_ScriptName] then
        _ScriptName = IO_SlaveToMaster[_ScriptName];
    end
    if IO[_ScriptName] then
        IO[_ScriptName].IsUsed = true;
        Logic.ExecuteInLuaLocalState(string.format(
            [[
                local ScriptName = "%s"
                if IO[ScriptName] then
                    IO[ScriptName].IsUsed = true
                end
            ]],
            _ScriptName
        ));
        if IO[_ScriptName].Action then
            IO[_ScriptName]:Action(_PlayerID, _KnightID);
        end
    end
end

function ModuleObjectInteraction.Global:CreateObject(_Description)
    local ID = GetID(_Description.Name);
    if ID == 0 then
        return;
    end
    self:DestroyObject(_Description.Name);

    local TypeName = Logic.GetEntityTypeName(Logic.GetEntityType(ID));
    if TypeName and not TypeName:find("^I_X_") then
        self:CreateSlaveObject(_Description);
    end

    _Description.IsActive = true;
    _Description.IsUsed = false;
    _Description.Player = _Description.Player or {1, 2, 3, 4, 5, 6, 7, 8};
    IO[_Description.Name] = _Description;
    Logic.ExecuteInLuaLocalState(string.format(
        [[IO["%s"] = %s]],
        _Description.Name,
        table.tostring(IO[_Description.Name])
    ));
    self:SetupObject(_Description);
    return _Description;
end

function ModuleObjectInteraction.Global:DestroyObject(_ScriptName)
    if not IO[_ScriptName] then
        return;
    end
    if IO[_ScriptName].Slave then
        IO_SlaveToMaster[IO[_ScriptName].Slave] = nil;
        Logic.ExecuteInLuaLocalState(string.format(
            [[IO_SlaveToMaster["%s"] = nil]],
            IO[_ScriptName].Slave
        ));
        IO_SlaveState[IO[_ScriptName].Slave] = nil;
        DestroyEntity(IO[_ScriptName].Slave);
    end
    self:SetObjectState(_ScriptName, 2);
    API.SendScriptEvent(QSB.ScriptEvents.ObjectDelete, _ScriptName);
    Logic.ExecuteInLuaLocalState(string.format(
        [[
            local ScriptName = "%s"
            API.SendScriptEvent(QSB.ScriptEvents.ObjectDelete, ScriptName)
            IO[ScriptName] = nil
        ]],
        _ScriptName
    ));
    IO[_ScriptName] = nil;
end

function ModuleObjectInteraction.Global:CreateSlaveObject(_Object)
    local Name;
    for k, v in pairs(IO_SlaveToMaster) do
        if v == _Object.Name and IsExisting(k) then
            Name = k;
        end
    end
    if Name == nil then
        self.SlaveSequence = self.SlaveSequence +1;
        Name = "QSB_SlaveObject_" ..self.SlaveSequence;
    end

    local SlaveID = GetID(Name);
    if not IsExisting(Name) then
        local x,y,z = Logic.EntityGetPos(GetID(_Object.Name));
        SlaveID = Logic.CreateEntity(Entities.I_X_DragonBoatWreckage, x, y, 0, 0);
        Logic.SetModel(SlaveID, Models.Effects_E_Mosquitos);
        Logic.SetEntityName(SlaveID, Name);
        IO_SlaveToMaster[Name] = _Object.Name;
        Logic.ExecuteInLuaLocalState(string.format(
            [[IO_SlaveToMaster["%s"] = "%s"]],
            Name,
            _Object.Name
        ));
        _Object.Slave = Name;
    end
    IO_SlaveState[Name] = 1;
    return SlaveID;
end

function ModuleObjectInteraction.Global:SetupObject(_Object)
    local ID = GetID((_Object.Slave and _Object.Slave) or _Object.Name);
    Logic.InteractiveObjectClearCosts(ID);
    Logic.InteractiveObjectClearRewards(ID);
    Logic.InteractiveObjectSetInteractionDistance(ID, _Object.Distance);
    Logic.InteractiveObjectSetTimeToOpen(ID, _Object.Waittime);

    local RewardResourceCart = _Object.RewardResourceCartType or Entities.U_ResourceMerchant;
    Logic.InteractiveObjectSetRewardResourceCartType(ID, RewardResourceCart);
    local RewardGoldCart = _Object.RewardGoldCartType or Entities.U_GoldCart;
    Logic.InteractiveObjectSetRewardGoldCartType(ID, RewardGoldCart);
    local CostResourceCart = _Object.CostResourceCartType or Entities.U_ResourceMerchant;
    Logic.InteractiveObjectSetCostResourceCartType(ID, CostResourceCart);
    local CostGoldCart = _Object.CostGoldCartType or Entities.U_GoldCart;
    Logic.InteractiveObjectSetCostGoldCartType(ID, CostGoldCart);

    if GetNameOfKeyInTable(Entities, _Object.Replacement) then
        Logic.InteractiveObjectSetReplacingEntityType(ID, _Object.Replacement);
    end
    if _Object.Reward then
        Logic.InteractiveObjectAddRewards(ID, _Object.Reward[1], _Object.Reward[2]);
    end
    if _Object.Costs and _Object.Costs[1] then
        Logic.InteractiveObjectAddCosts(ID, _Object.Costs[1], _Object.Costs[2]);
    end
    if _Object.Costs and _Object.Costs[3] then
        Logic.InteractiveObjectAddCosts(ID, _Object.Costs[3], _Object.Costs[4]);
    end
    table.insert(HiddenTreasures, ID);
    API.InteractiveObjectActivate(Logic.GetEntityName(ID), _Object.State or 0);
end

function ModuleObjectInteraction.Global:ResetObject(_ScriptName)
    local ID = GetID((IO[_ScriptName].Slave and IO[_ScriptName].Slave) or _ScriptName);
    RemoveInteractiveObjectFromOpenedList(ID);
    table.insert(HiddenTreasures, ID);
    Logic.InteractiveObjectSetAvailability(ID, true);
    self:SetObjectState(ID, IO[_ScriptName].State or 0);
    IO[_ScriptName].IsUsed = false;
    IO[_ScriptName].IsActive = true;

    API.SendScriptEvent(QSB.ScriptEvents.ObjectReset, _ScriptName);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.ObjectReset, "%s")]],
        _ScriptName
    ));
end

function ModuleObjectInteraction.Global:SetObjectState(_ScriptName, _State, ...)
    arg = ((not arg or #arg == 0) and {1, 2, 3, 4, 5, 6, 7, 8}) or arg;
    for i= 1, 8 do
        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, 2);
    end
    for i= 1, #arg, 1 do
        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), arg[i], _State);
    end
    Logic.InteractiveObjectSetAvailability(GetID(_ScriptName), _State ~= 2);
end

function ModuleObjectInteraction.Global:CreateDefaultObjectNames()
    IO_UserDefindedNames["D_X_ChestClosed"]    = {
        de = "Schatztruhe",
        en = "Treasure Chest",
        fr = "Coffre au Trésor"
    };
    IO_UserDefindedNames["D_X_ChestOpenEmpty"] = {
        de = "Leere Truhe",
        en = "Empty Chest",
        fr = "Coffre vide"
    };

    Logic.ExecuteInLuaLocalState(string.format(
        [[IO_UserDefindedNames = %s]],
        table.tostring(IO_UserDefindedNames)
    ));
end

function ModuleObjectInteraction.Global:OverrideObjectInteraction()
    GameCallback_OnObjectInteraction = function(_EntityID, _PlayerID)
        OnInteractiveObjectOpened(_EntityID, _PlayerID);
        OnTreasureFound(_EntityID, _PlayerID);

        local ScriptName = Logic.GetEntityName(_EntityID);
        if IO_SlaveToMaster[ScriptName] then
            ScriptName = IO_SlaveToMaster[ScriptName];
        end
        local KnightIDs = {};
        Logic.GetKnights(_PlayerID, KnightIDs);
        local KnightID = API.GetClosestToTarget(_EntityID, KnightIDs);
        API.SendScriptEvent(QSB.ScriptEvents.ObjectInteraction, ScriptName, KnightID, _PlayerID);
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.ObjectInteraction, "%s", %d, %d)]],
            ScriptName,
            KnightID,
            _PlayerID
        ));
    end

    QuestTemplate.AreObjectsActivated = function(self, _ObjectList)
        for i=1, _ObjectList[0] do
            if not _ObjectList[-i] then
                _ObjectList[-i] = GetID(_ObjectList[i]);
            end
            local EntityName = Logic.GetEntityName(_ObjectList[-i]);
            if IO_SlaveToMaster[EntityName] then
                EntityName = IO_SlaveToMaster[EntityName];
            end

            if IO[EntityName] then
                if IO[EntityName].IsUsed ~= true then
                    return false;
                end
            elseif Logic.IsInteractiveObject(_ObjectList[-i]) then
                if not IsInteractiveObjectOpen(_ObjectList[-i]) then
                    return false;
                end
            end
        end
        return true;
    end
end

function ModuleObjectInteraction.Global:ProcessChatInput(_Text)
    local Commands = Swift.Text:CommandTokenizer(_Text);
    for i= 1, #Commands, 1 do
        if Commands[1] == "enableobject" then
            local State = (Commands[3] and tonumber(Commands[3])) or nil;
            local PlayerID = (Commands[4] and tonumber(Commands[4])) or nil;
            if not IsExisting(Commands[2]) then
                error("object " ..Commands[2].. " does not exist!");
                return;
            end
            API.InteractiveObjectActivate(Commands[2], State, PlayerID);
            info("activated object " ..Commands[2].. ".");
        elseif Commands[1] == "disableobject" then
            local PlayerID = (Commands[3] and tonumber(Commands[3])) or nil;
            if not IsExisting(Commands[2]) then
                error("object " ..Commands[2].. " does not exist!");
                return;
            end
            API.InteractiveObjectDeactivate(Commands[2], PlayerID);
            info("deactivated object " ..Commands[2].. ".");
        elseif Commands[1] == "initobject" then
            if not IsExisting(Commands[2]) then
                error("object " ..Commands[2].. " does not exist!");
                return;
            end
            API.SetupObject({
                Name     = Commands[2],
                Waittime = 0,
                State    = 0
            });
            info("quick initalization of object " ..Commands[2].. ".");
        end
    end
end

function ModuleObjectInteraction.Global:StartObjectDestructionController()
    API.StartJobByEventType(Events.LOGIC_EVENT_ENTITY_DESTROYED, function()
        local DestryoedEntityID = Event.GetEntityID();
        local SlaveName  = Logic.GetEntityName(DestryoedEntityID);
        local MasterName = IO_SlaveToMaster[SlaveName];
        if SlaveName and MasterName then
            local Object = IO[MasterName];
            if not Object then
                return;
            end
            info("slave " ..SlaveName.. " of master " ..MasterName.. " has been deleted!");
            info("try to create new slave...");
            IO_SlaveToMaster[SlaveName] = nil;
            Logic.ExecuteInLuaLocalState(string.format(
                [[IO_SlaveToMaster["%s"] = nil]],
                SlaveName
            ));
            local SlaveID = ModuleObjectInteraction.Global:CreateSlaveObject(Object);
            if not IsExisting(SlaveID) then
                error("failed to create slave!");
                return;
            end
            ModuleObjectInteraction.Global:SetupObject(Object);
            if Object.IsUsed == true or (IO_SlaveState[SlaveName] and IO_SlaveState[SlaveName] == 0) then
                API.InteractiveObjectDeactivate(Object.Slave);
            end
            info("new slave created for master " ..MasterName.. ".");
        end
    end);
end

function ModuleObjectInteraction.Global:StartObjectConditionController()
    API.StartHiResJob(function()
        for k, v in pairs(IO) do
            if v and not v.IsUsed and v.IsActive then
                IO[k].IsFullfilled = true;
                if IO[k].Condition then
                    local IsFulfulled = v:Condition();
                    IO[k].IsFullfilled = IsFulfulled;
                end
                Logic.ExecuteInLuaLocalState(string.format(
                    [[
                        local ScriptName = "%s"
                        if IO[ScriptName] then
                            IO[ScriptName].IsFullfilled = %s
                        end
                    ]],
                    k,
                    tostring(IO[k].IsFullfilled)
                ))
            end
        end
    end);
end

-- Local Script ------------------------------------------------------------- --

function ModuleObjectInteraction.Local:OnGameStart()
    QSB.ScriptEvents.ObjectClicked = API.RegisterScriptEvent("Event_ObjectClicked");
    QSB.ScriptEvents.ObjectInteraction = API.RegisterScriptEvent("Event_ObjectInteraction");
    QSB.ScriptEvents.ObjectReset = API.RegisterScriptEvent("Event_ObjectReset");
    QSB.ScriptEvents.ObjectDelete = API.RegisterScriptEvent("Event_ObjectDelete");

    IO = {};
    IO_UserDefindedNames = {};
    IO_SlaveToMaster = {};
    IO_SlaveState = {};

    self:OverrideGameFunctions();
end

function ModuleObjectInteraction.Local:OnEvent(_ID, _ScriptName, _KnightID, _PlayerID)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.ObjectReset then
        if IO[_ScriptName] then
            IO[_ScriptName].IsUsed = false;
        end
    elseif _ID == QSB.ScriptEvents.ObjectInteraction then
        QSB.IO.LastObjectEntityID = GetID(_ScriptName);
        QSB.IO.LastHeroEntityID = _KnightID;
    end
end

function ModuleObjectInteraction.Local:OverrideGameFunctions()
    g_CurrentDisplayedQuestID = 0;

    GUI_Interaction.InteractiveObjectClicked_Orig_ModuleObjectInteraction = GUI_Interaction.InteractiveObjectClicked;
    GUI_Interaction.InteractiveObjectClicked = function()
        local i = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));
        local EntityID = g_Interaction.ActiveObjectsOnScreen[i];
        local PlayerID = GUI.GetPlayerID();
        if not EntityID then
            return;
        end
        local ScriptName = Logic.GetEntityName(EntityID);
        if IO_SlaveToMaster[ScriptName] then
            ScriptName = IO_SlaveToMaster[ScriptName];
        end
        if IO[ScriptName] then
            if not IO[ScriptName].IsFullfilled then
                local Text = XGUIEng.GetStringTableText("UI_ButtonDisabled/PromoteKnight");
                if IO[ScriptName].ConditionInfo then
                    Text = API.ConvertPlaceholders(API.Localize(IO[ScriptName].ConditionInfo));
                end
                Message(Text);
                return;
            end
            if type(IO[ScriptName].Costs) == "table" and #IO[ScriptName].Costs ~= 0 then
                local StoreHouseID = Logic.GetStoreHouse(PlayerID);
                local CastleID     = Logic.GetHeadquarters(PlayerID);
                if StoreHouseID == nil or StoreHouseID == 0 or CastleID == nil or CastleID == 0 then
                    GUI.AddNote("DEBUG: Player needs special buildings when using activation costs!");
                    return;
                end
            end
        end
        GUI_Interaction.InteractiveObjectClicked_Orig_ModuleObjectInteraction();

        -- Send additional click event
        -- This is supposed to be used in singleplayer only!
        if not Framework.IsNetworkGame() then
            local KnightIDs = {};
            Logic.GetKnights(PlayerID, KnightIDs);
            local KnightID = API.GetClosestToTarget(EntityID, KnightIDs);
            API.SendScriptEventToGlobal("ObjectClicked", ScriptName, KnightID, PlayerID);
            API.SendScriptEvent(QSB.ScriptEvents.ObjectClicked, ScriptName, KnightID, PlayerID);
        end
    end

    GUI_Interaction.InteractiveObjectUpdate = function()
        if g_Interaction.ActiveObjects == nil then
            return;
        end

        local PlayerID = GUI.GetPlayerID();
        for i = 1, #g_Interaction.ActiveObjects do
            local ObjectID = g_Interaction.ActiveObjects[i];
            local MasterObjectID = ObjectID;
            local ScriptName = Logic.GetEntityName(ObjectID);
            if IO_SlaveToMaster[ScriptName] then
                MasterObjectID = GetID(IO_SlaveToMaster[ScriptName]);
            end
            local X, Y = GUI.GetEntityInfoScreenPosition(MasterObjectID);
            local ScreenSizeX, ScreenSizeY = GUI.GetScreenSize();
            if X ~= 0 and Y ~= 0 and X > -50 and Y > -50 and X < (ScreenSizeX + 50) and Y < (ScreenSizeY + 50) then
                if not table.contains(g_Interaction.ActiveObjectsOnScreen, ObjectID) then
                    table.insert(g_Interaction.ActiveObjectsOnScreen, ObjectID);
                end
            else
                for i = 1, #g_Interaction.ActiveObjectsOnScreen do
                    if g_Interaction.ActiveObjectsOnScreen[i] == ObjectID then
                        table.remove(g_Interaction.ActiveObjectsOnScreen, i);
                    end
                end
            end
        end

        for i = 1, #g_Interaction.ActiveObjectsOnScreen do
            local Widget = "/InGame/Root/Normal/InteractiveObjects/" ..i;
            if XGUIEng.IsWidgetExisting(Widget) == 1 then
                local ObjectID       = g_Interaction.ActiveObjectsOnScreen[i];
                local MasterObjectID = ObjectID;
                local ScriptName     = Logic.GetEntityName(ObjectID);
                if IO_SlaveToMaster[ScriptName] then
                    MasterObjectID = GetID(IO_SlaveToMaster[ScriptName]);
                    ScriptName = Logic.GetEntityName(MasterObjectID);
                end
                local EntityType = Logic.GetEntityType(ObjectID);
                local X, Y = GUI.GetEntityInfoScreenPosition(MasterObjectID);
                local WidgetSize = {XGUIEng.GetWidgetScreenSize(Widget)};
                XGUIEng.SetWidgetScreenPosition(Widget, X - (WidgetSize[1]/2), Y - (WidgetSize[2]/2));
                local BaseCosts = {Logic.InteractiveObjectGetCosts(ObjectID)};
                local EffectiveCosts = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};
                local IsAvailable = Logic.InteractiveObjectGetAvailability(ObjectID);
                local HasSpace = Logic.InteractiveObjectHasPlayerEnoughSpaceForRewards(ObjectID, PlayerID);
                local Disable = false;

                if BaseCosts[1] ~= nil and EffectiveCosts[1] == nil and IsAvailable == true then
                    Disable = true;
                end
                if HasSpace == false then
                    Disable = true
                end
                if Disable == false then
                    if IO[ScriptName] and type(IO[ScriptName].Player) == "table" then
                        Disable = not self:IsAvailableForGuiPlayer(ScriptName);
                    elseif IO[ScriptName] and type(IO[ScriptName].Player) == "number" then
                        Disable = IO[ScriptName].Player ~= PlayerID;
                    end
                end

                if Disable == true then
                    XGUIEng.DisableButton(Widget, 1);
                else
                    XGUIEng.DisableButton(Widget, 0);
                end
                if GUI_Interaction.InteractiveObjectUpdateEx1 ~= nil then
                    GUI_Interaction.InteractiveObjectUpdateEx1(Widget, EntityType);
                end
                XGUIEng.ShowWidget(Widget, 1);
            end
        end

        for i = #g_Interaction.ActiveObjectsOnScreen + 1, 2 do
            local Widget = "/InGame/Root/Normal/InteractiveObjects/" .. i;
            XGUIEng.ShowWidget(Widget, 0);
        end

        for i = 1, #g_Interaction.ActiveObjectsOnScreen do
            local Widget     = "/InGame/Root/Normal/InteractiveObjects/" ..i;
            local ObjectID   = g_Interaction.ActiveObjectsOnScreen[i];
            local ScriptName = Logic.GetEntityName(ObjectID);
            if IO_SlaveToMaster[ScriptName] then
                ScriptName = IO_SlaveToMaster[ScriptName];
            end
            if IO[ScriptName] and IO[ScriptName].Texture then
                local FileBaseName;
                local a = (IO[ScriptName].Texture[1]) or 14;
                local b = (IO[ScriptName].Texture[2]) or 10;
                local c = (IO[ScriptName].Texture[3]) or 0;
                if type(c) == "string" then
                    FileBaseName = c;
                    c = 0;
                end
                API.SetIcon(Widget, {a, b, c}, nil, FileBaseName);
            end
        end
    end

    GUI_Interaction.InteractiveObjectMouseOver_Orig_ModuleObjectInteraction = GUI_Interaction.InteractiveObjectMouseOver;
    GUI_Interaction.InteractiveObjectMouseOver = function()
        local PlayerID = GUI.GetPlayerID();
        local ButtonNumber = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));
        local ObjectID = g_Interaction.ActiveObjectsOnScreen[ButtonNumber];
        local EntityType = Logic.GetEntityType(ObjectID);

        if g_GameExtraNo > 0 then
            local EntityTypeName = Logic.GetEntityTypeName(EntityType);
            if table.contains ({"R_StoneMine", "R_IronMine", "B_Cistern", "B_Well", "I_X_TradePostConstructionSite"}, EntityTypeName) then
                GUI_Interaction.InteractiveObjectMouseOver_Orig_ModuleObjectInteraction();
                return;
            end
        end
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);
        if string.find(EntityTypeName, "^I_X_") and tonumber(Logic.GetEntityName(ObjectID)) ~= nil then
            GUI_Interaction.InteractiveObjectMouseOver_Orig_ModuleObjectInteraction();
            return;
        end
        local Costs = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};
        local ScriptName = Logic.GetEntityName(ObjectID);
        if IO_SlaveToMaster[ScriptName] then
            ScriptName = IO_SlaveToMaster[ScriptName];
        end

        local CheckSettlement;
        if IO[ScriptName] and IO[ScriptName].IsUsed ~= true then
            local Key = "InteractiveObjectAvailable";
            if (IO[ScriptName] and type(IO[ScriptName].Player) == "table" and not self:IsAvailableForGuiPlayer(ScriptName))
            or (IO[ScriptName] and type(IO[ScriptName].Player) == "number" and IO[ScriptName].Player ~= PlayerID)
            or Logic.InteractiveObjectGetAvailability(ObjectID) == false then
                Key = "InteractiveObjectNotAvailable";
            end
            local DisabledKey;
            if Logic.InteractiveObjectHasPlayerEnoughSpaceForRewards(ObjectID, PlayerID) == false then
                DisabledKey = "InteractiveObjectAvailableReward";
            end
            local Title = IO[ScriptName].Title or ("UI_ObjectNames/" ..Key);
            Title = API.ConvertPlaceholders(API.Localize(Title));
            if Title and Title:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
                Title = XGUIEng.GetStringTableText(Title);
            end
            local Text = IO[ScriptName].Text or ("UI_ObjectDescription/" ..Key);
            Text = API.ConvertPlaceholders(API.Localize(Text));
            if Text and Text:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
                Text = XGUIEng.GetStringTableText(Text);
            end
            local Disabled = IO[ScriptName].DisabledText or DisabledKey;
            if Disabled then
                Disabled = API.ConvertPlaceholders(API.Localize(Disabled));
                if Disabled and Disabled:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
                    Disabled = XGUIEng.GetStringTableText(Disabled);
                end
            end
            Costs = IO[ScriptName].Costs;
            if Costs and Costs[1] and Costs[1] ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(Costs[1]) ~= GoodCategories.GC_Resource then
                CheckSettlement = true;
            end
            API.SetTooltipCosts(Title, Text, Disabled, Costs, CheckSettlement);
            return;
        end
        GUI_Interaction.InteractiveObjectMouseOver_Orig_ModuleObjectInteraction();
    end

    GUI_Interaction.DisplayQuestObjective_Orig_ModuleObjectInteraction = GUI_Interaction.DisplayQuestObjective
    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)
        local QuestIndexTemp = tonumber(_QuestIndex);
        if QuestIndexTemp then
            _QuestIndex = QuestIndexTemp;
        end

        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";
        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);
        local QuestObjectiveContainer;
        local QuestTypeCaption;

        g_CurrentDisplayedQuestID = _QuestIndex;

        if QuestType == Objective.Object then
            QuestObjectiveContainer = QuestObjectivesPath .. "/List";
            QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestInteraction");
            local ObjectList = {};

            for i = 1, Quest.Objectives[1].Data[0] do
                local ObjectType;
                if Logic.IsEntityDestroyed(Quest.Objectives[1].Data[i]) then
                    ObjectType = g_Interaction.SavedQuestEntityTypes[_QuestIndex][i];
                else
                    ObjectType = Logic.GetEntityType(GetID(Quest.Objectives[1].Data[i]));
                end
                local ObjectEntityName = Logic.GetEntityName(Quest.Objectives[1].Data[i]);
                local ObjectName = "";
                if ObjectType ~= nil and ObjectType ~= 0 then
                    local ObjectTypeName = Logic.GetEntityTypeName(ObjectType)
                    ObjectName = Wrapped_GetStringTableText(_QuestIndex, "Names/" .. ObjectTypeName);
                    if ObjectName == "" then
                        ObjectName = Wrapped_GetStringTableText(_QuestIndex, "UI_ObjectNames/" .. ObjectTypeName);
                    end
                    if ObjectName == "" then
                        ObjectName = IO_UserDefindedNames[ObjectTypeName];
                    end
                    if ObjectName == nil then
                        ObjectName = IO_UserDefindedNames[ObjectEntityName];
                    end
                    if ObjectName == nil then
                        ObjectName = "Debug: ObjectName missing for " .. ObjectTypeName;
                    end
                end
                table.insert(ObjectList, API.Localize(API.ConvertPlaceholders(ObjectName)));
            end
            for i = 1, 4 do
                local String = ObjectList[i];
                if String == nil then
                    String = "";
                end
                XGUIEng.SetText(QuestObjectiveContainer .. "/Entry" .. i, "{center}" .. String);
            end

            SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{14, 10});
            XGUIEng.SetText(QuestObjectiveContainer.."/Caption","{center}"..QuestTypeCaption);
            XGUIEng.ShowWidget(QuestObjectiveContainer, 1);
        else
            GUI_Interaction.DisplayQuestObjective_Orig_ModuleObjectInteraction(_QuestIndex, _MessageKey);
        end
    end
end

function ModuleObjectInteraction.Local:IsAvailableForGuiPlayer(_ScriptName)
    local PlayerID = GUI.GetPlayerID();
    if IO[_ScriptName] and type(IO[_ScriptName].Player) == "table" then
        for i= 1, 8 do
            if IO[_ScriptName].Player[i] and IO[_ScriptName].Player[i] == PlayerID then
                return true;
            end
        end
        return false;
    end
    return true;
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleObjectInteraction);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Erweitert die Möglichkeiten für die interaktiven Objekte.
--
-- <b>Befehle:</b><br>
-- <i>Diese Befehle können über die Konsole (SHIFT + ^) eingegeben werden, wenn
-- der Debug Mode aktiviert ist.</i><br>
-- <table border="1">
-- <tr>
-- <td><b>Befehl</b></td>
-- <td><b>Parameter</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>enableobject</td>
-- <td>ScriptName</td>
-- <td>Aktiviert das interaktive Objekt.</td>
-- </tr>
-- <tr>
-- <td>disableobject</td>
-- <td>ScriptName</td>
-- <td>Deaktiviert das interactive Objekt</td>
-- </tr>
-- <tr>
-- <td>initobject</td>
-- <td>ScriptName</td>
-- <td>Initialisiert ein interaktives Objekt grundlegend, sodass es benutzt werden kann.</td>
-- </tr>
-- </table>
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field ObjectClicked     Der Spieler klickt auf den Button des IO (Parameter: ScriptName, KnightID, PlayerID)
-- @field ObjectInteraction Es wird mit einem interaktiven Objekt interagiert (Parameter: ScriptName, KnightID, PlayerID)
-- @field ObjectDelete      Eine Interaktion wird von einem Objekt entfernt (Parameter: ScriptName)
-- @field ObjectReset       Der Zustand eines interaktiven Objekt wird zurückgesetzt (Parameter: ScriptName)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Erzeugt ein einfaches interaktives Objekt.
--
-- Dabei können alle Entities als interaktive Objekte behandelt werden, nicht
-- nur die, die eigentlich dafür vorgesehen sind.
--
-- Die Parameter des interaktiven Objektes werden durch seine Beschreibung
-- festgelegt. Die Beschreibung ist eine Table, die bestimmte Werte für das
-- Objekt beinhaltet. Dabei müssen nicht immer alle Werte angegeben werden.
--
-- <b>Achtung</b>: Wird eine Straße über einem Objekt platziert, während die
-- Kosten bereits bezahlt und auf dem Weg sind, läuft die Aktivierung ins Leere.
-- Zwar wird das Objekt zurückgesetzt, doch die bereits geschickten Waren sind
-- dann futsch.
--
-- Mögliche Angaben:
-- <table border="1">
-- <tr>
-- <td><b>Feldname</b></td>
-- <td><b>Typ</b></td>
-- <td><b>Beschreibung</b></td>
-- <td><b>Optional</b></td>
-- </tr>
-- <tr>
-- <td>Name</td>
-- <td>string</td>
-- <td>Der Skriptname des Entity, das zum interaktiven Objekt wird.</td>
-- <td>nein</td>
-- </tr>
-- <tr>
-- <td>Texture</td>
-- <td>table</td>
-- <td>Angezeigtes Icon des Buttons. Die Icons können auf die Icons des Spiels
-- oder auf eigene Icons zugreifen.
-- <br>- Spiel-Icons: {x, y, Spielversion}
-- <br>- Benutzerdefinierte Icons: {x, y, Dateinamenpräfix}</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Title</td>
-- <td>string</td>
-- <td>Angezeigter Titel des Objekt</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Text</td>
-- <td>string</td>
-- <td>Angezeigte Beschreibung des Objekt</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Distance</td>
-- <td>number</td>
-- <td>Die minimale Entfernung zum Objekt, die ein Held benötigt um das
-- objekt zu aktivieren.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Player</td>
-- <td>number|table</td>
-- <td>Spieler, der/die das Objekt aktivieren kann/können.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Waittime</td>
-- <td>number</td>
-- <td>Die Zeit, die ein Held benötigt, um das Objekt zu aktivieren.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Replacement</td>
-- <td>number</td>
-- <td>Entity, mit der das Objekt nach Aktivierung ersetzt wird.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Costs</td>
-- <td></td>
-- <td>Eine Table mit dem Typ und der Menge der Kosten. (Format: {Typ, Menge, Typ, Menge})</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Reward</td>
-- <td>table</td>
-- <td>Der Warentyp und die Menge der gefundenen Waren im Objekt. (Format: {Typ, Menge})</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>State</td>
-- <td>number</td>
-- <td>Bestimmt, wie sich der Button des interaktiven Objektes verhält.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Condition</td>
-- <td>function</td>
-- <td>Eine zusätzliche Aktivierungsbedinung als Funktion.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>ConditionInfo</td>
-- <td>string</td>
-- <td>Nachricht, die angezeigt wird, wenn die Bedinung nicht erfüllt ist.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Action</td>
-- <td>function</td>
-- <td>Eine Funktion, die nach der Aktivierung aufgerufen wird.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>RewardResourceCartType</td>
-- <td>number</td>
-- <td>Erlaubt, einen anderern Karren für Rohstoffkosten einstellen.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>RewardGoldCartType</td>
-- <td>number</td>
-- <td>Erlaubt, einen anderern Karren für Goldkosten einstellen.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>CostResourceCartType</td>
-- <td>number</td>
-- <td>Erlaubt, einen anderern Karren für Rohstoffbelohnungen einstellen.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>CostGoldCartType</td>
-- <td>number</td>
-- <td>Erlaubt, einen anderern Karren für Goldbelohnung einstellen.</td>
-- <td>ja</td>
-- </tr>
-- </table>
--
-- @param[type=table] _Description Beschreibung
-- @within Anwenderfunktionen
-- @see API.ResetObject
-- @see API.InteractiveObjectActivate
-- @see API.InteractiveObjectDeactivate
--
-- @usage
-- API.SetupObject {
--     Name     = "hut",
--     Distance = 1500,
--     Reward   = {Goods.G_Gold, 1000},
-- };
--
function API.SetupObject(_Description)
    if GUI then
        return;
    end
    return ModuleObjectInteraction.Global:CreateObject(_Description);
end
API.CreateObject = API.SetupObject;

---
-- Zerstört die Interation mit dem Objekt.
--
-- <b>Hinweis</b>: Das Entity selbst wird nicht zerstört.
--
-- @param[type=string] _ScriptName Skriptname des Objektes
-- @see API.SetupObject
-- @see API.ResetObject
-- @usage
-- API.DisposeObject("MyObject");
--
function API.DisposeObject(_ScriptName)
    if GUI or not IO[_ScriptName] then
        return;
    end
    ModuleObjectInteraction.Global:DestroyObject(_ScriptName);
end

---
-- Setzt das interaktive Objekt zurück. Dadurch verhält es sich, wie vor der
-- Aktivierung durch den Spieler.
--
-- <b>Hinweis</b>: Das Objekt muss wieder per Skript aktiviert werden, damit es
-- im Spiel ausgelöst werden.
--
-- @param[type=string] _ScriptName Skriptname des Objektes
-- @within Anwenderfunktionen
-- @see API.SetupObject
-- @see API.InteractiveObjectActivate
-- @see API.InteractiveObjectDeactivate
-- @usage
-- API.ResetObject("MyObject");
--
function API.ResetObject(_ScriptName)
    if GUI or not IO[_ScriptName] then
        return;
    end
    ModuleObjectInteraction.Global:ResetObject(_ScriptName);
    API.InteractiveObjectDeactivate(_ScriptName);
end

---
-- Aktiviert ein Interaktives Objekt, sodass es von den Spielern
-- aktiviert werden kann.
--
-- Optional kann das Objekt nur für einen bestimmten Spieler aktiviert werden.
--
-- Der State bestimmt, ob es immer aktiviert werden kann, oder ob der Spieler
-- einen Helden benutzen muss. Wird der Parameter weggelassen, muss immer ein
-- Held das Objekt aktivieren.
--
-- @param[type=string] _ScriptName Skriptname des Objektes
-- @param[type=number] _State      State des Objektes
-- @param[type=number] ...         (Optional) Liste mit PlayerIDs
-- @within Anwenderfunktionen
--
function API.InteractiveObjectActivate(_ScriptName, _State, ...)
    arg = arg or {1};
    if GUI then
        return;
    end
    if IO[_ScriptName] then
        local SlaveName = (IO[_ScriptName].Slave or _ScriptName);
        if IO[_ScriptName].Slave then
            IO_SlaveState[SlaveName] = 1;
            Logic.ExecuteInLuaLocalState(string.format(
                [[IO_SlaveState["%s"] = 1]],
                SlaveName
            ));
        end
        ModuleObjectInteraction.Global:SetObjectState(SlaveName, _State, unpack(arg));
        IO[_ScriptName].IsActive = true;
        Logic.ExecuteInLuaLocalState(string.format(
            [[IO["%s"].IsActive = true]],
            _ScriptName
        ));
    else
        ModuleObjectInteraction.Global:SetObjectState(_ScriptName, _State, unpack(arg));
    end
end
InteractiveObjectActivate = API.InteractiveObjectActivate;

---
-- Deaktiviert ein interaktives Objekt, sodass es nicht mehr von den Spielern
-- benutzt werden kann.
--
-- Optional kann das Objekt nur für einen bestimmten Spieler deaktiviert werden.
--
-- @param[type=string] _ScriptName Scriptname des Objektes
-- @param[type=number] ...         (Optional) Liste mit PlayerIDs
-- @within Anwenderfunktionen
--
function API.InteractiveObjectDeactivate(_ScriptName, ...)
    arg = arg or {1};
    if GUI then
        return;
    end
    if IO[_ScriptName] then
        local SlaveName = (IO[_ScriptName].Slave or _ScriptName);
        if IO[_ScriptName].Slave then
            IO_SlaveState[SlaveName] = 0;
            Logic.ExecuteInLuaLocalState(string.format(
                [[IO_SlaveState["%s"] = 0]],
                SlaveName
            ));
        end
        ModuleObjectInteraction.Global:SetObjectState(SlaveName, 2, unpack(arg));
        IO[_ScriptName].IsActive = false;
        Logic.ExecuteInLuaLocalState(string.format(
            [[IO["%s"].IsActive = false]],
            _ScriptName
        ));
    else
        ModuleObjectInteraction.Global:SetObjectState(_ScriptName, 2, unpack(arg));
    end
end
InteractiveObjectDeactivate = API.InteractiveObjectDeactivate;

---
-- Erzeugt eine Beschriftung für Custom Objects.
--
-- Im Questfenster werden die Namen von Custom Objects als ungesetzt angezeigt.
-- Mit dieser Funktion kann ein Name angelegt werden.
--
-- @param[type=string] _Key  Typname des Entity
-- @param              _Text Text der Beschriftung
-- @within Anwenderfunktionen
--
-- @usage
-- -- Beispiel #1: Einfache Beschriftung
-- API.InteractiveObjectSetQuestName("D_X_ChestOpenEmpty", "Leere Schatztruhe");
--
-- @usage
-- -- Beispiel #1: Multilinguale Beschriftung
-- API.InteractiveObjectSetQuestName("D_X_ChestClosed", {de = "Schatztruhe", en = "Treasure"});
--
function API.InteractiveObjectSetQuestName(_Key, _Text)
    if GUI then
        return;
    end
    IO_UserDefindedNames[_Key] = _Text;
    Logic.ExecuteInLuaLocalState(string.format(
        [[IO_UserDefindedNames["%s"] = %s]],
        _Key,
        table.tostring(IO_UserDefindedNames)
    ));
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

--
-- Stellt neue Behavior für Objekte bereit.
--

---
-- Der Spieler muss bis zu 4 interaktive Objekte benutzen.
--
-- @param[type=string] _Object1 Erstes Objekt
-- @param[type=string] _Object2 (optional) Zweites Objekt
-- @param[type=string] _Object3 (optional) Drittes Objekt
-- @param[type=string] _Object4 (optional) Viertes Objekt
--
-- @within Goal
--
function Goal_ActivateSeveralObjects(...)
    return B_Goal_ActivateSeveralObjects:new(...);
end

B_Goal_ActivateSeveralObjects = {
    Name = "Goal_ActivateSeveralObjects",
    Description = {
        en = "Goal: Activate an interactive object",
        de = "Ziel: Aktiviere ein interaktives Objekt",
        fr = "Objectif: activer un objet interactif",
    },
    Parameter = {
        { ParameterType.Default, en = "Object name 1", de = "Skriptname 1", fr = "Nom de l'entité 1" },
        { ParameterType.Default, en = "Object name 2", de = "Skriptname 2", fr = "Nom de l'entité 2" },
        { ParameterType.Default, en = "Object name 3", de = "Skriptname 3", fr = "Nom de l'entité 3" },
        { ParameterType.Default, en = "Object name 4", de = "Skriptname 4", fr = "Nom de l'entité 4" },
    },
    ScriptNames = {};
}

function B_Goal_ActivateSeveralObjects:GetGoalTable()
    return {Objective.Object, { unpack(self.ScriptNames) } }
end

function B_Goal_ActivateSeveralObjects:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        assert(_Parameter ~= nil and _Parameter ~= "", "Goal_ActivateSeveralObjects: At least one IO needed!");
    end
    if _Parameter ~= nil and _Parameter ~= "" then
        table.insert(self.ScriptNames, _Parameter);
    end
end

function B_Goal_ActivateSeveralObjects:GetMsgKey()
    return "Quest_Object_Activate"
end

Swift:RegisterBehavior(B_Goal_ActivateSeveralObjects);

-- -------------------------------------------------------------------------- --

-- Überschreibt ObjectInit, sodass auch Custom Objects verwaltet werden können.
B_Reward_ObjectInit.CustomFunction = function(self, _Quest)
    local EntityID = GetID(self.ScriptName);
    if EntityID == 0 then
        return;
    end
    QSB.InitalizedObjekts[EntityID] = _Quest.Identifier;

    local GoodReward;
    if self.RewardType and self.RewardType ~= "-" then
        GoodReward = {Goods[self.RewardType], self.RewardAmount};
    end

    local GoodCosts;
    if self.FirstCostType and self.FirstCostType ~= "-" then
        GoodCosts = GoodReward or {};
        table.insert(GoodCosts, Goods[self.FirstCostType]);
        table.insert(GoodCosts, Goods[self.FirstCostAmount]);
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        GoodCosts = GoodReward or {};
        table.insert(GoodCosts, Goods[self.SecondCostType]);
        table.insert(GoodCosts, Goods[self.SecondCostAmount]);
    end

    API.SetupObject {
        Name                   = self.ScriptName,
        Distance               = self.Distance,
        Waittime               = self.Waittime,
        Reward                 = GoodReward,
        Costs                  = GoodCosts,
    };
    API.InteractiveObjectActivate(self.ScriptName, self.UsingState);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleKnightTitleRequirements = {
    Properties = {
        Name = "ModuleKnightTitleRequirements",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {};
    Local  = {};

    Shared = {};
};

QSB.RequirementTooltipTypes = {};
QSB.ConsumedGoodsCounter = {};

-- Global Script ------------------------------------------------------------ --

function ModuleKnightTitleRequirements.Global:OnGameStart()
    QSB.ScriptEvents.KnightTitleChanged = API.RegisterScriptEvent("Event_KnightTitleChanged");
    QSB.ScriptEvents.GoodsConsumed = API.RegisterScriptEvent("Event_GoodsConsumed");

    self:OverrideKnightTitleChanged();
    self:OverwriteConsumedGoods();
end

function ModuleKnightTitleRequirements.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.KnightTitleChanged then
        local Consume = QSB.ConsumedGoodsCounter[arg[1]];
        QSB.ConsumedGoodsCounter[arg[1]] = Consume or {};
        for k,v in pairs(QSB.ConsumedGoodsCounter[arg[1]]) do
            QSB.ConsumedGoodsCounter[arg[1]][k] = 0;
        end
    elseif _ID == QSB.ScriptEvents.GoodsConsumed then
        local PlayerID = Logic.EntityGetPlayer(arg[1]);
        self:RegisterConsumedGoods(PlayerID, arg[2]);
    end
end

function ModuleKnightTitleRequirements.Global:RegisterConsumedGoods(_PlayerID, _Good)
    QSB.ConsumedGoodsCounter[_PlayerID]        = QSB.ConsumedGoodsCounter[_PlayerID] or {};
    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] or 0;
    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] +1;
end

function ModuleKnightTitleRequirements.Global:OverrideKnightTitleChanged()
    GameCallback_KnightTitleChanged_Orig_QSB_Requirements = GameCallback_KnightTitleChanged;
    GameCallback_KnightTitleChanged = function(_PlayerID, _TitleID)
        GameCallback_KnightTitleChanged_Orig_QSB_Requirements(_PlayerID, _TitleID);

        -- Send event
        API.SendScriptEvent(QSB.ScriptEvents.KnightTitleChanged, _PlayerID, _TitleID);
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.KnightTitleChanged, %d, %d)]],
            _PlayerID, _TitleID
        ));
    end
end

function ModuleKnightTitleRequirements.Global:OverwriteConsumedGoods()
    GameCallback_ConsumeGood_Orig_QSB_Requirements = GameCallback_ConsumeGood;
    GameCallback_ConsumeGood = function(_Consumer, _Good, _Building)
        GameCallback_ConsumeGood_Orig_QSB_Requirements(_Consumer, _Good, _Building)

        -- Send event
        API.SendScriptEvent(QSB.ScriptEvents.GoodsConsumed, _Consumer, _Good, _Building);
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.GoodsConsumed, %d, %d, %d)]],
            _Consumer, _Good, _Building
        ));
    end
end

-- Local Script ------------------------------------------------------------- --

function ModuleKnightTitleRequirements.Local:OnGameStart()
    QSB.ScriptEvents.KnightTitleChanged = API.RegisterScriptEvent("Event_KnightTitleChanged");
    QSB.ScriptEvents.GoodsConsumed = API.RegisterScriptEvent("Event_GoodsConsumed");

    self:OverwriteTooltips();
    self:InitTexturePositions();
    self:OverwriteUpdateRequirements();
end

function ModuleKnightTitleRequirements.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.KnightTitleChanged then
        local Consume = QSB.ConsumedGoodsCounter[arg[1]];
        QSB.ConsumedGoodsCounter[arg[1]] = Consume or {};
        for k,v in pairs(QSB.ConsumedGoodsCounter[arg[1]]) do
            QSB.ConsumedGoodsCounter[arg[1]][k] = 0;
        end
    elseif _ID == QSB.ScriptEvents.GoodsConsumed then
        local PlayerID = Logic.EntityGetPlayer(arg[1]);
        self:RegisterConsumedGoods(PlayerID, arg[2]);
    end
end

function ModuleKnightTitleRequirements.Local:RegisterConsumedGoods(_PlayerID, _Good)
    QSB.ConsumedGoodsCounter[_PlayerID]        = QSB.ConsumedGoodsCounter[_PlayerID] or {};
    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] or 0;
    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] +1;
end

function ModuleKnightTitleRequirements.Local:InitTexturePositions()
    g_TexturePositions.EntityCategories[EntityCategories.GC_Food_Supplier]          = { 1, 1};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Clothes_Supplier]       = { 1, 2};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Hygiene_Supplier]       = {16, 1};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Entertainment_Supplier] = { 1, 4};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Luxury_Supplier]        = {16, 3};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Weapon_Supplier]        = { 1, 7};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Medicine_Supplier]      = { 2,10};
    g_TexturePositions.EntityCategories[EntityCategories.Outpost]                   = {12, 3};
    g_TexturePositions.EntityCategories[EntityCategories.Spouse]                    = { 5,15};
    g_TexturePositions.EntityCategories[EntityCategories.CattlePasture]             = { 3,16};
    g_TexturePositions.EntityCategories[EntityCategories.SheepPasture]              = { 4, 1};
    g_TexturePositions.EntityCategories[EntityCategories.Soldier]                   = { 7,12};
    g_TexturePositions.EntityCategories[EntityCategories.GrainField]                = {14, 2};
    g_TexturePositions.EntityCategories[EntityCategories.BeeHive]                   = { 2, 1};
    g_TexturePositions.EntityCategories[EntityCategories.OuterRimBuilding]          = { 3, 4};
    g_TexturePositions.EntityCategories[EntityCategories.CityBuilding]              = { 8, 1};
    g_TexturePositions.EntityCategories[EntityCategories.Leader]                    = { 7, 11};
    g_TexturePositions.EntityCategories[EntityCategories.Range]                     = { 9, 8};
    g_TexturePositions.EntityCategories[EntityCategories.Melee]                     = { 9, 7};
    g_TexturePositions.EntityCategories[EntityCategories.SiegeEngine]               = { 2,15};

    g_TexturePositions.Entities[Entities.B_Beehive]                                 = { 2, 1};
    g_TexturePositions.Entities[Entities.B_Cathedral_Big]                           = { 3,12};
    g_TexturePositions.Entities[Entities.B_CattlePasture]                           = { 3,16};
    g_TexturePositions.Entities[Entities.B_GrainField_ME]                           = { 1,13};
    g_TexturePositions.Entities[Entities.B_GrainField_NA]                           = { 1,13};
    g_TexturePositions.Entities[Entities.B_GrainField_NE]                           = { 1,13};
    g_TexturePositions.Entities[Entities.B_GrainField_SE]                           = { 1,13};
    g_TexturePositions.Entities[Entities.U_MilitaryBallista]                        = {10, 5};
    g_TexturePositions.Entities[Entities.B_Outpost]                                 = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_ME]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_NA]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_NE]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_SE]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_SheepPasture]                            = { 4, 1};
    g_TexturePositions.Entities[Entities.U_SiegeEngineCart]                         = { 9, 4};
    g_TexturePositions.Entities[Entities.U_Trebuchet]                               = { 9, 1};
    if Framework.GetGameExtraNo() ~= 0 then
        g_TexturePositions.Entities[Entities.B_GrainField_AS]                       = { 1,13};
        g_TexturePositions.Entities[Entities.B_Outpost_AS]                          = {12, 3};
    end

    g_TexturePositions.Needs[Needs.Medicine]                                        = { 2,10};

    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_1]                = { 4, 7};
    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_2]                = { 4, 7};
    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_3]                = { 4, 7};
    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_1]             = { 4, 5};
    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_2]             = { 4, 5};
    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_3]             = { 4, 5};
    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_1]            = { 4, 6};
    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_2]            = { 4, 6};
    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_3]            = { 4, 6};

    g_TexturePositions.Buffs = g_TexturePositions.Buffs or {};

    g_TexturePositions.Buffs[Buffs.Buff_ClothesDiversity]                           = { 1, 2};
    g_TexturePositions.Buffs[Buffs.Buff_EntertainmentDiversity]                     = { 1, 4};
    g_TexturePositions.Buffs[Buffs.Buff_FoodDiversity]                              = { 1, 1};
    g_TexturePositions.Buffs[Buffs.Buff_HygieneDiversity]                           = { 1, 3};
    g_TexturePositions.Buffs[Buffs.Buff_Colour]                                     = { 5,11};
    g_TexturePositions.Buffs[Buffs.Buff_Entertainers]                               = { 5,12};
    g_TexturePositions.Buffs[Buffs.Buff_ExtraPayment]                               = { 1, 8};
    g_TexturePositions.Buffs[Buffs.Buff_Sermon]                                     = { 4,14};
    g_TexturePositions.Buffs[Buffs.Buff_Spice]                                      = { 5,10};
    g_TexturePositions.Buffs[Buffs.Buff_NoTaxes]                                    = { 1, 6};
    if Framework.GetGameExtraNo() ~= 0 then
        g_TexturePositions.Buffs[Buffs.Buff_Gems]                                   = { 1, 1, 1};
        g_TexturePositions.Buffs[Buffs.Buff_MusicalInstrument]                      = { 1, 3, 1};
        g_TexturePositions.Buffs[Buffs.Buff_Olibanum]                               = { 1, 2, 1};
    end

    g_TexturePositions.GoodCategories = g_TexturePositions.GoodCategories or {};

    g_TexturePositions.GoodCategories[GoodCategories.GC_Ammunition]                 = {10, 6};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Animal]                     = { 4,16};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Clothes]                    = { 1, 2};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Document]                   = { 5, 6};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Entertainment]              = { 1, 4};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Food]                       = { 1, 1};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Gold]                       = { 1, 8};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Hygiene]                    = {16, 1};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Luxury]                     = {16, 3};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Medicine]                   = { 2,10};
    g_TexturePositions.GoodCategories[GoodCategories.GC_None]                       = {15,16};
    g_TexturePositions.GoodCategories[GoodCategories.GC_RawFood]                    = { 3, 4};
    g_TexturePositions.GoodCategories[GoodCategories.GC_RawMedicine]                = { 2, 2};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Research]                   = { 5, 6};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Resource]                   = { 3, 4};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Tools]                      = { 4,12};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Water]                      = { 1,16};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Weapon]                     = { 8, 5};
end

function ModuleKnightTitleRequirements.Local:OverwriteUpdateRequirements()
    GUI_Knight.UpdateRequirements = function()
        local WidgetPos = ModuleKnightTitleRequirements.Local.RequirementWidgets;
        local RequirementsIndex = 1;

        local PlayerID = GUI.GetPlayerID();
        local CurrentTitle = Logic.GetKnightTitle(PlayerID);
        local NextTitle = CurrentTitle + 1;

        -- Headline
        local KnightID = Logic.GetKnightID(PlayerID);
        local KnightType = Logic.GetEntityType(KnightID);
        XGUIEng.SetText("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/NextKnightTitle", "{center}" .. GUI_Knight.GetTitleNameByTitleID(KnightType, NextTitle));
        XGUIEng.SetText("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/NextKnightTitleWhite", "{center}" .. GUI_Knight.GetTitleNameByTitleID(KnightType, NextTitle));

        -- show Settlers
        if KnightTitleRequirements[NextTitle].Settlers ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {5,16})
            local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfSettlersForKnightTitleExist(PlayerID, NextTitle)
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount)
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1)
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0)
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1)

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Settlers";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- show rich buildings
        if KnightTitleRequirements[NextTitle].RichBuildings ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {8,4});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfRichBuildingsForKnightTitleExist(PlayerID, NextTitle);
            if NeededAmount == -1 then
                NeededAmount = Logic.GetNumberOfPlayerEntitiesInCategory(PlayerID, EntityCategories.CityBuilding);
            end
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "RichBuildings";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Castle
        if KnightTitleRequirements[NextTitle].Headquarters ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,7});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Headquarters);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Headquarters";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Storehouse
        if KnightTitleRequirements[NextTitle].Storehouse ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,6});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Storehouse);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Storehouse";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Cathedral
        if KnightTitleRequirements[NextTitle].Cathedrals ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,5});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Cathedrals);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Cathedrals";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Volldekorierte Gebäude
        if KnightTitleRequirements[NextTitle].FullDecoratedBuildings ~= nil then
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist(PlayerID, NextTitle);
            local EntityCategory = KnightTitleRequirements[NextTitle].FullDecoratedBuildings;
            SetIcon(WidgetPos[RequirementsIndex].."/Icon"  , g_TexturePositions.Needs[Needs.Wealth]);

            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] , 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "FullDecoratedBuildings";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Stadtruf
        if KnightTitleRequirements[NextTitle].Reputation ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {5,14});
            local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededCityReputationForKnightTitleExist(PlayerID, NextTitle);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Reputation";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Güter sammeln
        if KnightTitleRequirements[NextTitle].Goods ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Goods do
                local GoodType = KnightTitleRequirements[NextTitle].Goods[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Goods[GoodType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfGoodTypesForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Goods" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Kategorien
        if KnightTitleRequirements[NextTitle].Category ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Category do
                local Category = KnightTitleRequirements[NextTitle].Category[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.EntityCategories[Category]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                local EntitiesInCategory = {Logic.GetEntityTypesInCategory(Category)};
                if Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.GC_Weapon_Supplier) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Weapons" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.SiegeEngine) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "HeavyWeapons" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Spouse) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Spouse" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Worker) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Worker" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Soldier) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Soldiers" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Leader) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Leader" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Outpost) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Outposts" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.CattlePasture) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Cattle" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.SheepPasture) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Sheep" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.CityBuilding) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "CityBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.OuterRimBuilding) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "OuterRimBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.GrainField) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "FarmerBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.BeeHive) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "FarmerBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.AttackableBuilding) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Buildings" .. i;
                else
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "EntityCategoryDefault" .. i;
                end
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Entities
        if KnightTitleRequirements[NextTitle].Entities ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Entities do
                local EntityType = KnightTitleRequirements[NextTitle].Entities[i][1];
                local EntityTypeName = Logic.GetEntityTypeName(EntityType);
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Entities[EntityType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                local TopltipType = "Entities" .. i;
                if EntityTypeName == "B_Beehive" or EntityTypeName:find("GrainField") or EntityTypeName:find("Pasture") then
                    TopltipType = "FarmerBuilding" .. i;
                end
                QSB.RequirementTooltipTypes[RequirementsIndex] = TopltipType;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Güter konsumieren
        if KnightTitleRequirements[NextTitle].Consume ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Consume do
                local GoodType = KnightTitleRequirements[NextTitle].Consume[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Goods[GoodType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfConsumedGoodsForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Consume" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Güter aus Gruppe produzieren
        if KnightTitleRequirements[NextTitle].Products ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Products do
                local Product = KnightTitleRequirements[NextTitle].Products[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.GoodCategories[Product]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoNumberOfProductsInCategoryExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Products" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Bonus aktivieren
        if KnightTitleRequirements[NextTitle].Buff ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Buff do
                local Buff = KnightTitleRequirements[NextTitle].Buff[i];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Buffs[Buff]);
                local IsFulfilled = DoNeededDiversityBuffForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "");
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Buff" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Selbstdefinierte Bedingung
        if KnightTitleRequirements[NextTitle].Custom ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Custom do
                local FileBaseName;
                local Icon = table.copy(KnightTitleRequirements[NextTitle].Custom[i][2]);
                if type(Icon[3]) == "string" then
                    FileBaseName = Icon[3];
                    Icon[3] = 0;
                end
                API.SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", Icon, nil, FileBaseName);
                local IsFulfilled, CurrentAmount, NeededAmount = DoCustomFunctionForKnightTitleSucceed(PlayerID, NextTitle, i);
                if CurrentAmount and NeededAmount then
                    XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                else
                    XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "");
                end
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Custom" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Dekorationselemente
        if KnightTitleRequirements[NextTitle].DecoratedBuildings ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].DecoratedBuildings do
                local GoodType = KnightTitleRequirements[NextTitle].DecoratedBuildings[i][1];
                SetIcon(WidgetPos[RequirementsIndex].."/Icon", g_TexturePositions.Goods[GoodType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "DecoratedBuildings" ..i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Übrige ausblenden
        for i=RequirementsIndex, 6 do
            XGUIEng.ShowWidget(WidgetPos[i], 0);
        end
    end
end

function ModuleKnightTitleRequirements.Local:OverwriteTooltips()
    GUI_Tooltip.SetNameAndDescription_Orig_QSB_Requirements = GUI_Tooltip.SetNameAndDescription;
    GUI_Tooltip.SetNameAndDescription = function(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean)
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local Selected = GUI.GetSelectedEntity();
        local PlayerID = GUI.GetPlayerID();

        for k,v in pairs(ModuleKnightTitleRequirements.Local.RequirementWidgets) do
            if v .. "/Icon" == XGUIEng.GetWidgetPathByID(CurrentWidgetID) then
                local key = QSB.RequirementTooltipTypes[k];
                local num = tonumber(string.sub(key, string.len(key)));
                if num ~= nil then
                    key = string.sub(key, 1, string.len(key)-1);
                end
                ModuleKnightTitleRequirements.Local:RequirementTooltipWrapped(key, num);
                return;
            end
        end
        GUI_Tooltip.SetNameAndDescription_Orig_QSB_Requirements(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean);
    end

    GUI_Knight.RequiredGoodTooltip = function()
        local key = QSB.RequirementTooltipTypes[2];
        local num = tonumber(string.sub(key, string.len(key)));
        if num ~= nil then
            key = string.sub(key, 1, string.len(key)-1);
        end
        ModuleKnightTitleRequirements.Local:RequirementTooltipWrapped(key, num);
    end

    if Framework.GetGameExtraNo() ~= 0 then
        ModuleKnightTitleRequirements.Local.BuffTypeNames[Buffs.Buff_Gems] = {
            de = "Edelsteine beschaffen",
            en = "Obtain gems",
            fr = "Se procurer des Gemmes",
        }
        ModuleKnightTitleRequirements.Local.BuffTypeNames[Buffs.Buff_Olibanum] = {
            de = "Weihrauch beschaffen",
            en = "Obtain olibanum",
            fr = "Se procurer de l'encens",
        }
        ModuleKnightTitleRequirements.Local.BuffTypeNames[Buffs.Buff_MusicalInstrument] = {
            de = "Muskinstrumente beschaffen",
            en = "Obtain instruments",
            fr = "Se procurer des instruments de musique",
        }
    end
end

function ModuleKnightTitleRequirements.Local:RequirementTooltipWrapped(_key, _i)
    local PlayerID = GUI.GetPlayerID();
    local KnightTitle = Logic.GetKnightTitle(PlayerID);
    local Title = ""
    local Text = "";

    if _key == "Consume" or _key == "Goods" or _key == "DecoratedBuildings" then
        local GoodType     = KnightTitleRequirements[KnightTitle+1][_key][_i][1];
        local GoodTypeName = Logic.GetGoodTypeName(GoodType);
        local GoodName     = XGUIEng.GetStringTableText("UI_ObjectNames/" .. GoodTypeName);

        if GoodName == nil then
            GoodName = "Goods." .. GoodTypeName;
        end
        Title = GoodName;
        Text  = ModuleKnightTitleRequirements.Local.Description[_key].Text;

    elseif _key == "Products" then
        local GoodCategoryNames = ModuleKnightTitleRequirements.Local.GoodCategoryNames;
        local Category = KnightTitleRequirements[KnightTitle+1][_key][_i][1];
        local CategoryName = API.Localize(GoodCategoryNames[Category]);

        if CategoryName == nil then
            CategoryName = "ERROR: Name missng!";
        end
        Title = CategoryName;
        Text  = ModuleKnightTitleRequirements.Local.Description[_key].Text;

    elseif _key == "Entities" then
        local EntityType     = KnightTitleRequirements[KnightTitle+1][_key][_i][1];
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);
        local EntityName = XGUIEng.GetStringTableText("Names/" .. EntityTypeName);

        if EntityName == nil then
            EntityName = "Entities." .. EntityTypeName;
        end

        Title = EntityName;
        Text  = ModuleKnightTitleRequirements.Local.Description[_key].Text;

    elseif _key == "Custom" then
        local Custom = KnightTitleRequirements[KnightTitle+1].Custom[_i];
        Title = Custom[3];
        Text  = Custom[4];

    elseif _key == "Buff" then
        local BuffTypeNames = ModuleKnightTitleRequirements.Local.BuffTypeNames;
        local BuffType = KnightTitleRequirements[KnightTitle+1][_key][_i];
        local BuffTitle = API.Localize(BuffTypeNames[BuffType]);

        if BuffTitle == nil then
            BuffTitle = "ERROR: Name missng!";
        end
        Title = BuffTitle;
        Text  = ModuleKnightTitleRequirements.Local.Description[_key].Text;

    else
        Title = ModuleKnightTitleRequirements.Local.Description[_key].Title;
        Text  = ModuleKnightTitleRequirements.Local.Description[_key].Text;
    end
    API.SetTooltipNormal(API.Localize(Title), API.Localize(Text), nil);
end

-- -------------------------------------------------------------------------- --

ModuleKnightTitleRequirements.Local.RequirementWidgets = {
    [1] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Settlers",
    [2] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Goods",
    [3] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/RichBuildings",
    [4] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Castle",
    [5] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Storehouse",
    [6] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Cathedral",
};

ModuleKnightTitleRequirements.Local.GoodCategoryNames = {
    [GoodCategories.GC_Ammunition]      = {de = "Munition",         en = "Ammunition",      fr = "Munition"},
    [GoodCategories.GC_Animal]          = {de = "Nutztiere",        en = "Livestock",       fr = "Animaux d'élevage"},
    [GoodCategories.GC_Clothes]         = {de = "Kleidung",         en = "Clothes",         fr = "Vêtements"},
    [GoodCategories.GC_Document]        = {de = "Dokumente",        en = "Documents",       fr = "Documents"},
    [GoodCategories.GC_Entertainment]   = {de = "Unterhaltung",     en = "Entertainment",   fr = "Divertissement"},
    [GoodCategories.GC_Food]            = {de = "Nahrungsmittel",   en = "Food",            fr = "Nourriture"},
    [GoodCategories.GC_Gold]            = {de = "Gold",             en = "Gold",            fr = "Or"},
    [GoodCategories.GC_Hygiene]         = {de = "Hygieneartikel",   en = "Hygiene",         fr = "Hygiène"},
    [GoodCategories.GC_Luxury]          = {de = "Dekoration",       en = "Decoration",      fr = "Décoration"},
    [GoodCategories.GC_Medicine]        = {de = "Medizin",          en = "Medicine",        fr = "Médecine"},
    [GoodCategories.GC_None]            = {de = "Nichts",           en = "None",            fr = "Rien"},
    [GoodCategories.GC_RawFood]         = {de = "Nahrungsmittel",   en = "Food",            fr = "Nourriture"},
    [GoodCategories.GC_RawMedicine]     = {de = "Medizin",          en = "Medicine",        fr = "Médecine"},
    [GoodCategories.GC_Research]        = {de = "Forschung",        en = "Research",        fr = "Recherche"},
    [GoodCategories.GC_Resource]        = {de = "Rohstoffe",        en = "Resource",        fr = "Ressources"},
    [GoodCategories.GC_Tools]           = {de = "Werkzeug",         en = "Tools",           fr = "Outils"},
    [GoodCategories.GC_Water]           = {de = "Wasser",           en = "Water",           fr = "Eau"},
    [GoodCategories.GC_Weapon]          = {de = "Waffen",           en = "Weapon",          fr = "Armes"},
};

ModuleKnightTitleRequirements.Local.BuffTypeNames = {
    [Buffs.Buff_ClothesDiversity]        = {de = "Vielfältige Kleidung",        en = "Clothes variety",         fr = "Diversité vestimentaire"},
    [Buffs.Buff_Colour]                  = {de = "Farben beschaffen",           en = "Obtain color",            fr = "Se procurer des couleurs"},
    [Buffs.Buff_Entertainers]            = {de = "Gaukler anheuern",            en = "Hire entertainer",        fr = "Engager des saltimbanques"},
    [Buffs.Buff_EntertainmentDiversity]  = {de = "Vielfältige Unterhaltung",    en = "Entertainment variety",   fr = "Diversité des divertissements"},
    [Buffs.Buff_ExtraPayment]            = {de = "Sonderzahlung",               en = "Extra payment",           fr = "Paiement supplémentaire"},
    [Buffs.Buff_Festival]                = {de = "Fest veranstalten",           en = "Hold Festival",           fr = "Organiser une fête"},
    [Buffs.Buff_FoodDiversity]           = {de = "Vielfältige Nahrung",         en = "Food variety",            fr = "Diversité alimentaire"},
    [Buffs.Buff_HygieneDiversity]        = {de = "Vielfältige Hygiene",         en = "Hygiene variety",         fr = "Diversité hygiénique"},
    [Buffs.Buff_NoTaxes]                 = {de = "Steuerbefreiung",             en = "No taxes",                fr = "Exonération fiscale"},
    [Buffs.Buff_Sermon]                  = {de = "Pregigt abhalten",            en = "Hold sermon",             fr = "Tenir des prêches"},
    [Buffs.Buff_Spice]                   = {de = "Salz beschaffen",             en = "Obtain salt",             fr = "Se procurer du sel"},
};

ModuleKnightTitleRequirements.Local.Description = {
    Settlers = {
        Title = {
            de = "Benötigte Siedler",
            en = "Needed settlers",
            fr = "Settlers nécessaires",
        },
        Text = {
            de = "- Benötigte Menge an Siedlern",
            en = "- Needed number of settlers",
            fr = "- Quantité de settlers nécessaire",
        },
    },

    RichBuildings = {
        Title = {
            de = "Reiche Häuser",
            en = "Rich city buildings",
            fr = "Bâtiments riches",
        },
        Text = {
            de = "- Menge an reichen Stadtgebäuden",
            en = "- Needed amount of rich city buildings",
            fr = "- Quantité de bâtiments de la ville riches",
        },
    },

    Goods = {
        Title = {
            de = "Waren lagern",
            en = "Store Goods",
            fr = "Entreposer des marchandises",
        },
        Text = {
            de = "- Benötigte Menge",
            en = "- Needed amount",
            fr = "- Quantité nécessaire",
        },
    },

    FullDecoratedBuildings = {
        Title = {
            de = "Dekorierte Häuser",
            en = "Decorated City buildings",
            fr = "Bâtiments décorés",
        },
        Text = {
            de = "- Menge an voll dekorierten Gebäuden",
            en = "- Amount of full decoraded city buildings",
            fr = "- Quantité de bâtiments entièrement décorés",
        },
    },

    DecoratedBuildings = {
        Title = {
            de = "Dekoration",
            en = "Decoration",
            fr = "Décoration",
        },
        Text = {
            de = "- Menge an Dekorationsgütern in der Siedlung",
            en = "- Amount of decoration goods in settlement",
            fr = "- Quantité de biens de décoration dans la ville",
        },
    },

    Headquarters = {
        Title = {
            de = "Burgstufe",
            en = "Castle level",
            fr = "Niveau du château",
        },
        Text = {
            de = "- Benötigte Ausbauten der Burg",
            en = "- Needed castle upgrades",
            fr = "- Améliorations nécessaires du château",
        },
    },

    Storehouse = {
        Title = {
            de = "Lagerhausstufe",
            en = "Storehouse level",
            fr = "Niveau de l'entrepôt",
        },
        Text = {
            de = "- Benötigte Ausbauten des Lagerhauses",
            en = "- Needed storehouse upgrades",
            fr = "- Améliorations nécessaires de l'entrepôt",
        },
    },

    Cathedrals = {
        Title = {
            de = "Kirchenstufe",
            en = "Cathedral level",
            fr = "Niveau de la cathédrale",
        },
        Text = {
            de = "- Benötigte Ausbauten der Kirche",
            en = "- Needed cathedral upgrades",
            fr = "- Améliorations nécessaires de la cathédrale",
        },
    },

    Reputation = {
        Title = {
            de = "Ruf der Stadt",
            en = "City reputation",
            fr = "Réputation de la ville",
        },
        Text = {
            de = "- Benötigter Ruf der Stadt",
            en = "- Needed city reputation",
            fr = "- Réputation de la ville nécessaire",
        },
    },

    EntityCategoryDefault = {
        Title = {
            de = "",
            en = "",
            fr = "",
        },
        Text = {
            de = "- Benötigte Anzahl",
            en = "- Needed amount",
            fr = "- Nombre requis",
        },
    },

    Cattle = {
        Title = {
            de = "Kühe",
            en = "Cattle",
            fr = "Vaches",
        },
        Text = {
            de = "- Benötigte Menge an Kühen",
            en = "- Needed amount of cattle",
            fr = "- Quantité de vaches nécessaire",
        },
    },

    Sheep = {
        Title = {
            de = "Schafe",
            en = "Sheeps",
            fr = "Moutons",
        },
        Text = {
            de = "- Benötigte Menge an Schafen",
            en = "- Needed amount of sheeps",
            fr = "- Quantité de moutons nécessaire",
        },
    },

    Outposts = {
        Title = {
            de = "Territorien",
            en = "Territories",
            fr = "Territoires",
        },
        Text = {
            de = "- Zu erobernde Territorien",
            en = "- Territories to claim",
            fr = "- Territoires à conquérir",
        },
    },

    CityBuilding = {
        Title = {
            de = "Stadtgebäude",
            en = "City buildings",
            fr = "Bâtiment de la ville",
        },
        Text = {
            de = "- Menge benötigter Stadtgebäude",
            en = "- Needed amount of city buildings",
            fr = "- Quantité de bâtiments urbains nécessaires",
        },
    },

    OuterRimBuilding = {
        Title = {
            de = "Rohstoffgebäude",
            en = "Gatherer",
            fr = "Cueilleur",
        },
        Text = {
            de = "- Menge benötigter Rohstoffgebäude",
            en = "- Needed amount of gatherer",
            fr = "- Quantité de bâtiments de matières premières nécessaires",
        },
    },

    FarmerBuilding = {
        Title = {
            de = "Farmeinrichtungen",
            en = "Farming structure",
            fr = "Installations de la ferme",
        },
        Text = {
            de = "- Menge benötigter Nutzfläche",
            en = "- Needed amount of farming structure",
            fr = "- Quantité de surface utile nécessaire",
        },
    },

    Consume = {
        Title = {
            de = "",
            en = "",
            fr = "",
        },
        Text = {
            de = "- Durch Siedler zu konsumierende Menge",
            en = "- Amount to be consumed by the settlers",
            fr = "- Quantité à consommer par les settlers",
        },
    },

    Products = {
        Title = {
            de = "",
            en = "",
            fr = "",
        },
        Text = {
            de = "- Benötigte Menge",
            en = "- Needed amount",
            fr = "- Quantité nécessaire",
        },
    },

    Buff = {
        Title = {
            de = "Bonus aktivieren",
            en = "Activate Buff",
            fr = "Activer bonus",
        },
        Text = {
            de = "- Aktiviere diesen Bonus auf den Ruf der Stadt",
            en = "- Raise the city reputatition with this buff",
            fr = "- Active ce bonus sur la réputation de la ville",
        },
    },

    Leader = {
        Title = {
            de = "Batalione",
            en = "Battalions",
            fr = "Battalions",
        },
        Text = {
            de = "- Menge an Batalionen unterhalten",
            en = "- Battalions you need under your command",
            fr = "- Maintenir une quantité de bataillons",
        },
    },

    Soldiers = {
        Title = {
            de = "Soldaten",
            en = "Soldiers",
            fr = "Soldats",
        },
        Text = {
            de = "- Menge an Streitkräften unterhalten",
            en = "- Soldiers you need under your command",
            fr = "- Maintenir une quantité de forces armées",
        },
    },

    Worker = {
        Title = {
            de = "Arbeiter",
            en = "Workers",
            fr = "Travailleurs",
        },
        Text = {
            de = "- Menge an arbeitender Bevölkerung",
            en = "- Workers you need under your reign",
            fr = "- Quantité de population au travail",
        },
    },

    Entities = {
        Title = {
            de = "",
            en = "",
            fr = "",
        },
        Text = {
            de = "- Benötigte Menge",
            en = "- Needed Amount",
            fr = "- Quantité nécessaire",
        },
    },

    Buildings = {
        Title = {
            de = "Gebäude",
            en = "Buildings",
            fr = "Bâtiments",
        },
        Text = {
            de = "- Gesamtmenge an Gebäuden",
            en = "- Amount of buildings",
            fr = "- Total des bâtiments",
        },
    },

    Weapons = {
        Title = {
            de = "Waffen",
            en = "Weapons",
            fr = "Armes",
        },
        Text = {
            de = "- Benötigte Menge an Waffen",
            en = "- Needed amount of weapons",
            fr = "- Quantité d'armes nécessaire",
        },
    },

    HeavyWeapons = {
        Title = {
            de = "Belagerungsgeräte",
            en = "Siege Engines",
            fr = "Matériel de siège",
        },
        Text = {
            de = "- Benötigte Menge an Belagerungsgeräten",
            en = "- Needed amount of siege engine",
            fr = "- Quantité de matériel de siège nécessaire",
        },
    },

    Spouse = {
        Title = {
            de = "Ehefrauen",
            en = "Spouses",
            fr = "Épouses",
        },
        Text = {
            de = "- Benötigte Anzahl Ehefrauen in der Stadt",
            en = "- Needed amount of spouses in your city",
            fr = "- Nombre d'épouses nécessaires dans la ville",
        },
    },
};

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleKnightTitleRequirements);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Ermöglicht das Anpassen der Aufstiegsbedingungen.
--
-- Die Aufstiegsbedingungen werden in der Funktion InitKnightTitleTables
-- angegeben und bearbeitet.
--
-- <b>Achtung</b>: es können maximal 6 Bedingungen angezeigt werden!
--
-- <p>Mögliche Aufstiegsbedingungen:
-- <ul>
-- <li><b>Entitytyp besitzen</b><br/>
-- Der Spieler muss eine bestimmte Anzahl von Entities eines Typs besitzen.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Entities = {
--     {Entities.B_Bakery, 2},
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Entitykategorie besitzen</b><br/>
-- Der Spieler muss eine bestimmte Anzahl von Entities einer Kategorie besitzen.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Category = {
--     {EntitiyCategories.CattlePasture, 10},
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Gütertyp besitzen</b><br/>
-- Der Spieler muss Rohstoffe oder Güter eines Typs besitzen.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Goods = {
--     {Goods.G_RawFish, 35},
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Produkte erzeugen</b><br/>
-- Der Spieler muss Gebrauchsgegenstände für ein Bedürfnis bereitstellen. Hier
-- werden nicht die Warentypen sonderen deren Kategorie angegeben.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Products = {
--     {GoodCategories.GC_Clothes, 6},
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Güter konsumieren</b><br/>
-- Die Siedler müssen eine Menge einer bestimmten Waren konsumieren.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Consume = {
--     {Goods.G_Bread, 30},
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Buffs aktivieren</b><br/>
-- Der Spieler muss einen Buff aktivieren.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Buff = {
--     Buffs.Buff_FoodDiversity,
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Stadtruf erreichen</b><br/>
-- Der Ruf der Stadt muss einen bestimmten Wert erreichen oder überschreiten.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Reputation = 20
-- </code></pre>
--
-- <li><b>Anzahl an Dekorationen</b><br/>
-- Der Spieler muss mindestens die Anzahl der angegebenen Dekoration besitzen.
-- <code><pre>
-- KnightTitleRequirements[KnightTitles.Mayor].DecoratedBuildings = {
--     {Goods.G_Banner, 9 },
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Anzahl voll dekorierter Gebäude</b><br/>
-- Anzahl an Gebäuden, an die alle vier Dekorationen angebracht sein müssen.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].FullDecoratedBuildings = 12
-- </code></pre>
-- </li>
--
-- <li><b>Spezialgebäude ausbauen</b><br/>
-- Ein Spezielgebäude muss ausgebaut werden.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Headquarters = 1
-- KnightTitleRequirements[KnightTitles.Mayor].Storehouse = 1
-- KnightTitleRequirements[KnightTitles.Mayor].Cathedrals = 1
-- </code></pre>
-- </li>
--
-- <li><b>Anzahl Siedler</b><br/>
-- Der Spieler benötigt eine Gesamtzahl an Siedlern.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Settlers = 40
-- </code></pre>
-- </li>
--
-- <li><b>Anzahl reiche Stadtgebäude</b><br/>
-- Eine Anzahl an Gebäuden muss durch Einnahmen Reichtum erlangen.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].RichBuildings = 30
-- </code></pre>
-- </li>
--
-- <li><b>Benutzerdefiniert</b><br/>
-- Eine benutzerdefinierte Funktion, die entweder als Schalter oder als Zähler
-- fungieren kann und true oder false zurückgeben muss. Soll ein Zähler
-- angezeigt werden, muss nach dem Wahrheitswert der aktuelle und der maximale
-- Wert des Zählers folgen.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Custom = {
--     {SomeFunction, {1, 1}, "Überschrift", "Beschreibung"}
--     ...
-- }
--
-- -- Funktion prüft Schalter
-- function SomeFunction(_PlayerID, _NextTitle, _Index)
--     return gvMission.MySwitch == true;
-- end
-- -- Funktion prüft Zähler
-- function SomeFunction(_PlayerID, _NextTitle, _Index)
--     return gvMission.MyCounter == 6, gvMission.MyCounter, 6;
-- end
-- </code></pre>
-- </li>
-- </ul></p>
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- </ul>
-- 
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field KnightTitleChanged Der Spieler hat einen neuen Titel erlangt (Parameter: PlayerID, TitleID)
-- @field GoodsConsumed      Güter werden von Siedlern konsumiert (Parameter: ConsumerID, GoodType, BuildingID)
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

-- Internal ----------------------------------------------------------------- --

---
-- Prüft, ob genug Entities in einer bestimmten Kategorie existieren.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Category == nil then
        return;
    end
    if _i then
        local EntityCategory = KnightTitleRequirements[_KnightTitle].Category[_i][1];
        local NeededAmount = KnightTitleRequirements[_KnightTitle].Category[_i][2];

        local ReachedAmount = 0;
        if EntityCategory == EntityCategories.Spouse then
            ReachedAmount = Logic.GetNumberOfSpouses(_PlayerID);
        else
            local Buildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategory)};
            for i=1, #Buildings do
                if Logic.IsBuilding(Buildings[i]) == 1 then
                    if Logic.IsConstructionComplete(Buildings[i]) == 1 then
                        ReachedAmount = ReachedAmount +1;
                    end
                else
                    ReachedAmount = ReachedAmount +1;
                end
            end
        end

        if ReachedAmount >= NeededAmount then
            return true, ReachedAmount, NeededAmount;
        end
        return false, ReachedAmount, NeededAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Category do
            bool, reach, need = DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob genug Entities eines bestimmten Typs existieren.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Entities == nil then
        return;
    end
    if _i then
        local EntityType = KnightTitleRequirements[_KnightTitle].Entities[_i][1];
        local NeededAmount = KnightTitleRequirements[_KnightTitle].Entities[_i][2];
        local Buildings = GetPlayerEntities(_PlayerID, EntityType);

        local ReachedAmount = 0;
        for i=1, #Buildings do
            if Logic.IsBuilding(Buildings[i]) == 1 then
                if Logic.IsConstructionComplete(Buildings[i]) == 1 then
                    ReachedAmount = ReachedAmount +1;
                end
            else
                ReachedAmount = ReachedAmount +1;
            end
        end

        if ReachedAmount >= NeededAmount then
            return true, ReachedAmount, NeededAmount;
        end
        return false, ReachedAmount, NeededAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Entities do
            bool, reach, need = DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob es genug Einheiten eines Warentyps gibt.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoesNeededNumberOfGoodTypesForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Goods == nil then
        return;
    end
    if _i then
        local GoodType = KnightTitleRequirements[_KnightTitle].Goods[_i][1];
        local NeededAmount = KnightTitleRequirements[_KnightTitle].Goods[_i][2];
        local ReachedAmount = GetPlayerGoodsInSettlement(GoodType, _PlayerID, true);

        if ReachedAmount >= NeededAmount then
            return true, ReachedAmount, NeededAmount;
        end
        return false, ReachedAmount, NeededAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Goods do
            bool, reach, need = DoesNeededNumberOfGoodTypesForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob die Siedler genug Einheiten einer Ware konsumiert haben.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoNeededNumberOfConsumedGoodsForKnightTitleExist = function( _PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Consume == nil then
        return;
    end
    if _i then
        QSB.ConsumedGoodsCounter[_PlayerID] = QSB.ConsumedGoodsCounter[_PlayerID] or {};

        local GoodType = KnightTitleRequirements[_KnightTitle].Consume[_i][1];
        local GoodAmount = QSB.ConsumedGoodsCounter[_PlayerID][GoodType] or 0;
        local NeededGoodAmount = KnightTitleRequirements[_KnightTitle].Consume[_i][2];
        if GoodAmount >= NeededGoodAmount then
            return true, GoodAmount, NeededGoodAmount;
        else
            return false, GoodAmount, NeededGoodAmount;
        end
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Consume do
            bool, reach, need = DoNeededNumberOfConsumedGoodsForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return false, reach, need
            end
        end
        return true, reach, need;
    end
end

---
-- Prüft, ob genug Waren der Kategorie hergestellt wurde.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoNumberOfProductsInCategoryExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Products == nil then
        return;
    end
    if _i then
        local GoodAmount = 0;
        local NeedAmount = KnightTitleRequirements[_KnightTitle].Products[_i][2];
        local GoodCategory = KnightTitleRequirements[_KnightTitle].Products[_i][1];
        local GoodsInCategory = {Logic.GetGoodTypesInGoodCategory(GoodCategory)};

        for i=1, #GoodsInCategory do
            GoodAmount = GoodAmount + GetPlayerGoodsInSettlement(GoodsInCategory[i], _PlayerID, true);
        end
        return (GoodAmount >= NeedAmount), GoodAmount, NeedAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Products do
            bool, reach, need = DoNumberOfProductsInCategoryExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob ein bestimmter Buff für den Spieler aktiv ist.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoNeededDiversityBuffForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Buff == nil then
        return;
    end
    if _i then
        local buff = KnightTitleRequirements[_KnightTitle].Buff[_i];
        if Logic.GetBuff(_PlayerID,buff) and Logic.GetBuff(_PlayerID,buff) ~= 0 then
            return true;
        end
        return false;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Buff do
            bool, reach, need = DoNeededDiversityBuffForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob die Custom Function true vermeldet.
--
-- <b>Hinweis</b>: Die Funktion wird innerhalb eines GUI Update aufgerufen.
-- Schreibe daher effizienten Lua Code!
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoCustomFunctionForKnightTitleSucceed = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Custom == nil then
        return;
    end
    if _i then
        return KnightTitleRequirements[_KnightTitle].Custom[_i][1](_PlayerID, _KnightTitle, _i);
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Custom do
            bool, reach, need = DoCustomFunctionForKnightTitleSucceed(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob genug Dekoration eines Typs angebracht wurde.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoNeededNumberOfDecoratedBuildingsForKnightTitleExist = function( _PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].DecoratedBuildings == nil then
        return
    end

    if _i then
        local CityBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)}
        local DecorationGoodType = KnightTitleRequirements[_KnightTitle].DecoratedBuildings[_i][1]
        local NeededBuildingsWithDecoration = KnightTitleRequirements[_KnightTitle].DecoratedBuildings[_i][2]
        local BuildingsWithDecoration = 0

        for i=1, #CityBuildings do
            local BuildingID = CityBuildings[i]
            local GoodState = Logic.GetBuildingWealthGoodState(BuildingID, DecorationGoodType)
            if GoodState > 0 then
                BuildingsWithDecoration = BuildingsWithDecoration + 1
            end
        end

        if BuildingsWithDecoration >= NeededBuildingsWithDecoration then
            return true, BuildingsWithDecoration, NeededBuildingsWithDecoration
        else
            return false, BuildingsWithDecoration, NeededBuildingsWithDecoration
        end
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].DecoratedBuildings do
            bool, reach, need = DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob die Spezialgebäude weit genug ausgebaut sind.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _EntityCategory Entity Category
-- @within Originalfunktionen
-- @local
--
DoNeededSpecialBuildingUpgradeForKnightTitleExist = function( _PlayerID, _KnightTitle, _EntityCategory)
    local SpecialBuilding
    local SpecialBuildingName
    if _EntityCategory == EntityCategories.Headquarters then
        SpecialBuilding = Logic.GetHeadquarters(_PlayerID)
        SpecialBuildingName = "Headquarters"
    elseif _EntityCategory == EntityCategories.Storehouse then
        SpecialBuilding = Logic.GetStoreHouse(_PlayerID)
        SpecialBuildingName = "Storehouse"
    elseif _EntityCategory == EntityCategories.Cathedrals then
        SpecialBuilding = Logic.GetCathedral(_PlayerID)
        SpecialBuildingName = "Cathedrals"
    else
        return
    end
    if KnightTitleRequirements[_KnightTitle][SpecialBuildingName] == nil then
        return
    end
    local NeededUpgradeLevel = KnightTitleRequirements[_KnightTitle][SpecialBuildingName]
    if SpecialBuilding ~= nil then
        local SpecialBuildingUpgradeLevel = Logic.GetUpgradeLevel(SpecialBuilding)
        if SpecialBuildingUpgradeLevel >= NeededUpgradeLevel then
            return true, SpecialBuildingUpgradeLevel, NeededUpgradeLevel
        else
            return false, SpecialBuildingUpgradeLevel, NeededUpgradeLevel
        end
    else
        return false, 0, NeededUpgradeLevel
    end
end

---
-- Prüft, ob der Ruf der Stadt hoch genug ist.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @within Originalfunktionen
-- @local
--
DoesNeededCityReputationForKnightTitleExist = function(_PlayerID, _KnightTitle)
    if KnightTitleRequirements[_KnightTitle].Reputation == nil then
        return;
    end
    local NeededAmount = KnightTitleRequirements[_KnightTitle].Reputation;
    if not NeededAmount then
        return;
    end
    local ReachedAmount = math.floor((Logic.GetCityReputation(_PlayerID) * 100) + 0.5);
    if ReachedAmount >= NeededAmount then
        return true, ReachedAmount, NeededAmount;
    end
    return false, ReachedAmount, NeededAmount;
end

---
-- Prüft, ob genug Gebäude vollständig dekoriert sind.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @within Originalfunktionen
-- @local
--
DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist = function( _PlayerID, _KnightTitle)
    if KnightTitleRequirements[_KnightTitle].FullDecoratedBuildings == nil then
        return
    end
    local CityBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)}
    local NeededBuildingsWithDecoration = KnightTitleRequirements[_KnightTitle].FullDecoratedBuildings
    local BuildingsWithDecoration = 0

    for i=1, #CityBuildings do
        local BuildingID = CityBuildings[i]
        local AmountOfWealthGoodsAtBuilding = 0

        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Banner ) > 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Sign  ) > 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Candle) > 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Ornament  ) > 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if AmountOfWealthGoodsAtBuilding >= 4 then
            BuildingsWithDecoration = BuildingsWithDecoration + 1
        end
    end

    if BuildingsWithDecoration >= NeededBuildingsWithDecoration then
        return true, BuildingsWithDecoration, NeededBuildingsWithDecoration
    else
        return false, BuildingsWithDecoration, NeededBuildingsWithDecoration
    end
end

---
-- Prüft, ob der Spieler befördert werden kann.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @within Originalfunktionen
-- @local
--
CanKnightBePromoted = function(_PlayerID, _KnightTitle)
    if _KnightTitle == nil then
        _KnightTitle = Logic.GetKnightTitle(_PlayerID) + 1;
    end

    if Logic.CanStartFestival(_PlayerID, 1) == true then
        if  KnightTitleRequirements[_KnightTitle] ~= nil
        and DoesNeededNumberOfSettlersForKnightTitleExist(_PlayerID, _KnightTitle) ~= false
        and DoNeededNumberOfGoodsForKnightTitleExist( _PlayerID, _KnightTitle)  ~= false
        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Headquarters) ~= false
        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Storehouse) ~= false
        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Cathedrals)  ~= false
        and DoNeededNumberOfRichBuildingsForKnightTitleExist( _PlayerID, _KnightTitle)  ~= false
        and DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoNeededNumberOfDecoratedBuildingsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoesNeededCityReputationForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoesNeededNumberOfGoodTypesForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoNeededDiversityBuffForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoCustomFunctionForKnightTitleSucceed( _PlayerID, _KnightTitle) ~= false
        and DoNeededNumberOfConsumedGoodsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoNumberOfProductsInCategoryExist( _PlayerID, _KnightTitle) ~= false then
            return true;
        end
    end
    return false;
end

---
-- Der Spieler gewinnt das Spiel
-- @within Originalfunktionen
-- @local
--
VictroryBecauseOfTitle = function()
    QuestTemplate:TerminateEventsAndStuff();
    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

--
-- Definiert den Standard der Aufstiegsbedingungen für den Spieler.
--

---
-- Diese Funktion muss entweder in der QSB modifiziert oder sowohl im globalen
-- als auch im lokalen Skript überschrieben werden. Ideal ist laden des
-- angepassten Skriptes als separate Datei. Bei Modifikationen muss das Schema
-- für Aufstiegsbedingungen und Rechtevergabe immer beibehalten werden.
--
-- <b>Hinweis</b>: Diese Funktion wird <b>automatisch</b> vom Code ausgeführt.
-- Du rufst sie <b>niemals</b> selbst auf!
--
-- @within Originalfunktionen
--
-- @usage
-- -- Dies ist ein Beispiel zum herauskopieren. Hier sind die üblichen
-- -- Bedingungen gesetzt. Wenn du diese Funktion in dein Skript kopierst, muss
-- -- sie im globalen und lokalen Skript stehen oder dort geladen werden!
-- InitKnightTitleTables = function()
--     KnightTitles = {}
--     KnightTitles.Knight     = 0
--     KnightTitles.Mayor      = 1
--     KnightTitles.Baron      = 2
--     KnightTitles.Earl       = 3
--     KnightTitles.Marquees   = 4
--     KnightTitles.Duke       = 5
--     KnightTitles.Archduke   = 6
--
--     -- ---------------------------------------------------------------------- --
--     -- Rechte und Pflichten                                                   --
--     -- ---------------------------------------------------------------------- --
--
--     NeedsAndRightsByKnightTitle = {}
--
--     -- Ritter ------------------------------------------------------------------
--
--     NeedsAndRightsByKnightTitle[KnightTitles.Knight] = {
--         ActivateNeedForPlayer,
--         {
--             Needs.Nutrition,                                    -- Bedürfnis: Nahrung
--             Needs.Medicine,                                     -- Bedürfnis: Medizin
--         },
--         ActivateRightForPlayer,
--         {
--             Technologies.R_Gathering,                           -- Recht: Rohstoffsammler
--             Technologies.R_Woodcutter,                          -- Recht: Holzfäller
--             Technologies.R_StoneQuarry,                         -- Recht: Steinbruch
--             Technologies.R_HuntersHut,                          -- Recht: Jägerhütte
--             Technologies.R_FishingHut,                          -- Recht: Fischerhütte
--             Technologies.R_CattleFarm,                          -- Recht: Kuhfarm
--             Technologies.R_GrainFarm,                           -- Recht: Getreidefarm
--             Technologies.R_SheepFarm,                           -- Recht: Schaffarm
--             Technologies.R_IronMine,                            -- Recht: Eisenmine
--             Technologies.R_Beekeeper,                           -- Recht: Imkerei
--             Technologies.R_HerbGatherer,                        -- Recht: Kräutersammler
--             Technologies.R_Nutrition,                           -- Recht: Nahrung
--             Technologies.R_Bakery,                              -- Recht: Bäckerei
--             Technologies.R_Dairy,                               -- Recht: Käserei
--             Technologies.R_Butcher,                             -- Recht: Metzger
--             Technologies.R_SmokeHouse,                          -- Recht: Räucherhaus
--             Technologies.R_Clothes,                             -- Recht: Kleidung
--             Technologies.R_Tanner,                              -- Recht: Ledergerber
--             Technologies.R_Weaver,                              -- Recht: Weber
--             Technologies.R_Construction,                        -- Recht: Konstruktion
--             Technologies.R_Wall,                                -- Recht: Mauer
--             Technologies.R_Pallisade,                           -- Recht: Palisade
--             Technologies.R_Trail,                               -- Recht: Pfad
--             Technologies.R_KnockDown,                           -- Recht: Abriss
--             Technologies.R_Sermon,                              -- Recht: Predigt
--             Technologies.R_SpecialEdition,                      -- Recht: Special Edition
--             Technologies.R_SpecialEdition_Pavilion,             -- Recht: Pavilion AeK SE
--         }
--     }
--
--     -- Landvogt ----------------------------------------------------------------
--
--     NeedsAndRightsByKnightTitle[KnightTitles.Mayor] = {
--         ActivateNeedForPlayer,
--         {
--             Needs.Clothes,                                      -- Bedürfnis: KLeidung
--         },
--         ActivateRightForPlayer, {
--             Technologies.R_Hygiene,                             -- Recht: Hygiene
--             Technologies.R_Soapmaker,                           -- Recht: Seifenmacher
--             Technologies.R_BroomMaker,                          -- Recht: Besenmacher
--             Technologies.R_Military,                            -- Recht: Militär
--             Technologies.R_SwordSmith,                          -- Recht: Schwertschmied
--             Technologies.R_Barracks,                            -- Recht: Schwertkämpferkaserne
--             Technologies.R_Thieves,                             -- Recht: Diebe
--             Technologies.R_SpecialEdition_StatueFamily,         -- Recht: Familienstatue Aek SE
--         },
--         StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
--     }
--
--     -- Baron -------------------------------------------------------------------
--
--     NeedsAndRightsByKnightTitle[KnightTitles.Baron] = {
--         ActivateNeedForPlayer,
--         {
--             Needs.Hygiene,                                      -- Bedürfnis: Hygiene
--         },
--         ActivateRightForPlayer, {
--             Technologies.R_SiegeEngineWorkshop,                 -- Recht: Belagerungswaffenschmied
--             Technologies.R_BatteringRam,                        -- Recht: Ramme
--             Technologies.R_Medicine,                            -- Recht: Medizin
--             Technologies.R_Entertainment,                       -- Recht: Unterhaltung
--             Technologies.R_Tavern,                              -- Recht: Taverne
--             Technologies.R_Festival,                            -- Recht: Fest
--             Technologies.R_Street,                              -- Recht: Straße
--             Technologies.R_SpecialEdition_Column,               -- Recht: Säule AeK SE
--         },
--         StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
--     }
--
--     -- Graf --------------------------------------------------------------------
--
--     NeedsAndRightsByKnightTitle[KnightTitles.Earl] = {
--         ActivateNeedForPlayer,
--         {
--             Needs.Entertainment,                                -- Bedürfnis: Unterhaltung
--             Needs.Prosperity,                                   -- Bedürfnis: Reichtum
--         },
--         ActivateRightForPlayer, {
--             Technologies.R_BowMaker,                            -- Recht: Bogenmacher
--             Technologies.R_BarracksArchers,                     -- Recht: Bogenschützenkaserne
--             Technologies.R_Baths,                               -- Recht: Badehaus
--             Technologies.R_AmmunitionCart,                      -- Recht: Munitionswagen
--             Technologies.R_Prosperity,                          -- Recht: Reichtum
--             Technologies.R_Taxes,                               -- Recht: Steuern einstellen
--             Technologies.R_Ballista,                            -- Recht: Mauerkatapult
--             Technologies.R_SpecialEdition_StatueSettler,        -- Recht: Siedlerstatue AeK SE
--         },
--         StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
--     }
--
--     -- Marquees ----------------------------------------------------------------
--
--     NeedsAndRightsByKnightTitle[KnightTitles.Marquees] = {
--         ActivateNeedForPlayer,
--         {
--             Needs.Wealth,                                       -- Bedürfnis: Verschönerung
--         },
--         ActivateRightForPlayer, {
--             Technologies.R_Theater,                             -- Recht: Theater
--             Technologies.R_Wealth,                              -- Recht: Schmuckgebäude
--             Technologies.R_BannerMaker,                         -- Recht: Bannermacher
--             Technologies.R_SiegeTower,                          -- Recht: Belagerungsturm
--             Technologies.R_SpecialEdition_StatueProduction,     -- Recht: Produktionsstatue AeK SE
--         },
--         StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
--     }
--
--     -- Herzog ------------------------------------------------------------------
--
--     NeedsAndRightsByKnightTitle[KnightTitles.Duke] = {
--         ActivateNeedForPlayer, nil,
--         ActivateRightForPlayer, {
--             Technologies.R_Catapult,                            -- Recht: Katapult
--             Technologies.R_Carpenter,                           -- Recht: Tischler
--             Technologies.R_CandleMaker,                         -- Recht: Kerzenmacher
--             Technologies.R_Blacksmith,                          -- Recht: Schmied
--             Technologies.R_SpecialEdition_StatueDario,          -- Recht: Dariostatue AeK SE
--         },
--         StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
--     }
--
--     -- Erzherzog ---------------------------------------------------------------
--
--     NeedsAndRightsByKnightTitle[KnightTitles.Archduke] = {
--         ActivateNeedForPlayer,nil,
--         ActivateRightForPlayer, {
--             Technologies.R_Victory                              -- Sieg
--         },
--         -- VictroryBecauseOfTitle,                              -- Sieg wegen Titel
--         StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
--     }
--
--
--
--     -- Reich des Ostens --------------------------------------------------------
--
--     if g_GameExtraNo >= 1 then
--         local TechnologiesTableIndex = 4;
--         table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Cistern);
--         table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Brazier);
--         table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Shrine);
--         table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Baron][TechnologiesTableIndex],Technologies.R_Beautification_Pillar);
--         table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_StoneBench);
--         table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_Vase);
--         table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Marquees][TechnologiesTableIndex],Technologies.R_Beautification_Sundial);
--         table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Archduke][TechnologiesTableIndex],Technologies.R_Beautification_TriumphalArch);
--         table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Duke][TechnologiesTableIndex],Technologies.R_Beautification_VictoryColumn);
--     end
--
--
--
--     -- ---------------------------------------------------------------------- --
--     -- Bedingungen                                                            --
--     -- ---------------------------------------------------------------------- --
--
--     KnightTitleRequirements = {}
--
--     -- Ritter ------------------------------------------------------------------
--
--     KnightTitleRequirements[KnightTitles.Mayor] = {}
--     KnightTitleRequirements[KnightTitles.Mayor].Headquarters = 1
--     KnightTitleRequirements[KnightTitles.Mayor].Settlers = 10
--     KnightTitleRequirements[KnightTitles.Mayor].Products = {
--         {GoodCategories.GC_Clothes, 6},
--     }
--
--     -- Baron -------------------------------------------------------------------
--
--     KnightTitleRequirements[KnightTitles.Baron] = {}
--     KnightTitleRequirements[KnightTitles.Baron].Settlers = 30
--     KnightTitleRequirements[KnightTitles.Baron].Headquarters = 1
--     KnightTitleRequirements[KnightTitles.Baron].Storehouse = 1
--     KnightTitleRequirements[KnightTitles.Baron].Cathedrals = 1
--     KnightTitleRequirements[KnightTitles.Baron].Products = {
--         {GoodCategories.GC_Hygiene, 12},
--     }
--
--     -- Graf --------------------------------------------------------------------
--
--     KnightTitleRequirements[KnightTitles.Earl] = {}
--     KnightTitleRequirements[KnightTitles.Earl].Settlers = 50
--     KnightTitleRequirements[KnightTitles.Earl].Headquarters = 2
--     KnightTitleRequirements[KnightTitles.Earl].Goods = {
--         {Goods.G_Beer, 18},
--     }
--
--     -- Marquess ----------------------------------------------------------------
--
--     KnightTitleRequirements[KnightTitles.Marquees] = {}
--     KnightTitleRequirements[KnightTitles.Marquees].Settlers = 70
--     KnightTitleRequirements[KnightTitles.Marquees].Headquarters = 2
--     KnightTitleRequirements[KnightTitles.Marquees].Storehouse = 2
--     KnightTitleRequirements[KnightTitles.Marquees].Cathedrals = 2
--     KnightTitleRequirements[KnightTitles.Marquees].RichBuildings = 20
--
--     -- Herzog ------------------------------------------------------------------
--
--     KnightTitleRequirements[KnightTitles.Duke] = {}
--     KnightTitleRequirements[KnightTitles.Duke].Settlers = 90
--     KnightTitleRequirements[KnightTitles.Duke].Storehouse = 2
--     KnightTitleRequirements[KnightTitles.Duke].Cathedrals = 2
--     KnightTitleRequirements[KnightTitles.Duke].Headquarters = 3
--     KnightTitleRequirements[KnightTitles.Duke].DecoratedBuildings = {
--         {Goods.G_Banner, 9 },
--     }
--
--     -- Erzherzog ---------------------------------------------------------------
--
--     KnightTitleRequirements[KnightTitles.Archduke] = {}
--     KnightTitleRequirements[KnightTitles.Archduke].Settlers = 150
--     KnightTitleRequirements[KnightTitles.Archduke].Storehouse = 3
--     KnightTitleRequirements[KnightTitles.Archduke].Cathedrals = 3
--     KnightTitleRequirements[KnightTitles.Archduke].Headquarters = 3
--     KnightTitleRequirements[KnightTitles.Archduke].RichBuildings = 30
--     KnightTitleRequirements[KnightTitles.Archduke].FullDecoratedBuildings = 30
--
--     -- Einstellungen Aktivieren
--     CreateTechnologyKnightTitleTable()
-- end
--
InitKnightTitleTables = function()
    KnightTitles = {}
    KnightTitles.Knight     = 0
    KnightTitles.Mayor      = 1
    KnightTitles.Baron      = 2
    KnightTitles.Earl       = 3
    KnightTitles.Marquees   = 4
    KnightTitles.Duke       = 5
    KnightTitles.Archduke   = 6

    -- ---------------------------------------------------------------------- --
    -- Rechte und Pflichten                                                   --
    -- ---------------------------------------------------------------------- --

    NeedsAndRightsByKnightTitle = {}

    -- Ritter ------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Knight] = {
        ActivateNeedForPlayer,
        {
            Needs.Nutrition,                                    -- Bedürfnis: Nahrung
            Needs.Medicine,                                     -- Bedürfnis: Medizin
        },
        ActivateRightForPlayer,
        {
            Technologies.R_Gathering,                           -- Recht: Rohstoffsammler
            Technologies.R_Woodcutter,                          -- Recht: Holzfäller
            Technologies.R_StoneQuarry,                         -- Recht: Steinbruch
            Technologies.R_HuntersHut,                          -- Recht: Jägerhütte
            Technologies.R_FishingHut,                          -- Recht: Fischerhütte
            Technologies.R_CattleFarm,                          -- Recht: Kuhfarm
            Technologies.R_GrainFarm,                           -- Recht: Getreidefarm
            Technologies.R_SheepFarm,                           -- Recht: Schaffarm
            Technologies.R_IronMine,                            -- Recht: Eisenmine
            Technologies.R_Beekeeper,                           -- Recht: Imkerei
            Technologies.R_HerbGatherer,                        -- Recht: Kräutersammler
            Technologies.R_Nutrition,                           -- Recht: Nahrung
            Technologies.R_Bakery,                              -- Recht: Bäckerei
            Technologies.R_Dairy,                               -- Recht: Käserei
            Technologies.R_Butcher,                             -- Recht: Metzger
            Technologies.R_SmokeHouse,                          -- Recht: Räucherhaus
            Technologies.R_Clothes,                             -- Recht: Kleidung
            Technologies.R_Tanner,                              -- Recht: Ledergerber
            Technologies.R_Weaver,                              -- Recht: Weber
            Technologies.R_Construction,                        -- Recht: Konstruktion
            Technologies.R_Wall,                                -- Recht: Mauer
            Technologies.R_Pallisade,                           -- Recht: Palisade
            Technologies.R_Trail,                               -- Recht: Pfad
            Technologies.R_KnockDown,                           -- Recht: Abriss
            Technologies.R_Sermon,                              -- Recht: Predigt
            Technologies.R_SpecialEdition,                      -- Recht: Special Edition
            Technologies.R_SpecialEdition_Pavilion,             -- Recht: Pavilion AeK SE
        }
    }

    -- Landvogt ----------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Mayor] = {
        ActivateNeedForPlayer,
        {
            Needs.Clothes,                                      -- Bedürfnis: KLeidung
        },
        ActivateRightForPlayer, {
            Technologies.R_Hygiene,                             -- Recht: Hygiene
            Technologies.R_Soapmaker,                           -- Recht: Seifenmacher
            Technologies.R_BroomMaker,                          -- Recht: Besenmacher
            Technologies.R_Military,                            -- Recht: Militär
            Technologies.R_SwordSmith,                          -- Recht: Schwertschmied
            Technologies.R_Barracks,                            -- Recht: Schwertkämpferkaserne
            Technologies.R_Thieves,                             -- Recht: Diebe
            Technologies.R_SpecialEdition_StatueFamily,         -- Recht: Familienstatue Aek SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Baron -------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Baron] = {
        ActivateNeedForPlayer,
        {
            Needs.Hygiene,                                      -- Bedürfnis: Hygiene
        },
        ActivateRightForPlayer, {
            Technologies.R_SiegeEngineWorkshop,                 -- Recht: Belagerungswaffenschmied
            Technologies.R_BatteringRam,                        -- Recht: Ramme
            Technologies.R_Medicine,                            -- Recht: Medizin
            Technologies.R_Entertainment,                       -- Recht: Unterhaltung
            Technologies.R_Tavern,                              -- Recht: Taverne
            Technologies.R_Festival,                            -- Recht: Fest
            Technologies.R_Street,                              -- Recht: Straße
            Technologies.R_SpecialEdition_Column,               -- Recht: Säule AeK SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Graf --------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Earl] = {
        ActivateNeedForPlayer,
        {
            Needs.Entertainment,                                -- Bedürfnis: Unterhaltung
            Needs.Prosperity,                                   -- Bedürfnis: Reichtum
        },
        ActivateRightForPlayer, {
            Technologies.R_BowMaker,                            -- Recht: Bogenmacher
            Technologies.R_BarracksArchers,                     -- Recht: Bogenschützenkaserne
            Technologies.R_Baths,                               -- Recht: Badehaus
            Technologies.R_AmmunitionCart,                      -- Recht: Munitionswagen
            Technologies.R_Prosperity,                          -- Recht: Reichtum
            Technologies.R_Taxes,                               -- Recht: Steuern einstellen
            Technologies.R_Ballista,                            -- Recht: Mauerkatapult
            Technologies.R_SpecialEdition_StatueSettler,        -- Recht: Siedlerstatue AeK SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Marquees ----------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Marquees] = {
        ActivateNeedForPlayer,
        {
            Needs.Wealth,                                       -- Bedürfnis: Verschönerung
        },
        ActivateRightForPlayer, {
            Technologies.R_Theater,                             -- Recht: Theater
            Technologies.R_Wealth,                              -- Recht: Schmuckgebäude
            Technologies.R_BannerMaker,                         -- Recht: Bannermacher
            Technologies.R_SiegeTower,                          -- Recht: Belagerungsturm
            Technologies.R_SpecialEdition_StatueProduction,     -- Recht: Produktionsstatue AeK SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Herzog ------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Duke] = {
        ActivateNeedForPlayer, nil,
        ActivateRightForPlayer, {
            Technologies.R_Catapult,                            -- Recht: Katapult
            Technologies.R_Carpenter,                           -- Recht: Tischler
            Technologies.R_CandleMaker,                         -- Recht: Kerzenmacher
            Technologies.R_Blacksmith,                          -- Recht: Schmied
            Technologies.R_SpecialEdition_StatueDario,          -- Recht: Dariostatue AeK SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Erzherzog ---------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Archduke] = {
        ActivateNeedForPlayer,nil,
        ActivateRightForPlayer, {
            Technologies.R_Victory                              -- Sieg
        },
        -- VictroryBecauseOfTitle,                              -- Sieg wegen Titel
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }



    -- Reich des Ostens --------------------------------------------------------

    if g_GameExtraNo >= 1 then
        local TechnologiesTableIndex = 4;
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Cistern);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Brazier);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Shrine);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Baron][TechnologiesTableIndex],Technologies.R_Beautification_Pillar);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_StoneBench);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_Vase);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Marquees][TechnologiesTableIndex],Technologies.R_Beautification_Sundial);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Archduke][TechnologiesTableIndex],Technologies.R_Beautification_TriumphalArch);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Duke][TechnologiesTableIndex],Technologies.R_Beautification_VictoryColumn);
    end



    -- ---------------------------------------------------------------------- --
    -- Bedingungen                                                            --
    -- ---------------------------------------------------------------------- --

    KnightTitleRequirements = {}

    -- Ritter ------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Mayor] = {}
    KnightTitleRequirements[KnightTitles.Mayor].Headquarters = 1
    KnightTitleRequirements[KnightTitles.Mayor].Settlers = 10
    KnightTitleRequirements[KnightTitles.Mayor].Products = {
        {GoodCategories.GC_Clothes, 6},
    }

    -- Baron -------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Baron] = {}
    KnightTitleRequirements[KnightTitles.Baron].Settlers = 30
    KnightTitleRequirements[KnightTitles.Baron].Headquarters = 1
    KnightTitleRequirements[KnightTitles.Baron].Storehouse = 1
    KnightTitleRequirements[KnightTitles.Baron].Cathedrals = 1
    KnightTitleRequirements[KnightTitles.Baron].Products = {
        {GoodCategories.GC_Hygiene, 12},
    }

    -- Graf --------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Earl] = {}
    KnightTitleRequirements[KnightTitles.Earl].Settlers = 50
    KnightTitleRequirements[KnightTitles.Earl].Headquarters = 2
    KnightTitleRequirements[KnightTitles.Earl].Goods = {
        {Goods.G_Beer, 18},
    }

    -- Marquess ----------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Marquees] = {}
    KnightTitleRequirements[KnightTitles.Marquees].Settlers = 70
    KnightTitleRequirements[KnightTitles.Marquees].Headquarters = 2
    KnightTitleRequirements[KnightTitles.Marquees].Storehouse = 2
    KnightTitleRequirements[KnightTitles.Marquees].Cathedrals = 2
    KnightTitleRequirements[KnightTitles.Marquees].RichBuildings = 20

    -- Herzog ------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Duke] = {}
    KnightTitleRequirements[KnightTitles.Duke].Settlers = 90
    KnightTitleRequirements[KnightTitles.Duke].Storehouse = 2
    KnightTitleRequirements[KnightTitles.Duke].Cathedrals = 2
    KnightTitleRequirements[KnightTitles.Duke].Headquarters = 3
    KnightTitleRequirements[KnightTitles.Duke].DecoratedBuildings = {
        {Goods.G_Banner, 9 },
    }

    -- Erzherzog ---------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Archduke] = {}
    KnightTitleRequirements[KnightTitles.Archduke].Settlers = 150
    KnightTitleRequirements[KnightTitles.Archduke].Storehouse = 3
    KnightTitleRequirements[KnightTitles.Archduke].Cathedrals = 3
    KnightTitleRequirements[KnightTitles.Archduke].Headquarters = 3
    KnightTitleRequirements[KnightTitles.Archduke].RichBuildings = 30
    KnightTitleRequirements[KnightTitles.Archduke].FullDecoratedBuildings = 30

    -- Einstellungen Aktivieren
    CreateTechnologyKnightTitleTable()
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleQuest = {
    Properties = {
        Name = "ModuleQuest",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        ExternalTriggerConditions = {},
        ExternalTimerConditions = {},
        ExternalDecisionConditions = {},
        SegmentsOfQuest = {},
    },
    Local  = {},

    Shared = {},
}

QSB.SegmentResult = {
    Success = 1,
    Failure = 2,
    Ignore  = 3,
}

-- -------------------------------------------------------------------------- --
-- Global

function ModuleQuest.Global:OnGameStart()
    Quest_Loop = self.QuestLoop;
    self:OverrideKernelQuestApi();

    -- TODO: Stop goals for cinematics
    -- TODO: Stop triggers for cinematics
    -- TODO: Stop timers for cinematics
end

function ModuleQuest.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

function ModuleQuest.Global:CreateNestedQuest(_Data)
    if not _Data.Segments then
        return;
    end
    -- Add behavior to check on segments
    table.insert(
        _Data,
        Goal_MapScriptFunction(self:GetCheckQuestSegmentsInlineGoal(), _Data.Name)
    )
    -- Create quest
    local Name = self:CreateSimpleQuest(_Data);
    if Name ~= nil then
        Quests[GetQuestID(Name)].Visible = false;
        self.SegmentsOfQuest[Name] = {};
        -- Create segments
        for i= 1, #_Data.Segments, 1 do
            self:CreateSegmentForSegmentedQuest(_Data.Segments[i], Name, i);
        end
    end
    return Name;
end

function ModuleQuest.Global:CreateSegmentForSegmentedQuest(_Data, _ParentName, _Index)
    local Name = _Data.Name or _ParentName.. "@Segment" .._Index;
    local Parent = Quests[GetQuestID(_ParentName)];

    local QuestDescription = {
        Name        = Name,
        Segments    = _Data.Segments,
        Result      = _Data.Result or QSB.SegmentResult.Success,
        Sender      = _Data.Sender or Parent.SendingPlayer,
        Receiver    = _Data.Receiver or Parent.ReceivingPlayer,
        Time        = _Data.Time,
        Suggestion  = _Data.Suggestion,
        Success     = _Data.Success,
        Failure     = _Data.Failure,
        Description = _Data.Description,
        Loop        = _Data.Loop,
        Callback    = _Data.Callback,
    };
    for i= 1, #_Data do
        table.insert(QuestDescription, _Data[i]);
    end

    table.insert(QuestDescription, Trigger_OnQuestActive(_ParentName, 0));
    if QuestDescription.Segments then
        self:CreateNestedQuest(QuestDescription);
    else
        self:CreateSimpleQuest(QuestDescription);
    end
    table.insert(self.SegmentsOfQuest[_ParentName], QuestDescription);
end

function ModuleQuest.Global:GetCheckQuestSegmentsInlineGoal()
    return function (_QuestName)
        local AllSegmentsConcluded = true;
        local SegmentList = ModuleQuest.Global.SegmentsOfQuest[_QuestName];
        for i= 1, #SegmentList, 1 do
            local SegmentQuest = Quests[GetQuestID(SegmentList[i].Name)];
            -- Non existing segment fails quest
            if not SegmentQuest then
                return false;
            end
            -- Not expectec result of segment fails quest
            if SegmentQuest.State == QuestState.Over and SegmentQuest.Result ~= QuestResult.Interrupted then
                if SegmentList[i].Result == QSB.SegmentResult.Success and SegmentQuest.Result ~= QuestResult.Success then
                    ModuleQuest.Global:AbortAllQuestSegments(_QuestName);
                    return false;
                end
                if SegmentList[i].Result == QSB.SegmentResult.Failure and SegmentQuest.Result ~= QuestResult.Failure then
                    ModuleQuest.Global:AbortAllQuestSegments(_QuestName);
                    return false;
                end
            end
            -- Check if segment is concluded
            if SegmentQuest.State ~= QuestState.Over then
                AllSegmentsConcluded = false;
            end
        end
        -- Success after all segments have been completed
        if AllSegmentsConcluded then
            return true;
        end
    end;
end

function ModuleQuest.Global:AbortAllQuestSegments(_QuestName)
    for i= 1, #self.SegmentsOfQuest[_QuestName], 1 do
        local SegmentName = self.SegmentsOfQuest[_QuestName][i].Name;
        if API.IsValidQuest(_QuestName) and Quests[API.GetQuestID(SegmentName)].State ~= QuestState.Over then
            API.StopQuest(SegmentName, true);
        end
    end
end

function ModuleQuest.Global:OverrideKernelQuestApi()
    API.FailQuest_Orig_ModuleQuest = API.FailQuest;
    API.FailQuest = function(_QuestName, _NoMessage)
        -- Fail segments of quest fist
        if ModuleQuest.Global.SegmentsOfQuest[_QuestName] then
            for k, v in pairs(ModuleQuest.Global.SegmentsOfQuest[_QuestName]) do
                if API.IsValidQuest(v.Name) and Quests[API.GetQuestID(v.Name)].State ~= QuestState.Over then
                    API.FailQuest_Orig_ModuleQuest(v.Name, true);
                end
            end
        end
        -- Proceed with failing
        API.FailQuest_Orig_ModuleQuest(_QuestName, _NoMessage);
    end

    API.RestartQuest_Orig_ModuleQuest = API.RestartQuest;
    API.RestartQuest = function(_QuestName, _NoMessage)
        -- Restart segments of quest first
        if ModuleQuest.Global.SegmentsOfQuest[_QuestName] then
            for k, v in pairs(ModuleQuest.Global.SegmentsOfQuest[_QuestName]) do
                if API.IsValidQuest(v.Name) then
                    API.StopQuest_Orig_ModuleQuest(v.Name, true);
                    API.RestartQuest_Orig_ModuleQuest(v.Name, true);
                end
            end
        end
        -- Proceed with restarting
        API.RestartQuest_Orig_ModuleQuest(_QuestName, _NoMessage);
    end

    API.StartQuest_Orig_ModuleQuest = API.StartQuest;
    API.StartQuest = function(_QuestName, _NoMessage)
        -- Start segments of quest first
        if ModuleQuest.Global.SegmentsOfQuest[_QuestName] then
            for k, v in pairs(ModuleQuest.Global.SegmentsOfQuest[_QuestName]) do
                if API.IsValidQuest(v.Name) and Quests[API.GetQuestID(v.Name)].State ~= QuestState.Over then
                    API.StartQuest_Orig_ModuleQuest(v.Name, true);
                end
            end
        end
        -- Proceed with starting
        API.StartQuest_Orig_ModuleQuest(_QuestName, _NoMessage);
    end

    API.StopQuest_Orig_ModuleQuest = API.StopQuest;
    API.StopQuest = function(_QuestName, _NoMessage)
        -- Stop segments of quest first
        if ModuleQuest.Global.SegmentsOfQuest[_QuestName] then
            for k, v in pairs(ModuleQuest.Global.SegmentsOfQuest[_QuestName]) do
                if API.IsValidQuest(v.Name) and Quests[API.GetQuestID(v.Name)].State ~= QuestState.Over then
                    API.StopQuest_Orig_ModuleQuest(v.Name, true);
                end
            end
        end
        -- Proceed with stopping
        API.StopQuest_Orig_ModuleQuest(_QuestName, _NoMessage);
    end

    API.WinQuest_Orig_ModuleQuest = API.WinQuest;
    API.WinQuest = function(_QuestName, _NoMessage)
        -- Stop segments of quest first
        if ModuleQuest.Global.SegmentsOfQuest[_QuestName] then
            for k, v in pairs(ModuleQuest.Global.SegmentsOfQuest[_QuestName]) do
                if API.IsValidQuest(v.Name) and Quests[API.GetQuestID(v.Name)].State ~= QuestState.Over then
                    API.StopQuest_Orig_ModuleQuest(v.Name, true);
                end
            end
        end
        -- Proceed with winning
        API.WinQuest_Orig_ModuleQuest(_QuestName, _NoMessage);
    end
end

function ModuleQuest.Global:CreateSimpleQuest(_Data)
    if not _Data.Name then
        QSB.AutomaticQuestNameCounter = (QSB.AutomaticQuestNameCounter or 0) +1;
        _Data.Name = string.format("AutoNamed_Quest_%d", QSB.AutomaticQuestNameCounter);
    end
    if not self:QuestValidateQuestName(_Data.Name) then
        error("Quest '"..tostring(_Data.Name).."': invalid questname! Contains forbidden characters!");
        return;
    end

    -- Fill quest data
    local QuestData = {
        _Data.Name,
        (_Data.Sender ~= nil and _Data.Sender) or 1,
        (_Data.Receiver ~= nil and _Data.Receiver) or 1,
        {},
        {},
        (_Data.Time ~= nil and _Data.Time) or 0,
        {},
        {},
        _Data.Callback,
        _Data.Loop,
        _Data.Visible == true or _Data.Suggestion ~= nil,
        _Data.EndMessage == true or (_Data.Failure ~= nil or _Data.Success ~= nil),
        API.ConvertPlaceholders((type(_Data.Description) == "table" and API.Localize(_Data.Description)) or _Data.Description),
        API.ConvertPlaceholders((type(_Data.Suggestion) == "table" and API.Localize(_Data.Suggestion)) or _Data.Suggestion),
        API.ConvertPlaceholders((type(_Data.Success) == "table" and API.Localize(_Data.Success)) or _Data.Success),
        API.ConvertPlaceholders((type(_Data.Failure) == "table" and API.Localize(_Data.Failure)) or _Data.Failure)
    };

    -- Validate data
    if not self:QuestValidateQuestData(QuestData) then
        error("ModuleQuest: Failed to vaidate quest data. Table has been copied to log.");
        API.DumpTable(QuestData, "Quest");
        return;
    end

    -- Behaviour
    for k,v in pairs(_Data) do
        if tonumber(k) ~= nil then
            if type(v) == "table" then
                if v.GetGoalTable then
                    table.insert(QuestData[4], v:GetGoalTable());

                    local Idx = #QuestData[4];
                    QuestData[4][Idx].Context            = v;
                    QuestData[4][Idx].FuncOverrideIcon   = QuestData[4][Idx].Context.GetIcon;
                    QuestData[4][Idx].FuncOverrideMsgKey = QuestData[4][Idx].Context.GetMsgKey;
                elseif v.GetReprisalTable then
                    table.insert(QuestData[8], v:GetReprisalTable());
                elseif v.GetRewardTable then
                    table.insert(QuestData[7], v:GetRewardTable());
                else
                    table.insert(QuestData[5], v:GetTriggerTable());
                end
            end
        end
    end

    -- Default goal
    if #QuestData[4] == 0 then
        table.insert(QuestData[4], {Objective.Dummy});
    end
    -- Default trigger
    if #QuestData[5] == 0 then
        table.insert(QuestData[5], {Triggers.Time, 0 });
    end
    -- Enough space behavior
    if QuestData[11] then
        table.insert(QuestData[5], self:GetFreeSpaceInlineTrigger());
    end

    -- Create quest
    local QuestID, Quest = QuestTemplate:New(unpack(QuestData, 1, 16));
    Quest.MsgTableOverride = _Data.MSGKeyOverwrite;
    Quest.IconOverride = _Data.IconOverwrite;
    Quest.QuestInfo = _Data.InfoText;
    Quest.Arguments = (_Data.Arguments ~= nil and table.copy(_Data.Arguments)) or {};
    return _Data.Name, Quests[0];
end

function ModuleQuest.Global:QuestValidateQuestData(_Data)
    return (
        (type(_Data[1]) == "string" and self:QuestValidateQuestName(_Data[1]) and Quests[GetQuestID(_Data[1])] == nil) and
        (type(_Data[2]) == "number" and _Data[2] >= 1 and _Data[2] <= 8) and
        (type(_Data[3]) == "number" and _Data[3] >= 1 and _Data[3] <= 8) and
        (type(_Data[6]) == "number" and _Data[6] >= 0) and
        ((_Data[9] ~= nil and type(_Data[9]) == "function") or (_Data[9] == nil)) and
        ((_Data[10] ~= nil and type(_Data[10]) == "function") or (_Data[10] == nil)) and
        (type(_Data[11]) == "boolean") and
        (type(_Data[12]) == "boolean") and
        ((_Data[13] ~= nil and type(_Data[13]) == "string") or (_Data[13] == nil)) and
        ((_Data[14] ~= nil and type(_Data[14]) == "string") or (_Data[14] == nil)) and
        ((_Data[15] ~= nil and type(_Data[15]) == "string") or (_Data[15] == nil)) and
        ((_Data[16] ~= nil and type(_Data[16]) == "string") or (_Data[16] == nil))
    );
end

function ModuleQuest.Global:QuestValidateQuestName(_Name)
    return string.find(_Name, "^[A-Za-z0-9_ @ÄÖÜäöüß]+$") ~= nil;
end

-- This prevents from triggering a quest when all slots are occupied. But the
-- mapper who uses this automation must also keep in mind that they might soft
-- lock the game if fully relying on this trigger without thinking! This is
-- only here to ensure functionality in case of errors and NOT to support the
-- sloth of mappers!
-- Also this technically is a bugfix but can not be put into the kernel.
function ModuleQuest.Global:GetFreeSpaceInlineTrigger()
    return {
        Triggers.Custom2, {
            {},
            function(_Data, _Quest)
                local VisbleQuests = 0;
                if Quests[0] > 0 then
                    for i= 1, Quests[0], 1 do
                        if Quests[i].State == QuestState.Active and Quests[i].Visible == true then
                            VisbleQuests = VisbleQuests +1;
                        end
                    end
                end
                return VisbleQuests < 6;
            end
        }
    };
end

-- -------------------------------------------------------------------------- --
-- Quest Loop

function ModuleQuest.Global.QuestLoop(_arguments)
    local self = JobQueue_GetParameter(_arguments);
    if self.LoopCallback ~= nil then
        self:LoopCallback();
    end
    if self.State == QuestState.NotTriggered then
        local triggered = true;
        -- Are triggers active?
        for i= 1, #ModuleQuest.Global.ExternalTriggerConditions, 1 do
            if not ModuleQuest.Global.ExternalTriggerConditions[i](self.ReceivingPlayer, self) then
                triggered = false;
                break;
            end
        end
        -- Normal condition
        if triggered then
            for i = 1, self.Triggers[0] do
                -- Write Trigger to Log
                local Text = ModuleQuest.Global:SerializeBehavior(self.Triggers[i], Triggers.Custom2, 4);
                if Text then
                    debug("Quest '" ..self.Identifier.. "' " ..Text, true);
                end
                -- Check Trigger
                triggered = triggered and self:IsTriggerActive(self.Triggers[i]);
            end
        end
        if triggered then
            self:SetMsgKeyOverride();
            self:SetIconOverride();
            self:Trigger();
        end
    elseif self.State == QuestState.Active then
        -- Do timers tick?
        for i= 1, #ModuleQuest.Global.ExternalTimerConditions, 1 do
            if not ModuleQuest.Global.ExternalTimerConditions[i](self.ReceivingPlayer, self) then
                self.StartTime = self.StartTime +1;
                break;
            end
        end
        -- Are goals checked?
        local CheckBehavior = true;
        for i= 1, #ModuleQuest.Global.ExternalDecisionConditions, 1 do
            if not ModuleQuest.Global.ExternalDecisionConditions[i](self.ReceivingPlayer, self) then
                CheckBehavior = false;
                break;
            end
        end
        if CheckBehavior then
            local allTrue = true;
            local anyFalse = false;
            for i = 1, self.Objectives[0] do
                -- Write Trigger to Log
                local Text = ModuleQuest.Global:SerializeBehavior(self.Objectives[i], Objective.Custom2, 1);
                if Text then
                    debug("Quest '" ..self.Identifier.. "' " ..Text, true);
                end
                -- Check Goal
                local completed = self:IsObjectiveCompleted(self.Objectives[i]);
                if self.Objectives[i].Type == Objective.Deliver and completed == nil then
                    if self.Objectives[i].Data[4] == nil then
                        self.Objectives[i].Data[4] = 0;
                    end
                    if self.Objectives[i].Data[3] ~= nil then
                        self.Objectives[i].Data[4] = self.Objectives[i].Data[4] + 1;
                    end
                    local st = self.StartTime;
                    local sd = self.Duration;
                    local dt = self.Objectives[i].Data[4];
                    local sum = self.StartTime + self.Duration - self.Objectives[i].Data[4];
                    if self.Duration > 0 and self.StartTime + self.Duration + self.Objectives[i].Data[4] < Logic.GetTime() then
                        completed = false;
                    end
                else
                    if self.Duration > 0 and self.StartTime + self.Duration < Logic.GetTime() then
                        if completed == nil and
                            (self.Objectives[i].Type == Objective.Protect or self.Objectives[i].Type == Objective.Dummy or self.Objectives[i].Type == Objective.NoChange) then
                            completed = true;
                        elseif completed == nil or self.Objectives[i].Type == Objective.DummyFail then
                            completed = false;
                    end
                    end
                end
                allTrue = (completed == true) and allTrue;
                anyFalse = completed == false or anyFalse;
            end
            if allTrue then
                self:Success();
            elseif anyFalse then
                self:Fail();
            end
        end
    else
        if self.IsEventQuest == true then
            Logic.ExecuteInLuaLocalState("StopEventMusic(nil, "..self.ReceivingPlayer..")");
        end
        if self.Result == QuestResult.Success then
            for i = 1, self.Rewards[0] do
                -- Write Trigger to Log
                local Text = ModuleQuest.Global:SerializeBehavior(self.Rewards[i], Reward.Custom, 3);
                if Text then
                    debug("Quest '" ..self.Identifier.. "' " ..Text, true);
                end
                -- Add Reward
                self:AddReward(self.Rewards[i]);
            end
        elseif self.Result == QuestResult.Failure then
            for i = 1, self.Reprisals[0] do
                -- Write Trigger to Log
                local Text = ModuleQuest.Global:SerializeBehavior(self.Reprisals[i], Reprisal.Custom, 3);
                if Text then
                    debug("Quest '" ..self.Identifier.. "' " ..Text, true);
                end
                -- Add Reward
                self:AddReprisal(self.Reprisals[i]);
            end
        end
        if self.EndCallback ~= nil then
            self:EndCallback();
        end
        return true;
    end
end

function ModuleQuest.Global:SerializeBehavior(_Data, _CustomType, _Typ)
    local BehaviorType = "Objective";
    local BehaTable = Objective;
    if _Typ == 2 then
        BehaviorType = "Reprisal";
        BehaTable = Reprisal;
    elseif _Typ == 3 then
        BehaviorType = "Reward";
        BehaTable = Reward;
    elseif _Typ == 4 then
        BehaviorType = "Trigger";
        BehaTable = Triggers;
    end

    local Info = "Running {";
    local Beha = GetNameOfKeyInTable(BehaTable, _Data.Type);

    if _Data.Type == _CustomType then
        local FunctionName = _Data.Data[1].FuncName;
        Info = Info.. BehaviorType.. "." ..Beha.. "";
        if FunctionName == nil then
            return;
        else
            Info = Info.. ", " ..tostring(FunctionName);
        end
        if _Data.Data and _Data.Data[1].i47ya_6aghw_frxil and #_Data.Data[1].i47ya_6aghw_frxil > 0 then
            for j= 1, #_Data.Data[1].i47ya_6aghw_frxil, 1 do
                Info = Info.. ", (" ..type(_Data.Data[1].i47ya_6aghw_frxil[j]).. ") " ..tostring(_Data.Data[1].i47ya_6aghw_frxil[j]);
            end
        end
    else
        Info = Info.. BehaviorType.. "." ..Beha.. "";
        if _Data.Data then
            if type(_Data.Data) == "table" then
                for j= 1, #_Data.Data do
                    Info = Info.. ", (" ..type(_Data.Data[j]).. ") " ..tostring(_Data.Data[j]);
                end
            else
                Info = Info.. ", (" ..type(_Data.Data).. ") " ..tostring(_Data.Data);
            end
        end
    end
    Info = Info.. "}";
    return Info;
end

-- -------------------------------------------------------------------------- --
-- Chat Commands

function ModuleQuest.Global:FindQuestNames(_Pattern, _ExactName)
    local FoundQuests = FindQuestsByName(_Pattern, _ExactName);
    if #FoundQuests == 0 then
        return {};
    end
    local NamesOfFoundQuests = {};
    for i= 1, #FoundQuests, 1 do
        table.insert(NamesOfFoundQuests, FoundQuests[i].Identifier);
    end
    return NamesOfFoundQuests;
end

function ModuleQuest.Global:ProcessChatInput(_Text, _PlayerID, _IsDebug)
    local Commands = Swift.Text:CommandTokenizer(_Text);
    for i= 1, #Commands, 1 do
        if Commands[1] == "fail" or Commands[1] == "restart"
        or Commands[1] == "start" or Commands[1] == "stop"
        or Commands[1] == "win" then
            local FoundQuests = self:FindQuestNames(Commands[2], true);
            if #FoundQuests ~= 1 then
                error("Unable to find quest containing '" ..Commands[2].. "'");
                return;
            end
            if Commands[1] == "fail" then
                API.FailQuest(FoundQuests[1]);
                info("fail quest '" ..FoundQuests[1].. "'");
            elseif Commands[1] == "restart" then
                API.RestartQuest(FoundQuests[1]);
                info("restart quest '" ..FoundQuests[1].. "'");
            elseif Commands[1] == "start" then
                API.StartQuest(FoundQuests[1]);
                info("trigger quest '" ..FoundQuests[1].. "'");
            elseif Commands[1] == "stop" then
                API.StopQuest(FoundQuests[1]);
                info("interrupt quest '" ..FoundQuests[1].. "'");
            elseif Commands[1] == "win" then
                API.WinQuest(FoundQuests[1]);
                info("win quest '" ..FoundQuests[1].. "'");
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Local

function ModuleQuest.Local:OnGameStart()
end

function ModuleQuest.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.ChatClosed then
        self:ProcessChatInput(arg[1], arg[2], arg[3]);
    end
end

function ModuleQuest.Local:ProcessChatInput(_Text, _PlayerID, _IsDebug)
    if not _IsDebug or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    -- FIXME: This will not work in Multiplayer (Does it need to?)
    GUI.SendScriptCommand(string.format(
        [[ModuleQuest.Global:ProcessChatInput("%s", %d, %s)]],
        _Text, _PlayerID, tostring(_IsDebug == true)
    ));
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleQuest);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Aufträge können über das Skript erstellt werden.
--
-- Normaler Weise werden Aufträge im Questassistenten erzeugt. Dies ist aber
-- statisch und das Kopieren von Aufträgen ist nicht möglich. Wenn Aufträge
-- im Skript erzeugt werden, verschwinden alle diese Nachteile. Aufträge
-- können im Skript kopiert und angepasst werden. Es ist ebenfalls machbar,
-- die Aufträge in Sequenzen zu erzeugen.
--
-- Außerdem können Aufträge ineinander verschachtelt werden. Diese sogenannten
-- Nested Quests vereinfachen die Schreibweise und die Verlinkung der Aufträge.
--
-- <b>Befehle:</b><br>
-- <i>Diese Befehle können über die Konsole (SHIFT + ^) eingegeben werden, wenn
-- der Debug Mode aktiviert ist.</i><br>
-- <table border="1">
-- <tr>
-- <td><b>Befehl</b></td>
-- <td><b>Parameter</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>stop</td>
-- <td>QuestName</td>
-- <td>Unterbricht den angegebenen Quest.</td>
-- </tr>
-- <tr>
-- <td>start</td>
-- <td>QuestName</td>
-- <td>Startet den angegebenen Quest.</td>
-- </tr>
-- <tr>
-- <td>win</td>
-- <td>QuestName</td>
-- <td>Schließt den angegebenen Quest erfolgreich ab.</td>
-- </tr>
-- <tr>
-- <td>fail</td>
-- <td>QuestName</td>
-- <td>Lässt den angegebenen Quest fehlschlagen</td>
-- </tr>
-- <tr>
-- <td>restart</td>
-- <td>QuestName</td>
-- <td>Startet den angegebenen Quest neu.</td>
-- </tr>
-- </table>
--
-- <h4>Bekannte Probleme</h4>
-- Jede Voice Message - <b>Quests sind ebenfalls Voice Messages</b> - hat die
-- Chance, dass die Message Queue des Spiels hängen bleibt und dann ein leeres
-- Fenster mit dem Titel "Rhian over the Sea Chapell" angezeigt wird, welches
-- das Portrait Window dauerhaft blockiert und verhindert, dass weitere Voice
-- Messages - <b>auch Quests</b> - angezeigt werden können.
--
-- Es wird dringend geraten, Quests <b>ausschließlich</b> zur Darstellung von
-- Aufgaben für den Spieler und für <b>nichts anderes</b> zu benutzen.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- <li><a href="modules.QSB_1_Requester.QSB_1_Requester.html">(1) Requester</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Die Abschlussarten eines Quest Segment.
--
-- @field Success Phase muss erfolgreich abgeschlossen werden.
-- @field Failure Phase muss fehlschlagen.
-- @field Ignore  Erfolg und Misserfolg werden geleichermaßen akzeptiert.
--
QSB.SegmentResult = QSB.SegmentResult or {}

---
-- Erstellt einen Quest.
--
-- Ein Auftrag braucht immer wenigstens ein Goal und einen Trigger um ihn
-- erstellen zu können. Hat ein Quest keinen Namen, erhält er automatisch
-- einen mit fortlaufender Nummerierung.
--
-- Ein Quest besteht aus verschiedenen Eigenschaften und Behavior, die nicht
-- alle zwingend gesetzt werden müssen. Behavior werden einfach nach den
-- Eigenschaften nacheinander angegeben.
-- <p><u>Eigenschaften:</u></p>
-- <ul>
-- <li>Name: Der eindeutige Name des Quests</li>
-- <li>Sender: PlayerID des Auftraggeber (Default 1)</li>
-- <li>Receiver: PlayerID des Auftragnehmer (Default 1)</li>
-- <li>Suggestion: Vorschlagnachricht des Quests</li>
-- <li>Success: Erfolgsnachricht des Quest</li>
-- <li>Failure: Fehlschlagnachricht des Quest</li>
-- <li>Description: Aufgabenbeschreibung (Nur bei Custom)</li>
-- <li>Time: Zeit bis zu, Fehlschlag/Abschluss</li>
-- <li>Loop: Funktion, die während der Laufzeit des Quests aufgerufen wird</li>
-- <li>Callback: Funktion, die nach Abschluss aufgerufen wird</li>
-- </ul>
--
-- @param[type=table] _Data Questdefinition
-- @return[type=string] Name des Quests
-- @return[type=number] Gesamtzahl Quests
-- @within Anwenderfunktionen
-- @see API.CreateNestedQuest
--
-- @usage
-- API.CreateQuest {
--     Name        = "UnimaginativeQuestname",
--     Suggestion  = "Wir müssen das Kloster finden.",
--     Success     = "Dies sind die berümten Heilermönche.",
--
--     Goal_DiscoverPlayer(4),
--     Reward_Diplomacy(1, 4, "EstablishedContact"),
--     Trigger_Time(0),
-- }
--
function API.CreateQuest(_Data)
    if GUI then
        return;
    end
    if _Data.Name and Quests[GetQuestID(_Data.Name)] then
        error("API.CreateQuest: A quest named " ..tostring(_Data.Name).. " already exists!");
        return;
    end
    return ModuleQuest.Global:CreateSimpleQuest(_Data);
end

---
-- Erstellt einen verschachtelten Auftrag.
--
-- Verschachtelte Aufträge (Nested Quests) vereinfachen aufschreiben und
-- zuordnen der zugeordneten Aufträge. Ein Nested Quest ist selbst unsichtbar
-- und hat mindestens ein ihm untergeordnetes Segment. Die Segmente eines
-- Nested Quest sind wiederum Quests.
--
-- Du kannst für Segmente die gleichen Einträge setzen, wie bei gewöhnlichen
-- Quests. Zudem kannst du auch ihnen einen Namen geben. Wenn du das nicht tust,
-- werden sie automatisch benannt. Der Name setzt sich dann zusammen aus dem
-- Namen des Nested Quest und ihrem Index (z.B. "ExampleName@Segment1").
--
-- Segmente haben ein erwartetes Ergebnis. Für gewöhnlich ist dies auf Erfolg
-- festgelegt. Du kanns es aber auch auf Fehlschlag ändern oder ganz ignorieren.
-- Ein Nested Quest ist abgeschlossen, wenn alle Segmente mit ihrem erwarteten
-- Ergebnis abgeschlossen wurden (Erfolg) oder mindestens einer ein anderes
-- Ergebnis als erwartet hatte (Fehlschlag).
--
-- Werden Status oder Resultat eines Quest über Funktionen verändert (zb.
-- API.StopQuest oder "stop" Konsolenbefehl), dann werden die Segmente
-- ebenfalls beeinflusst.
--
-- Es ist nicht zwingend notwendig, einen Trigger für die Segmente zu setzen.
-- Alle Segmente starten automatisch sobald der Nested Quest startet. Du kannst
-- weitere Trigger zu Segmenten hinzufügen, um dieses Verhalten nach deinen
-- Bedürfnissen abzuändern (z.B. auf ein vorangegangenes Segment triggern).
--
-- Nested Quests können auch ineinander verschachtelt werden. Man kann also
-- innerhalb eines verschachtelten Auftrags eine weitere Ebene Verschachtelung
-- aufmachen.
--
-- @param[type=table] _Data Daten des Quest
-- @return[type=string] Name des Nested Quest oder nil bei Fehler
-- @within Anwenderfunktionen
-- @see QSB.SegmentResult
-- @see API.CreateQuest
--
-- @usage
-- API.CreateNestedQuest {
--     Name        = "MainQuest",
--     Segments    = {
--         {
--             Suggestion  = "Wir benötigen einen höheren Titel!",
--
--             Goal_KnightTitle("Mayor"),
--         },
--         {
--             -- Mit dem Typ Ignore wird ein Fehlschlag ignoriert.
--             Result      = QSB.SegmentResult.Ignore,
--
--             Suggestion  = "Wir benötigen außerdem mehr Asche! Und das sofort...",
--             Success     = "Geschafft!",
--             Failure     = "Versagt!",
--             Time        = 3 * 60,
--
--             Goal_Produce("G_Gold", 5000),
--
--             Trigger_OnQuestSuccess("MainQuest@Segment1", 1),
--             -- Segmented Quest wird gewonnen.
--             Reward_QuestSuccess("MainQuest"),
--         },
--         {
--             Suggestion  = "Dann versuchen wir es mit Eisen...",
--             Success     = "Geschafft!",
--             Failure     = "Versagt!",
--             Time        = 3 * 60,
--
--             Trigger_OnQuestFailure("MainQuest@Segment2"),
--             Goal_Produce("G_Iron", 50),
--         }
--     },
--
--     -- Wenn ein Quest nicht das erwartete Ergebnis hat, Fehlschlag.
--     Reprisal_Defeat(),
--     -- Wenn alles erfüllt wird, ist das Spiel gewonnen.
--     Reward_VictoryWithParty(),
-- };
--
function API.CreateNestedQuest(_Data)
    if GUI or type(_Data) ~= "table" then
        return;
    end
    if _Data.Segments == nil or #_Data.Segments == 0 then
        error(string.format("API.CreateNestedQuest: Segmented quest '%s' is missing it's segments!", tostring(_Data.Name)));
        return;
    end
    return ModuleQuest.Global:CreateNestedQuest(_Data);
end

---
-- Fügt eine Prüfung hinzu, ob Quests getriggert werden. Soll ein Quest nicht
-- getriggert werden, muss false zurückgegeben werden, sonst true.
--
-- @param[type=function] _Function Prüffunktion
-- @within Anwenderfunktionen
-- @local
--
function API.AddDisableTriggerCondition(_Function)
    if GUI then
        return;
    end
    table.insert(ModuleQuest.Global.ExternalTriggerConditions, _Function);
end

---
-- Fügt eine Prüfung hinzu, ob für laufende Quests Zeit vergeht. Soll keine Zeit
-- vergehen für einen Quest, muss false zurückgegeben werden, sonst true.
--
-- @param[type=function] _Function Prüffunktion
-- @within Anwenderfunktionen
-- @local
--
function API.AddDisableTimerCondition(_Function)
    if GUI then
        return;
    end
    table.insert(ModuleQuest.Global.ExternalTimerConditions, _Function);
end

---
-- Fügt eine Prüfung hinzu, ob für laufende Quests Ziele geprüft werden. Sollen
-- keine Ziele geprüft werden, muss false zurückgegeben werden, sonst true.
--
-- @param[type=function] _Function Prüffunktion
-- @within Anwenderfunktionen
-- @local
--
function API.AddDisableDecisionCondition(_Function)
    if GUI then
        return;
    end
    table.insert(ModuleQuest.Global.ExternalDecisionConditions, _Function);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleSelection = {
    Properties = {
        Name = "ModuleSelection",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        TrebuchetIDToCart = {},
        SelectedEntities = {},
    },
    Local = {
        SelectedEntities = {},
        TrebuchetDisassemble = false,
        TrebuchetErect = false,
        ThiefRelease = false,
        SiegeEngineRelease = true,
        MilitaryRelease = true,
    },

    Shared = {
        Text = {
            Tooltips = {
                KnightButton = {
                    Title = {
                        de = "Ritter selektieren",
                        en = "Select Knight",
                        fr = "Sélectionner le chevalier",
                    },
                    Text = {
                        de = "- Klick selektiert den Ritter {cr}- Doppelklick springt zum Ritter{cr}- STRG halten selektiert alle Ritter",
                        en = "- Click selects the knight {cr}- Double click jumps to knight{cr}- Press CTRL to select all knights",
                        fr = "- Clic sélectionne le chevalier {cr}- Double-clic saute au chevalier{cr}- Maintenir CTRL sélectionne tous les chevaliers",
                    },
                },

                BattalionButton = {
                    Title = {
                        de = "Militär selektieren",
                        en = "Select Units",
                        fr = "Sélectionner les unitées",
                    },
                    Text = {
                        de = "- Selektiert alle Militäreinheiten {cr}- SHIFT halten um auch Diebe, Munitionswagen und Trebuchets auszuwählen",
                        en = "- Selects all military units {cr}- Press SHIFT to additionally select ammunition carts, thieves and trebuchets",
                        fr = "- Sélectionne toutes les unités militaires {cr}- Maintenir SHIFT pour sélectionner aussi les voleurs, les chariots de munitions et les trébuchets",
                    },
                },

                ReleaseSoldiers = {
                    Title = {
                        de = "Militär entlassen",
                        en = "Release military unit",
                        fr = "licencier l'unitées",
                    },
                    Text = {
                        de = "- Eine Militäreinheit entlassen {cr}- Soldaten werden nacheinander entlassen",
                        en = "- Dismiss a military unit {cr}- Soldiers will be dismissed each after another",
                        fr = "- Licencier une unité militaire {cr}- Les soldats sont licenciés les uns après les autres",
                    },
                    Disabled = {
                        de = "Kann nicht entlassen werden!",
                        en = "Releasing is impossible!",
                        fr = "Ne peut pas être licencié!",
                    },
                },

                TrebuchetCart = {
                    Title = {
                        de = "Trebuchetwagen",
                        en = "Trebuchet cart",
                        fr = "Chariot à trébuchet",
                    },
                    Text = {
                        de = "- Kann einmalig zum Trebuchet ausgebaut werden",
                        en = "- Can uniquely be transmuted into a trebuchet",
                        fr = "- Peut être transformé une seule fois en trébuchet",
                    },
                },

                Trebuchet = {
                    Title = {
                        de = "Trebuchet",
                        en = "Trebuchet",
                        fr = "Trébuchet",
                    },
                    Text = {
                        de = "- Kann über weite Strecken Gebäude angreifen {cr}- Kann Gebäude in Brand stecken {cr}- Trebuchet kann manuell zurückgeschickt werden",
                        en = "- Can perform long range attacks on buildings {cr}- Can set buildings on fire {cr}- The trebuchet can be manually send back to the city",
                        fr = "- Peut attaquer des bâtiments sur de longues distances {cr}- Peut mettre le feu à des bâtiments {cr}- Le trébuchet peut être renvoyé manuellement",
                    },
                },
            },
        }
    };
}

-- Global ------------------------------------------------------------------- --

function ModuleSelection.Global:OnGameStart()
    QSB.ScriptEvents.SelectionChanged = API.RegisterScriptEvent("Event_SelectionChanged");

    API.RegisterScriptCommand("Cmd_SelectionDestroyEntity", function(_Entity)
        DestroyEntity(_Entity);
    end);
    API.RegisterScriptCommand("Cmd_SelectionSetTaskList", function(_Entity)
        Logic.SetTaskList(GetID(_Entity), TaskLists.TL_NPC_IDLE);
    end);
    API.RegisterScriptCommand("Cmd_SelectionErectTrebuchet", function(_Entity)
        return ModuleSelection.Global:MilitaryErectTrebuchet(_Entity);
    end);
    API.RegisterScriptCommand("Cmd_SelectionDisambleTrebuchet", function(_Entity)
        return ModuleSelection.Global:MilitaryDisambleTrebuchet(_Entity);
    end);

    for i= 1, 8 do
        self.SelectedEntities[i] = {};
    end
end

function ModuleSelection.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.SelectionChanged then
        self.SelectedEntities[arg[1]] = arg[3];
    end
end

function ModuleSelection.Global:MilitaryDisambleTrebuchet(_EntityID)
    local x,y,z = Logic.EntityGetPos(_EntityID);
    local PlayerID = Logic.EntityGetPlayer(_EntityID);

    -- Extern callback for the mapscript
    if GameCallback_QSB_OnDisambleTrebuchet then
        GameCallback_QSB_OnDisambleTrebuchet(_EntityID, PlayerID, x, y, z);
        return;
    end

    Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);
    Logic.SetEntityInvulnerabilityFlag(_EntityID, 1);
    Logic.SetEntitySelectableFlag(_EntityID, 0);
    Logic.SetVisible(_EntityID, false);

    local TrebuchetCart = self.TrebuchetIDToCart[_EntityID];
    if TrebuchetCart ~= nil then
        Logic.SetEntityInvulnerabilityFlag(TrebuchetCart, 0);
        Logic.SetEntitySelectableFlag(TrebuchetCart, 1);
        Logic.SetVisible(TrebuchetCart, true);
    else
        TrebuchetCart = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, PlayerID);
        self.TrebuchetIDToCart[_EntityID] = TrebuchetCart;
    end

    Logic.DEBUG_SetSettlerPosition(TrebuchetCart, x, y);
    Logic.SetTaskList(TrebuchetCart, TaskLists.TL_NPC_IDLE);
    Logic.ExecuteInLuaLocalState(string.format(
        [[GUI.SelectEntity(%d)]], TrebuchetCart
    ));
end

function ModuleSelection.Global:MilitaryErectTrebuchet(_EntityID)
    local x,y,z = Logic.EntityGetPos(_EntityID);
    local PlayerID = Logic.EntityGetPlayer(_EntityID);

    -- Extern callback for the mapscript
    if GameCallback_QSB_OnErectTrebuchet then
        GameCallback_QSB_OnErectTrebuchet(_EntityID, PlayerID, x, y, z);
        return;
    end

    Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);
    Logic.SetEntityInvulnerabilityFlag(_EntityID, 1);
    Logic.SetEntitySelectableFlag(_EntityID, 0);
    Logic.SetVisible(_EntityID, false);

    local Trebuchet;
    for k, v in pairs(self.TrebuchetIDToCart) do
        if v == _EntityID then
            Trebuchet = tonumber(k);
        end
    end
    if Trebuchet == nil then
        Trebuchet = Logic.CreateEntity(Entities.U_Trebuchet, x, y, 0, PlayerID);
        self.TrebuchetIDToCart[Trebuchet] = _EntityID;
    end

    Logic.SetEntityInvulnerabilityFlag(Trebuchet, 0);
    Logic.SetEntitySelectableFlag(Trebuchet, 1);
    Logic.SetVisible(Trebuchet, true);
    Logic.DEBUG_SetSettlerPosition(Trebuchet, x, y);
    Logic.ExecuteInLuaLocalState([[
        GUI.SelectEntity(]]..Trebuchet..[[)
    ]]);
end

-- Local -------------------------------------------------------------------- --

function ModuleSelection.Local:OnGameStart()
    QSB.ScriptEvents.SelectionChanged = API.RegisterScriptEvent("Event_SelectionChanged");

    if API.IsHistoryEditionNetworkGame() then
        return;
    end
    self:OverrideSelection();
    self:OverwriteMilitaryCommands();
    self:OverwriteMilitaryErect();
    self:OverwriteMilitaryDisamble();
    self:OverwriteMultiselectIcon();
    self:OverwriteMilitaryDismount();
    self:OverwriteThiefDeliver();
    self:OverwriteSelectKnight();
    self:OverwriteSelectAllUnits();
    self:OverwriteNamesAndDescription();
end

function ModuleSelection.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

function ModuleSelection.Local:OverrideSelection()
    GameCallback_GUI_SelectionChanged_Orig_ModuleSelection = GameCallback_GUI_SelectionChanged;
    GameCallback_GUI_SelectionChanged = function(_Source)
        GameCallback_GUI_SelectionChanged_Orig_ModuleSelection(_Source);
        ModuleSelection.Local:OnSelectionCanged(_Source);
    end
end

function ModuleSelection.Local:OverwriteMilitaryCommands()
    GUI_Military.StandGroundClicked = function()
        Sound.FXPlay2DSound( "ui\\menu_click");
        local SelectedEntities = {GUI.GetSelectedEntities()};
        for i=1,#SelectedEntities do
            local LeaderID = SelectedEntities[i];
            local eType = Logic.GetEntityType(LeaderID);
            GUI.SendCommandStationaryDefend(LeaderID);
            if eType == Entities.U_Trebuchet then
                API.BroadcastScriptCommand(
                    QSB.ScriptCommands.SelectionSetTaskList,
                    LeaderID,
                    TaskLists.TL_NPC_IDLE
                );
            end
        end
    end

    GUI_Military.StandGroundUpdate = function()
        local WidgetAttack = "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack";
        local SelectedEntities = {GUI.GetSelectedEntities()};
        SetIcon(WidgetAttack, {12, 4});
        if #SelectedEntities == 1 then
            local eID = SelectedEntities[1];
            local eType = Logic.GetEntityType(eID);
            if eType == Entities.U_Trebuchet then
                if Logic.GetAmmunitionAmount(eID) > 0 then
                    XGUIEng.ShowWidget(WidgetAttack, 0);
                else
                    XGUIEng.ShowWidget(WidgetAttack, 1);
                end
                SetIcon(WidgetAttack, {1, 10});
            else
                XGUIEng.ShowWidget(WidgetAttack, 1);
            end
        end
    end
end

function ModuleSelection.Local:OverwriteMilitaryErect()
    GUI_Military.ErectClicked_Orig_ModuleSelection = GUI_Military.ErectClicked;
    GUI_Military.ErectClicked = function()
        GUI_Military.ErectClicked_Orig_ModuleSelection();
        local SelectedEntities = {GUI.GetSelectedEntities()};
        for i=1, #SelectedEntities, 1 do
            local EntityType = Logic.GetEntityType(SelectedEntities[i]);
            if EntityType == Entities.U_SiegeEngineCart then
                API.BroadcastScriptCommand(
                    QSB.ScriptCommands.SelectionErectTrebuchet,
                    SelectedEntities[i]
                );
            end
        end
    end

    GUI_Military.ErectUpdate_Orig_ModuleSelection = GUI_Military.ErectUpdate;
    GUI_Military.ErectUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local SiegeCartID = GUI.GetSelectedEntity();
        local EntityType = Logic.GetEntityType(SiegeCartID);
        if EntityType == Entities.U_SiegeEngineCart then
            local Disabled = (ModuleSelection.Local.TrebuchetErect and 0) or 1;
            XGUIEng.DisableButton(CurrentWidgetID, Disabled);
            SetIcon(CurrentWidgetID, {12, 6});
        else
            GUI_Military.ErectUpdate_Orig_ModuleSelection();
        end
    end

    GUI_Military.ErectMouseOver_Orig_ModuleSelection = GUI_Military.ErectMouseOver;
    GUI_Military.ErectMouseOver = function()
        local SiegeCartID = GUI.GetSelectedEntity();
        local TooltipTextKey;
        if Logic.GetEntityType(SiegeCartID) == Entities.U_SiegeEngineCart then
            TooltipTextKey = "ErectCatapult";
        else
            GUI_Military.ErectMouseOver_Orig_ModuleSelection();
            return;
        end
        GUI_Tooltip.TooltipNormal(TooltipTextKey, "Erect");
    end
end

function ModuleSelection.Local:OverwriteMilitaryDisamble()
    GUI_Military.DisassembleClicked_Orig_ModuleSelection = GUI_Military.DisassembleClicked;
    GUI_Military.DisassembleClicked = function()
        GUI_Military.DisassembleClicked_Orig_ModuleSelection();
        local SelectedEntities = {GUI.GetSelectedEntities()};
        for i=1, #SelectedEntities, 1 do
            local EntityType = Logic.GetEntityType(SelectedEntities[i]);
            if EntityType == Entities.U_Trebuchet then
                API.BroadcastScriptCommand(
                    QSB.ScriptCommands.SelectionDisambleTrebuchet,
                    SelectedEntities[i]
                );
            end
        end
    end

    GUI_Military.DisassembleMouseOver_Orig_ModuleSelection = GUI_Military.DisassembleMouseOver;
    GUI_Military.DisassembleMouseOver = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID()
        local PlayerID = GUI.GetPlayerID()
        local SiegeEngineID = GUI.GetSelectedEntity()
        local TooltipDisabledTextKey
        if Logic.IsSiegeEngineUnderConstruction(SiegeEngineID) == true then
            TooltipDisabledTextKey = "Disassemble"
        else
            TooltipDisabledTextKey = "DisassembleNoSoldiersAttached"
            if not ModuleSelection.Local.TrebuchetDisassemble then
                TooltipDisabledTextKey = "Disassemble";
            end
        end
        GUI_Tooltip.TooltipNormal(nil, TooltipDisabledTextKey)
    end

    GUI_Military.DisassembleUpdate_Orig_ModuleSelection = GUI_Military.DisassembleUpdate;
    GUI_Military.DisassembleUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local SiegeEngineID = GUI.GetSelectedEntity();
        local EntityType = Logic.GetEntityType(SiegeEngineID);
        if EntityType == Entities.U_Trebuchet then
            local Disabled = (ModuleSelection.Local.TrebuchetDisassemble and 0) or 1;
            XGUIEng.DisableButton(CurrentWidgetID, Disabled);
            SetIcon(CurrentWidgetID, {12, 9});
        else
            GUI_Military.DisassembleUpdate_Orig_ModuleSelection();
        end
    end
end

function ModuleSelection.Local:OnSelectionCanged(_Source)
    local OldSelection = self.SelectedEntities or {};
    local SelectedEntities = {GUI.GetSelectedEntities()};
    local PlayerID = GUI.GetPlayerID();
    local EntityID = GUI.GetSelectedEntity();
    local EntityType = Logic.GetEntityType(EntityID);

    local OldSelectionString = Swift.LuaBase:ConvertTableToString(self.SelectedEntities[PlayerID] or {});
    self.SelectedEntities[PlayerID] = SelectedEntities;
    local NewSelectionString = Swift.LuaBase:ConvertTableToString(self.SelectedEntities[PlayerID] or {});

    -- This event is only send on the local machine. Only the local player
    -- can select units, so the event musn't be send to other players!
    API.SendScriptEvent(
        QSB.ScriptEvents.SelectionChanged,
        PlayerID,
        OldSelection[PlayerID],
        SelectedEntities
    );
    API.SendScriptEventToGlobal(
        "SelectionChanged",
        PlayerID,
        OldSelection[PlayerID],
        SelectedEntities
    );

    if EntityID ~= nil then
        if EntityType == Entities.U_SiegeEngineCart then
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/BGMilitary", 1);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngineCart", 1);
        elseif EntityType == Entities.U_Trebuchet then
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/BGMilitary", 1);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military", 1);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack", 0);
            GUI_Military.StrengthUpdate();
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngine", 1);
        end
    end
end

function ModuleSelection.Local:OverwriteMultiselectIcon()
    GUI_MultiSelection.IconUpdate_Orig_ModuleSelection = GUI_MultiSelection.IconUpdate;
    GUI_MultiSelection.IconUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local CurrentMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);
        local CurrentMotherName = XGUIEng.GetWidgetNameByID(CurrentMotherID);
        local Index = CurrentMotherName + 0;
        local CurrentMotherPath = XGUIEng.GetWidgetPathByID(CurrentMotherID);
        local HealthWidgetPath = CurrentMotherPath .. "/Health";
        local EntityID = g_MultiSelection.EntityList[Index];
        local EntityType = Logic.GetEntityType(EntityID);
        local HealthState = Logic.GetEntityHealth(EntityID);
        local EntityMaxHealth = Logic.GetEntityMaxHealth(EntityID);
        if EntityType ~= Entities.U_SiegeEngineCart and EntityType ~= Entities.U_Trebuchet then
            GUI_MultiSelection.IconUpdate_Orig_ModuleSelection();
            return;
        end
        if Logic.IsEntityAlive(EntityID) == false then
            XGUIEng.ShowWidget(CurrentMotherID, 0);
            GUI_MultiSelection.CreateEX();
            return;
        end
        SetIcon(CurrentWidgetID, g_TexturePositions.Entities[EntityType]);
        HealthState = math.floor(HealthState / EntityMaxHealth * 100);
        if HealthState < 50 then
            local green = math.floor(2*255* (HealthState/100));
            XGUIEng.SetMaterialColor(HealthWidgetPath,0,255,green, 20,255);
        else
            local red = 2*255 - math.floor(2*255* (HealthState/100));
            XGUIEng.SetMaterialColor(HealthWidgetPath,0,red, 255, 20,255);
        end
        XGUIEng.SetProgressBarValues(HealthWidgetPath,HealthState, 100);
    end

    GUI_MultiSelection.IconMouseOver_Orig_ModuleSelection = GUI_MultiSelection.IconMouseOver;
    GUI_MultiSelection.IconMouseOver = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local CurrentMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);
        local CurrentMotherName = XGUIEng.GetWidgetNameByID(CurrentMotherID);
        local Index = tonumber(CurrentMotherName);
        local EntityID = g_MultiSelection.EntityList[Index];
        local EntityType = Logic.GetEntityType(EntityID);
        if EntityType ~= Entities.U_SiegeEngineCart and EntityType ~= Entities.U_Trebuchet then
            GUI_MultiSelection.IconMouseOver_Orig_ModuleSelection();
            return;
        end
        if EntityType == Entities.U_SiegeEngineCart then
            local TooltipData = API.Localize(ModuleSelection.Shared.Text.Tooltips.TrebuchetCart);
            API.SetTooltipNormal(TooltipData.Title, TooltipData.Text);
        elseif EntityType == Entities.U_Trebuchet then
            local TooltipData = API.Localize(ModuleSelection.Shared.Text.Tooltips.Trebuchet);
            API.SetTooltipNormal(TooltipData.Title, TooltipData.Text);
        end
    end
end

function ModuleSelection.Local:OverwriteMilitaryDismount()
    GUI_Military.DismountClicked_Orig_ModuleSelection = GUI_Military.DismountClicked;
    GUI_Military.DismountClicked = function()
        local Selected = GUI.GetSelectedEntity();
        local Type = Logic.GetEntityType(Selected);
        local Guarded = Logic.GetGuardedEntityID(Selected);
        local Guardian = Logic.GetGuardianEntityID(Selected);
        if Guarded ~= 0 and Logic.EntityGetPlayer(Guarded) ~= GUI.GetPlayerID() then
            GUI_Military.DismountClicked_Orig_ModuleSelection();
            return;
        end
        if Logic.IsKnight(Selected) or Logic.IsEntityInCategory(Selected, EntityCategories.AttackableMerchant) == 1 then
            GUI_Military.DismountClicked_Orig_ModuleSelection();
            return;
        end
        if Logic.IsLeader(Selected) == 1 and Guarded == 0 then
            if ModuleSelection.Local.MilitaryRelease then
                Sound.FXPlay2DSound( "ui\\menu_click");
                local Soldiers = {Logic.GetSoldiersAttachedToLeader(Selected)};
                API.BroadcastScriptCommand(QSB.ScriptCommands.SelectionDestroyEntity, Soldiers[#Soldiers]);
                return;
            end
        end
        if Type == Entities.U_AmmunitionCart or Type == Entities.U_BatteringRamCart
        or Type == Entities.U_CatapultCart or Type == Entities.U_SiegeTowerCart
        or Type == Entities.U_MilitaryBatteringRam or Entities.U_MilitaryCatapult
        or Type == Entities.U_MilitarySiegeTower then
            if ModuleSelection.Local.SiegeEngineRelease and Guardian == 0 then
                Sound.FXPlay2DSound( "ui\\menu_click");
                API.BroadcastScriptCommand(QSB.ScriptCommands.SelectionDestroyEntity, Selected);
            else
                GUI_Military.DismountClicked_Orig_ModuleSelection();
            end
        end
    end

    GUI_Military.DismountUpdate_Orig_ModuleSelection = GUI_Military.DismountUpdate;
    GUI_Military.DismountUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local Selected = GUI.GetSelectedEntity();
        local Type = Logic.GetEntityType(Selected);
        local Guarded = Logic.GetGuardedEntityID(Selected);
        local Guardian = Logic.GetGuardianEntityID(Selected);
        SetIcon(CurrentWidgetID, {12, 1});
        if Guarded ~= 0 and Logic.EntityGetPlayer(Guarded) ~= GUI.GetPlayerID() then
            XGUIEng.DisableButton(CurrentWidgetID, 0);
            GUI_Military.DismountUpdate_Orig_ModuleSelection();
            return;
        end
        if Logic.IsKnight(Selected) or Logic.IsEntityInCategory(Selected, EntityCategories.AttackableMerchant) == 1 then
            XGUIEng.DisableButton(CurrentWidgetID, 0);
            GUI_Military.DismountUpdate_Orig_ModuleSelection();
            return;
        end
        SetIcon(CurrentWidgetID, {14, 12});
        if Type == Entities.U_MilitaryLeader then
            if not ModuleSelection.Local.MilitaryRelease then
                XGUIEng.DisableButton(CurrentWidgetID, 1);
            else
                XGUIEng.DisableButton(CurrentWidgetID, 0);
            end
            return;
        end
        if Type == Entities.U_AmmunitionCart or Type == Entities.U_BatteringRamCart
        or Type == Entities.U_CatapultCart or Type == Entities.U_SiegeTowerCart
        or Type == Entities.U_MilitaryBatteringRam or Entities.U_MilitaryCatapult
        or Type == Entities.U_MilitarySiegeTower then
            if Guardian ~= 0 then
                SetIcon(CurrentWidgetID, {12, 1});
                XGUIEng.DisableButton(CurrentWidgetID, 0);
            else
                if not ModuleSelection.Local.SiegeEngineRelease then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                else
                    XGUIEng.DisableButton(CurrentWidgetID, 0);
                end
            end
        end
    end
end

function ModuleSelection.Local:OverwriteThiefDeliver()
    GUI_Thief.ThiefDeliverClicked_Orig_ModuleSelection = GUI_Thief.ThiefDeliverClicked;
    GUI_Thief.ThiefDeliverClicked = function()
        if not ModuleSelection.Local.ThiefRelease then
            GUI_Thief.ThiefDeliverClicked_Orig_ModuleSelection();
            return;
        end
        Sound.FXPlay2DSound( "ui\\menu_click");
        local ThiefID = GUI.GetSelectedEntity()
        if ThiefID == nil or Logic.GetEntityType(ThiefID) ~= Entities.U_Thief then
            return;
        end
        API.BroadcastScriptCommand(QSB.ScriptCommands.SelectionDestroyEntity, ThiefID);
    end

    GUI_Thief.ThiefDeliverMouseOver_Orig_ModuleSelection = GUI_Thief.ThiefDeliverMouseOver;
    GUI_Thief.ThiefDeliverMouseOver = function()
        if not ModuleSelection.Local.ThiefRelease then
            GUI_Thief.ThiefDeliverMouseOver_Orig_ModuleSelection();
            return;
        end
        local Text = API.Localize(ModuleSelection.Shared.Text.Tooltips.ReleaseSoldiers);
        API.SetTooltipNormal(Text.Title, Text.Text, Text.Disabled);
    end

    GUI_Thief.ThiefDeliverUpdate_Orig_ModuleSelection = GUI_Thief.ThiefDeliverUpdate;
    GUI_Thief.ThiefDeliverUpdate = function()
        if not ModuleSelection.Local.ThiefRelease then
            GUI_Thief.ThiefDeliverUpdate_Orig_ModuleSelection();
            return;
        end
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local ThiefID = GUI.GetSelectedEntity();
        if ThiefID == nil or Logic.GetEntityType(ThiefID) ~= Entities.U_Thief then
            XGUIEng.DisableButton(CurrentWidgetID, 1);
        else
            XGUIEng.DisableButton(CurrentWidgetID, 0);
        end
        SetIcon(CurrentWidgetID, {14, 12});
    end
end

function ModuleSelection.Local:OverwriteSelectKnight()
    GUI_Knight.JumpToButtonClicked = function()
        local PlayerID = GUI.GetPlayerID();
        local KnightID = Logic.GetKnightID(PlayerID);
        if KnightID > 0 then
            g_MultiSelection.EntityList = {};
            g_MultiSelection.Highlighted = {};
            GUI.ClearSelection();
            if XGUIEng.IsModifierPressed(Keys.ModifierControl) then
                local knights = {}
                Logic.GetKnights(PlayerID, knights);
                for i=1,#knights do
                    GUI.SelectEntity(knights[i]);
                end
            else
                GUI.SelectEntity(Logic.GetKnightID(PlayerID));
                if ((Framework.GetTimeMs() - g_Selection.LastClickTime ) < g_Selection.MaxDoubleClickTime) then
                    local pos = GetPosition(KnightID);
                    Camera.RTS_SetLookAtPosition(pos.X, pos.Y);
                else
                    Sound.FXPlay2DSound("ui\\mini_knight");
                end
                g_Selection.LastClickTime = Framework.GetTimeMs();
            end
            GUI_MultiSelection.CreateMultiSelection(g_SelectionChangedSource.User);
        else
            GUI.AddNote("Debug: You do not have a knight");
        end
    end
end

function ModuleSelection.Local:OverwriteSelectAllUnits()
    GUI_MultiSelection.SelectAllPlayerUnitsClicked = function()
        if XGUIEng.IsModifierPressed(Keys.ModifierShift) then
            ModuleSelection.Local:ExtendedLeaderSortOrder();
        else
            ModuleSelection.Local:NormalLeaderSortOrder();
        end
        Sound.FXPlay2DSound("ui\\menu_click");
        GUI.ClearSelection();
        local PlayerID = GUI.GetPlayerID()
        for i = 1, #LeaderSortOrder do
            local EntitiesOfThisType = GetPlayerEntities(PlayerID, LeaderSortOrder[i])
            for j = 1, #EntitiesOfThisType do
                GUI.SelectEntity(EntitiesOfThisType[j])
            end
        end
        local Knights = {}
        Logic.GetKnights(PlayerID, Knights)
        for k = 1, #Knights do
            GUI.SelectEntity(Knights[k])
        end
        GUI_MultiSelection.CreateMultiSelection(g_SelectionChangedSource.User);
    end
end

function ModuleSelection.Local:NormalLeaderSortOrder()
    g_MultiSelection = {};
    g_MultiSelection.EntityList = {};
    g_MultiSelection.Highlighted = {};

    LeaderSortOrder     = {};
    LeaderSortOrder[1]  = Entities.U_MilitarySword;
    LeaderSortOrder[2]  = Entities.U_MilitaryBow;
    LeaderSortOrder[3]  = Entities.U_MilitarySword_RedPrince;
    LeaderSortOrder[4]  = Entities.U_MilitaryBow_RedPrince;
    LeaderSortOrder[5]  = Entities.U_MilitaryBandit_Melee_ME;
    LeaderSortOrder[6]  = Entities.U_MilitaryBandit_Melee_NA;
    LeaderSortOrder[7]  = Entities.U_MilitaryBandit_Melee_NE;
    LeaderSortOrder[8]  = Entities.U_MilitaryBandit_Melee_SE;
    LeaderSortOrder[9]  = Entities.U_MilitaryBandit_Ranged_ME;
    LeaderSortOrder[10] = Entities.U_MilitaryBandit_Ranged_NA;
    LeaderSortOrder[11] = Entities.U_MilitaryBandit_Ranged_NE;
    LeaderSortOrder[12] = Entities.U_MilitaryBandit_Ranged_SE;
    LeaderSortOrder[13] = Entities.U_MilitaryCatapult;
    LeaderSortOrder[14] = Entities.U_MilitarySiegeTower;
    LeaderSortOrder[15] = Entities.U_MilitaryBatteringRam;
    LeaderSortOrder[16] = Entities.U_CatapultCart;
    LeaderSortOrder[17] = Entities.U_SiegeTowerCart;
    LeaderSortOrder[18] = Entities.U_BatteringRamCart;

    -- Asien wird nur in der Erweiterung gebraucht.
    if g_GameExtraNo >= 1 then
        table.insert(LeaderSortOrder,  4, Entities.U_MilitarySword_Khana);
        table.insert(LeaderSortOrder,  6, Entities.U_MilitaryBow_Khana);
        table.insert(LeaderSortOrder,  7, Entities.U_MilitaryBandit_Melee_AS);
        table.insert(LeaderSortOrder, 12, Entities.U_MilitaryBandit_Ranged_AS);
    end

    -- Community Patch
    if Entities.U_MilitaryCavalry then
        table.insert(LeaderSortOrder,  2, Entities.U_MilitaryCavalry);
    end
    if Entities.U_MilitaryPoleArm then
        table.insert(LeaderSortOrder,  2, Entities.U_MilitaryPoleArm);
    end
    if Entities.U_MilitaryCannon then
        table.insert(LeaderSortOrder,  17, Entities.U_MilitaryCannon);
    end
end

function ModuleSelection.Local:ExtendedLeaderSortOrder()
    g_MultiSelection = {};
    g_MultiSelection.EntityList = {};
    g_MultiSelection.Highlighted = {};

    LeaderSortOrder     = {};
    LeaderSortOrder[1]  = Entities.U_MilitarySword;
    LeaderSortOrder[2]  = Entities.U_MilitaryBow;
    LeaderSortOrder[3]  = Entities.U_MilitarySword_RedPrince;
    LeaderSortOrder[4]  = Entities.U_MilitaryBow_RedPrince;
    LeaderSortOrder[5]  = Entities.U_MilitaryBandit_Melee_ME;
    LeaderSortOrder[6]  = Entities.U_MilitaryBandit_Melee_NA;
    LeaderSortOrder[7]  = Entities.U_MilitaryBandit_Melee_NE;
    LeaderSortOrder[8]  = Entities.U_MilitaryBandit_Melee_SE;
    LeaderSortOrder[9]  = Entities.U_MilitaryBandit_Ranged_ME;
    LeaderSortOrder[10] = Entities.U_MilitaryBandit_Ranged_NA;
    LeaderSortOrder[11] = Entities.U_MilitaryBandit_Ranged_NE;
    LeaderSortOrder[12] = Entities.U_MilitaryBandit_Ranged_SE;
    LeaderSortOrder[13] = Entities.U_MilitaryCatapult;
    LeaderSortOrder[14] = Entities.U_Trebuchet;
    LeaderSortOrder[15] = Entities.U_MilitarySiegeTower;
    LeaderSortOrder[16] = Entities.U_MilitaryBatteringRam;
    LeaderSortOrder[17] = Entities.U_CatapultCart;
    LeaderSortOrder[18] = Entities.U_SiegeTowerCart;
    LeaderSortOrder[19] = Entities.U_BatteringRamCart;
    LeaderSortOrder[20] = Entities.U_AmmunitionCart;
    LeaderSortOrder[21] = Entities.U_Thief;

    -- Asien wird nur in der Erweiterung gebraucht.
    if g_GameExtraNo >= 1 then
        table.insert(LeaderSortOrder,  4, Entities.U_MilitarySword_Khana);
        table.insert(LeaderSortOrder,  6, Entities.U_MilitaryBow_Khana);
        table.insert(LeaderSortOrder,  7, Entities.U_MilitaryBandit_Melee_AS);
        table.insert(LeaderSortOrder, 12, Entities.U_MilitaryBandit_Ranged_AS);
    end

    -- Community Patch
    if Entities.U_MilitaryCavalry then
        table.insert(LeaderSortOrder,  2, Entities.U_MilitaryCavalry);
    end
    if Entities.U_MilitaryPoleArm then
        table.insert(LeaderSortOrder,  2, Entities.U_MilitaryPoleArm);
    end
    if Entities.U_MilitaryCannon then
        table.insert(LeaderSortOrder,  17, Entities.U_MilitaryCannon);
    end
end

function ModuleSelection.Local:OverwriteNamesAndDescription()
    GUI_Tooltip.SetNameAndDescription_Orig_ModuleSelection = GUI_Tooltip.SetNameAndDescription;
    GUI_Tooltip.SetNameAndDescription = function(
        _TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName,
        _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean
    )
        local MotherWidget = "/InGame/Root/Normal/AlignBottomRight";
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();

        if XGUIEng.GetWidgetID(MotherWidget.. "/MapFrame/KnightButton") == CurrentWidgetID then
            local Text = API.Localize(ModuleSelection.Shared.Text.Tooltips.KnightButton);
            API.SetTooltipNormal(Text.Title, Text.Text);
            return;
        end

        if XGUIEng.GetWidgetID(MotherWidget.. "/MapFrame/BattalionButton") == CurrentWidgetID then
            local Text = API.Localize(ModuleSelection.Shared.Text.Tooltips.BattalionButton);
            API.SetTooltipNormal(Text.Title, Text.Text);
            return;
        end

        if XGUIEng.GetWidgetID(MotherWidget.. "/DialogButtons/SiegeEngineCart/Dismount") == CurrentWidgetID
        or XGUIEng.GetWidgetID(MotherWidget.. "/DialogButtons/AmmunitionCart/Dismount") == CurrentWidgetID
        or XGUIEng.GetWidgetID(MotherWidget.. "/DialogButtons/Military/Dismount") == CurrentWidgetID
        then
            local SelectedEntity = GUI.GetSelectedEntity();
            if SelectedEntity ~= 0 then
                if Logic.IsEntityInCategory(SelectedEntity, EntityCategories.Military) == 1 then
                    local GuardianEntity = Logic.GetGuardianEntityID(SelectedEntity);
                    local GuardedEntity = Logic.GetGuardedEntityID(SelectedEntity);
                    if GuardianEntity == 0 and GuardedEntity == 0 then
                        local Text = API.Localize(ModuleSelection.Shared.Text.Tooltips.ReleaseSoldiers);
                        API.SetTooltipNormal(Text.Title, Text.Text, Text.Disabled);
                        return;
                    end
                end
            end
        end

        GUI_Tooltip.SetNameAndDescription_Orig_ModuleSelection(
            _TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName,
            _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean
        );
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleSelection);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Die Optionen für selektierte Einheiten können individualisiert werden.
--
-- Es wird ein Button zum Entlassen von Einheiten hinzugefügt.
-- 
-- <table border="1">
-- <tr><td><b>Einheitentyp</b></td><td><b>Vorsteinstellung</b></td></tr>
-- <tr><td>Soldaten</td><td>aktiv</td></tr>
-- <tr><td>Kriegsmaschinen</td><td>aktiv</td></tr>
-- <tr><td>Diebe</td><td>deaktiviert</td></tr>
-- </table>
--
-- Trebuchets haben nun das gleiche Menü, wie die anderen Kriegsmaschinen. Sie
-- können jedoch nicht abgebaut werden.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field SelectionChanged Die Selektion hat sich geändert (Parameter: PlayerID, OldIdList, NewIdList)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Deaktiviert oder aktiviert das Entlassen von Dieben.
-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)
-- @within Anwenderfunktionen
--
-- @usage
-- API.DisableReleaseThieves(false);
--
function API.DisableReleaseThieves(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.DisableReleaseThieves(%s)]],
            tostring(_Flag)
        ));
        return;
    end
    ModuleSelection.Local.ThiefRelease = not _Flag;
end

---
-- Deaktiviert oder aktiviert das Entlassen von Kriegsmaschinen.
-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)
-- @within Anwenderfunktionen
--
-- @usage
-- API.DisableReleaseSiegeEngines(true);
--
function API.DisableReleaseSiegeEngines(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.DisableReleaseSiegeEngines(%s)]],
            tostring(_Flag)
        ));
        return;
    end
    ModuleSelection.Local.SiegeEngineRelease = not _Flag;
end

---
-- Deaktiviert oder aktiviert das Entlassen von Soldaten.
-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)
-- @within Anwenderfunktionen
--
-- @usage
-- API.DisableReleaseSoldiers(false);
--
function API.DisableReleaseSoldiers(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.DisableReleaseSoldiers(%s)]],
            tostring(_Flag)
        ));
        return;
    end
    ModuleSelection.Local.MilitaryRelease = not _Flag;
end

---
-- Prüft ob das Entity selektiert ist.
--
-- @param _Entity                Entity das selektiert sein soll (Skriptname oder ID)
-- @param[type=number] _PlayerID ID des selektierenden Spielers
-- @return[type=boolean] Entity ist selektiert
-- @within Anwenderfunktionen
--
-- @usage
-- if API.IsEntityInSelection("hakim", 1) then
--     -- Do something
-- end
--
function API.IsEntityInSelection(_Entity, _PlayerID)
    if IsExisting(_Entity) then
        local EntityID = GetID(_Entity);
        local SelectedEntities;
        if not GUI then
            SelectedEntities = ModuleSelection.Global.SelectedEntities[_PlayerID];
        else
            SelectedEntities = {GUI.GetSelectedEntities()};
        end
        for i= 1, #SelectedEntities, 1 do
            if SelectedEntities[i] == EntityID then
                return true;
            end
        end
    end
    return false;
end

---
-- Gibt die ID des selektierten Entity zurück.
--
-- Wenn mehr als ein Entity selektiert sind, wird das erste Entity
-- zurückgegeben. Sind keine Entities selektiert, wird 0 zurückgegeben.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=number] ID des selektierten Entities
-- @within Anwenderfunktionen
--
-- @usage
-- local SelectedEntity = API.GetSelectedEntity(1);
--
function API.GetSelectedEntity(_PlayerID)
    local SelectedEntity;
    if not GUI then
        SelectedEntity = ModuleSelection.Global.SelectedEntities[_PlayerID][1];
    else
        SelectedEntity = GUI.GetSelectedEntity();
    end
    return SelectedEntity or 0;
end

---
-- Gibt alle selektierten Entities zurück.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=table] ID des selektierten Entities
-- @within Anwenderfunktionen
--
-- @usage
-- local Selection = API.GetSelectedEntities(1);
--
function API.GetSelectedEntities(_PlayerID)
    local SelectedEntities;
    if not GUI then
        SelectedEntities = ModuleSelection.Global.SelectedEntities[_PlayerID];
    else
        SelectedEntities = {GUI.GetSelectedEntities()};
    end
    return SelectedEntities;
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleArmySystem = {
    Properties = {
        Name = "ModuleArmySystem",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        AiPlayer = {},
    },
    Local = {},
    Shared = {}
}

-- -------------------------------------------------------------------------- --
-- Global Script

function ModuleArmySystem.Global:OnGameStart()
    QSB.ScriptEvents.ArmyCreated = API.RegisterScriptEvent("Event_ArmyCreated");
    QSB.ScriptEvents.ArmyDefeated = API.RegisterScriptEvent("Event_ArmyDefeated");

    for i= 1, 8 do
        self.AiPlayer[i] = {
            ArmyMax = 3,
            AutoEmploy = false,
            Armies = {}
        };
    end

    API.StartHiResJob(function()
        ModuleArmySystem.Global:ControlAiPlayer();
    end)
end

function ModuleArmySystem.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

function ModuleArmySystem.Global:ControlAiPlayer()
    for PlayerID = 1, 8 do
        for ArmyID, Army in pairs(ModuleArmySystem.Global.AiPlayer[PlayerID].Armies) do
            -- Control player
            -- ...

            -- Control armies
            if math.floor(Logic.GetTime() * 10) % ArmyID == 0 then
                if Army:IsAlive() then
                    if Army.Commands[1] then
                        local Command = Army.Commands[1];
                        if Command[1](Army) == true then
                            Army:RemoveCommand();
                            if Command[2] then
                                Army:AddCommand(Command[1], true);
                            end
                        end
                    end
                else
                    self:DisbandArmy(PlayerID, ArmyID);
                end
            end
        end
    end
end

function ModuleArmySystem.Global:CountArmies(_PlayerID)
    local Count = 0;
    for k,v in pairs(self.AiPlayer[_PlayerID].Armies) do
        Count = Count +1;
    end
    return Count;
end

-- -------------------------------------------------------------------------- --

function ModuleArmySystem.Global:GetArmy(_PlayerID, _ArmyID)
    return self.AiPlayer[_PlayerID].Armies[_ArmyID];
end

function ModuleArmySystem.Global:CreateArmyForPlayer(_PlayerID, _HomePosition)
    local Army = TWA.Army:New(_PlayerID, _HomePosition);
    self.AiPlayer[_PlayerID].Armies[Army.ID] = Army;
    return Army.ID;
end

function ModuleArmySystem.Global:DisbandArmyOfPlayer(_PlayerID, _ArmyID)
    if self.AiPlayer[_PlayerID].Armies[_ArmyID] then
        self.AiPlayer[_PlayerID].Armies[_ArmyID]:Dispose();
    end
    self.AiPlayer[_PlayerID].Armies[_ArmyID] = nil;
end

function ModuleArmySystem.Global:EnlargeArmyOfPlayer(_PlayerID, _ArmyID, _Melee, _Ranged, _Rams, _Towers, _Catapults, _AmmoCarts, _ReuseTroops, _UnitType)
    local Army = self:GetArmy(_PlayerID, _ArmyID);
    if not Army then
        return;
    end
    local Position = Army:GetAnchor();

    local MeleeToSpawn = _Melee or 0;
    if _ReuseTroops then
        MeleeToSpawn = self:AddUnemployedMeleeToArmyOfPlayer(_PlayerID, _ArmyID, _Melee);
    end
    local RangedToSpawn = _Ranged or 0;
    if _ReuseTroops then
        RangedToSpawn = self:AddUnemployedRangedToArmyOfPlayer(_PlayerID, _ArmyID, _Ranged);
    end
    local RamsToSpawn = _Rams or 0;
    if _ReuseTroops then
        RamsToSpawn = self:AddUnemployedRamsToArmyOfPlayer(_PlayerID, _ArmyID, _Rams);
    end
    local TowersToSpawn = _Towers or 0;
    if _ReuseTroops then
        TowersToSpawn = self:AddUnemployedTowersToArmyOfPlayer(_PlayerID, _ArmyID, _Towers);
    end
    local CatapultsToSpawn = _Catapults or 0;
    if _ReuseTroops then
        CatapultsToSpawn = self:AddUnemployedCatapultsToArmyOfPlayer(_PlayerID, _ArmyID, _Catapults);
    end
    local AmmoCartsToSpawn = _AmmoCarts or 0;

    for i= 1, MeleeToSpawn do
        local FighterType = AIScriptHelper_GetTroopTypeOverride(Entities.U_MilitarySword, _UnitType)
        local EntityID = Logic.CreateBattalionOnUnblockedLand(FighterType, Position.X, Position.Y, 0, _PlayerID);
        AICore.AddEntityToArmy(_PlayerID, _ArmyID, EntityID);
    end
    for i= 1, RangedToSpawn do
        local FighterType = AIScriptHelper_GetTroopTypeOverride(Entities.U_MilitaryBow, _UnitType)
        local EntityID = Logic.CreateBattalionOnUnblockedLand(FighterType, Position.X, Position.Y, 0, _PlayerID);
        AICore.AddEntityToArmy(_PlayerID, _ArmyID, EntityID);
    end
    for i= 1, RamsToSpawn do
        local EntityID = Logic.CreateEntityOnUnblockedLand(Entities.U_BatteringRamCart, Position.X, Position.Y, 0, _PlayerID);
        AICore.AddEntityToArmy(_PlayerID, _ArmyID, EntityID);
    end
    for i= 1, TowersToSpawn do
        local EntityID = Logic.CreateEntityOnUnblockedLand(Entities.U_SiegeTowerCart, Position.X, Position.Y, 0, _PlayerID);
        AICore.AddEntityToArmy(_PlayerID, _ArmyID, EntityID);
    end
    for i= 1, CatapultsToSpawn do
        local EntityID = Logic.CreateEntityOnUnblockedLand(Entities.U_CatapultCart, Position.X, Position.Y, 0, _PlayerID);
        AICore.AddEntityToArmy(_PlayerID, _ArmyID, EntityID);
    end
    for i= 1, AmmoCartsToSpawn do
        local EntityID = Logic.CreateEntityOnUnblockedLand(Entities.U_AmmunitionCart, Position.X, Position.Y, 0, _PlayerID);
        AICore.AddEntityToArmy(_PlayerID, _ArmyID, EntityID);
    end
end

function ModuleArmySystem.Global:AddUnemployedMeleeToArmyOfPlayer(_PlayerID, _ArmyID, _Amount)
    local FoundSword = _Amount;
    for i = _Amount, 1, -1 do
        if AICore.CheckFreeUnits(_PlayerID, i, 0, 0, 0, 0 ) then
            AICore.AddSwordsmenToArmy(_PlayerID, _ArmyID, i, i, i);
            FoundSword = _Amount - i;
            break
        end
    end
    return FoundSword;
end

function ModuleArmySystem.Global:AddUnemployedRangedToArmyOfPlayer(_PlayerID, _ArmyID, _Amount)
    local FoundBow = _Amount;
    for i = _Amount, 1, -1 do
        if AICore.CheckFreeUnits(_PlayerID, 0, i, 0, 0, 0) then
            AICore.AddBowmenToArmy(_PlayerID, _ArmyID, i, i, i);
            FoundBow = _Amount - i;
            break
        end
    end
    return FoundBow;
end

function ModuleArmySystem.Global:AddUnemployedRamsToArmyOfPlayer(_PlayerID, _ArmyID, _Amount)
    local FoundRams = _Amount;
    for i = _Amount, 1, -1 do
        if AICore.CheckFreeUnits(_PlayerID, 0, 0, i, 0, 0) then
            AICore.AddRamToArmy(_PlayerID, _ArmyID, i, i, i);
            FoundRams = _Amount - i;
            break
        end
    end
    return FoundRams;
end

function ModuleArmySystem.Global:AddUnemployedTowersToArmyOfPlayer(_PlayerID, _ArmyID, _Amount)
    local FoundTowers = _Amount;
    for i = _Amount, 1, -1 do
        if AICore.CheckFreeUnits(_PlayerID, 0, 0, 0, i, 0) then
            AICore.AddTowerToArmy(_PlayerID, _ArmyID, i, i, i);
            FoundTowers = _Amount - i;
            break
        end
    end
    return FoundTowers;
end

function ModuleArmySystem.Global:AddUnemployedCatapultsToArmyOfPlayer(_PlayerID, _ArmyID, _Amount)
    local FoundCatapults = _Amount;
    for i = _Amount, 1, -1 do
        if AICore.CheckFreeUnits(_PlayerID, 0, 0, 0, 0, i) then
            AICore.AddCatapultToArmy(_PlayerID, _ArmyID, i, i, i);
            CatapultsNew = _Amount - i;
            break
        end
    end
    return FoundCatapults;
end

-- -------------------------------------------------------------------------- --
-- Local Script

function ModuleArmySystem.Local:OnGameStart()
    QSB.ScriptEvents.ArmyCreated = API.RegisterScriptEvent("Event_ArmyCreated");
    QSB.ScriptEvents.ArmyDefeated = API.RegisterScriptEvent("Event_ArmyDefeated");
end

function ModuleArmySystem.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleArmySystem);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --



--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

TWA.Army = {
    ID = 0,
    PlayerID = 0,
    IsReady = false,
    HomePosition = nil,
    Anchor = nil,
    Path = nil,

    Commands = {};
};

function TWA.Army:New(_PlayerID, _HomePosition)
    local ArmyID = AICore.CreateArmy(_PlayerID);
    local Army = table.copy(self);
    Army.PlayerID = _PlayerID;
    Army.ID = ArmyID;
    Army.HomePosition = _HomePosition;
    return Army;
end

function TWA.Army:Dispose()
    self.State = QSB.ArmyState.Idle;
    AICore.DisbandUnusedArmy(self.PlayerID, self.ID);
end

function TWA.Army:SetReady(_Flag)
    self.IsReady = _Flag == true;
end

-- -------------------------------------------------------------------------- --

function TWA.Army:GetAnchor()
    if self.Anchor then
        return API.GetPosition(self.Anchor);
    end
    return self:GetPosition();
end

function TWA.Army:SetAnchor(_Position)
    self.Anchor = _Position;
end

function TWA.Army:GetPosition()
    local MemberList = AICore.GetArmyMembers(self.PlayerID, self.ID);
    if #MemberList > 0 then
        return API.GetGeometricFocus(unpack(MemberList));
    end
    return API.GetPosition(self.HomePosition);
end

-- -------------------------------------------------------------------------- --

-- TODO: Walk in formation
function TWA.Army:Move(_Position)
    local Position = API.GetPosition(_Position);
    local MemberList = AICore.GetArmyMembers(self.PlayerID, self.ID);
    for i= 1, #MemberList do
        Logic.MoveSettler(MemberList[i], Position.X, Position.Y, -1);
    end
end

function TWA.Army:SetPath(_Path)
    self.Path = _Path;
end

function TWA.Army:AddCommand(_Command, _Looped, _Index)
    if _Index then
        table.insert(self.Commands, _Index, {_Command, _Looped});
        return;
    end
    table.insert(self.Commands, {_Command, _Looped});
end

function TWA.Army:RemoveCommand(_Index)
    if _Index then
        return table.remove(self.Commands, _Index);
    end
    return table.remove(self.Commands, 1);
end

-- -------------------------------------------------------------------------- --

function TWA.Army:IsFighting()
    local MemberList = AICore.GetArmyMembers(self.PlayerID, self.ID);
    for i= 1, #MemberList do
        local Soldiers = {Logic.GetSoldiersAttachedToLeader(MemberList[i])};
        if Soldiers[1] > 0 and Logic.IsFighting(Soldiers[2]) then
            return true;
        end
    end
    return false;
end

function TWA.Army:IsMoving()
    local MemberList = AICore.GetArmyMembers(self.PlayerID, self.ID);
    for i= 1, #MemberList do
        if Logic.IsEntityMoving(MemberList[i]) then
            return true;
        end
    end
    return false;
end

function TWA.Army:IsAlive()
    if not self.IsReady then
        return true;
    end
    local MemberList = AICore.GetArmyMembers(self.PlayerID, self.ID);
    if #MemberList > 0 then
        return true;
    end
    return false;
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ArmyPath = {
    Current = 1,
    Waypoints = {},
};

function ArmyPath:New(...)
    local Path = table.copy(self);
    Path:Set(...);
    return Path;
end

function ArmyPath:GetCurrent()
    return self.Waypoints[self.Current];
end

function ArmyPath:Set(...)
    self:Reset();
    self.Waypoints = {};
    for i= 1, #arg do
        table.insert(self.Waypoints, arg[i]);
    end
end

function ArmyPath:Next()
    self.Current = self.Current +1;
end

function ArmyPath:Reset()
    self.Current = 1;
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

TWA.ArmyCommand = {};

-- -------------------------------------------------------------------------- --
-- Command Idle
-- The army is doing nothing.

function TWA.ArmyCommand.Idle(_Army)
    return true;
end

-- -------------------------------------------------------------------------- --
-- Command Walk
-- The army is walking on its waypoints to the target.

function TWA.ArmyCommand.Walk(_Army)
    if _Army.Path then
        local Waypoint = _Army.Path:GetCurrent();
        if not Waypoint then
            _Army.Path:Reset();
            return true;
        end

        if API.GetDistance(Waypoint, _Army:GetAnchor()) <= 1000 then
            _Army.Path:Next();
        else
            if not _Army:IsMoving() then
                _Army:Move(Waypoint);
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Command Defend
-- The army stopps and is defending against enemies.

function TWA.ArmyCommand.Defend(_Army)
    local Position = _Army:GetAnchor();
    local Targets = {Logic.GetPlayerEntitiesInArea(
        _Army.PlayerID,
        Entities.U_MilitaryLeader,
        Position.X, Position.X,
        2500,
        1
    )};

    if Targets[1] > 0 then
        if not _Army:IsFighting() then
            local x, y, z = Logic.EntityGetPos(Targets[2]);
            for i= 1, #_Army.Troops do
                Logic.GroupAttackMove(_Army.Troops[i], x, y,-1);
            end
        end
    end
    return true;
end

-- -------------------------------------------------------------------------- --
-- Command Raid
-- The army tries to inflict as many damage as possible at its location.

function TWA.ArmyCommand.Raid(_Army)
    return true;
end

-- -------------------------------------------------------------------------- --
-- Command Claim
-- The army tries to conquer the territory by taking the outpost.

function TWA.ArmyCommand.Claim(_Army)
    return true;
end

-- -------------------------------------------------------------------------- --
-- Command DestroyOutpost
-- The army tries to destroy all buildings on the claimed territory.

function TWA.ArmyCommand.DestroyOutpost(_Army)
    return true;
end

-- -------------------------------------------------------------------------- --
-- Command DestroyCity
-- The army tries to destroy the storehouse at the territory.

function TWA.ArmyCommand.DestroyCity(_Army)
    return true;
end

-- -------------------------------------------------------------------------- --
-- Command AttackWall
-- The army uses war machines to attack the closest walls.

function TWA.ArmyCommand.AttackWall(_Army)
    return true;
end

-- -------------------------------------------------------------------------- --
-- Command AttackCatapult
-- The army uses catapults to attack wall catapults.

function TWA.ArmyCommand.AttackCatapult(_Army)
    return true;
end

-- -------------------------------------------------------------------------- --
-- Command Errect
-- The army is assembling the war machines.

function TWA.ArmyCommand.Errect(_Army)
    return true;
end

-- -------------------------------------------------------------------------- --
-- Command Disassemble
-- The army is disassembling the war machines.

function TWA.ArmyCommand.Disassemble(_Army)

end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --



--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleBriefingSystem = {
    Properties = {
        Name = "ModuleBriefingSystem",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        Briefing = {},
        BriefingQueue = {},
        BriefingCounter = 0,
    },
    Local = {
        ParallaxWidgets = {
            -- Can not set UV coordinates for this... :(
            -- {"/EndScreen/EndScreen/BG", "/EndScreen/EndScreen"},
            {"/EndScreen/EndScreen/BackGround", "/EndScreen/EndScreen"},
            -- Can not set UV coordinates for this... :(
            -- {"/InGame/MissionStatistic/BG", "/InGame/MissionStatistic"},
            {"/InGame/Root/EndScreen/BlackBG", "/InGame/Root/EndScreen"},
            {"/InGame/Root/EndScreen/BG", "/InGame/Root/EndScreen"},
            {"/InGame/Root/BlackStartScreen/BG", "/InGame/Root/BlackStartScreen"},
        },
        Briefing = {},
    },
    -- This is a shared structure but the values are asynchronous!
    Shared = {
        Text = {
            NextButton = {de = "Weiter",  en = "Forward",  fr = "Continuer"},
            PrevButton = {de = "Zurück",  en = "Previous", fr = "Retour"},
            EndButton  = {de = "Beenden", en = "Close",    fr = "Quitter"},
        },
    },
};

QSB.CinematicEventTypes.Briefing = 2;

QSB.Briefing = {
    TIMER_PER_CHAR = 0.175,
    CAMERA_ANGLEDEFAULT = 43,
    CAMERA_ROTATIONDEFAULT = -45,
    CAMERA_ZOOMDEFAULT = 6500,
    CAMERA_FOVDEFAULT = 42,
    DLGCAMERA_ANGLEDEFAULT = 27,
    DLGCAMERA_ROTATIONDEFAULT = -45,
    DLGCAMERA_ZOOMDEFAULT = 1750,
    DLGCAMERA_FOVDEFAULT = 25,
};

-- Global ------------------------------------------------------------------- --

function ModuleBriefingSystem.Global:OnGameStart()
    QSB.ScriptEvents.BriefingStarted = API.RegisterScriptEvent("Event_BriefingStarted");
    QSB.ScriptEvents.BriefingEnded = API.RegisterScriptEvent("Event_BriefingEnded");
    QSB.ScriptEvents.BriefingPageShown = API.RegisterScriptEvent("Event_BriefingPageShown");
    QSB.ScriptEvents.BriefingOptionSelected = API.RegisterScriptEvent("Event_BriefingOptionSelected");
    QSB.ScriptEvents.BriefingLeftClick = API.RegisterScriptEvent("Event_BriefingLeftClick");
    QSB.ScriptEvents.BriefingSkipButtonPressed = API.RegisterScriptEvent("Event_BriefingSkipButtonPressed");

    for i= 1, 8 do
        self.BriefingQueue[i] = {};
    end
    -- Updates the dialog queue for all players
    API.StartHiResJob(function()
        ModuleBriefingSystem.Global:UpdateQueue();
        ModuleBriefingSystem.Global:BriefingExecutionController();
    end);
end

function ModuleBriefingSystem.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.EscapePressed then
        -- TODO fix problem with throneroom
    elseif _ID == QSB.ScriptEvents.BriefingStarted then
        self:NextPage(arg[1]);
    elseif _ID == QSB.ScriptEvents.BriefingEnded then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.BriefingEnded, %d, %s)]],
            arg[1],
            table.tostring(arg[2])
        ));
    elseif _ID == QSB.ScriptEvents.BriefingPageShown then
        local Page = self.Briefing[arg[1]][arg[2]];
        if type(Page) == "table" then
            Page = table.tostring(Page);
        end
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.BriefingPageShown, %d, %d, %s)]],
            arg[1],
            arg[2],
            Page
        ));
    elseif _ID == QSB.ScriptEvents.BriefingOptionSelected then
        self:OnOptionSelected(arg[1], arg[2]);
    elseif _ID == QSB.ScriptEvents.BriefingSkipButtonPressed then
        self:SkipButtonPressed(arg[1]);
    end
end

function ModuleBriefingSystem.Global:UpdateQueue()
    for i= 1, 8 do
        if self:CanStartBriefing(i) then
            local Next = ModuleGuiEffects.Global:LookUpCinematicInQueue(i);
            if Next and Next[1] == QSB.CinematicEventTypes.Briefing then
                self:NextBriefing(i);
            end
        end
    end
end

function ModuleBriefingSystem.Global:BriefingExecutionController()
    for i= 1, 8 do
        if self.Briefing[i] and not self.Briefing[i].DisplayIngameCutscene then
            local PageID = self.Briefing[i].CurrentPage;
            local Page = self.Briefing[i][PageID];
            -- Auto Skip
            if Page and not Page.MC and Page.Duration > 0 then
                if (Page.Started + Page.Duration) < Logic.GetTime() then
                    self:NextPage(i);
                end
            end
        end
    end
end

function ModuleBriefingSystem.Global:CreateBriefingGetPage(_Briefing)
    _Briefing.GetPage = function(self, _NameOrID)
        local ID = ModuleBriefingSystem.Global:GetPageIDByName(_Briefing.PlayerID, _NameOrID);
        return ModuleBriefingSystem.Global.Briefing[_Briefing.PlayerID][ID];
    end
end

function ModuleBriefingSystem.Global:CreateBriefingAddPage(_Briefing)
    _Briefing.AddPage = function(self, _Page)
        -- Briefing length
        self.Length = (self.Length or 0) +1;
        -- Animations
        _Briefing.PageAnimations = _Briefing.PageAnimations or {};
        -- Parallaxes
        _Briefing.PageParallax = _Briefing.PageParallax or {};

        -- Set page name
        local Identifier = "Page" ..(#self +1);
        if _Page.Name then
            Identifier = _Page.Name;
        else
            _Page.Name = Identifier;
        end

        -- Make page legit
        _Page.__Legit = true;
        -- Language
        _Page.Title = API.Localize(_Page.Title or "");
        _Page.Text = API.Localize(_Page.Text or "");

        -- Bars
        if _Page.BigBars == nil then
            _Page.BigBars = true;
        end

        -- Simple camera animation
        if _Page.Position then
            -- Fill angle
            if not _Page.Angle then
                _Page.Angle = QSB.Briefing.CAMERA_ANGLEDEFAULT;
                if _Page.DialogCamera then
                    _Page.Angle = QSB.Briefing.DLGCAMERA_ANGLEDEFAULT;
                end
            end
            -- Fill rotation
            if not _Page.Rotation then
                _Page.Rotation = QSB.Briefing.CAMERA_ROTATIONDEFAULT;
                if _Page.DialogCamera then
                    _Page.Rotation = QSB.Briefing.DLGCAMERA_ROTATIONDEFAULT;
                end
            end
            -- Fill zoom
            if not _Page.Zoom then
                _Page.Zoom = QSB.Briefing.CAMERA_ZOOMDEFAULT;
                if _Page.DialogCamera then
                    _Page.Zoom = QSB.Briefing.DLGCAMERA_ZOOMDEFAULT;
                end
            end
            -- Optional fly to
            local Position2, Rotation2, Zoom2, Angle2;
            if _Page.FlyTo then
                Position2 = _Page.FlyTo.Position or Position2;
                Rotation2 = _Page.FlyTo.Rotation or Rotation2;
                Zoom2     = _Page.FlyTo.Zoom or Zoom2;
                Angle2    = _Page.FlyTo.Angle or Angle2;
            end
            -- Create the animation
            _Briefing.PageAnimations[Identifier] = {
                Clear = true,
                {_Page.Duration or 1,
                 _Page.Position, _Page.Rotation, _Page.Zoom, _Page.Angle,
                 Position2, Rotation2, Zoom2, Angle2}
            };
        end

        -- Field of View
        if not _Page.FOV then
            if _Page.DialogCamera then
                _Page.FOV = QSB.Briefing.DLGCAMERA_FOVDEFAULT;
            else
                _Page.FOV = QSB.Briefing.CAMERA_FOVDEFAULT;
            end
        end

        -- Display time
        if not _Page.Duration then
            if not _Page.Position then
                _Page.DisableSkipping = false;
                _Page.Duration = -1;
            else
                if _Page.DisableSkipping == nil then
                    _Page.DisableSkipping = false;
                end
                _Page.Duration = _Page.Text:len() * QSB.Briefing.TIMER_PER_CHAR;
                _Page.Duration = (_Page.Duration < 6 and 6) or _Page.Duration < 6;
            end
        end

        -- Multiple choice selection
        _Page.GetSelected = function(self)
            return 0;
        end
        -- Return page
        table.insert(self, _Page);
        return _Page;
    end
end

function ModuleBriefingSystem.Global:CreateBriefingAddMCPage(_Briefing)
    _Briefing.AddMCPage = function(self, _Page)
        -- Create base page
        local Page = self:AddPage(_Page);

        -- Multiple choice selection
        Page.GetSelected = function(self)
            if self.MC then
                return self.MC.Selected;
            end
            return 0;
        end

        -- Multiple Choice
        if Page.MC then
            for i= 1, #Page.MC do
                Page.MC[i][1] = API.Localize(Page.MC[i][1]);
                Page.MC[i].ID = Page.MC[i].ID or i;
            end
            Page.BigBars = true;
            Page.DisableSkipping = true;
            Page.Duration = -1;
        end
        -- Return page
        return Page;
    end
end

function ModuleBriefingSystem.Global:CreateBriefingAddRedirect(_Briefing)
    _Briefing.AddRedirect = function(self, _Target)
        -- Dialog length
        self.Length = (self.Length or 0) +1;
        -- Return page
        local Page = (_Target == nil and -1) or _Target;
        table.insert(self, Page);
        return Page;
    end
end

function ModuleBriefingSystem.Global:StartBriefing(_Name, _PlayerID, _Data)
    self.BriefingQueue[_PlayerID] = self.BriefingQueue[_PlayerID] or {};
    ModuleGuiEffects.Global:PushCinematicEventToQueue(
        _PlayerID,
        QSB.CinematicEventTypes.Briefing,
        _Name,
        _Data
    );
end

function ModuleBriefingSystem.Global:EndBriefing(_PlayerID)
    Logic.SetGlobalInvulnerability(0);
    API.SendScriptEvent(
        QSB.ScriptEvents.BriefingEnded,
        _PlayerID,
        self.Briefing[_PlayerID]
    );
    if self.Briefing[_PlayerID].Finished then
        self.Briefing[_PlayerID]:Finished();
    end
    API.FinishCinematicEvent(self.Briefing[_PlayerID].Name, _PlayerID);
    self.Briefing[_PlayerID] = nil;
end

function ModuleBriefingSystem.Global:NextBriefing(_PlayerID)
    if self:CanStartBriefing(_PlayerID) then
        local BriefingData = ModuleGuiEffects.Global:PopCinematicEventFromQueue(_PlayerID);
        assert(BriefingData[1] == QSB.CinematicEventTypes.Briefing);
        API.StartCinematicEvent(BriefingData[2], _PlayerID);

        local Briefing = BriefingData[3];
        Briefing.Name = BriefingData[2];
        Briefing.PlayerID = _PlayerID;
        Briefing.CurrentPage = 0;
        self.Briefing[_PlayerID] = Briefing;
        self:TransformAnimations(_PlayerID);
        self:TransformParallax(_PlayerID);

        if Briefing.EnableGlobalImmortality then
            Logic.SetGlobalInvulnerability(1);
        end
        if self.Briefing[_PlayerID].Starting then
            self.Briefing[_PlayerID]:Starting();
        end

        -- This is an exception from the rule that the global event is send
        -- before the local event! For timing reasons...
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.BriefingStarted, %d, %s)]],
            _PlayerID,
            table.tostring(self.Briefing[_PlayerID])
        ));
        API.SendScriptEvent(
            QSB.ScriptEvents.BriefingStarted,
            _PlayerID,
            self.Briefing[_PlayerID]
        );
    end
end

function ModuleBriefingSystem.Global:TransformAnimations(_PlayerID)
    if self.Briefing[_PlayerID].PageAnimations then
        for k, v in pairs(self.Briefing[_PlayerID].PageAnimations) do
            local PageID = self:GetPageIDByName(_PlayerID, k);
            if PageID ~= 0 then
                self.Briefing[_PlayerID][PageID].Animations = {};
                self.Briefing[_PlayerID][PageID].Animations.Repeat = v.Repeat == true;
                self.Briefing[_PlayerID][PageID].Animations.Clear = v.Clear == true;
                for i= 1, #v, 1 do
                    -- Relaive position
                    if type(v[i][3]) == "number" then
                        local Entry = {};
                        Entry.Interpolation = v[i].Interpolation;
                        Entry.Duration = v[i][1] or (2 * 60);
                        Entry.Start = {
                            Position = (type(v[i][2]) ~= "table" and {v[i][2],0}) or v[i][2],
                            Rotation = v[i][3] or QSB.Briefing.CAMERA_ROTATIONDEFAULT,
                            Zoom     = v[i][4] or QSB.Briefing.CAMERA_ZOOMDEFAULT,
                            Angle    = v[i][5] or QSB.Briefing.CAMERA_ANGLEDEFAULT,
                        };
                        local EndPosition = v[i][6] or Entry.Start.Position;
                        Entry.End = {
                            Position = (type(EndPosition) ~= "table" and {EndPosition,0}) or EndPosition,
                            Rotation = v[i][7] or Entry.Start.Rotation,
                            Zoom     = v[i][8] or Entry.Start.Zoom,
                            Angle    = v[i][9] or Entry.Start.Angle,
                        };
                        table.insert(self.Briefing[_PlayerID][PageID].Animations, Entry);
                    -- Vector
                    elseif type(v[i][3]) == "table" then
                        local Entry = {};
                        Entry.Interpolation = v[i].Interpolation;
                        Entry.Duration = v[i][1] or (2 * 60);
                        Entry.Start = {
                            Position = (type(v[i][2]) ~= "table" and {v[i][2],0}) or v[i][2],
                            LookAt   = (type(v[i][3]) ~= "table" and {v[i][3],0}) or v[i][3],
                        };
                        local EndPosition = v[i][4] or Entry.Start.Position;
                        local EndLookAt   = v[i][5] or Entry.Start.LookAt;
                        Entry.End = {
                            Position = (type(EndPosition) ~= "table" and {EndPosition,0}) or EndPosition,
                            LookAt   = (type(EndLookAt) ~= "table" and {EndLookAt,0}) or EndLookAt,
                        };
                        table.insert(self.Briefing[_PlayerID][PageID].Animations, Entry);
                    end
                end
            end
        end
        self.Briefing[_PlayerID].PageAnimations = nil;
    end
end

function ModuleBriefingSystem.Global:TransformParallax(_PlayerID)
    if self.Briefing[_PlayerID].PageParallax then
        for k, v in pairs(self.Briefing[_PlayerID].PageParallax) do
            local PageID = self:GetPageIDByName(_PlayerID, k);
            if PageID ~= 0 then
                self.Briefing[_PlayerID][PageID].Parallax = {};
                self.Briefing[_PlayerID][PageID].Parallax.Clear = v.Clear == true;
                for i= 1, 4, 1 do
                    if v[i] then
                        local Entry = {};
                        Entry.Image = v[i][1];
                        Entry.Interpolation = v[i].Interpolation;
                        Entry.Duration = v[i][2] or (2 * 60);
                        Entry.Start = {
                            U0 = v[i][3] or 0,
                            V0 = v[i][4] or 0,
                            U1 = v[i][5] or 1,
                            V1 = v[i][6] or 1,
                            A  = v[i][7] or 255
                        };
                        Entry.End = {
                            U0 = v[i][8] or Entry.Start.U0,
                            V0 = v[i][9] or Entry.Start.V0,
                            U1 = v[i][10] or Entry.Start.U1,
                            V1 = v[i][11] or Entry.Start.V1,
                            A  = v[i][12] or Entry.Start.A
                        };
                        self.Briefing[_PlayerID][PageID].Parallax[i] = Entry;
                    end
                end
            end
        end
        self.Briefing[_PlayerID].PageParallax = nil;
    end
end

function ModuleBriefingSystem.Global:NextPage(_PlayerID)
    if self.Briefing[_PlayerID] == nil then
        return;
    end

    self.Briefing[_PlayerID].CurrentPage = self.Briefing[_PlayerID].CurrentPage +1;
    local PageID = self.Briefing[_PlayerID].CurrentPage;
    if PageID == -1 or PageID == 0 then
        self:EndBriefing(_PlayerID);
        return;
    end

    local Page = self.Briefing[_PlayerID][PageID];
    if type(Page) == "table" then
        if PageID <= #self.Briefing[_PlayerID] then
            self.Briefing[_PlayerID][PageID].Started = Logic.GetTime();
            self.Briefing[_PlayerID][PageID].Duration = Page.Duration or -1;
            if self.Briefing[_PlayerID][PageID].Action then
                self.Briefing[_PlayerID][PageID]:Action();
            end
            self:DisplayPage(_PlayerID, PageID);
        else
            self:EndBriefing(_PlayerID);
        end
    elseif type(Page) == "number" or type(Page) == "string" then
        local Target = self:GetPageIDByName(_PlayerID, self.Briefing[_PlayerID][PageID]);
        self.Briefing[_PlayerID].CurrentPage = Target -1;
        self:NextPage(_PlayerID);
    else
        self:EndBriefing(_PlayerID);
    end
end

function ModuleBriefingSystem.Global:DisplayPage(_PlayerID, _PageID)
    if self.Briefing[_PlayerID] == nil then
        return;
    end

    local Page = self.Briefing[_PlayerID][_PageID];
    if type(Page) == "table" then
        local PageID = self.Briefing[_PlayerID].CurrentPage;
        if Page.MC then
            for i= 1, #Page.MC, 1 do
                if type(Page.MC[i][3]) == "function" then
                    self.Briefing[_PlayerID][PageID].MC[i].Visible = Page.MC[i][3](_PlayerID, PageID, i);
                end
            end
        end
    end

    API.SendScriptEvent(
        QSB.ScriptEvents.BriefingPageShown,
        _PlayerID,
        _PageID,
        self.Briefing[_PlayerID][_PageID]
    );
end

function ModuleBriefingSystem.Global:SkipButtonPressed(_PlayerID, _PageID)
    if not self.Briefing[_PlayerID] then
        return;
    end
    local PageID = self.Briefing[_PlayerID].CurrentPage;
    if self.Briefing[_PlayerID][PageID].OnForward then
        self.Briefing[_PlayerID][PageID]:OnForward();
    end
    self:NextPage(_PlayerID);
end

function ModuleBriefingSystem.Global:OnOptionSelected(_PlayerID, _OptionID)
    if self.Briefing[_PlayerID] == nil then
        return;
    end
    local PageID = self.Briefing[_PlayerID].CurrentPage;
    if type(self.Briefing[_PlayerID][PageID]) ~= "table" then
        return;
    end
    local Page = self.Briefing[_PlayerID][PageID];
    if Page.MC then
        local Option;
        for i= 1, #Page.MC, 1 do
            if Page.MC[i].ID == _OptionID then
                Option = Page.MC[i];
            end
        end
        if Option ~= nil then
            local Target = Option[2];
            if type(Option[2]) == "function" then
                Target = Option[2](_PlayerID, PageID, _OptionID);
            end
            self.Briefing[_PlayerID][PageID].MC.Selected = Option.ID;
            self.Briefing[_PlayerID].CurrentPage = self:GetPageIDByName(_PlayerID, Target) -1;
            self:NextPage(_PlayerID);
        end
    end
end

function ModuleBriefingSystem.Global:GetCurrentBriefing(_PlayerID)
    return self.Briefing[_PlayerID];
end

function ModuleBriefingSystem.Global:GetCurrentBriefingPage(_PlayerID)
    if self.Briefing[_PlayerID] then
        local PageID = self.Briefing[_PlayerID].CurrentPage;
        return self.Briefing[_PlayerID][PageID];
    end
end

function ModuleBriefingSystem.Global:GetPageIDByName(_PlayerID, _Name)
    if type(_Name) == "string" then
        if self.Briefing[_PlayerID] ~= nil then
            for i= 1, #self.Briefing[_PlayerID], 1 do
                if type(self.Briefing[_PlayerID][i]) == "table" and self.Briefing[_PlayerID][i].Name == _Name then
                    return i;
                end
            end
        end
        return 0;
    end
    return _Name;
end

function ModuleBriefingSystem.Global:CanStartBriefing(_PlayerID)
    return  self.Briefing[_PlayerID] == nil and
            not API.IsCinematicEventActive(_PlayerID) and
            self.LoadscreenClosed;
end

-- Local -------------------------------------------------------------------- --

function ModuleBriefingSystem.Local:OnGameStart()
    QSB.ScriptEvents.BriefingStarted = API.RegisterScriptEvent("Event_BriefingStarted");
    QSB.ScriptEvents.BriefingEnded = API.RegisterScriptEvent("Event_BriefingEnded");
    QSB.ScriptEvents.BriefingPageShown = API.RegisterScriptEvent("Event_BriefingPageShown");
    QSB.ScriptEvents.BriefingOptionSelected = API.RegisterScriptEvent("Event_BriefingOptionSelected");
    QSB.ScriptEvents.BriefingLeftClick = API.RegisterScriptEvent("Event_BriefingLeftClick");
    QSB.ScriptEvents.BriefingSkipButtonPressed = API.RegisterScriptEvent("Event_BriefingSkipButtonPressed");

    self:OverrideThroneRoomFunctions();
end

function ModuleBriefingSystem.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.EscapePressed then
        -- TODO fix problem with throneroom
    elseif _ID == QSB.ScriptEvents.BriefingStarted then
        self:StartBriefing(arg[1], arg[2]);
    elseif _ID == QSB.ScriptEvents.BriefingEnded then
        self:EndBriefing(arg[1], arg[2]);
    elseif _ID == QSB.ScriptEvents.BriefingPageShown then
        self:DisplayPage(arg[1], arg[2], arg[3]);
    elseif _ID == QSB.ScriptEvents.BriefingSkipButtonPressed then
        self:SkipButtonPressed(arg[1]);
    end
end

function ModuleBriefingSystem.Local:StartBriefing(_PlayerID, _Briefing)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.Briefing[_PlayerID] = _Briefing;
    self.Briefing[_PlayerID].LastSkipButtonPressed = 0;
    self.Briefing[_PlayerID].CurrentPage = 0;
    local PosX, PosY = Camera.RTS_GetLookAtPosition();
    local Rotation = Camera.RTS_GetRotationAngle();
    local ZoomFactor = Camera.RTS_GetZoomFactor();
    local SpeedFactor = Game.GameTimeGetFactor(_PlayerID);
    self.Briefing[_PlayerID].Backup = {
        Camera = {PosX, PosY, Rotation, ZoomFactor},
        Speed  = SpeedFactor,
    };

    API.DeactivateNormalInterface(_PlayerID);
    API.DeactivateBorderScroll(_PlayerID);

    if not Framework.IsNetworkGame() then
        Game.GameTimeSetFactor(_PlayerID, 1);
    end
    self:ActivateCinematicMode(_PlayerID);
end

function ModuleBriefingSystem.Local:EndBriefing(_PlayerID, _Briefing)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end

    if self.Briefing[_PlayerID].RestoreGameSpeed and not Framework.IsNetworkGame() then
        Game.GameTimeSetFactor(_PlayerID, self.Briefing[_PlayerID].Backup.Speed);
    end
    if self.Briefing[_PlayerID].RestoreCamera then
        Camera.RTS_SetLookAtPosition(self.Briefing[_PlayerID].Backup.Camera[1], self.Briefing[_PlayerID].Backup.Camera[2]);
        Camera.RTS_SetRotationAngle(self.Briefing[_PlayerID].Backup.Camera[3]);
        Camera.RTS_SetZoomFactor(self.Briefing[_PlayerID].Backup.Camera[4]);
    end

    self:DeactivateCinematicMode(_PlayerID);
    API.ActivateNormalInterface(_PlayerID);
    API.ActivateBorderScroll(_PlayerID);
    ModuleGuiControl.Local:UpdateHiddenWidgets();

    self.Briefing[_PlayerID] = nil;
    Display.SetRenderFogOfWar(1);
    Display.SetRenderBorderPins(1);
    Display.SetRenderSky(0);
end

function ModuleBriefingSystem.Local:DisplayPage(_PlayerID, _PageID, _PageData)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.Briefing[_PlayerID][_PageID] = _PageData;
    self.Briefing[_PlayerID].AnimationQueue = self.Briefing[_PlayerID].AnimationQueue or {};
    self.Briefing[_PlayerID].ParallaxLayers = self.Briefing[_PlayerID].ParallaxLayers or {};
    self.Briefing[_PlayerID].CurrentPage = _PageID;
    if type(self.Briefing[_PlayerID][_PageID]) == "table" then
        self.Briefing[_PlayerID][_PageID].Started = Logic.GetTime();
        self:SetPageFarClipPlane(_PlayerID, _PageID);
        self:DisplayPageBars(_PlayerID, _PageID);
        self:DisplayPageTitle(_PlayerID, _PageID);
        self:DisplayPageText(_PlayerID, _PageID);
        self:DisplayPageControls(_PlayerID, _PageID);
        self:DisplayPageAnimations(_PlayerID, _PageID);
        self:DisplayPageFader(_PlayerID, _PageID);
        self:DisplayPageParallaxes(_PlayerID, _PageID);
        if self.Briefing[_PlayerID][_PageID].MC then
            self:DisplayPageOptionsDialog(_PlayerID, _PageID);
        end
    end
end

function ModuleBriefingSystem.Local:SetPageFarClipPlane(_PlayerID, _PageID)
    ModuleGuiEffects.Local:ResetFarClipPlane();
    local Page = self.Briefing[_PlayerID][_PageID];
    if Page.FarClipPlane then
        ModuleGuiEffects.Local:SetFarClipPlane(Page.FarClipPlane);
    end
end

function ModuleBriefingSystem.Local:DisplayPageBars(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    local Opacity = (Page.BarOpacity ~= nil and Page.BarOpacity) or 1;
    local OpacityBig = (255 * Opacity);
    local OpacitySmall = (255 * Opacity);

    local BigVisibility = (Page.BigBars and 1) or 0;
    local SmallVisibility = (Page.BigBars and 0) or 1;
    if Opacity == 0 then
        BigVisibility = 0;
        SmallVisibility = 0;
    end

    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", BigVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", SmallVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", BigVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", SmallVisibility);

    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarBottom", 1, OpacityBig);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarTop", 1, OpacityBig);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarBottom", 1, OpacitySmall);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarTop", 1, OpacitySmall);
end

function ModuleBriefingSystem.Local:DisplayPageTitle(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    local TitleWidget = "/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight";
    XGUIEng.SetText(TitleWidget, "");
    if Page.Title then
        local Title = API.ConvertPlaceholders(Page.Title);
        if Title:find("^[A-Za-Z0-9_]+/[A-Za-Z0-9_]+$") then
            Title = XGUIEng.GetStringTableText(Title);
        end
        if Title:sub(1, 1) ~= "{" then
            Title = "{@color:255,250,0,255}{center}" ..Title;
        end
        XGUIEng.SetText(TitleWidget, Title);
    end
end

function ModuleBriefingSystem.Local:DisplayPageText(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    local TextWidget = "/InGame/ThroneRoom/Main/MissionBriefing/Text";
    XGUIEng.SetText(TextWidget, "");
    if Page.Text then
        local Text = API.ConvertPlaceholders(Page.Text);
        if Text:find("^[A-Za-Z0-9_]+/[A-Za-Z0-9_]+$") then
            Text = XGUIEng.GetStringTableText(Text);
        end
        if Text:sub(1, 1) ~= "{" then
            Text = "{center}" ..Text;
        end
        if not Page.BigBars then
            Text = "{cr}{cr}{cr}" .. Text;
        end
        XGUIEng.SetText(TextWidget, Text);
    end
end

function ModuleBriefingSystem.Local:DisplayPageControls(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    local SkipFlag = 1;

    SkipFlag = ((Page.Duration == nil or Page.Duration == -1) and 1) or 0;
    if Page.DisableSkipping ~= nil then
        SkipFlag = (Page.DisableSkipping and 0) or 1;
    end
    if Page.MC ~= nil then
        SkipFlag = 0;
    end
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", SkipFlag);
end

function ModuleBriefingSystem.Local:DisplayPageAnimations(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    if Page.Animations then
        if Page.Animations.Clear then
            self.Briefing[_PlayerID].CurrentAnimation = nil;
            self.Briefing[_PlayerID].AnimationQueue = {};
        end
        for i= 1, #Page.Animations, 1 do
            local Animation = table.copy(Page.Animations[i]);
            table.insert(self.Briefing[_PlayerID].AnimationQueue, Animation);
        end
    end
end

function ModuleBriefingSystem.Local:DisplayPageFader(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    g_Fade.To = Page.FaderAlpha or 0;

    local PageFadeIn = Page.FadeIn;
    if PageFadeIn then
        FadeIn(PageFadeIn);
    end

    local PageFadeOut = Page.FadeOut;
    if PageFadeOut then
        -- FIXME: This would create jobs that are only be paused at the end!
        self.Briefing[_PlayerID].FaderJob = API.StartHiResJob(function(_Time, _FadeOut)
            if Logic.GetTimeMs() > _Time - (_FadeOut * 1000) then
                FadeOut(_FadeOut);
                return true;
            end
        end, Logic.GetTimeMs() + ((Page.Duration or 0) * 1000), PageFadeOut);
    end
end

function ModuleBriefingSystem.Local:DisplayPageParallaxes(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    if Page.Parallax then
        if Page.Parallax.Clear then
            for i= 1, #self.ParallaxWidgets do
                XGUIEng.SetMaterialTexture(self.ParallaxWidgets[i][1], 1, "");
                XGUIEng.SetMaterialColor(self.ParallaxWidgets[i][1], 1, 255, 255, 255, 0);
            end
            self.Briefing[_PlayerID].ParallaxLayers = {};
        end
        for i= 1, 4, 1 do
            if Page.Parallax[i] then
                local Animation = table.copy(Page.Parallax[i]);
                Animation.Started = XGUIEng.GetSystemTime();
                self.Briefing[_PlayerID].ParallaxLayers[i] = Animation;
            end
        end
    end
end

function ModuleBriefingSystem.Local:ControlParallaxes(_PlayerID)
    if self.Briefing[_PlayerID].ParallaxLayers then
        local CurrentTime = XGUIEng.GetSystemTime();
        for k, v in pairs(self.Briefing[_PlayerID].ParallaxLayers) do
            local Widget = self.ParallaxWidgets[k][1];
            local Size = {GUI.GetScreenSize()};
            local Factor = math.min(math.lerp(v.Started, CurrentTime, v.Duration), 1);
            if v.Interpolation then
                Factor = math.min(v:Interpolation(CurrentTime), 1);
            end
            local Alpha = v.Start.A  + (v.End.A - v.Start.A)   * Factor;
            local u0    = v.Start.U0 + (v.End.U0 - v.Start.U0) * Factor;
            local v0    = v.Start.V0 + (v.End.V0 - v.Start.V0) * Factor;
            local u1    = v.Start.U1 + (v.End.U1 - v.Start.U1) * Factor;
            local v1    = v.Start.U1 + (v.End.U1 - v.Start.U1) * Factor;
            if Size[1]/Size[2] < 1.6 then
                u0 = u0 + (u0 / 0.125);
                u1 = u1 - (u1 * 0.125);
            end
            XGUIEng.SetMaterialAlpha(Widget, 1, Alpha or 255);
            XGUIEng.SetMaterialTexture(Widget, 1, v.Image);
            XGUIEng.SetMaterialUV(Widget, 1, u0, v0, u1, v1);
        end
    end
end

function ModuleBriefingSystem.Local:DisplayPageOptionsDialog(_PlayerID, _PageID)
    local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
    local Screen = {GUI.GetScreenSize()};
    local Page = self.Briefing[_PlayerID][_PageID];
    local Listbox = XGUIEng.GetWidgetID(Widget .. "/ListBox");

    self.Briefing[_PlayerID].MCSelectionBoxPosition = {
        XGUIEng.GetWidgetScreenPosition(Widget)
    };

    XGUIEng.ListBoxPopAll(Listbox);
    self.Briefing[_PlayerID].MCSelectionOptionsMap = {};
    for i=1, #Page.MC, 1 do
        if Page.MC[i].Visible ~= false then
            XGUIEng.ListBoxPushItem(Listbox, Page.MC[i][1]);
            table.insert(self.Briefing[_PlayerID].MCSelectionOptionsMap, Page.MC[i].ID);
        end
    end
    XGUIEng.ListBoxSetSelectedIndex(Listbox, 0);

    local wSize = {XGUIEng.GetWidgetScreenSize(Widget)};
    local xFix = math.ceil((Screen[1] /2) - (wSize[1] /2));
    local yFix = math.ceil(Screen[2] - (wSize[2] -10));
    if Page.Text and Page.Text ~= "" then
        yFix = math.ceil((Screen[2] /2) - (wSize[2] /2));
    end
    XGUIEng.SetWidgetScreenPosition(Widget, xFix, yFix);
    XGUIEng.PushPage(Widget, false);
    XGUIEng.ShowWidget(Widget, 1);
    self.Briefing[_PlayerID].MCSelectionIsShown = true;
end

function ModuleBriefingSystem.Local:OnOptionSelected(_PlayerID)
    local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
    local Position = self.Briefing[_PlayerID].MCSelectionBoxPosition;
    XGUIEng.SetWidgetScreenPosition(Widget, Position[1], Position[2]);
    XGUIEng.ShowWidget(Widget, 0);
    XGUIEng.PopPage();

    local Selected = XGUIEng.ListBoxGetSelectedIndex(Widget .. "/ListBox")+1;
    local AnswerID = self.Briefing[_PlayerID].MCSelectionOptionsMap[Selected];

    API.SendScriptEvent(QSB.ScriptEvents.BriefingOptionSelected, _PlayerID, AnswerID);
    API.BroadcastScriptEventToGlobal(
        "BriefingOptionSelected",
        _PlayerID,
        AnswerID
    );
end

function ModuleBriefingSystem.Local:ThroneRoomCameraControl(_PlayerID, _Page)
    if _Page then
        -- Camera
        self:ControlCameraAnimation(_PlayerID);
        local FOV = (type(_Page) == "table" and _Page.FOV) or 42;
        local PX, PY, PZ = self:GetPagePosition(_PlayerID);
        local LX, LY, LZ = self:GetPageLookAt(_PlayerID);
        if PX and not LX then
            LX, LY, LZ, PX, PY, PZ, FOV = self:GetCameraProperties(_PlayerID, FOV);
        end
        Camera.ThroneRoom_SetPosition(PX, PY, PZ);
        Camera.ThroneRoom_SetLookAt(LX, LY, LZ);
        Camera.ThroneRoom_SetFOV(FOV);

        -- Parallax
        self:ControlParallaxes(_PlayerID);

        -- Multiple Choice
        if self.Briefing[_PlayerID].MCSelectionIsShown then
            local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
            if XGUIEng.IsWidgetShown(Widget) == 0 then
                self.Briefing[_PlayerID].MCSelectionIsShown = false;
                self:OnOptionSelected(_PlayerID);
            end
        end

        -- Button texts
        local SkipText = API.Localize(ModuleBriefingSystem.Shared.Text.NextButton);
        local PageID = self.Briefing[_PlayerID].CurrentPage;
        if PageID == #self.Briefing[_PlayerID] or self.Briefing[_PlayerID][PageID+1] == -1 then
            SkipText = API.Localize(ModuleBriefingSystem.Shared.Text.EndButton);
        end
        XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..SkipText);
    end
end

function ModuleBriefingSystem.Local:ControlCameraAnimation(_PlayerID)
    if self.Briefing[_PlayerID].CurrentAnimation then
        local CurrentTime = XGUIEng.GetSystemTime();
        local Animation = self.Briefing[_PlayerID].CurrentAnimation;
        if CurrentTime > Animation.Started + Animation.Duration then
            if #self.Briefing[_PlayerID].AnimationQueue > 0 then
                self.Briefing[_PlayerID].CurrentAnimation = nil;
            end
        end
    end
    if self.Briefing[_PlayerID].CurrentAnimation == nil then
        if self.Briefing[_PlayerID].AnimationQueue and #self.Briefing[_PlayerID].AnimationQueue > 0 then
            local PageID = self.Briefing[_PlayerID].CurrentPage;
            local Page = self.Briefing[_PlayerID][PageID];
            local Next = table.remove(self.Briefing[_PlayerID].AnimationQueue, 1);
            if Page and Page.Animations and Page.Animations.Repeat then
                table.insert(self.Briefing[_PlayerID].AnimationQueue, Next);
            end
            Next.Started = XGUIEng.GetSystemTime();
            self.Briefing[_PlayerID].CurrentAnimation = Next;
        end
    end
end

function ModuleBriefingSystem.Local:GetPagePosition(_PlayerID)
    local Position, FlyTo;
    if self.Briefing[_PlayerID].CurrentAnimation then
        Position = self.Briefing[_PlayerID].CurrentAnimation.Start.Position;
        FlyTo = self.Briefing[_PlayerID].CurrentAnimation.End;
    end

    local x, y, z = self:ConvertPosition(Position);
    if FlyTo then
        local lX, lY, lZ = self:ConvertPosition(FlyTo.Position);
        if lX and lY and lZ then
            x = x + (lX - x) * self:GetInterpolationFactor(_PlayerID);
            y = y + (lY - y) * self:GetInterpolationFactor(_PlayerID);
            z = z + (lZ - z) * self:GetInterpolationFactor(_PlayerID);
        end
    end
    return x, y, z;
end

function ModuleBriefingSystem.Local:GetPageLookAt(_PlayerID)
    local LookAt, FlyTo;
    if self.Briefing[_PlayerID].CurrentAnimation then
        LookAt = self.Briefing[_PlayerID].CurrentAnimation.Start.LookAt;
        FlyTo = self.Briefing[_PlayerID].CurrentAnimation.End;
    end

    local x, y, z = self:ConvertPosition(LookAt);
    if FlyTo and x then
        local lX, lY, lZ = self:ConvertPosition(FlyTo.LookAt);
        if lX and lY and lZ then
            x = x + (lX - x) * self:GetInterpolationFactor(_PlayerID);
            y = y + (lY - y) * self:GetInterpolationFactor(_PlayerID);
            z = z + (lZ - z) * self:GetInterpolationFactor(_PlayerID);
        end
    end
    return x, y, z;
end

function ModuleBriefingSystem.Local:ConvertPosition(_Table)
    local x, y, z;
    if _Table and type(_Table) == "table" then
        if _Table.X then
            x = _Table.X;
            y = _Table.Y;
            z = _Table.Z;
        elseif _Table[3] then
            x = _Table[1];
            y = _Table[2];
            z = _Table[3];
        else
            x, y, z = Logic.EntityGetPos(GetID(_Table[1]));
            z = z + (_Table[2] or 0);
        end
    end
    return x, y, z;
end

function ModuleBriefingSystem.Local:GetInterpolationFactor(_PlayerID)
    if self.Briefing[_PlayerID].CurrentAnimation then
        local CurrentTime = XGUIEng.GetSystemTime();
        if self.Briefing[_PlayerID].CurrentAnimation.Interpolation then
            return self.Briefing[_PlayerID].CurrentAnimation:Interpolation(CurrentTime);
        end
        local Factor = math.lerp(
            self.Briefing[_PlayerID].CurrentAnimation.Started,
            CurrentTime,
            self.Briefing[_PlayerID].CurrentAnimation.Duration
        );
        return math.min(Factor, 1);
    end
    return 1;
end

function ModuleBriefingSystem.Local:GetCameraProperties(_PlayerID, _FOV)
    local CurrPage, FlyTo;
    if self.Briefing[_PlayerID].CurrentAnimation then
        CurrPage = self.Briefing[_PlayerID].CurrentAnimation.Start;
        FlyTo = self.Briefing[_PlayerID].CurrentAnimation.End;
    end

    local startPosition = CurrPage.Position;
    local endPosition = (FlyTo and FlyTo.Position) or CurrPage.Position;
    local startRotation = CurrPage.Rotation;
    local endRotation = (FlyTo and FlyTo.Rotation) or CurrPage.Rotation;
    local startZoomAngle = CurrPage.Angle;
    local endZoomAngle = (FlyTo and FlyTo.Angle) or CurrPage.Angle;
    local startZoomDistance = CurrPage.Zoom;
    local endZoomDistance = (FlyTo and FlyTo.Zoom) or CurrPage.Zoom;

    local factor = self:GetInterpolationFactor(_PlayerID);

    local lPLX, lPLY, lPLZ = self:ConvertPosition(startPosition);
    local cPLX, cPLY, cPLZ = self:ConvertPosition(endPosition);
    local lookAtX = lPLX + (cPLX - lPLX) * factor;
    local lookAtY = lPLY + (cPLY - lPLY) * factor;
    local lookAtZ = lPLZ + (cPLZ - lPLZ) * factor;

    local zoomDistance = startZoomDistance + (endZoomDistance - startZoomDistance) * factor;
    local zoomAngle = startZoomAngle + (endZoomAngle - startZoomAngle) * factor;
    local rotation = startRotation + (endRotation - startRotation) * factor;
    local line = zoomDistance * math.cos(math.rad(zoomAngle));
    local positionX = lookAtX + math.cos(math.rad(rotation - 90)) * line;
    local positionY = lookAtY + math.sin(math.rad(rotation - 90)) * line;
    local positionZ = lookAtZ + (zoomDistance) * math.sin(math.rad(zoomAngle));

    return lookAtX, lookAtY, lookAtZ, positionX, positionY, positionZ, _FOV;
end

function ModuleBriefingSystem.Local:SkipButtonPressed(_PlayerID, _Page)
    if not self.Briefing[_PlayerID] then
        return;
    end
    if (self.Briefing[_PlayerID].LastSkipButtonPressed + 500) < Logic.GetTimeMs() then
        self.Briefing[_PlayerID].LastSkipButtonPressed = Logic.GetTimeMs();
    end
end

function ModuleBriefingSystem.Local:GetCurrentBriefing(_PlayerID)
    return self.Briefing[_PlayerID];
end

function ModuleBriefingSystem.Local:GetCurrentBriefingPage(_PlayerID)
    if self.Briefing[_PlayerID] then
        local PageID = self.Briefing[_PlayerID].CurrentPage;
        return self.Briefing[_PlayerID][PageID];
    end
end

function ModuleBriefingSystem.Local:GetPageIDByName(_PlayerID, _Name)
    if type(_Name) == "string" then
        if self.Briefing[_PlayerID] ~= nil then
            for i= 1, #self.Briefing[_PlayerID], 1 do
                if type(self.Briefing[_PlayerID][i]) == "table" and self.Briefing[_PlayerID][i].Name == _Name then
                    return i;
                end
            end
        end
        return 0;
    end
    return _Name;
end

function ModuleBriefingSystem.Local:OverrideThroneRoomFunctions()
    GameCallback_Camera_ThroneRoomLeftClick_Orig_ModuleBriefingSystem = GameCallback_Camera_ThroneRoomLeftClick;
    GameCallback_Camera_ThroneRoomLeftClick = function(_PlayerID)
        GameCallback_Camera_ThroneRoomLeftClick_Orig_ModuleBriefingSystem(_PlayerID);
        if _PlayerID == GUI.GetPlayerID() then
            -- Must trigger in global script for all players.
            API.BroadcastScriptEventToGlobal(
                "BriefingLeftClick",
                _PlayerID
            );
            API.SendScriptEvent(QSB.ScriptEvents.BriefingLeftClick, _PlayerID);
        end
    end

    GameCallback_Camera_SkipButtonPressed_Orig_ModuleBriefingSystem = GameCallback_Camera_SkipButtonPressed;
    GameCallback_Camera_SkipButtonPressed = function(_PlayerID)
        GameCallback_Camera_SkipButtonPressed_Orig_ModuleBriefingSystem(_PlayerID);
        if _PlayerID == GUI.GetPlayerID() then
            -- Must trigger in global script for all players.
            API.BroadcastScriptEventToGlobal(
                "BriefingSkipButtonPressed",
                _PlayerID
            );
            API.SendScriptEvent(QSB.ScriptEvents.BriefingSkipButtonPressed, _PlayerID);
        end
    end

    GameCallback_Camera_ThroneroomCameraControl_Orig_ModuleBriefingSystem = GameCallback_Camera_ThroneroomCameraControl;
    GameCallback_Camera_ThroneroomCameraControl = function(_PlayerID)
        GameCallback_Camera_ThroneroomCameraControl_Orig_ModuleBriefingSystem(_PlayerID);
        if _PlayerID == GUI.GetPlayerID() then
            local Briefing = ModuleBriefingSystem.Local:GetCurrentBriefing(_PlayerID);
            if Briefing ~= nil then
                ModuleBriefingSystem.Local:ThroneRoomCameraControl(
                    _PlayerID,
                    ModuleBriefingSystem.Local:GetCurrentBriefingPage(_PlayerID)
                );
            end
        end
    end

    GameCallback_Escape_Orig_BriefingSystem = GameCallback_Escape;
    GameCallback_Escape = function()
        if ModuleBriefingSystem.Local.Briefing[GUI.GetPlayerID()] then
            return;
        end
        GameCallback_Escape_Orig_BriefingSystem();
    end
end

function ModuleBriefingSystem.Local:ActivateCinematicMode(_PlayerID)
    if self.CinematicActive or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.CinematicActive = true;

    if not self.LoadscreenClosed then
        XGUIEng.PopPage();
    end
    local ScreenX, ScreenY = GUI.GetScreenSize();

    -- Parallax
    function EndScreen_ExitGame() end
    function MissionFadeInEndScreen() end
    for i= 1, #self.ParallaxWidgets do
        XGUIEng.ShowWidget(self.ParallaxWidgets[i][1], 1);
        XGUIEng.ShowWidget(self.ParallaxWidgets[i][2], 1);
        XGUIEng.PushPage(self.ParallaxWidgets[i][2], false);

        XGUIEng.SetMaterialTexture(self.ParallaxWidgets[i][1], 1, "");
        XGUIEng.SetMaterialColor(self.ParallaxWidgets[i][1], 1, 255, 255, 255, 0);
        XGUIEng.SetMaterialUV(self.ParallaxWidgets[i][1], 1, 0, 0, 1, 1);
    end
    XGUIEng.ShowWidget("/EndScreen/EndScreen/BG", 0);

    -- Throneroom Main
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);
    XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2", false);
    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_Dodge", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2_Dodge", false);
    XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo/LeftFrame", false);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/Frame", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/DialogBG", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/FrameEdges", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogBottomRight3pcs", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/KnightInfoButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/BackButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Briefing", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/TitleContainer", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Text", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Title", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/updater", 1);

    -- Text
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Title", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");

    -- Title and back button
    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight");
    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", x, 65 * (ScreenY/1080));
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Objectives", 2, 0, 2000, 20);

    -- Briefing messages
    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/Text", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/BG", 0);
    XGUIEng.SetText("/InGame/ThroneRoom/KnightInfo/Text", " ");
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Text", 200, 300, 1000, 10);

    self.SelectionBackup = {GUI.GetSelectedEntities()};
    GUI.ClearSelection();
    GUI.ClearNotes();
    GUI.ForbidContextSensitiveCommandsInSelectionState();
    GUI.ActivateCutSceneState();
    GUI.SetFeedbackSoundOutputState(0);
    GUI.EnableBattleSignals(false);
    Input.CutsceneMode();
    if not self.Briefing[_PlayerID].EnableFoW then
        Display.SetRenderFogOfWar(0);
    end
    if self.Briefing[_PlayerID].EnableSky then
        Display.SetRenderSky(1);
    end
    if not self.Briefing[_PlayerID].EnableBorderPins then
        Display.SetRenderBorderPins(0);
    end
    Display.SetUserOptionOcclusionEffect(0);
    Camera.SwitchCameraBehaviour(5);

    InitializeFader();
    g_Fade.To = 0;
    SetFaderAlpha(0);

    if not self.LoadscreenClosed then
        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);
    end
end

function ModuleBriefingSystem.Local:DeactivateCinematicMode(_PlayerID)
    if not self.CinematicActive or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.CinematicActive = false;

    g_Fade.To = 0;
    SetFaderAlpha(0);
    XGUIEng.PopPage();
    Camera.SwitchCameraBehaviour(0);
    Display.UseStandardSettings();
    Input.GameMode();
    GUI.EnableBattleSignals(true);
    GUI.SetFeedbackSoundOutputState(1);
    GUI.ActivateSelectionState();
    GUI.PermitContextSensitiveCommandsInSelectionState();
    for k, v in pairs(self.SelectionBackup) do
        GUI.SelectEntity(v);
    end
    Display.SetRenderSky(0);
    Display.SetRenderBorderPins(1);
    Display.SetRenderFogOfWar(1);
    if Options.GetIntValue("Display", "Occlusion", 0) > 0 then
        Display.SetUserOptionOcclusionEffect(1);
    end

    XGUIEng.ShowWidget("/EndScreen/EndScreen/BG", 1);
    for i= 1, #self.ParallaxWidgets do
        XGUIEng.ShowWidget(self.ParallaxWidgets[i][1], 0);
        XGUIEng.ShowWidget(self.ParallaxWidgets[i][2], 0);
        XGUIEng.PopPage();
    end
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);

    ModuleGuiEffects.Local:ResetFarClipPlane();
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleBriefingSystem);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Ermöglicht Briefings für verschiedene Verwendungszwecke.
--
-- Briefings dienen zur Darstellung von Dialogen oder zur näheren Erleuterung
-- der aktuellen Spielsituation. Mit Multiple Choice können dem Spieler mehrere
-- Auswahlmöglichkeiten gegeben, multiple Handlungsstränge gestartet
-- oder Menüstrukturen abgebildet werden. Mittels Sprüngen und Leerseiten
-- kann innerhalb des Multiple Choice Briefings navigiert werden.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- <li><a href="modules.QSB_1_GuiEffects.QSB_1_GuiEffects.html">(1) Anzeigeeffekte</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field BriefingStarted           Ein Briefing beginnt (Parameter: PlayerID, BriefingTable)
-- @field BriefingEnded             Ein Briefing endet (Parameter: PlayerID, BriefingTable)
-- @field BriefingPageShown         Ein Briefing endet (Parameter: PlayerID, PageIndex)
-- @field BriefingSkipButtonPressed Der Spieler überspringt eine Seite (Parameter: PlayerID)
-- @field BriefingOptionSelected    Eine Multiple Choice Option wurde ausgewählt (Parameter: PlayerID, OptionID)
-- @field BriefingLeftClick         Left Mouse wurde während des Briefings gedrückt (Parameter: PlayerID)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Startet ein Briefing.
--
-- Die Funktion bekommt ein Table mit der Briefingdefinition, wenn sie
-- aufgerufen wird.
--
-- <p>(→ Beispiel #1)</p>
--
-- <h5>Einstellungen</h5>
-- Für ein Briefing können verschiedene spezielle Einstellungen vorgenommen
-- werden.
--
-- Mögliche Werte:
-- <table border="1">
-- <tr>
-- <td><b>Feldname</b></td>
-- <td><b>Typ</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>Starting</td>
-- <td>function</td>
-- <td>(Optional) Eine Funktion, die beim Start des Briefing ausgeführt wird.<br>
-- Wird (im globalen Skript) vor QSB.ScriptEvents.BriefingStarted aufgerufen!
-- </td>
-- </tr>
-- <tr>
-- <td>Finished</td>
-- <td>function</td>
-- <td>(Optional) Eine Funktion, die nach Beendigung des Briefing ausgeführt wird.<br>
-- Wird (im globalen Skript) nach QSB.ScriptEvents.BriefingEnded aufgerufen!
-- </td>
-- </tr>
-- <tr>
-- <td>RestoreCamera</td>
-- <td>boolean</td>
-- <td>(Optional) Stellt die Kameraposition am Ende des Dialog wieder her. <br>Standard: ein</td>
-- </tr>
-- <tr>
-- <td>RestoreGameSpeed</td>
-- <td>boolean</td>
-- <td>(Optional) Stellt die Geschwindigkeit von vor dem Dialog wieder her. <br>Standard: ein</td>
-- </tr>
-- <tr>
-- <td>EnableGlobalImmortality</td>
-- <td>boolean</td>
-- <td>(Optional) Alle Einheiten und Gebäude werden unverwundbar solange das Briefing aktiv ist. <br>Standard: ein</td>
-- </tr>
-- <tr>
-- <td>EnableSky</td>
-- <td>boolean</td>
-- <td>(Optional) Der Himmel wird während des Briefing angezeigt. <br>Standard: ein</td>
-- </tr>
-- <tr>
-- <td>EnableFoW</td>
-- <td>boolean</td>
-- <td>(Optional) Der Nebel des Krieges wird während des Briefing angezeigt. <br>Standard: aus</td>
-- </tr>
-- <tr>
-- <td>EnableBorderPins</td>
-- <td>boolean</td>
-- <td>(Optional) Die Grenzsteine werden während des Briefing angezeigt. <br>Standard: aus</td>
-- </tr>
-- </table>
--
-- <h5>Animationen</h5>
-- Kameraanimationen für Seiten eines Briefings können vom Text einer Page
-- entkoppelt werden. Das hat den Charme, dass Spielfiguren erzählen und
-- erzählen und die Kamera über die ganze Zeit die gleiche Animation zeigt,
-- was das Lesen angenehmer macht.
--
-- <b>Hinweis:</b> Animationen werden nur erzeugt, wenn die Page noch keine
-- Position hat! Andernfalls werden die Werte für Angle, Rotation und Zoom
-- aus der Page genommen und/oder Defaults verwendet.
--
-- Animationen können über eine Table angegeben werden. Diese wird direkt
-- in die Briefing Table geschrieben. Die Animation wird die Kamera dann von
-- Position 1 zu Position 2 bewegen. Dabei ist die zweite Position optional
-- und kann weggelassen werden.
-- 
-- <p>(→ Beispiel #2)</p>
-- <p>(→ Beispiel #3)</p>
-- <p>(→ Beispiel #4)</p>
--
-- <h5>Parallax</h5>
-- Unter Parallax versteht man (im Kontext eines Videospiels) einen Hintergrund,
-- dessen Bildausschnitt veränderlich ist. So wurden früher z.B. der Hintergrund
-- eines Side Scrollers (Super Mario, Sonic, ...) realisiert.
--
-- Während eines Briefings können bis zu 6 übereinander liegende Ebenen solcher
-- Parallaxe verwendet werden. Dabei wird eine Grafik vorgegeben, die durch
-- Angabe von UV-Koordinaten und Alphawert animiert werden kann. Diese Grafiken
-- liegen hinter allen Elementen des Thronerooms.
--
-- Parallaxe können über eine Table angegeben werden. Diese wird direkt in die
-- Briefing Table geschrieben. Jede Ebene kann getrennt von den anderen agieren.
-- Ein Parallax kann statisch ein Bild anzeigen oder animiert sein. In diesem
-- Fall wird sich von Position 1 zu Position 2 bewegt, wobei Position 2 optional
-- ist und weggelassen werden kann.
--
-- Die UV-Koordinaten ergeben zwei Punkte auf der Grafik aus der ein Rechteck
-- ergänzt wird. Die Koordinaten können entweder pixelgenau order relativ
-- angegeben werden. Pixelgenau bedeutet, dass man einen Punkt exakt an einer
-- bestimmten Position auf der Grafik auswählt und setzt (z.B. 100, 50). Gibt
-- man relative Werte an, dann benutzt man Zahlen zwischen 0 und 1, wobei 0 für
-- 0% und 1 für 100% steht. In jedem Fall sind die Koordinaten absolut oder
-- relativ zur Grafik und nicht zur Bildschirmgröße.
--
-- <b>Achtung:</b> Die Grafiken müssen immer im 16:9 Format sein. Für den Fall,
-- dass das Spiel in einer 4:3 Auflösung gespielt wird, werden automatisch die
-- angegebenen Koordinaten umgerechnet und links und rechts abgeschnitten.
-- Konzipiere Grafiken also stets so, dass sie auch im 4:3 Format noch das
-- wichtigste zeigen.
--
-- <p>(→ Beispiel #5)</p>
-- <p>(→ Beispiel #6)</p>
--
-- @param[type=table]  _Briefing Definition des Briefing
-- @param[type=string] _Name     Name des Briefing
-- @param[type=number] _PlayerID Empfänger des Briefing
-- @within Anwenderfunktionen
--
-- @usage
-- -- Beispiel #1: Grobes Gerüst eines Briefings
-- function Briefing1(_Name, _PlayerID)
--     local Briefing = {
--         -- Hier können verschiedene Konfigurationen vorgenommen werden.
--     };
--     local AP, ASP = API.AddBriefingPages(Briefing);
--
--     -- Aufrufe von AP oder ASP um Seiten zu erstellen
--
--     Briefing.Starting = function(_Data)
--         -- Mach was tolles hier, wenn es anfängt.
--     end
--     Briefing.Finished = function(_Data)
--         -- Mach was tolles hier, wenn es endet.
--     end
--     -- Das Briefing wird gestartet
--     API.StartBriefing(Briefing, _Name, _PlayerID);
-- end
--
-- @usage
-- -- Beispiel #2: Angabe von Animationen
-- Briefing.PageAnimations = {
--     ["Page1"] = {
--         -- Relativdarstellung
--         -- Animationsdauer, Position1, Rotation1, Zoom1, Angle1, Position2, Rotation2, Zoom2, Angle2
--         {30, "pos4", -60, 2000, 35, "pos4", -30, 2000, 25},
--         -- Hier können weitere Animationen folgen...
--     },
--     ["Page3"] = {
--         -- Vektordarstellung
--         -- Animationsdauer, {Position1, Höhe}, {LookAt1, Höhe}, {Position2, Höhe}, {LookAt2, Höhe}
--         {30, {"pos2", 500}, {"pos4", 0}, {"pos7", 1000}, {"pos8", 0}},
--         -- Hier können weitere Animationen folgen...
--     },
--     -- Hier können weitere Pages folgen...
-- };
--
-- @usage
-- -- Beispiel #3: Laufende Animationen ersetzen
-- Briefing.PageAnimations = {
--     ["Page1"] = {
--         -- Löscht alle laufenden Animationen
--         Clear = true,
--         {30, "pos4", -60, 2000, 35, "pos4", -30, 2000, 25},
--     },
-- };
--
-- @usage
-- -- Beispiel #4: Animation in Endlosschleife
-- Briefing.PageAnimations = {
--     ["Page1"] = {
--         -- Lässt die Animationen sich wiederholen
--         Repeat = true,
--         {30, "pos4",   0, 4000, 35, "pos4", 180, 4000, 35},
--         {30, "pos4", 180, 4000, 35, "pos4", 360, 4000, 35},
--     },
-- };
--
-- @usage
-- -- Beispiel #5: Angabe von Parallaxen
-- Briefing.PageParallax = {
--     ["Page1"] = {
--         -- Bilddatei, Anzeigedauer,
--         -- U0Start, V0Start, U1Start, V1Start, AlphaStart,
--         -- U0End, V0End, U1End, V1End, AlphaEnd
--         {"maps/externalmap/mapname/graphics/Parallax6.png", 60,
--          0, 0, 0.8, 1, 255,
--          0.2, 0, 1, 1, 255},
--         -- Hier können weitere Einträge folgen...
--     },
--     ["Page3"] = {
--         -- Bilddatei, Anzeigedauer,
--         -- U0Start, V0Start, U1Start, V1Start, AlphaStart
--         {"maps/externalmap/mapname/graphics/Parallax1.png", 1,
--          0, 0, 1, 1, 180},
--         -- Hier können weitere Einträge folgen...
--     }
--     -- Hier können weitere Pages folgen...
-- };
--
-- @usage
-- -- Beispiel #6: Laufende Parallaxe ersetzen
-- Briefing.PageParallax = {
--     ["Page1"] = {
--         -- Löscht alle laufenden Paralaxe
--         Clear = true,
--         {"maps/externalmap/mapname/graphics/Parallax6.png",
--          60, 0, 0, 0.8, 1, 255, 0.2, 0, 1, 1, 255},
--     },
-- };
--
-- @usage
-- -- Beispiel #7: Parallaxe im Vordergrund
-- Briefing.PageParallax = {
--     ["Page1"] = {
--         -- Parallaxe erscheinen im Vordergrund
--         Foreground = true,
--         {"maps/externalmap/mapname/graphics/Parallax6.png",
--          60, 0, 0, 0.8, 1, 255, 0.2, 0, 1, 1, 255},
--     },
-- };
--
function API.StartBriefing(_Briefing, _Name, _PlayerID)
    if GUI then
        return;
    end
    local PlayerID = _PlayerID;
    if not PlayerID and not Framework.IsNetworkGame() then
        PlayerID = QSB.HumanPlayerID;
    end
    assert(_Name ~= nil);
    assert(_PlayerID ~= nil);
    if type(_Briefing) ~= "table" then
        error("API.StartBriefing (" .._Name.. "): _Briefing must be a table!");
        return;
    end
    if #_Briefing == 0 then
        error("API.StartBriefing (" .._Name.. "): _Briefing does not contain pages!");
        return;
    end
    for i=1, #_Briefing do
        if type(_Briefing[i]) == "table" and not _Briefing[i].__Legit then
            error("API.StartBriefing (" .._Name.. ", Page #" ..i.. "): Page is not initialized!");
            return;
        end
    end
    if _Briefing.EnableSky == nil then
        _Briefing.EnableSky = true;
    end
    if _Briefing.EnableFoW == nil then
        _Briefing.EnableFoW = false;
    end
    if _Briefing.EnableGlobalImmortality == nil then
        _Briefing.EnableGlobalImmortality = true;
    end
    if _Briefing.EnableBorderPins == nil then
        _Briefing.EnableBorderPins = false;
    end
    if _Briefing.RestoreGameSpeed == nil then
        _Briefing.RestoreGameSpeed = true;
    end
    if _Briefing.RestoreCamera == nil then
        _Briefing.RestoreCamera = true;
    end
    ModuleBriefingSystem.Global:StartBriefing(_Name, PlayerID, _Briefing);
end

---
-- Prüft ob für den Spieler gerade ein Briefing aktiv ist.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=boolean] Briefing ist aktiv
-- @within Anwenderfunktionen
--
function API.IsBriefingActive(_PlayerID)
    if API.GetScriptEnvironment() == QSB.Environment.GLOBAL then
        return ModuleBriefingSystem.Global:GetCurrentBriefing(_PlayerID) ~= nil;
    end
    return ModuleBriefingSystem.Local:GetCurrentBriefing(_PlayerID) ~= nil;
end

---
-- Erzeugt die Funktionen zur Erstellung von Seiten und Animationen in einem
-- Briefing. Diese Funktion muss vor dem Start eines Briefing aufgerufen werden,
-- damit Seiten gebunden werden können. Je nach Bedarf können Rückgaben von
-- rechts nach links weggelassen werden.
--
-- @param[type=table] _Briefing Briefing Definition
-- @return[type=function] <a href="#AP">AP</a>
-- @return[type=function] <a href="#ASP">ASP</a>
-- @within Anwenderfunktionen
-- @see API.StartBriefing
--
-- @usage
-- -- Wenn nur AP benötigt wird.
-- local AP = API.AddBriefingPages(Briefing);
-- -- Wenn zusätzlich ASP benötigt wird.
-- local AP, ASP = API.AddBriefingPages(Briefing);
--
function API.AddBriefingPages(_Briefing)
    ModuleBriefingSystem.Global:CreateBriefingGetPage(_Briefing);
    ModuleBriefingSystem.Global:CreateBriefingAddPage(_Briefing);
    ModuleBriefingSystem.Global:CreateBriefingAddMCPage(_Briefing);
    ModuleBriefingSystem.Global:CreateBriefingAddRedirect(_Briefing);

    local AP = function(_Page)
        local Page;
        if type(_Page) == "table" then
            if _Page.MC then
                Page = _Briefing:AddMCPage(_Page);
            else
                Page = _Briefing:AddPage(_Page);
            end
        else
            Page = _Briefing:AddRedirect(_Page);
        end
        return Page;
    end

    local ASP = function(...)
        _Briefing.PageAnimations = _Briefing.PageAnimations or {};

        local Name, Title,Text, Position;
        local DialogCam = false;
        local Action = function() end;
        local NoSkipping = false;

        -- Set page parameters
        if (#arg == 3 and type(arg[1]) == "string")
        or (#arg >= 4 and type(arg[4]) == "boolean") then
            Name = table.remove(arg, 1);
        end
        Title = table.remove(arg, 1);
        Text = table.remove(arg, 1);
        if #arg > 0 then
            DialogCam = table.remove(arg, 1) == true;
        end
        if #arg > 0 then
            Position = table.remove(arg, 1);
        end
        if #arg > 0 then
            Action = table.remove(arg, 1);
        end
        if #arg > 0 then
            NoSkipping = not table.remove(arg, 1);
        end

        -- Calculate camera rotation
        local Rotation;
        if Position then
            Rotation = QSB.Briefing.CAMERA_ROTATIONDEFAULT;
            if Position and Logic.IsSettler(GetID(Position)) == 1 then
                Rotation = Logic.GetEntityOrientation(GetID(Position)) + 90;
            end
        end

        -- Create page
        return _Briefing:AddPage {
            Name            = Name,
            Title           = Title,
            Text            = Text,
            Action          = Action,
            Position        = Position,
            DisableSkipping = NoSkipping,
            DialogCamera    = DialogCam,
            Rotation        = Rotation,
        };
    end

    -- Prevent hard errors
    local AAN = function()
        error("AAN has been removed!");
    end;
    return AP, ASP, AAN;
end

---
-- Erzeugt eine neue Seite für das Briefing.
--
-- <b>Achtung</b>: Diese Funktion wird von
-- <a href="#API.AddBriefingPages">API.AddBriefingPages</a> erzeugt und an
-- das Briefing gebunden.
--
-- <h5>Briefing Page</h5>
-- Die Briefing Page definiert, was zum Zeitpunkt ihrer Anzeige dargestellt
-- wird.
--
-- <p>(→ Beispiel #1)</p>
--
-- Folgende Parameter werden als Felder (Name = Wert) übergeben:
-- <table border="1">
-- <tr>
-- <td><b>Feldname</b></td>
-- <td><b>Typ</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>Title</td>
-- <td>string|table</td>
-- <td>Der Titel, der oben angezeigt wird. Es ist möglich eine Table mit
-- deutschen und englischen Texten anzugeben.</td>
-- </tr>
-- <tr>
-- <td>Text</td>
-- <td>string|table</td>
-- <td>Der Text, der unten angezeigt wird. Es ist möglich eine Table mit
-- deutschen und englischen Texten anzugeben.</td>
-- </tr>
-- <tr>
-- <td>Position</td>
-- <td>string</td>
-- <td>Striptname des Entity, welches die Kamera ansieht.</td>
-- </tr>
-- <tr>
-- <td>Duration</td>
-- <td>number</td>
-- <td>(Optional) Bestimmt, wie lange die Page angezeigt wird. Wird es
-- weggelassen, wird automatisch eine Anzeigezeit anhand der Textlänge bestimmt.
-- Diese ist immer mindestens 6 Sekunden.</td>
-- </tr>
-- <tr>
-- <td>DialogCamera</td>
-- <td>boolean</td>
-- <td>(Optional) Eine Boolean, welche angibt, ob Nah- oder Fernsicht benutzt
-- wird.</td>
-- </tr>
-- <tr>
-- <td>DisableSkipping</td>
-- <td>boolean</td>
-- <td>(Optional) Das Überspringen der Seite wird unterbunden.</td>
-- </tr>
-- <tr>
-- <td>Action</td>
-- <td>function</td>
-- <td>(Optional) Eine Funktion, die jedes Mal ausgeführt wird, sobald
-- die Seite angezeigt wird.</td>
-- </tr>
-- <tr>
-- <td>FarClipPlane</td>
-- <td>number</td>
-- <td>(Optional) Renderdistanz für die Seite (Default 100000).
-- wird.</td>
-- </tr>
-- <tr>
-- <tr>
-- <td>Rotation</td>
-- <td>number</td>
-- <td>(Optional) Rotation der Kamera gibt den Winkel an, indem die Kamera
-- um das Ziel gedreht wird.</td>
-- </tr>
-- <tr>
-- <td>Zoom</td>
-- <td>number</td>
-- <td>(Optional) Zoom bestimmt die Entfernung der Kamera zum Ziel.</td>
-- </tr>
-- <tr>
-- <td>Angle</td>
-- <td>number</td>
-- <td>(Optional) Angle gibt den Winkel an, in dem die Kamera gekippt wird.
-- </td>
-- </tr>
-- <tr>
-- <td>FlyTo</td>
-- <td>table</td>
-- <td>(Optional) Kann ein zweites Set von Position, Rotation, Zoom und Angle
-- enthalten, zudem sich die Kamera dann bewegt.
-- </td>
-- </tr>
-- <tr>
-- <td>FadeIn</td>
-- <td>number</td>
-- <td>(Optional) Dauer des Einblendens von Schwarz zu Beginn des Flight.</td>
-- </tr>
-- <tr>
-- <td>FadeOut</td>
-- <td>number</td>
-- <td>(Optional) Dauer des Abblendens zu Schwarz am Ende des Flight.</td>
-- </tr>
-- <tr>
-- <td>FaderAlpha</td>
-- <td>number</td>
-- <td>(Optional) Zeigt entweder die Blende an (1) oder nicht (0). Per Default
-- wird die Blende nicht angezeigt. <br><b>Zwischen einer Seite mit FadeOut und
-- der nächsten mit Fade In muss immer eine Seite mit FaderAlpha sein!</b></td>
-- </tr>
-- <tr>
-- <td>BarOpacity</td>
-- <td>number</td>
-- <td>(Optional) Setzt den Alphawert der Bars (Zwischen 0 und 1).</td>
-- </tr>
-- <tr>
-- <td>BigBars</td>
-- <td>boolean</td>
-- <td>(Optional) Schalted breite Balken ein oder aus.</td>
-- </tr>
-- <tr>
-- <td>MC</td>
-- <td>table</td>
-- <td>(Optional) Liste von Optionen zur Verzweigung des Briefings. Dies kann
-- benutzt werden, um z.B. Dialoge mit Antwortmöglichkeiten zu erstellen.</td>
-- </tr>
-- </table>
--
-- <h5>Multiple Choice</h5>
-- In einem Briefing kann der Spieler auch zur Auswahl einer Option gebeten
-- werden. Dies wird als Multiple Choice bezeichnet. Schreibe die Optionen
-- in eine Untertabelle MC.
--
-- <p>(→ Beispiel #2)</p>
-- 
-- Es kann der Name der Zielseite angegeben werden, oder eine Funktion, die
-- den Namen des Ziels zurück gibt. In der Funktion können vorher beliebige
-- Dinge getan werden, wie z.B. Variablen setzen.
--
-- Eine Antwort kann markiert werden, dass sie auch bei einem Rücksprung,
-- nicht mehrfach gewählt werden kann. In diesem Fall ist sie bei erneutem
-- Aufsuchen der Seite nicht mehr gelistet.
-- 
-- <p>(→ Beispiel #3)</p>
--
-- Eine Option kann auch bedingt ausgeblendet werden. Dazu wird eine Funktion
-- angegeben, welche über die Sichtbarkeit entscheidet.
-- 
-- <p>(→ Beispiel #4)</p>
--
-- Nachdem der Spieler eine Antwort gewählt hat, wird er auf die Seite mit
-- dem angegebenen Namen geleitet.
--
-- Um das Briefing zu beenden, nachdem ein Pfad beendet ist, wird eine leere
-- AP-Seite genutzt. Auf diese Weise weiß das Briefing, das es an dieser
-- Stelle zuende ist.
--
-- <p>(→ Beispiel #5)</p>
--
-- Soll stattdessen zu einer anderen Seite gesprungen werden, kann bei AP der
-- Name der Seite angeben werden, zu der gesprungen werden soll.
--
-- <p>(→ Beispiel #6)</p>
--
-- Um später zu einem beliebigen Zeitpunkt die gewählte Antwort einer Seite zu
-- erfahren, muss der Name der Seite genutzt werden.
-- 
-- Die zurückgegebene Zahl ist die ID der Antwort, angefangen von oben. Wird 0
-- zurückgegeben, wurde noch nicht geantwortet.
-- 
-- <p>(→ Beispiel #7)</p>
--
-- @param[type=table] _Data Daten der Seite
-- @return[type=table] Erzeugte Seite
-- @within Briefing
--
-- @usage
-- -- Beispiel #1: Eine einfache Seite erstellen
-- AP {
--    -- Hier werden die Attribute der Page angegeben
--    Title        = "Marcus",
--    Text         = "Das ist eine simple Seite.",
--    Position     = "Marcus",
--    Rotation     = 30,
--    DialogCamera = true,
-- };
--
-- @usage
-- -- Beispiel #2: Verwendung von Multiple Choice
-- AP {
--    Title        = "Marcus",
--    Text         = "Das ist eine nicht so simple Seite.",
--    Position     = "Marcus",
--    Rotation     = 30,
--    DialogCamera = true,
--    -- MC ist das Table mit den auswählbaren Antworten
--    MC = {
--        -- Zielseite ist der Name der Page, zu der gesprungen wird.
--        {"Antwort 1", "Zielseite"},
--        -- Option2Clicked ist eine Funktion, die etwas macht und
--        -- danach die Page zurückgibt, zu der gesprungen wird.
--        {"Antwort 2", Option2Clicked},
--    },
-- };
--
-- @usage
-- -- Beispiel #3: Antwort, die nur einmal gewählt werden kann
-- MC = {
--     {"Antwort 3", "AnotherPage", Remove = true},
-- }
--
-- @usage
-- -- Beispiel #4: Antwort mit gesteuerter Sichtbarkeit
-- MC = {
--     {"Antwort 3", "AnotherPage", Disable = OptionIsDisabled},
-- }
--
-- @usage
-- -- Beispiel #5: Abbruch des Briefings
-- AP()
--
-- @usage
-- -- Beispiel #6: Sprung zu anderer Seite
-- AP("SomePageName")
--
-- @usage
-- -- Beispiel #7: Erfragen der gewählten Antwort
-- Briefing.Finished = function(_Data)
--     local Choosen = _Data:GetPage("Choice"):GetSelected();
--     -- In Choosen steht der Index der Antwort
-- end
--
function AP(_Data)
    assert(false);
end

---
-- Erzeugt eine neue Seite für das Briefing in Kurzschreibweise.
--
-- <b>Achtung</b>: Diese Funktion wird von
-- <a href="#API.AddBriefingPages">API.AddBriefingPages</a> erzeugt und an
-- das Briefing gebunden.
--
-- Die Seite erhält automatisch einen Namen, entsprechend der Reihenfolge aller
-- Seitenaufrufe von AP oder ASP. Werden also vor dem Aufruf bereits 2 Seiten
-- erzeugt, so würde die Seite den Namen "Page3" erhalten.
--
-- Folgende Parameter werden in <u>genau dieser Reihenfolge</u> an die Funktion
-- übergeben:
-- <table border="1">
-- <tr>
-- <td><b>Bezeichnung</b></td>
-- <td><b>Typ</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>Name</td>
-- <td>string</td>
-- <td>Der interne Name der Page.</td>
-- </tr>
-- <tr>
-- <td>Title</td>
-- <td>string|table</td>
-- <td>Der angezeigte Titel der Seite. Es können auch Text Keys oder
-- lokalisierte Tables übergeben werden.</td>
-- </tr>
-- <tr>
-- <td>Text</td>
-- <td>string|table</td>
-- <td>Der angezeigte Text der Seite. Es können auch Text Keys oder
-- lokalisierte Tables übergeben werden.</td>
-- </tr>
-- <tr>
-- <td>DialogCamera</td>
-- <td>boolean</td>
-- <td>Die Kamera geht in Nahsicht und stellt Charaktere dar. Wird
-- sie weggelassen, wird die Fernsicht verwendet.</td>
-- </tr>
-- <tr>
-- <td>Position</td>
-- <td>string</td>
-- <td>(Optional) Skriptname des Entity zu das die Kamera springt.</td>
-- </tr>
-- <tr>
-- <td>Action</td>
-- <td>function</td>
-- <td>(Optional) Eine Funktion, die jedes Mal ausgeführt wird, wenn die Seite
-- angezeigt wird.</td>
-- </tr>
-- <tr>
-- <td>EnableSkipping</td>
-- <td>boolean</td>
-- <td>(Optional) Steuert, ob die Seite übersprungen werden darf. Wenn es nicht
-- angegeben wird, ist das Überspringen immer deaktiviert.</td>
-- </tr>
-- </table>
--
-- @param ... Daten der Seite
-- @return[type=table] Erzeugte Seite
-- @within Briefing
--
-- @usage
-- -- Hinweis dazu: In Lua werden Parameter von links nach rechts aufgelöst.
-- -- Will man also Parameter weglassen, wenn danach noch welche folgen, muss
-- -- man die Leerstellen mit nil auffüllen.
--
-- -- Fernsicht
-- ASP("Title", "Some important text.", false, "HQ");
-- -- Page Name
-- ASP("Page1", "Title", "Some important text.", false, "HQ");
-- -- Nahsicht
-- ASP("Title", "Some important text.", true, "Marcus");
-- -- Aktion ausführen
-- ASP("Title", "Some important text.", true, "Marcus", MyFunction);
-- -- Überspringen erlauben/verbieten
-- ASP("Title", "Some important text.", true, "HQ", nil, true);
--
function ASP(...)
    assert(false);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Fügt Behavior zur Steuerung von Briefings hinzu.
--
-- @set sort=true
--

-- -------------------------------------------------------------------------- --

---
-- Ruft die Funktion auf und startet das enthaltene Briefing.
--
-- Jedes Briefing braucht einen eindeutigen Namen!
--
-- @param[type=string] _Name   Bezeichner des Briefing
-- @param[type=string] _Briefing Funktionsname als String
-- @within Reprisal
--
function Reprisal_Briefing(...)
    return B_Reprisal_Briefing:new(...);
end

B_Reprisal_Briefing = {
    Name = "Reprisal_Briefing",
    Description = {
        en = "Reprisal: Calls a function to start an new briefing.",
        de = "Vergeltung: Ruft die Funktion auf und startet das enthaltene Briefing.",
        fr = "Rétribution: Appelle la fonction et démarre le briefing qu'elle contient.",
    },
    Parameter = {
        { ParameterType.Default, en = "Briefing name",     de = "Name des Briefing",     fr = "Nom du briefing" },
        { ParameterType.Default, en = "Briefing function", de = "Funktion mit Briefing", fr = "Fonction avec briefing" },
    },
}

function B_Reprisal_Briefing:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_Briefing:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.BriefingName = _Parameter;
    elseif (_Index == 1) then
        self.Function = _Parameter;
    end
end

function B_Reprisal_Briefing:CustomFunction(_Quest)
    _G[self.Function](self.BriefingName, _Quest.ReceivingPlayer);
end

function B_Reprisal_Briefing:Debug(_Quest)
    if self.BriefingName == nil or self.BriefingName == "" then
        error(string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    if not type(_G[self.Function]) == "function" then
        error(_Quest.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_Briefing);

-- -------------------------------------------------------------------------- --

---
-- Ruft die Funktion auf und startet das enthaltene Briefing.
--
-- Jedes Briefing braucht einen eindeutigen Namen!
--
-- @param[type=string] _Name   Bezeichner des Briefing
-- @param[type=string] _Briefing Funktionsname als String
-- @within Reward
--
function Reward_Briefing(...)
    return B_Reward_Briefing:new(...);
end

B_Reward_Briefing = Swift.LuaBase:CopyTable(B_Reprisal_Briefing);
B_Reward_Briefing.Name = "Reward_Briefing";
B_Reward_Briefing.Description.en = "Reward: Calls a function to start an new briefing.";
B_Reward_Briefing.Description.de = "Lohn: Ruft die Funktion auf und startet das enthaltene Briefing.";
B_Reward_Briefing.Description.fr = "Récompense: Appelle la fonction et démarre le briefing qu'elle contient.";
B_Reward_Briefing.GetReprisalTable = nil;

B_Reward_Briefing.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_Briefing);

-- -------------------------------------------------------------------------- --

---
-- Prüft, ob ein Briefing beendet ist und startet dann den Quest.
--
-- @param[type=string] _Name     Bezeichner des Briefing
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Waittime (optional) Wartezeit in Sekunden
-- @within Trigger
--
function Trigger_Briefing(...)
    return B_Trigger_Briefing:new(...);
end

B_Trigger_Briefing = {
    Name = "Trigger_Briefing",
    Description = {
        en = "Trigger: Checks if an briefing has concluded and starts the quest if so.",
        de = "Auslöser: Prüft, ob ein Briefing beendet ist und startet dann den Quest.",
        fr = "Déclencheur: Vérifie si un briefing est terminé et lance ensuite la quête.",
    },
    Parameter = {
        { ParameterType.Default,  en = "Briefing name", de = "Name des Briefing", fr = "Nom du briefing" },
        { ParameterType.PlayerID, en = "Player ID",     de = "Player ID",         fr = "Player ID" },
        { ParameterType.Number,   en = "Wait time",     de = "Wartezeit",         fr = "Temps d'attente" },
    },
}

function B_Trigger_Briefing:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_Briefing:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.BriefingName = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or 0;
        self.WaitTime = _Parameter * 1;
    end
end

function B_Trigger_Briefing:CustomFunction(_Quest)
    if API.GetCinematicEvent(self.BriefingName, self.PlayerID) == CinematicEvent.Concluded then
        if self.WaitTime and self.WaitTime > 0 then
            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
            if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                return true;
            end
        else
            return true;
        end
    end
    return false;
end

function B_Trigger_Briefing:Debug(_Quest)
    if self.WaitTime < 0 then
        error(string.format("%s: %s: Wait time must be 0 or greater!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.PlayerID < 1 or self.PlayerID > 8 then
        error(string.format("%s: %s: Player-ID must be between 1 and 8!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.BriefingName == nil or self.BriefingName == "" then
        error(string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_Briefing);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleCutsceneSystem = {
    Properties = {
        Name = "ModuleCutsceneSystem",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        Cutscene = {},
        CutsceneQueue = {},
        CutsceneCounter = 0;
    },
    Local = {
        Cutscene = {},
    },

    Shared = {
        Text = {
            FastForwardActivate   = {de = "Beschleunigen",      en = "Fast Forward", fr = "Accélérer"},
            FastForwardDeactivate = {de = "Zurücksetzen",       en = "Normal Speed", fr = "Réinitialiser"},
            FastFormardMessage    = {de = "SCHNELLER VORLAUF",  en = "FAST FORWARD", fr = "AVANCÉ RAPIDE"},
        },
    },
};

QSB.CinematicEventTypes.Cutscene = 3;

-- Global ------------------------------------------------------------------- --

function ModuleCutsceneSystem.Global:OnGameStart()
    QSB.ScriptEvents.CutsceneStarted = API.RegisterScriptEvent("Event_CutsceneStarted");
    QSB.ScriptEvents.CutsceneEnded = API.RegisterScriptEvent("Event_CutsceneEnded");
    QSB.ScriptEvents.CutsceneSkipButtonPressed = API.RegisterScriptEvent("Event_CutsceneSkipButtonPressed");
    QSB.ScriptEvents.CutsceneFlightStarted = API.RegisterScriptEvent("Event_CutsceneFlightStarted");
    QSB.ScriptEvents.CutsceneFlightEnded = API.RegisterScriptEvent("Event_CutsceneFlightEnded");

    for i= 1, 8 do
        self.CutsceneQueue[i] = {};
    end

    API.StartHiResJob(function()
        ModuleCutsceneSystem.Global:UpdateQueue();
    end);
end

function ModuleCutsceneSystem.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.EscapePressed then
        -- Nothing to do?
    elseif _ID == QSB.ScriptEvents.CutsceneStarted then
        -- Nothing to do?
    elseif _ID == QSB.ScriptEvents.CutsceneEnded then
        self:EndCutscene(arg[1]);
    elseif _ID == QSB.ScriptEvents.CutsceneFlightStarted then
        self:StartCutsceneFlight(arg[1], arg[2], arg[3]);
    elseif _ID == QSB.ScriptEvents.CutsceneFlightEnded then
        self:EndCutsceneFlight(arg[1], arg[2]);
    elseif _ID == QSB.ScriptEvents.CutsceneSkipButtonPressed then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.CutsceneSkipButtonPressed, %d)]],
            arg[1]
        ));
    end
end

function ModuleCutsceneSystem.Global:UpdateQueue()
    for i= 1, 8 do
        if self:CanStartCutscene(i) then
            local Next = ModuleGuiEffects.Global:LookUpCinematicInQueue(i);
            if Next and Next[1] == QSB.CinematicEventTypes.Cutscene then
                self:NextCutscene(i);
            end
        end
    end
end

function ModuleCutsceneSystem.Global:CreateCutsceneGetPage(_Cutscene)
    _Cutscene.GetPage = function(self, _PlayerID, _NameOrID)
        local ID = ModuleCutsceneSystem.Global:GetPageIDByName(_PlayerID, _NameOrID);
        return ModuleCutsceneSystem.Global.Cutscene[_PlayerID][ID];
    end
end

function ModuleCutsceneSystem.Global:CreateCutsceneAddPage(_Cutscene)
    _Cutscene.AddPage = function(self, _Page)
        if type(_Page) == "table" then
            -- Make page legit
            _Page.__Legit = true;

            -- Translate text
            _Page.Title = API.Localize(_Page.Title);
            if _Page.Text then
                _Page.Text = API.Localize(_Page.Text);
            end
            -- Translate text lines
            if _Page.Lines then
                _Page.Lines = API.Localize(_Page.Lines);
            end
            if not _Page.Lines and not _Page.Text then
                assert(false, "Missing Lines or Text attribute!");
                return;
            end

            -- Set bar default
            if _Page.BigBars == nil then
                _Page.BigBars = false;
            end
        end
        table.insert(_Cutscene, _Page);
        return _Page;
    end
end

function ModuleCutsceneSystem.Global:StartCutscene(_Name, _PlayerID, _Data)
    self.CutsceneQueue[_PlayerID] = self.CutsceneQueue[_PlayerID] or {};
    ModuleGuiEffects.Global:PushCinematicEventToQueue(
        _PlayerID,
        QSB.CinematicEventTypes.Cutscene,
        _Name,
        _Data
    );
end

function ModuleCutsceneSystem.Global:EndCutscene(_PlayerID)
    Logic.SetGlobalInvulnerability(0);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.CutsceneEnded, %d)]],
        _PlayerID
    ));
    if self.Cutscene[_PlayerID].Finished then
        self.Cutscene[_PlayerID]:Finished();
    end
    API.FinishCinematicEvent(self.Cutscene[_PlayerID].Name, _PlayerID);
    self.Cutscene[_PlayerID] = nil;
end

function ModuleCutsceneSystem.Global:NextCutscene(_PlayerID)
    if self:CanStartCutscene(_PlayerID) then
        local CutsceneData = ModuleGuiEffects.Global:PopCinematicEventFromQueue(_PlayerID);
        assert(CutsceneData[1] == QSB.CinematicEventTypes.Cutscene);
        API.StartCinematicEvent(CutsceneData[2], _PlayerID);

        local Cutscene = CutsceneData[3];
        Cutscene.Name = CutsceneData[2];
        Cutscene.PlayerID = _PlayerID;
        Cutscene.BarOpacity = Cutscene.BarOpacity or 1;
        Cutscene.CurrentPage = 0;
        self.Cutscene[_PlayerID] = Cutscene;

        if Cutscene.EnableGlobalImmortality then
            Logic.SetGlobalInvulnerability(1);
        end
        if self.Cutscene[_PlayerID].Starting then
            self.Cutscene[_PlayerID]:Starting();
        end

        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.CutsceneStarted, %d, %s)]],
            _PlayerID,
            table.tostring(self.Cutscene[_PlayerID])
        ));
        API.SendScriptEvent(
            QSB.ScriptEvents.CutsceneStarted,
            _PlayerID,
            self.Cutscene[_PlayerID]
        );
    end
end

function ModuleCutsceneSystem.Global:StartCutsceneFlight(_PlayerID, _PageID, _Duration)
    if self.Cutscene[_PlayerID] == nil then
        return;
    end
    self.Cutscene[_PlayerID][_PageID].Duration = _Duration;
    if self.Cutscene[_PlayerID][_PageID].Action then
        self.Cutscene[_PlayerID][_PageID]:Action();
    end

    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.CutsceneFlightStarted, %d, %d, %d)]],
        _PlayerID,
        _PageID,
        _Duration
    ));
end

function ModuleCutsceneSystem.Global:EndCutsceneFlight(_PlayerID, _PageID)
    if self.Cutscene[_PlayerID] == nil then
        return;
    end
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.CutsceneFlightEnded, %d, %d)]],
        _PlayerID,
        _PageID
    ));
end

function ModuleCutsceneSystem.Global:DisplayPage(_PlayerID, _PageID)
    if self.Cutscene[_PlayerID] == nil then
        return;
    end
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.CutscenePageShown, %d, %d)]],
        _PlayerID,
        _PageID
    ));
end

function ModuleCutsceneSystem.Global:GetCurrentCutscene(_PlayerID)
    return self.Cutscene[_PlayerID];
end

function ModuleCutsceneSystem.Global:GetCurrentCutscenePage(_PlayerID)
    if self.Cutscene[_PlayerID] then
        local PageID = self.Cutscene[_PlayerID].CurrentPage;
        return self.Cutscene[_PlayerID][PageID];
    end
end

function ModuleCutsceneSystem.Global:GetPageIDByName(_PlayerID, _Name)
    if type(_Name) == "string" then
        if self.Cutscene[_PlayerID] ~= nil then
            for i= 1, #self.Cutscene[_PlayerID], 1 do
                if type(self.Cutscene[_PlayerID][i]) == "table" and self.Cutscene[_PlayerID][i].Name == _Name then
                    return i;
                end
            end
        end
        return 0;
    end
    return _Name;
end

function ModuleCutsceneSystem.Global:CanStartCutscene(_PlayerID)
    return  self.Cutscene[_PlayerID] == nil and
            not API.IsCinematicEventActive(_PlayerID) and
            self.LoadscreenClosed;
end

-- Local -------------------------------------------------------------------- --

function ModuleCutsceneSystem.Local:OnGameStart()
    QSB.ScriptEvents.CutsceneStarted = API.RegisterScriptEvent("Event_CutsceneStarted");
    QSB.ScriptEvents.CutsceneEnded = API.RegisterScriptEvent("Event_CutsceneEnded");
    QSB.ScriptEvents.CutsceneSkipButtonPressed = API.RegisterScriptEvent("Event_CutsceneSkipButtonPressed");
    QSB.ScriptEvents.CutsceneFlightStarted = API.RegisterScriptEvent("Event_CutsceneFlightStarted");
    QSB.ScriptEvents.CutsceneFlightEnded = API.RegisterScriptEvent("Event_CutsceneFlightEnded");

    self:OverrideThroneRoomFunctions();
end

function ModuleCutsceneSystem.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.EscapePressed then
        -- Nothing to do?
    elseif _ID == QSB.ScriptEvents.CutsceneStarted then
        self:StartCutscene(arg[1], arg[2]);
    elseif _ID == QSB.ScriptEvents.CutsceneEnded then
        self:EndCutscene(arg[1]);
    elseif _ID == QSB.ScriptEvents.CutsceneFlightStarted then
        self:StartCutsceneFlight(arg[1], arg[2], arg[3]);
    elseif _ID == QSB.ScriptEvents.CutsceneFlightEnded then
        self:EndCutsceneFlight(arg[1], arg[2]);
    elseif _ID == QSB.ScriptEvents.CutsceneSkipButtonPressed then
        self:SkipButtonPressed(arg[1]);
    end
end

function ModuleCutsceneSystem.Local:StartCutscene(_PlayerID, _Cutscene)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.Cutscene[_PlayerID] = _Cutscene;
    self.Cutscene[_PlayerID].LastSkipButtonPressed = 0;
    self.Cutscene[_PlayerID].CurrentPage = 0;

    API.DeactivateNormalInterface(_PlayerID);
    API.DeactivateBorderScroll(_PlayerID);

    if not Framework.IsNetworkGame() then
        Game.GameTimeSetFactor(_PlayerID, 1);
    end
    self:ActivateCinematicMode(_PlayerID);
    self:NextFlight(_PlayerID);
end

function ModuleCutsceneSystem.Local:EndCutscene(_PlayerID)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end

    if not Framework.IsNetworkGame() then
        Game.GameTimeSetFactor(_PlayerID, 1);
    end
    self:DeactivateCinematicMode(_PlayerID);
    API.ActivateNormalInterface(_PlayerID);
    API.ActivateBorderScroll(_PlayerID);
    ModuleGuiControl.Local:UpdateHiddenWidgets();

    self.Cutscene[_PlayerID] = nil;
end

function ModuleCutsceneSystem.Local:NextFlight(_PlayerID)
    if self.Cutscene[_PlayerID] then
        self.Cutscene[_PlayerID].CurrentPage = self.Cutscene[_PlayerID].CurrentPage +1;
        local PageID = self.Cutscene[_PlayerID].CurrentPage;

        if self.Cutscene[_PlayerID][PageID] then
            local Flight = self.Cutscene[_PlayerID][PageID].Flight;
            if Camera.IsValidCutscene(Flight) then
                if GUI.GetPlayerID() == _PlayerID then
                    Camera.StartCutscene(Flight);
                end
            else
                -- This shouldn't happen!
                error("ModuleCutsceneSystem.Local:NextFlight: " ..tostring(Flight).. " is an invalid flight!");
                self:PropagateCutsceneEnded(_PlayerID);
            end
        else
            self:PropagateCutsceneEnded(_PlayerID);
        end
    end
end

function ModuleCutsceneSystem.Local:PropagateCutsceneEnded(_PlayerID)
    if not self.Cutscene[_PlayerID] then
        return;
    end
    API.BroadcastScriptEventToGlobal(
        "CutsceneEnded",
        _PlayerID
    );
end

function ModuleCutsceneSystem.Local:FlightStarted(_Duration)
    local PlayerID = GUI.GetPlayerID();
    if self.Cutscene[PlayerID] then
        local PageID = self.Cutscene[PlayerID].CurrentPage;
        API.BroadcastScriptEventToGlobal(
            "CutsceneFlightStarted",
            PlayerID,
            PageID,
            _Duration
        );
    end
end
CutsceneFlightStarted = function(_Duration)
    ModuleCutsceneSystem.Local:FlightStarted(_Duration);
end

function ModuleCutsceneSystem.Local:StartCutsceneFlight(_PlayerID, _PageID, _Duration)
    if self.Cutscene[_PlayerID] == nil then
        return;
    end
    self:DisplayPage(_PlayerID, _PageID, _Duration);
end

function ModuleCutsceneSystem.Local:FlightFinished()
    local PlayerID = GUI.GetPlayerID();
    if self.Cutscene[PlayerID] then
        local PageID = self.Cutscene[PlayerID].CurrentPage;
        API.BroadcastScriptEventToGlobal(
            "CutsceneFlightEnded",
            PlayerID,
            PageID
        );
    end
end
CutsceneFlightFinished = function()
    ModuleCutsceneSystem.Local:FlightFinished();
end

function ModuleCutsceneSystem.Local:EndCutsceneFlight(_PlayerID, _PageID)
    if self.Cutscene[_PlayerID] == nil then
        return;
    end
    self:NextFlight(_PlayerID);
end

function ModuleCutsceneSystem.Local:DisplayPage(_PlayerID, _PageID, _Duration)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.Cutscene[_PlayerID].AnimationQueue = self.Cutscene[_PlayerID].AnimationQueue or {};
    self.Cutscene[_PlayerID].CurrentPage = _PageID;
    if type(self.Cutscene[_PlayerID][_PageID]) == "table" then
        self.Cutscene[_PlayerID][_PageID].Started = Logic.GetTime();
        self.Cutscene[_PlayerID][_PageID].Duration = _Duration;
        ModuleGuiEffects.Local:ResetFarClipPlane();
        self:DisplayPageBars(_PlayerID, _PageID);
        self:DisplayPageTitle(_PlayerID, _PageID);
        self:DisplayPageText(_PlayerID, _PageID);
        self:DisplayPageControls(_PlayerID, _PageID);
        self:DisplayPageFader(_PlayerID, _PageID);
    end
end

function ModuleCutsceneSystem.Local:DisplayPageBars(_PlayerID, _PageID)
    local Page = self.Cutscene[_PlayerID][_PageID];
    local Opacity = (Page.Opacity ~= nil and Page.Opacity) or 1;
    local OpacityBig = (255 * Opacity);
    local OpacitySmall = (255 * Opacity);

    local BigVisibility = (Page.BigBars and 1) or 0;
    local SmallVisibility = (Page.BigBars and 0) or 1;
    if Opacity == 0 then
        BigVisibility = 0;
        SmallVisibility = 0;
    end

    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", BigVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", SmallVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", BigVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", SmallVisibility);

    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarBottom", 1, OpacityBig);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarTop", 1, OpacityBig);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarBottom", 1, OpacitySmall);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarTop", 1, OpacitySmall);
end

function ModuleCutsceneSystem.Local:DisplayPageTitle(_PlayerID, _PageID)
    local Page = self.Cutscene[_PlayerID][_PageID];
    local TitleWidget = "/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight";
    XGUIEng.SetText(TitleWidget, "");
    if Page.Title then
        local Title = API.ConvertPlaceholders(Page.Title);
        if Title:find("^[A-Za-Z0-9_]+/[A-Za-Z0-9_]+$") then
            Title = XGUIEng.GetStringTableText(Title);
        end
        if Title:sub(1, 1) ~= "{" then
            Title = "{@color:255,250,0,255}{center}" ..Title;
        end
        XGUIEng.SetText(TitleWidget, Title);
    end
end

function ModuleCutsceneSystem.Local:DisplayPageText(_PlayerID, _PageID)
    local Page = self.Cutscene[_PlayerID][_PageID];
    local TextWidget = "/InGame/ThroneRoom/Main/MissionBriefing/Text";
    XGUIEng.SetText(TextWidget, "Bockwurst");
    if Page.Text then
        local Text = API.ConvertPlaceholders(Page.Text);
        if Text:find("^[A-Za-Z0-9_]+/[A-Za-Z0-9_]+$") then
            Text = XGUIEng.GetStringTableText(Text);
        end
        if Text:sub(1, 1) ~= "{" then
            Text = "{center}" ..Text;
        end
        if not Page.BigBars then
            Text = "{cr}{cr}{cr}" .. Text;
        end
        XGUIEng.SetText(TextWidget, Text);
    end
end

function ModuleCutsceneSystem.Local:DisplayPageControls(_PlayerID, _PageID)
    local Page = self.Cutscene[_PlayerID][_PageID];
    local SkipFlag = 1;
    if Page.DisableSkipping == true then
        self.Cutscene[_PlayerID].FastForward = false;
        Game.GameTimeSetFactor(_PlayerID, 1);
        SkipFlag = 0;
    end
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", SkipFlag);
end

function ModuleCutsceneSystem.Local:DisplayPageFader(_PlayerID, _PageID)
    local Page = self.Cutscene[_PlayerID][_PageID];
    g_Fade.To = Page.FaderAlpha or 0;

    local PageFadeIn = Page.FadeIn;
    if PageFadeIn then
        FadeIn(PageFadeIn);
    end

    local PageFadeOut = Page.FadeOut;
    if PageFadeOut then
        -- FIXME: This would create jobs that are only be paused at the end!
        self.Cutscene[_PlayerID].FaderJob = API.StartHiResJob(function(_Time, _FadeOut)
            if Logic.GetTimeMs() > _Time - (_FadeOut * 1000) then
                FadeOut(_FadeOut);
                return true;
            end
        end, (Page.Started * 1000) + (Page.Duration * 100), PageFadeOut);
    end
end

function ModuleCutsceneSystem.Local:ThroneRoomCameraControl(_PlayerID, _Page)
    if _Page then
        if _Page.DisableSkipping then
            XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");
            -- XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 0);
            return;
        end
        -- XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1);

        -- Button text
        local SkipText = API.Localize(ModuleCutsceneSystem.Shared.Text.FastForwardActivate);
        if self.Cutscene[_PlayerID].FastForward then
            SkipText = API.Localize(ModuleCutsceneSystem.Shared.Text.FastForwardDeactivate);
        end
        XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..SkipText);

        -- Fast forward message
        if self.Cutscene[_PlayerID].FastForward then
            local RealTime = API.RealTimeGetSecondsPassedSinceGameStart();
            if not self.Cutscene[_PlayerID].FastForwardRealTime then
                self.Cutscene[_PlayerID].FastForwardRealTime = RealTime;
            end
            if self.Cutscene[_PlayerID].FastForwardRealTime < RealTime then
                self.Cutscene[_PlayerID].FastForwardIndent = (self.Cutscene[_PlayerID].FastForwardIndent or 0) +1;
                if self.Cutscene[_PlayerID].FastForwardIndent > 4 then
                    self.Cutscene[_PlayerID].FastForwardIndent = 1;
                end
                self.Cutscene[_PlayerID].FastForwardRealTime = RealTime;
            end
            local Text = "{cr}{cr}" ..API.Localize(ModuleCutsceneSystem.Shared.Text.FastFormardMessage);
            local Indent = string.rep("  ", (self.Cutscene[_PlayerID].FastForwardIndent or 0));
            XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", Text..Indent.. ". . .");
        else
            XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");
        end

        -- Far Clip Plane
        -- (After each camera event is executed, the value is reset to what ever
        -- is set in it. So to not need to add script events to each flight we
        -- need to set the value here.)
        if _Page.FarClipPlane then
            ModuleGuiEffects.Local:SetFarClipPlane(_Page.FarClipPlane);
        end
    end
end

function ModuleCutsceneSystem.Local:SkipButtonPressed(_PlayerID)
    if self.Cutscene[_PlayerID] == nil then
        return;
    end
    if (self.Cutscene[_PlayerID].LastSkipButtonPressed + 500) < Logic.GetTimeMs() then
        self.Cutscene[_PlayerID].LastSkipButtonPressed = Logic.GetTimeMs();

        -- Change speed of cutscene is only possible in singleplayer!
        if not Framework.IsNetworkGame() then
            if self.Cutscene[_PlayerID].FastForward then
                self.Cutscene[_PlayerID].FastForward = false;
                Game.GameTimeSetFactor(_PlayerID, 1);
            else
                self.Cutscene[_PlayerID].FastForward = true;
                Game.GameTimeSetFactor(_PlayerID, 10);
            end
        end
    end
end

function ModuleCutsceneSystem.Local:GetCurrentCutscene(_PlayerID)
    return self.Cutscene[_PlayerID];
end

function ModuleCutsceneSystem.Local:GetCurrentCutscenePage(_PlayerID)
    if self.Cutscene[_PlayerID] then
        local PageID = self.Cutscene[_PlayerID].CurrentPage;
        return self.Cutscene[_PlayerID][PageID];
    end
end

function ModuleCutsceneSystem.Local:GetPageIDByName(_PlayerID, _Name)
    if type(_Name) == "string" then
        if self.Cutscene[_PlayerID] ~= nil then
            for i= 1, #self.Cutscene[_PlayerID], 1 do
                if type(self.Cutscene[_PlayerID][i]) == "table" and self.Cutscene[_PlayerID][i].Name == _Name then
                    return i;
                end
            end
        end
        return 0;
    end
    return _Name;
end

function ModuleCutsceneSystem.Local:OverrideThroneRoomFunctions()
    GameCallback_Camera_SkipButtonPressed_Orig_ModuleCutsceneSystem = GameCallback_Camera_SkipButtonPressed;
    GameCallback_Camera_SkipButtonPressed = function(_PlayerID)
        GameCallback_Camera_SkipButtonPressed_Orig_ModuleCutsceneSystem(_PlayerID);
        if _PlayerID == GUI.GetPlayerID() then
            API.BroadcastScriptEventToGlobal(
                "CutsceneSkipButtonPressed",
                GUI.GetPlayerID()
            );
        end
    end

    GameCallback_Camera_ThroneroomCameraControl_Orig_ModuleCutsceneSystem = GameCallback_Camera_ThroneroomCameraControl;
    GameCallback_Camera_ThroneroomCameraControl = function(_PlayerID)
        GameCallback_Camera_ThroneroomCameraControl_Orig_ModuleCutsceneSystem(_PlayerID);
        if _PlayerID == GUI.GetPlayerID() then
            local Cutscene = ModuleCutsceneSystem.Local:GetCurrentCutscene(_PlayerID);
            if Cutscene ~= nil then
                ModuleCutsceneSystem.Local:ThroneRoomCameraControl(
                    _PlayerID,
                    ModuleCutsceneSystem.Local:GetCurrentCutscenePage(_PlayerID)
                );
            end
        end
    end

    GameCallback_Escape_Orig_CutsceneSystem = GameCallback_Escape;
    GameCallback_Escape = function()
        if ModuleCutsceneSystem.Local.Cutscene[GUI.GetPlayerID()] then
            return;
        end
        GameCallback_Escape_Orig_CutsceneSystem();
    end
end

function ModuleCutsceneSystem.Local:ActivateCinematicMode(_PlayerID)
    if self.CinematicActive or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.CinematicActive = true;

    if not self.LoadscreenClosed then
        XGUIEng.PopPage();
    end
    local ScreenX, ScreenY = GUI.GetScreenSize();

    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);
    XGUIEng.PushPage("/InGame/ThroneRoomBars", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2", false);
    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_Dodge", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2_Dodge", false);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/Frame", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/DialogBG", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/FrameEdges", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogBottomRight3pcs", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/KnightInfoButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Briefing", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/BackButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Cutscene", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/TitleContainer", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Text", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Title", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/BG", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/LeftFrame", 0);

    -- Text
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Title", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");

    -- Title and back button position
    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight");
    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", x, 65 * (ScreenY/1080));

    self.SelectionBackup = {GUI.GetSelectedEntities()};
    GUI.ClearSelection();
    GUI.ClearNotes();
    GUI.ForbidContextSensitiveCommandsInSelectionState();
    GUI.ActivateCutSceneState();
    GUI.SetFeedbackSoundOutputState(0);
    GUI.EnableBattleSignals(false);
    Input.CutsceneMode();
    if not self.Cutscene[_PlayerID].EnableFoW then
        Display.SetRenderFogOfWar(0);
    end
    if self.Cutscene[_PlayerID].EnableSky then
        Display.SetRenderSky(1);
    end
    if not self.Cutscene[_PlayerID].EnableBorderPins then
        Display.SetRenderBorderPins(0);
    end
    Display.SetUserOptionOcclusionEffect(0);
    Camera.SwitchCameraBehaviour(5);

    InitializeFader();
    g_Fade.To = 1;
    SetFaderAlpha(1);

    if not self.LoadscreenClosed then
        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);
    end
end

function ModuleCutsceneSystem.Local:DeactivateCinematicMode(_PlayerID)
    if not self.CinematicActive or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.CinematicActive = false;

    g_Fade.To = 0;
    SetFaderAlpha(0);
    XGUIEng.PopPage();
    Camera.SwitchCameraBehaviour(0);
    Display.UseStandardSettings();
    Input.GameMode();
    GUI.EnableBattleSignals(true);
    GUI.SetFeedbackSoundOutputState(1);
    GUI.ActivateSelectionState();
    GUI.PermitContextSensitiveCommandsInSelectionState();
    for k, v in pairs(self.SelectionBackup) do
        GUI.SelectEntity(v);
    end
    Display.SetRenderSky(0);
    Display.SetRenderBorderPins(1);
    Display.SetRenderFogOfWar(1);
    if Options.GetIntValue("Display", "Occlusion", 0) > 0 then
        Display.SetUserOptionOcclusionEffect(1);
    end

    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");

    ModuleGuiEffects.Local:ResetFarClipPlane();
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleCutsceneSystem);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Ermöglicht die Verwendung von echten Kameraflügen.
--
-- Cutscenes sind Kameraflüge, die zur szenerischen Untermalung gedacht sind.
-- Texte sind kurz zu halten oder ganz wegzulassen, da der Spieler die Animation
-- genießen soll und bestimmt nicht die ganze Zeit mit den Augen am
-- Bildschirmrand festkleben will. Ebensowenig sind breite Bars oder der
-- stetige Wechsel zwischen schmal und breit zu empfehlen.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- <li><a href="modules.QSB_1_GuiEffects.QSB_1_GuiEffects.html">(1) Anzeigeeffekte</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field CutsceneStarted           Eine Cutscene beginnt (Parameter: PlayerID, CutsceneTable)
-- @field CutsceneEnded             Eine Cutscene endet (Parameter: PlayerID, CutsceneTable)
-- @field CutsceneSkipButtonPressed Der Spieler beschleunigt die Wiedergabegeschwindigkeit (Parameter: PlayerID)
-- @field CutsceneFlightStarted     Ein Flight wird gestartet (Parameter: PlayerID, PageIndex, Duration)
-- @field CutsceneFlightEnded       Ein Flight ist beendet (Parameter: PlayerID, PageIndex)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Startet eine Cutscene.
--
-- Die Funktion bekommt ein Table mit der Definition der Cutscene, wenn sie
-- aufgerufen wird.
--
-- <p>(→ Beispiel #1)</p>
--
-- <h5>Einstellungen</h5>
-- Für eine Cutscene können verschiedene spezielle Einstellungen vorgenommen
-- werden.
--
-- Mögliche Werte:
-- <table border="1">
-- <tr>
-- <td><b>Feldname</b></td>
-- <td><b>Typ</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>Starting</td>
-- <td>function</td>
-- <td>(Optional) Eine Funktion, die beim Start der Cutscene ausgeführt wird.<br>
-- Wird (im globalen Skript) vor QSB.ScriptEvents.CutsceneStarted aufgerufen!
-- </td>
-- </tr>
-- <tr>
-- <td>Finished</td>
-- <td>function</td>
-- <td>(Optional) Eine Funktion, die nach Beendigung der Cutscene ausgeführt wird.<br>
-- Wird (im globalen Skript) nach QSB.ScriptEvents.CutsceneEnded aufgerufen!
-- </td>
-- </tr>
-- <tr>
-- <td>EnableGlobalImmortality</td>
-- <td>boolean</td>
-- <td>(Optional) Alle Einheiten und Gebäude werden unverwundbar solange die Cutscene aktiv ist. <br>Standard: ein</td>
-- </tr>
-- <tr>
-- <td>EnableSky</td>
-- <td>boolean</td>
-- <td>(Optional) Der Himmel wird während der Cutscene angezeigt. <br>Standard: ein</td>
-- </tr>
-- <tr>
-- <td>EnableFoW</td>
-- <td>boolean</td>
-- <td>(Optional) Der Nebel des Krieges wird während der Cutscene angezeigt. <br>Standard: aus</td>
-- </tr>
-- <tr>
-- <td>EnableBorderPins</td>
-- <td>boolean</td>
-- <td>(Optional) Die Grenzsteine werden während der Cutscene angezeigt. <br>Standard: aus</td>
-- </tr>
-- </table>
--
-- @param[type=table]  _Cutscene Definition der Cutscene
-- @param[type=string] _Name     Name der Cutscene
-- @param[type=number] _PlayerID Empfänger der Cutscene
-- @within Anwenderfunktionen
--
-- @usage
-- 
-- function Cutscene1(_Name, _PlayerID)
--     local Cutscene = {};
--     local AP = API.AddCutscenePages(Cutscene);
--
--     -- Aufrufe von AP um Seiten zu erstellen
--
--     Cutscene.Starting = function(_Data)
--         -- Mach was tolles hier wenn es anfängt.
--     end
--     Cutscene.Finished = function(_Data)
--         -- Mach was tolles hier wenn es endet.
--     end
--     API.StartCutscene(Cutscene, _Name, _PlayerID);
-- end
--
function API.StartCutscene(_Cutscene, _Name, _PlayerID)
    if GUI then
        return;
    end
    local PlayerID = _PlayerID;
    if not PlayerID and not Framework.IsNetworkGame() then
        PlayerID = QSB.HumanPlayerID;
    end
    assert(_Name ~= nil);
    assert(_PlayerID ~= nil);
    if type(_Cutscene) ~= "table" then
        error("API.StartCutscene (" .._Name.. "): _Cutscene must be a table!");
        return;
    end
    if #_Cutscene == 0 then
        error("API.StartCutscene (" .._Name.. "): _Cutscene does not contain pages!");
        return;
    end
    for i=1, #_Cutscene do
        if not _Cutscene[i].__Legit then
            error("API.StartCutscene (" .._Name.. ", Page #" ..i.. "): Page is not initialized!");
            return;
        end
    end
    if _Cutscene.EnableSky == nil then
        _Cutscene.EnableSky = true;
    end
    if _Cutscene.EnableFoW == nil then
        _Cutscene.EnableFoW = false;
    end
    if _Cutscene.EnableGlobalImmortality == nil then
        _Cutscene.EnableGlobalImmortality = true;
    end
    if _Cutscene.EnableBorderPins == nil then
        _Cutscene.EnableBorderPins = false;
    end
    ModuleCutsceneSystem.Global:StartCutscene(_Name, PlayerID, _Cutscene);
end

---
-- Prüft ob für den Spieler gerade eine Cutscene aktiv ist.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=boolean] Cutscene ist aktiv
-- @within Anwenderfunktionen
--
function API.IsCutsceneActive(_PlayerID)
    if API.GetScriptEnvironment() == QSB.Environment.GLOBAL then
        return ModuleCutsceneSystem.Global:GetCurrentCutscene(_PlayerID) ~= nil;
    end
    return ModuleCutsceneSystem.Local:GetCurrentCutscene(_PlayerID) ~= nil;
end

---
-- Erzeugt die Funktion zur Erstellung von Flights in einer Cutscene. Diese
-- Funktion muss vor dem Start einer Cutscene aufgerufen werden, damit Seiten
-- gebunden werden können.
--
-- @param[type=table] _Cutscene Cutscene Definition
-- @return[type=function] <a href="#AP">AP</a>
-- @within Anwenderfunktionen
--
-- @usage
-- local AP = API.AddCutscenePages(Cutscene);
--
function API.AddCutscenePages(_Cutscene)
    ModuleCutsceneSystem.Global:CreateCutsceneGetPage(_Cutscene);
    ModuleCutsceneSystem.Global:CreateCutsceneAddPage(_Cutscene);

    local AP = function(_Page)
        return _Cutscene:AddPage(_Page);
    end
    return AP;
end

---
-- Erzeugt einen neuen Flight für die Cutscene.
--
-- <p>(→ Beispiel #1)</p>
--
-- <b>Achtung</b>: Diese Funktion wird von
-- <a href="#API.AddCutscenePages">API.AddCutscenePages</a> erzeugt und an
-- die Cutscene gebunden.
--
-- Folgende Parameter werden als Felder (Name = Wert) übergeben:
-- <table border="1">
-- <tr>
-- <td><b>Feldname</b></td>
-- <td><b>Typ</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>Flight</td>
-- <td>string</td>
-- <td>Name der CS-Datei ohne Dateiendung</td>
-- </tr>
-- <tr>
-- <td>Title</td>
-- <td>string|table</td>
-- <td>Der Titel, der oben angezeigt wird. Es ist möglich eine Table mit
-- deutschen und englischen Texten anzugeben.</td>
-- </tr>
-- <tr>
-- <td>Text</td>
-- <td>string|table</td>
-- <td>Der Text, der unten angezeigt wird. Es ist möglich eine Table mit
-- deutschen und englischen Texten anzugeben.</td>
-- </tr>
-- <tr>
-- <td>Action</td>
-- <td>function</td>
-- <td>(Optional) Eine Funktion, die ausgeführt wird, sobald der Flight
-- angezeigt wird.</td>
-- </tr>
-- <tr>
-- <td>FarClipPlane</td>
-- <td>number</td>
-- <td>(Optional) Renderdistanz für die Seite (Default 35000).
-- wird.</td>
-- </tr>
-- <tr>
-- <td>FadeIn</td>
-- <td>number</td>
-- <td>(Optional) Dauer des Einblendens von Schwarz zu Beginn des Flight.</td>
-- </tr>
-- <tr>
-- <td>FadeOut</td>
-- <td>number</td>
-- <td>(Optional) Dauer des Abblendens zu Schwarz am Ende des Flight.</td>
-- </tr>
-- <tr>
-- <td>FaderAlpha</td>
-- <td>number</td>
-- <td>(Optional) Zeigt entweder die Blende an (1) oder nicht (0). Per Default
-- wird die Blende nicht angezeigt. <br><b>Zwischen einer Seite mit FadeOut und
-- der nächsten mit Fade In muss immer eine Seite mit FaderAlpha sein!</b></td>
-- </tr>
-- <tr>
-- <td>DisableSkipping</td>
-- <td>boolean</td>
-- <td>(Optional) Die Fast Forward Aktion wird unterbunden. Außerdem wird die Beschleunigung automatisch aufgehoben.</td>
-- </tr>
-- <tr>
-- <td>BigBars</td>
-- <td>boolean</td>
-- <td>(Optional) Schalted breite Balken ein oder aus.</td>
-- </tr>
-- <tr>
-- <td>BarOpacity</td>
-- <td>number</td>
-- <td>(Optional) Setzt den Alphawert der Bars (Zwischen 0 und 1).</td>
-- </tr>
-- </table>
--
-- @usage
-- -- Beispiel #1: Eine einfache Seite erstellen
-- AP {
--     -- Dateiname der Cutscene ohne .cs
--     Flight       = "c02",
--     -- Maximale Renderdistanz
--     FarClipPlane = 45000,
--     -- Text
--     Title        = "Title",
--     Text         = "Text of the flight.",
-- };
--
-- @within Cutscene
--
function AP(_Data)
    assert(false);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Fügt Behavior zur Steuerung von Cutscenes hinzu.
--
-- @set sort=true
--

-- -------------------------------------------------------------------------- --

---
-- Ruft die Funktion auf und startet das enthaltene Cutscene.
--
-- Jede Cutscene braucht einen eindeutigen Namen!
--
-- @param[type=string] _Name   Bezeichner des Cutscene
-- @param[type=string] _Cutscene Funktionsname als String
-- @within Reprisal
--
function Reprisal_Cutscene(...)
    return B_Reprisal_Cutscene:new(...);
end

B_Reprisal_Cutscene = {
    Name = "Reprisal_Cutscene",
    Description = {
        en = "Reprisal: Calls a function to start an new Cutscene.",
        de = "Vergeltung: Ruft die Funktion auf und startet die enthaltene Cutscene.",
        fr = "Rétribution : Appelle la fonction et démarre la cutscene contenue.",
    },
    Parameter = {
        { ParameterType.Default, en = "Cutscene name",     de = "Name der Cutscene",     fr = "Nom de la cutscene", },
        { ParameterType.Default, en = "Cutscene function", de = "Funktion mit Cutscene", fr = "Fonction avec cutscene", },
    },
}

function B_Reprisal_Cutscene:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} }
end

function B_Reprisal_Cutscene:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.CutsceneName = _Parameter;
    elseif (_Index == 1) then
        self.Function = _Parameter;
    end
end

function B_Reprisal_Cutscene:CustomFunction(_Quest)
    _G[self.Function](self.CutsceneName, _Quest.ReceivingPlayer);
end

function B_Reprisal_Cutscene:Debug(_Quest)
    if self.CutsceneName == nil or self.CutsceneName == "" then
        error(string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    if not type(_G[self.Function]) == "function" then
        error(_Quest.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_Cutscene);

-- -------------------------------------------------------------------------- --

---
-- Ruft die Funktion auf und startet das enthaltene Cutscene.
--
-- Jede Cutscene braucht einen eindeutigen Namen!
--
-- @param[type=string] _Name   Bezeichner des Cutscene
-- @param[type=string] _Cutscene Funktionsname als String
-- @within Reward
--
function Reward_Cutscene(...)
    return B_Reward_Cutscene:new(...);
end

B_Reward_Cutscene = Swift.LuaBase:CopyTable(B_Reprisal_Cutscene);
B_Reward_Cutscene.Name = "Reward_Cutscene";
B_Reward_Cutscene.Description.en = "Reward: Calls a function to start an new Cutscene.";
B_Reward_Cutscene.Description.de = "Lohn: Ruft die Funktion auf und startet die enthaltene Cutscene.";
B_Reward_Cutscene.Description.fr = "Récompense: Appelle la fonction et démarre la cutscene contenue.";
B_Reward_Cutscene.GetReprisalTable = nil;

B_Reward_Cutscene.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_Cutscene);

-- -------------------------------------------------------------------------- --

---
-- Prüft, ob ein Cutscene beendet ist und startet dann den Quest.
--
-- @param[type=string] _Name     Bezeichner des Cutscene
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Waittime (optional) Wartezeit in Sekunden
-- @within Trigger
--
function Trigger_Cutscene(...)
    return B_Trigger_Cutscene:new(...);
end

B_Trigger_Cutscene = {
    Name = "Trigger_Cutscene",
    Description = {
        en = "Trigger: Checks if an Cutscene has concluded and starts the quest if so.",
        de = "Auslöser: Prüft, ob eine Cutscene beendet ist und startet dann den Quest.",
        fr = "Déclencheur: Vérifie si une cutscene est terminée et démarre ensuite la quête.",
    },
    Parameter = {
        { ParameterType.Default,  en = "Cutscene name", de = "Name der Cutscene", fr  ="Nom de la cutscene" },
        { ParameterType.PlayerID, en = "Player ID",     de = "Player ID",         fr  ="Player ID" },
        { ParameterType.Number,   en = "Wait time",     de = "Wartezeit",         fr  ="Temps d'attente" },
    },
}

function B_Trigger_Cutscene:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_Cutscene:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.CutsceneName = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or 0;
        self.WaitTime = _Parameter * 1;
    end
end

function B_Trigger_Cutscene:CustomFunction(_Quest)
    if API.GetCinematicEvent(self.CutsceneName, self.PlayerID) == CinematicEvent.Concluded then
        if self.WaitTime and self.WaitTime > 0 then
            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
            if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                return true;
            end
        else
            return true;
        end
    end
    return false;
end

function B_Trigger_Cutscene:Debug(_Quest)
    if self.WaitTime < 0 then
        error(string.format("%s: %s: Wait time must be 0 or greater!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.PlayerID < 1 or self.PlayerID > 8 then
        error(string.format("%s: %s: Player-ID must be between 1 and 8!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.CutsceneName == nil or self.CutsceneName == "" then
        error(string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_Cutscene);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleDialogSystem = {
    Properties = {
        Name = "ModuleDialogSystem",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        Dialog = {},
        DialogQueue = {},
        DialogCounter = 0,
    },
    Local = {
        Dialog = {},
    },
    -- This is a shared structure but the values are asynchronous!
    Shared = {
        Text = {
            Continue = {
                de = "{cr}{cr}{azure}(Weiter mit ESC)",
                en = "{cr}{cr}{azure}(Continue with ESC)",
                fr = "{cr}{cr}{azure}(Continuer avec ESC)",
            }
        },
    },
};

QSB.CinematicEventTypes.Dialog = 5;

QSB.Dialog = {
    TIMER_PER_CHAR = 0.175,
    CAMERA_ANGLEDEFAULT = 43,
    CAMERA_ROTATIONDEFAULT = -45,
    CAMERA_ZOOMDEFAULT = 6500,
    CAMERA_FOVDEFAULT = 42,
    DLGCAMERA_ANGLEDEFAULT = 27,
    DLGCAMERA_ROTATIONDEFAULT = -45,
    DLGCAMERA_ZOOMDEFAULT = 1750,
    DLGCAMERA_FOVDEFAULT = 25,
}

-- Global ------------------------------------------------------------------- --

function ModuleDialogSystem.Global:OnGameStart()
    QSB.ScriptEvents.DialogStarted = API.RegisterScriptEvent("Event_DialogStarted");
    QSB.ScriptEvents.DialogEnded = API.RegisterScriptEvent("Event_DialogEnded");
    QSB.ScriptEvents.DialogPageShown = API.RegisterScriptEvent("Event_DialogPageShown");
    QSB.ScriptEvents.DialogOptionSelected = API.RegisterScriptEvent("Event_DialogOptionSelected");

    for i= 1, 8 do
        self.DialogQueue[i] = {};
    end
    API.StartHiResJob(function()
        ModuleDialogSystem.Global:UpdateQueue();
        ModuleDialogSystem.Global:DialogExecutionController();
    end);
end

function ModuleDialogSystem.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.EscapePressed then
        self:SkipButtonPressed(arg[1]);
    elseif _ID == QSB.ScriptEvents.DialogStarted then
        self:NextPage(arg[1]);
    elseif _ID == QSB.ScriptEvents.DialogEnded then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.DialogEnded, %d, %s)]],
            arg[1],
            table.tostring(arg[2])
        ));
    elseif _ID == QSB.ScriptEvents.DialogPageShown then
        local Page = self.Dialog[arg[1]][arg[2]];
        if type(Page) == "table" then
            Page = table.tostring(Page);
        end
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.DialogPageShown, %d, %d, %s)]],
            arg[1],
            arg[2],
            Page
        ));
    elseif _ID == QSB.ScriptEvents.DialogOptionSelected then
        self:OnOptionSelected(arg[1], arg[2]);
    end
end

-- Manages the actual activation of dialogues.
function ModuleDialogSystem.Global:UpdateQueue()
    for i= 1, 8 do
        if self:CanStartDialog(i) then
            local Next = ModuleGuiEffects.Global:LookUpCinematicInQueue(i);
            if Next and Next[1] == QSB.CinematicEventTypes.Dialog then
                self:NextDialog(i);
            end
        end
    end
end

-- Manages auto skipping of pages.
function ModuleDialogSystem.Global:DialogExecutionController()
    for i= 1, 8 do
        if self.Dialog[i] then
            local PageID = self.Dialog[i].CurrentPage;
            local Page = self.Dialog[i][PageID];
            if Page and not Page.MC and Page.Duration > 0 and Page.AutoSkip then
                if (Page.Started + Page.Duration) < Logic.GetTime() then
                    self:NextPage(i);
                end
            end
        end
    end
end

function ModuleDialogSystem.Global:CreateDialogGetPage(_Dialog)
    _Dialog.GetPage = function(self, _NameOrID)
        local ID = ModuleDialogSystem.Global:GetPageIDByName(_Dialog.PlayerID, _NameOrID);
        return ModuleDialogSystem.Global.Dialog[_Dialog.PlayerID][ID];
    end
end

function ModuleDialogSystem.Global:CreateDialogAddPage(_Dialog)
    _Dialog.AddPage = function(self, _Page)
        -- Dialog length
        self.Length = (self.Length or 0) +1;

        -- Set page name
        local Identifier = "Page" ..(#self +1);
        if _Page.Name then
            Identifier = _Page.Name;
        else
            _Page.Name = Identifier;
        end

        -- Make page legit
        _Page.__Legit = true;
        -- Language
        _Page.Text = API.Localize(_Page.Text or "");

        -- Skip page
        _Page.AutoSkip = false;
        if _Page.Duration then
            if _Page.Duration == -1 then
                _Page.Duration = string.len(_Page.Text or "") * QSB.Dialog.TIMER_PER_CHAR;
                _Page.Duration = (_Page.Duration < 6 and 6) or _Page.Duration < 6;
            end
            _Page.AutoSkip = _Page.Duration > 0;
        end

        -- Default camera rotation
        if not _Page.Rotation then
            _Page.Rotation = QSB.Dialog.CAMERA_ROTATIONDEFAULT;
            if _Page.DialogCamera then
                _Page.Rotation = QSB.Dialog.DLGCAMERA_ROTATIONDEFAULT;
            end
            if _Page.Position and type(_Page.Position) ~= "table" then
                local ID = GetID(_Page.Position);
                local Orientation = Logic.GetEntityOrientation(ID) +90;
                _Page.Rotation = Orientation;
            elseif _Page.Target then
                local ID = GetID(_Page.Target);
                local Orientation = Logic.GetEntityOrientation(ID) +90;
                _Page.Rotation = Orientation;
            end
        end
        -- Default camera distance
        if not _Page.Distance then
            _Page.Distance = QSB.Dialog.CAMERA_ZOOMDEFAULT;
            if _Page.DialogCamera then
                _Page.Distance = QSB.Dialog.DLGCAMERA_ZOOMDEFAULT;
            end
        end
        -- Default camera angle
        if not _Page.Angle then
            _Page.Angle = QSB.Dialog.CAMERA_ANGLEDEFAULT;
            if _Page.DialogCamera then
                _Page.Angle = QSB.Dialog.DLGCAMERA_ANGLEDEFAULT;
            end
        end

        -- Multiple choice selection
        _Page.GetSelected = function(self)
            return 0;
        end
        -- Return page
        table.insert(self, _Page);
        return _Page;
    end
end

function ModuleDialogSystem.Global:CreateDialogAddMCPage(_Dialog)
    _Dialog.AddMCPage = function(self, _Page)
        -- Create base page
        local Page = self:AddPage(_Page);

        -- Multiple Choice options
        if Page.MC then
            for i= 1, #Page.MC do
                Page.MC[i][1] = API.Localize(Page.MC[i][1]);
                Page.MC[i].ID = Page.MC[i].ID or i;
            end
            Page.AutoSkip = false;
            Page.Duration = -1;
        end

        -- Multiple choice selection
        Page.GetSelected = function(self)
            if self.MC then
                return self.MC.Selected;
            end
            return 0;
        end
        -- Return page
        return Page;
    end
end

function ModuleDialogSystem.Global:CreateDialogAddRedirect(_Dialog)
    _Dialog.AddRedirect = function(self, _Target)
        -- Dialog length
        self.Length = (self.Length or 0) +1;
        -- Return page
        local Page = (_Target == nil and -1) or _Target;
        table.insert(self, Page);
        return Page;
    end
end

-- Does not really start the dialog. It is pushed inside the global queue for
-- all informational stuff and executed later by a job.
function ModuleDialogSystem.Global:StartDialog(_Name, _PlayerID, _Data)
    self.DialogQueue[_PlayerID] = self.DialogQueue[_PlayerID] or {};
    ModuleGuiEffects.Global:PushCinematicEventToQueue(
        _PlayerID,
        QSB.CinematicEventTypes.Dialog,
        _Name,
        _Data
    );
end

function ModuleDialogSystem.Global:EndDialog(_PlayerID)
    Logic.SetGlobalInvulnerability(0);
    Logic.ExecuteInLuaLocalState(string.format(
        [[ModuleDialogSystem.Local:ResetTimerButtons(%d);
          Camera.RTS_FollowEntity(0);]],
        _PlayerID
    ));
    API.SendScriptEvent(
        QSB.ScriptEvents.DialogEnded,
        _PlayerID,
        self.Dialog[_PlayerID]
    );
    if self.Dialog[_PlayerID].Finished then
        self.Dialog[_PlayerID]:Finished();
    end
    API.FinishCinematicEvent(self.Dialog[_PlayerID].Name, _PlayerID);
    self.Dialog[_PlayerID] = nil;
end

function ModuleDialogSystem.Global:NextDialog(_PlayerID)
    if self:CanStartDialog(_PlayerID) then
        local DialogData = ModuleGuiEffects.Global:PopCinematicEventFromQueue(_PlayerID);
        assert(DialogData[1] == QSB.CinematicEventTypes.Dialog);
        API.StartCinematicEvent(DialogData[2], _PlayerID);

        local Dialog = DialogData[3];
        Dialog.Name = DialogData[2];
        Dialog.PlayerID = _PlayerID;
        Dialog.LastSkipButtonPressed = 0;
        Dialog.CurrentPage = 0;
        self.Dialog[_PlayerID] = Dialog;

        if Dialog.EnableGlobalImmortality then
            Logic.SetGlobalInvulnerability(1);
        end
        if self.Dialog[_PlayerID].Starting then
            self.Dialog[_PlayerID]:Starting();
        end

        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.DialogStarted, %d, %s)]],
            _PlayerID,
            table.tostring(self.Dialog[_PlayerID])
        ));
        API.SendScriptEvent(
            QSB.ScriptEvents.DialogStarted,
            _PlayerID,
            self.Dialog[_PlayerID]
        );
    end
end

function ModuleDialogSystem.Global:NextPage(_PlayerID)
    if self.Dialog[_PlayerID] == nil then
        return;
    end

    self.Dialog[_PlayerID].CurrentPage = self.Dialog[_PlayerID].CurrentPage +1;
    local PageID = self.Dialog[_PlayerID].CurrentPage;
    if PageID == -1 or PageID == 0 then
        self:EndDialog(_PlayerID);
        return;
    end

    local Page = self.Dialog[_PlayerID][PageID];
    if type(Page) == "table" then
        if PageID <= #self.Dialog[_PlayerID] then
            self.Dialog[_PlayerID][PageID].Started = Logic.GetTime();
            self.Dialog[_PlayerID][PageID].Duration = Page.Duration or -1;
            if self.Dialog[_PlayerID][PageID].Action then
                self.Dialog[_PlayerID][PageID]:Action();
            end
            self:DisplayPage(_PlayerID, PageID);
        else
            self:EndDialog(_PlayerID);
        end
    elseif type(Page) == "number" or type(Page) == "string" then
        local Target = self:GetPageIDByName(_PlayerID, self.Dialog[_PlayerID][PageID]);
        self.Dialog[_PlayerID].CurrentPage = Target -1;
        self:NextPage(_PlayerID);
    else
        self:EndDialog(_PlayerID);
    end
end

function ModuleDialogSystem.Global:DisplayPage(_PlayerID, _PageID)
    if self.Dialog[_PlayerID] == nil then
        return;
    end

    local Page = self.Dialog[_PlayerID][_PageID];
    if type(Page) == "table" then
        local PageID = self.Dialog[_PlayerID].CurrentPage;
        if Page.MC then
            for i= 1, #Page.MC, 1 do
                if type(Page.MC[i][3]) == "function" then
                    self.Dialog[_PlayerID][PageID].MC[i].Visible = Page.MC[i][3](_PlayerID, PageID, i);
                end
            end
        end
    end

    API.SendScriptEvent(
        QSB.ScriptEvents.DialogPageShown,
        _PlayerID,
        _PageID,
        self.Dialog[_PlayerID][_PageID]
    );
end

-- There is no skip button but I want to keep the original names to make
-- comparisons easier for other authors who might want to implement yet
-- another information system.
function ModuleDialogSystem.Global:SkipButtonPressed(_PlayerID, _PageID)
    if not self.Dialog[_PlayerID] then
        return;
    end
    if (self.Dialog[_PlayerID].LastSkipButtonPressed + 500) > Logic.GetTimeMs() then
        return;
    end
    local PageID = self.Dialog[_PlayerID].CurrentPage;
    if self.Dialog[_PlayerID][PageID].AutoSkip
    or self.Dialog[_PlayerID][PageID].MC then
        return;
    end
    if self.Dialog[_PlayerID][PageID].OnForward then
        self.Dialog[_PlayerID][PageID]:OnForward();
    end
    self.Dialog[_PlayerID].LastSkipButtonPressed = Logic.GetTimeMs();
    self:NextPage(_PlayerID);
end

function ModuleDialogSystem.Global:OnOptionSelected(_PlayerID, _OptionID)
    if self.Dialog[_PlayerID] == nil then
        return;
    end
    local PageID = self.Dialog[_PlayerID].CurrentPage;
    if type(self.Dialog[_PlayerID][PageID]) ~= "table" then
        return;
    end
    local Page = self.Dialog[_PlayerID][PageID];
    if Page.MC then
        local Option;
        for i= 1, #Page.MC, 1 do
            if Page.MC[i].ID == _OptionID then
                Option = Page.MC[i];
            end
        end
        if Option ~= nil then
            local Target = Option[2];
            if type(Option[2]) == "function" then
                Target = Option[2](_PlayerID, PageID, _OptionID);
            end
            self.Dialog[_PlayerID][PageID].MC.Selected = Option.ID;
            self.Dialog[_PlayerID].CurrentPage = self:GetPageIDByName(_PlayerID, Target) -1;
            self:NextPage(_PlayerID);
        end
    end
end

function ModuleDialogSystem.Global:GetCurrentDialog(_PlayerID)
    return self.Dialog[_PlayerID];
end

function ModuleDialogSystem.Global:GetCurrentDialogPage(_PlayerID)
    if self.Dialog[_PlayerID] then
        local PageID = self.Dialog[_PlayerID].CurrentPage;
        return self.Dialog[_PlayerID][PageID];
    end
end

function ModuleDialogSystem.Global:GetPageIDByName(_PlayerID, _Name)
    if type(_Name) == "string" then
        if self.Dialog[_PlayerID] ~= nil then
            for i= 1, #self.Dialog[_PlayerID], 1 do
                if type(self.Dialog[_PlayerID][i]) == "table" and self.Dialog[_PlayerID][i].Name == _Name then
                    return i;
                end
            end
        end
        return 0;
    end
    return _Name;
end

function ModuleDialogSystem.Global:CanStartDialog(_PlayerID)
    return self.Dialog[_PlayerID] == nil
           and not API.IsCinematicEventActive(_PlayerID)
           and self.LoadscreenClosed;
end

-- Local -------------------------------------------------------------------- --

function ModuleDialogSystem.Local:OnGameStart()
    QSB.ScriptEvents.DialogStarted = API.RegisterScriptEvent("Event_DialogStarted");
    QSB.ScriptEvents.DialogEnded = API.RegisterScriptEvent("Event_DialogEnded");
    QSB.ScriptEvents.DialogPageShown = API.RegisterScriptEvent("Event_DialogPageShown");
    QSB.ScriptEvents.DialogOptionSelected = API.RegisterScriptEvent("Event_DialogOptionSelected");

    self:OverrideThroneRoomFunctions();
end

function ModuleDialogSystem.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.EscapePressed then
        -- Nothing to do?
    elseif _ID == QSB.ScriptEvents.DialogStarted then
        self:StartDialog(arg[1], arg[2]);
    elseif _ID == QSB.ScriptEvents.DialogEnded then
        self:EndDialog(arg[1], arg[2]);
    elseif _ID == QSB.ScriptEvents.DialogPageShown then
        self:DisplayPage(arg[1], arg[2], arg[3]);
    end
end

function ModuleDialogSystem.Local:StartDialog(_PlayerID, _Dialog)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.Dialog[_PlayerID] = _Dialog;
    self.Dialog[_PlayerID].CurrentPage = 0;
    local PosX, PosY = Camera.RTS_GetLookAtPosition();
    local Rotation = Camera.RTS_GetRotationAngle();
    local ZoomFactor = Camera.RTS_GetZoomFactor();
    local SpeedFactor = Game.GameTimeGetFactor(_PlayerID);
    local SubX, SubY = XGUIEng.GetWidgetLocalPosition("/InGame/Root/Normal/AlignBottomLeft/SubTitles");
    self.Dialog[_PlayerID].Backup = {
        SubTitles = {SubX, SubY},
        Camera    = {PosX, PosY, Rotation, ZoomFactor},
        Speed     = SpeedFactor,
    };

    API.DeactivateNormalInterface(_PlayerID);
    API.DeactivateBorderScroll(_PlayerID);

    if not Framework.IsNetworkGame() then
        Game.GameTimeSetFactor(_PlayerID, 1);
    end
    self:ActivateCinematicMode(_PlayerID);
end

function ModuleDialogSystem.Local:EndDialog(_PlayerID, _Dialog)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end

    if self.Dialog[_PlayerID].RestoreGameSpeed and not Framework.IsNetworkGame() then
        Game.GameTimeSetFactor(_PlayerID, self.Dialog[_PlayerID].Backup.Speed);
    end
    if self.Dialog[_PlayerID].RestoreCamera then
        Camera.RTS_SetLookAtPosition(self.Dialog[_PlayerID].Backup.Camera[1], self.Dialog[_PlayerID].Backup.Camera[2]);
        Camera.RTS_SetRotationAngle(self.Dialog[_PlayerID].Backup.Camera[3]);
        Camera.RTS_SetZoomFactor(self.Dialog[_PlayerID].Backup.Camera[4]);
    end

    self:DeactivateCinematicMode(_PlayerID);
    API.ActivateNormalInterface(_PlayerID);
    API.ActivateBorderScroll(_PlayerID);
    ModuleGuiControl.Local:UpdateHiddenWidgets();

    self.Dialog[_PlayerID] = nil;
    Display.SetRenderFogOfWar(1);
    Display.SetRenderBorderPins(1);
    Display.SetRenderSky(0);
end

function ModuleDialogSystem.Local:DisplayPage(_PlayerID, _PageID, _PageData)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.Dialog[_PlayerID][_PageID] = _PageData;
    self.Dialog[_PlayerID].CurrentPage = _PageID;

    if type(self.Dialog[_PlayerID][_PageID]) == "table" then
        self.Dialog[_PlayerID][_PageID].Started = Logic.GetTime();
        self:DisplayPageFader(_PlayerID, _PageID);
        self:DisplayPagePosition(_PlayerID, _PageID);
        self:DisplayPageActor(_PlayerID, _PageID);
        self:DisplayPageTitle(_PlayerID, _PageID);
        self:DisplayPageText(_PlayerID, _PageID);
        if self.Dialog[_PlayerID][_PageID].MC then
            self:DisplayPageOptionsDialog(_PlayerID, _PageID);
        end
    end
end

function ModuleDialogSystem.Local:DisplayPagePosition(_PlayerID, _PageID)
    local Page = self.Dialog[_PlayerID][_PageID];
    -- Camera
    Camera.RTS_FollowEntity(0);
    if Page.Position then
        local Position = Page.Position;
        if type(Position) ~= "table" then
            Position = GetPosition(Page.Position);
        end
        Camera.RTS_SetLookAtPosition(Position.X, Position.Y);
    elseif Page.Target then
        Camera.RTS_FollowEntity(GetID(Page.Target));
    else
        assert(false);
    end
    Camera.RTS_SetRotationAngle(Page.Rotation);
    Camera.RTS_SetZoomFactor(Page.Distance / 18000);
    -- FIXME: This does not work?
    Camera.RTS_SetZoomAngle(Page.Angle);
end

function ModuleDialogSystem.Local:DisplayPageFader(_PlayerID, _PageID)
    local Page = self.Dialog[_PlayerID][_PageID];
    g_Fade.To = Page.FaderAlpha or 0;

    local PageFadeIn = Page.FadeIn;
    if PageFadeIn then
        FadeIn(PageFadeIn);
    end

    local PageFadeOut = Page.FadeOut;
    if PageFadeOut then
        -- FIXME: This would create jobs that are only be paused at the end!
        self.Dialog[_PlayerID].FaderJob = API.StartHiResJob(function(_Time, _FadeOut)
            if Logic.GetTimeMs() > _Time - (_FadeOut * 1000) then
                FadeOut(_FadeOut);
                return true;
            end
        end, Logic.GetTimeMs() + ((Page.Duration or 0) * 1000), PageFadeOut);
    end
end

function ModuleDialogSystem.Local:DisplayPageActor(_PlayerID, _PageID)
    local PortraitWidget = "/InGame/Root/Normal/AlignBottomLeft/Message";
    XGUIEng.ShowWidget(PortraitWidget, 1);
    XGUIEng.ShowAllSubWidgets(PortraitWidget, 1);
    XGUIEng.ShowWidget(PortraitWidget.. "/QuestLog", 0);
    XGUIEng.ShowWidget(PortraitWidget.. "/Update", 0);
    local Page = self.Dialog[_PlayerID][_PageID];
    if not Page.Actor or Page.Actor == -1 then
        XGUIEng.ShowWidget(PortraitWidget, 0);
        return;
    end
    local Actor = self:GetPageActor(_PlayerID, _PageID);
    self:DisplayActorPortrait(_PlayerID, Actor);
end

function ModuleDialogSystem.Local:GetPageActor(_PlayerID, _PageID)
    local Actor = g_PlayerPortrait[_PlayerID];
    local Page = self.Dialog[_PlayerID][_PageID];
    if type(Page.Actor) == "string" then
        Actor = Page.Actor;
    elseif type(Page.Actor) == "number" then
        Actor = g_PlayerPortrait[Page.Actor];
    end
    -- If someone doesn't read the fucking manual...
    if not Models["Heads_" .. tostring(Actor)] then
        Actor = "H_NPC_Generic_Trader";
    end
    return Actor;
end

function ModuleDialogSystem.Local:DisplayPageTitle(_PlayerID, _PageID)
    local PortraitWidget = "/InGame/Root/Normal/AlignBottomLeft/Message";
    local Page = self.Dialog[_PlayerID][_PageID];
    if Page.Title then
        local Title = API.ConvertPlaceholders(Page.Title);
        if Title:find("^[A-Za-Z0-9_]+/[A-Za-Z0-9_]+$") then
            Title = XGUIEng.GetStringTableText(Title);
        end
        if Title:sub(1, 1) ~= "{" then
            Title = "{center}" ..Title;
        end
        XGUIEng.SetText(PortraitWidget.. "/MessagePortrait/PlayerName", Title);
        XGUIEng.ShowWidget(PortraitWidget.. "/MessagePortrait/PlayerName", 1);
    else
        XGUIEng.ShowWidget(PortraitWidget.. "/MessagePortrait/PlayerName", 0);
    end
end

function ModuleDialogSystem.Local:DisplayPageText(_PlayerID, _PageID)
    self:ResetSubtitlesPosition(_PlayerID);
    local Page = self.Dialog[_PlayerID][_PageID];
    local SubtitlesWidget = "/InGame/Root/Normal/AlignBottomLeft/SubTitles";
    if not Page or not Page.Text or Page.Text == "" then
        XGUIEng.SetText(SubtitlesWidget.. "/VoiceText1", " ");
        XGUIEng.ShowWidget(SubtitlesWidget, 0);
        return;
    end
    XGUIEng.ShowWidget(SubtitlesWidget, 1);
    XGUIEng.ShowWidget(SubtitlesWidget.. "/Update", 0);
    XGUIEng.ShowWidget(SubtitlesWidget.. "/VoiceText1", 1);
    XGUIEng.ShowWidget(SubtitlesWidget.. "/BG", 1);

    local Text = API.ConvertPlaceholders(API.Localize(Page.Text));
    local Extension = "";
    if not Page.AutoSkip and not Page.MC then
        Extension = API.ConvertPlaceholders(API.Localize(ModuleDialogSystem.Shared.Text.Continue));
    end
    XGUIEng.SetText(SubtitlesWidget.. "/VoiceText1", Text .. Extension);
    self:SetSubtitlesPosition(_PlayerID, _PageID);
end

function ModuleDialogSystem.Local:SetSubtitlesPosition(_PlayerID, _PageID)
    local Page = self.Dialog[_PlayerID][_PageID];
    local MotherWidget = "/InGame/Root/Normal/AlignBottomLeft/SubTitles";
    local Height = XGUIEng.GetTextHeight(MotherWidget.. "/VoiceText1", true);
    local W, H = XGUIEng.GetWidgetSize(MotherWidget.. "/VoiceText1");
    local X,Y = XGUIEng.GetWidgetLocalPosition(MotherWidget);
    if Page.Actor then
        XGUIEng.SetWidgetSize(MotherWidget.. "/BG", W + 10, Height + 120);
        Y = 675 - Height;
        XGUIEng.SetWidgetLocalPosition(MotherWidget, X, Y);
    else
        XGUIEng.SetWidgetSize(MotherWidget.. "/BG", W + 10, Height + 35);
        Y = 1115 - Height;
        XGUIEng.SetWidgetLocalPosition(MotherWidget, 46, Y);
    end
end

function ModuleDialogSystem.Local:ResetSubtitlesPosition(_PlayerID)
    local Position = self.Dialog[_PlayerID].Backup.SubTitles;
    local SubtitleWidget = "/InGame/Root/Normal/AlignBottomLeft/SubTitles";
    XGUIEng.SetWidgetLocalPosition(SubtitleWidget, Position[1], Position[2]);
end

-- This is needed to reset the timer buttons after the portrait widget has been
-- abused to show the actor in the dialog.
function ModuleDialogSystem.Local:ResetTimerButtons(_PlayerID)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    if not g_Interaction.TimerQuests then
        return;
    end
    local MainWidget = "/InGame/Root/Normal/AlignTopLeft/QuestTimers/";
    for i= 1,6 do
        local ButtonWidget = MainWidget ..i.. "/TimerButton";
        local QuestIndex = g_Interaction.TimerQuests[i];
        if QuestIndex ~= nil then
            local Quest = Quests[QuestIndex];
            if g_Interaction.CurrentMessageQuestIndex == QuestIndex and not QuestLog.IsQuestLogShown() then
                g_Interaction.CurrentMessageQuestIndex = nil;
                g_VoiceMessageIsRunning = false;
                g_VoiceMessageEndTime = nil;
                XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait", 0);
                XGUIEng.ShowWidget(QuestLog.Widget.Main, 0);
                XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/SubTitles", 0);
                XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);
                XGUIEng.HighLightButton(ButtonWidget, 0);
            end
            if Quest then
                self:DisplayActorPortrait(Quest.SendingPlayer);
            end
        end
    end
end

function ModuleDialogSystem.Local:DisplayActorPortrait(_PlayerID, _HeadModel)
    local PortraitWidget = "/InGame/Root/Normal/AlignBottomLeft/Message";
    local Actor = g_PlayerPortrait[_PlayerID];
    if _HeadModel then
        -- Just because I am paranoid... Should never happen.
        if not Models["Heads_" .. tostring(_HeadModel)] then
            _HeadModel = "H_NPC_Generic_Trader";
        end
        Actor = _HeadModel;
    end
    XGUIEng.ShowWidget(PortraitWidget.. "/MessagePortrait", 1);
    XGUIEng.ShowWidget(PortraitWidget.. "/QuestObjectives", 0);
    SetPortraitWithCameraSettings(PortraitWidget.. "/MessagePortrait/3DPortraitFaceFX", Actor);
    GUI.PortraitWidgetSetRegister(PortraitWidget.. "/MessagePortrait/3DPortraitFaceFX", "Mood_Friendly", 1,2,0);
    GUI.PortraitWidgetSetRegister(PortraitWidget.. "/MessagePortrait/3DPortraitFaceFX", "Mood_Angry", 1,2,0);
end

function ModuleDialogSystem.Local:DisplayPageOptionsDialog(_PlayerID, _PageID)
    local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
    local Screen = {GUI.GetScreenSize()};
    local Page = self.Dialog[_PlayerID][_PageID];
    local Listbox = XGUIEng.GetWidgetID(Widget .. "/ListBox");

    -- Save original coordinates of sound provider selection
    self.Dialog[_PlayerID].MCSelectionBoxPosition = {
        XGUIEng.GetWidgetScreenPosition(Widget)
    };

    -- Fill sound provider selection with options
    XGUIEng.ListBoxPopAll(Listbox);
    self.Dialog[_PlayerID].MCSelectionOptionsMap = {};
    for i=1, #Page.MC, 1 do
        if Page.MC[i].Visible ~= false then
            XGUIEng.ListBoxPushItem(Listbox, Page.MC[i][1]);
            table.insert(self.Dialog[_PlayerID].MCSelectionOptionsMap, Page.MC[i].ID);
        end
    end
    XGUIEng.ListBoxSetSelectedIndex(Listbox, 0);

    -- Set choice position
    local ChoiceSize = {XGUIEng.GetWidgetScreenSize(Widget)};
    local CX = math.ceil((Screen[1] * 0.05) + (ChoiceSize[1] /2));
    local CY = math.ceil(Screen[2] - (ChoiceSize[2] + 60 * (Screen[2]/540)));
    if not Page.Actor then
        CX = 15 * (Screen[1]/960);
        CY = math.ceil(Screen[2] - (ChoiceSize[2] + 0 * (Screen[2]/540)));
    end
    XGUIEng.SetWidgetScreenPosition(Widget, CX, CY);
    XGUIEng.PushPage(Widget, false);
    XGUIEng.ShowWidget(Widget, 1);

    -- Set text position
    if not Page.Actor then
        local TextWidget = "/InGame/Root/Normal/AlignBottomLeft/SubTitles";
        local DX,DY = XGUIEng.GetWidgetLocalPosition(TextWidget);
        XGUIEng.SetWidgetLocalPosition(TextWidget, DX, DY-220);
    end

    self.Dialog[_PlayerID].MCSelectionIsShown = true;
end

function ModuleDialogSystem.Local:OnOptionSelected(_PlayerID)
    local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
    local Position = self.Dialog[_PlayerID].MCSelectionBoxPosition;
    XGUIEng.SetWidgetScreenPosition(Widget, Position[1], Position[2]);
    XGUIEng.ShowWidget(Widget, 0);
    XGUIEng.PopPage();

    local Selected = XGUIEng.ListBoxGetSelectedIndex(Widget .. "/ListBox")+1;
    local AnswerID = self.Dialog[_PlayerID].MCSelectionOptionsMap[Selected];

    API.SendScriptEvent(QSB.ScriptEvents.DialogOptionSelected, _PlayerID, AnswerID);
    API.BroadcastScriptEventToGlobal(
        "DialogOptionSelected",
        _PlayerID,
        AnswerID
    );
end

function ModuleDialogSystem.Local:ThroneRoomCameraControl(_PlayerID, _Page)
    if _Page then
        if self.Dialog[_PlayerID].MCSelectionIsShown then
            local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
            if XGUIEng.IsWidgetShown(Widget) == 0 then
                self.Dialog[_PlayerID].MCSelectionIsShown = false;
                self:OnOptionSelected(_PlayerID);
            end
        end
    end
end

function ModuleDialogSystem.Local:ConvertPosition(_Table)
    local Position = _Table;
    if type(Position) ~= "table" then
        Position = GetPosition(_Table);
    end
    return Position.X, Position.Y, Position.Z;
end

function ModuleDialogSystem.Local:GetCurrentDialog(_PlayerID)
    return self.Dialog[_PlayerID];
end

function ModuleDialogSystem.Local:GetCurrentDialogPage(_PlayerID)
    if self.Dialog[_PlayerID] then
        local PageID = self.Dialog[_PlayerID].CurrentPage;
        return self.Dialog[_PlayerID][PageID];
    end
end

function ModuleDialogSystem.Local:GetPageIDByName(_PlayerID, _Name)
    if type(_Name) == "string" then
        if self.Dialog[_PlayerID] ~= nil then
            for i= 1, #self.Dialog[_PlayerID], 1 do
                if type(self.Dialog[_PlayerID][i]) == "table" and self.Dialog[_PlayerID][i].Name == _Name then
                    return i;
                end
            end
        end
        return 0;
    end
    return _Name;
end

function ModuleDialogSystem.Local:IsAnyCinematicEventActive(_PlayerID)
    for k, v in pairs(ModuleGuiEffects.Local.CinematicEventStatus[_PlayerID]) do
        if v == 1 then
            return true;
        end
    end
    return false;
end

function ModuleDialogSystem.Local:OverrideThroneRoomFunctions()
    -- We only need this to update the sound provider list box for the multiple
    -- choice options. We do not even use the throneroom camera.
    GameCallback_Camera_ThroneroomCameraControl_Orig_ModuleDialogSystem = GameCallback_Camera_ThroneroomCameraControl;
    GameCallback_Camera_ThroneroomCameraControl = function(_PlayerID)
        GameCallback_Camera_ThroneroomCameraControl_Orig_ModuleDialogSystem(_PlayerID);
        if _PlayerID == GUI.GetPlayerID() then
            local Dialog = ModuleDialogSystem.Local:GetCurrentDialog(_PlayerID);
            if Dialog ~= nil then
                ModuleDialogSystem.Local:ThroneRoomCameraControl(
                    _PlayerID,
                    ModuleDialogSystem.Local:GetCurrentDialogPage(_PlayerID)
                );
            end
        end
    end
end

function ModuleDialogSystem.Local:ActivateCinematicMode(_PlayerID)
    -- Check for cinematic mode running and UI player
    if self.CinematicActive or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.CinematicActive = true;

    -- Pop loadscreen if visible
    if not self.LoadscreenClosed then
        XGUIEng.PopPage();
    end

    -- Show throneroom updater
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);
    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main", 1);
    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/Main", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/updater", 1);

    -- Show message stuff
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechStartAgainOrStop", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechButtons/SpeechStartAgainOrStop", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/Update", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/SubTitles/Update", 0);
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionDialog/Text", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionDialog/Title", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionDialog/Objectives", " ");

    -- Change ui state for cinematic
    self.SelectionBackup = {GUI.GetSelectedEntities()};
    GUI.ClearSelection();
    GUI.ClearNotes();
    GUI.ForbidContextSensitiveCommandsInSelectionState();
    GUI.ActivateCutSceneState();
    GUI.SetFeedbackSoundOutputState(0);
    GUI.EnableBattleSignals(false);
    Input.CutsceneMode();
    if not self.Dialog[_PlayerID].EnableFoW then
        Display.SetRenderFogOfWar(0);
    end
    if self.Dialog[_PlayerID].EnableSky then
        Display.SetRenderSky(1);
    end
    if not self.Dialog[_PlayerID].EnableBorderPins then
        Display.SetRenderBorderPins(0);
    end
    Display.SetUserOptionOcclusionEffect(0);
    Camera.SwitchCameraBehaviour(0);

    -- Prepare the fader
    InitializeFader();
    g_Fade.To = 0;
    SetFaderAlpha(0);

    -- Push loadscreen if previously visible
    -- (This should never happen)
    if not self.LoadscreenClosed then
        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);
    end
end

function ModuleDialogSystem.Local:DeactivateCinematicMode(_PlayerID)
    -- Check for cinematic mode running and UI player
    if not self.CinematicActive or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.CinematicActive = false;

    -- Reset ui state
    g_Fade.To = 0;
    SetFaderAlpha(0);
    XGUIEng.PopPage();
    Camera.SwitchCameraBehaviour(0);
    Display.UseStandardSettings();
    Input.GameMode();
    GUI.EnableBattleSignals(true);
    GUI.SetFeedbackSoundOutputState(1);
    GUI.ActivateSelectionState();
    GUI.PermitContextSensitiveCommandsInSelectionState();
    for k, v in pairs(self.SelectionBackup) do
        GUI.SelectEntity(v);
    end
    Display.SetRenderSky(0);
    Display.SetRenderBorderPins(1);
    Display.SetRenderFogOfWar(1);
    if Options.GetIntValue("Display", "Occlusion", 0) > 0 then
        Display.SetUserOptionOcclusionEffect(1);
    end

    -- Hide the message stuff
    XGUIEng.SetText("/InGame/Root/Normal/AlignBottomLeft/SubTitles/VoiceText1", " ");
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechButtons/SpeechStartAgainOrStop", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechStartAgainOrStop", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/Update", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/SubTitles/Update", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/SubTitles", 0);

    -- Reset the throneroom
    XGUIEng.PopPage();
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);

    ModuleGuiEffects.Local:ResetFarClipPlane();
    self:ResetSubtitlesPosition(_PlayerID);
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleDialogSystem);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Dialoge können verwendet werden, um Gespräche darzustellen.
--
-- Dialoge dienen zur Darstellung von Gesprächen. Mit Multiple Choice können
-- dem Spieler mehrere Auswahlmöglichkeiten gegeben, multiple Handlungsstränge
-- gestartet werden. Mittels Sprüngen und Leerseiten kann innerhalb des
-- Dialog navigiert werden.
--
-- Das Dialogsystem soll eine Alternative zu den Briefings darstellen, denen
-- die Darstellung wie im Thronsaal zu "unpersönlich" ist.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- <li><a href="modules.QSB_1_GuiEffects.QSB_1_GuiEffects.html">(1) Anzeigeeffekte</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field DialogStarted        Ein Dialog beginnt (Parameter: PlayerID, DialogTable)
-- @field DialogEnded          Ein Dialog endet (Parameter: PlayerID, DialogTable)
-- @field DialogPageShown      Ein Dialog endet (Parameter: PlayerID, PageIndex)
-- @field DialogOptionSelected Eine Multiple Choice Option wurde ausgewählt (Parameter: PlayerID, OptionID)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Startet einen Dialog.
--
-- Die Funktion bekommt ein Table mit der Dialogdefinition, wenn sie
-- aufgerufen wird.
--
-- <p>(→ Beispiel #1)</p>
--
-- Für einen Dialog können verschiedene spezielle Einstellungen vorgenommen
-- werden.<br>Mögliche Werte:
-- <table border="1">
-- <tr>
-- <td><b>Einstellung</b></td>
-- <td><b>Typ</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>Starting</td>
-- <td>function</td>
-- <td>(Optional) Eine Funktion, die beim Start des Dialog ausgeführt wird.<br>
-- Wird (im globalen Skript) vor QSB.ScriptEvents.DialogStarted aufgerufen!
-- </td>
-- </tr>
-- <tr>
-- <td>Finished</td>
-- <td>function</td>
-- <td>(Optional) Eine Funktion, die nach Beendigung des Dialog ausgeführt wird.<br>
-- Wird (im globalen Skript) nach QSB.ScriptEvents.DialogEnded aufgerufen!
-- </td>
-- </tr>
-- <tr>
-- <td>RestoreCamera</td>
-- <td>boolean</td>
-- <td>(Optional) Stellt die Kameraposition am Ende des Dialog wieder her. <br>Standard: ein</td>
-- </tr>
-- <tr>
-- <td>RestoreGameSpeed</td>
-- <td>boolean</td>
-- <td>(Optional) Stellt die Geschwindigkeit von vor dem Dialog wieder her. <br>Standard: ein</td>
-- </tr>
-- <tr>
-- <td>EnableGlobalImmortality</td>
-- <td>boolean</td>
-- <td>(Optional) Alle Einheiten und Gebäude werden unverwundbar solange der Dialog aktiv ist. <br>Standard: ein</td>
-- </tr>
-- <tr>
-- <td>EnableFoW</td>
-- <td>boolean</td>
-- <td>(Optional) Der Nebel des Krieges während des Dialog anzeigen. <br>Standard: aus</td>
-- </tr>
-- <tr>
-- <td>EnableBorderPins</td>
-- <td>boolean</td>
-- <td>(Optional) Die Grenzsteine während des Dialog anzeigen. <br>Standard: aus</td>
-- </tr>
-- </table>
--
-- @param[type=table]  _Dialog   Definition des Dialog
-- @param[type=string] _Name     Name des Dialog
-- @param[type=number] _PlayerID Empfänger des Dialog
-- @within Anwenderfunktionen
--
-- @usage
-- -- Beispiel #1: Grobes Gerüst eines Briefings
-- function Dialog1(_Name, _PlayerID)
--     local Dialog = {
--         DisableFow = true,
--         DisableBoderPins = true,
--     };
--     local AP, ASP = API.AddDialogPages(Dialog);
--
--     -- Aufrufe von AP oder ASP um Seiten zu erstellen
--
--     Dialog.Starting = function(_Data)
--         -- Mach was tolles hier, wenn es anfängt.
--     end
--     Dialog.Finished = function(_Data)
--         -- Mach was tolles hier, wenn es endet.
--     end
--     API.StartDialog(Dialog, _Name, _PlayerID);
-- end
--
function API.StartDialog(_Dialog, _Name, _PlayerID)
    if GUI then
        return;
    end
    local PlayerID = _PlayerID;
    if not PlayerID and not Framework.IsNetworkGame() then
        PlayerID = QSB.HumanPlayerID;
    end
    assert(_Name ~= nil);
    assert(_PlayerID ~= nil);
    if type(_Dialog) ~= "table" then
        error("API.StartDialog (" .._Name.. "): _Dialog must be a table!");
        return;
    end
    if #_Dialog == 0 then
        error("API.StartDialog (" .._Name.. "): _Dialog does not contain pages!");
        return;
    end
    for i=1, #_Dialog do
        if type(_Dialog[i]) == "table" and not _Dialog[i].__Legit then
            error("API.StartDialog (" .._Name.. ", Page #" ..i.. "): Page is not initialized!");
            return;
        end
    end
    if _Dialog.EnableSky == nil then
        _Dialog.EnableSky = true;
    end
    if _Dialog.EnableFoW == nil then
        _Dialog.EnableFoW = false;
    end
    if _Dialog.EnableGlobalImmortality == nil then
        _Dialog.EnableGlobalImmortality = true;
    end
    if _Dialog.EnableBorderPins == nil then
        _Dialog.EnableBorderPins = false;
    end
    if _Dialog.RestoreGameSpeed == nil then
        _Dialog.RestoreGameSpeed = true;
    end
    if _Dialog.RestoreCamera == nil then
        _Dialog.RestoreCamera = true;
    end
    ModuleDialogSystem.Global:StartDialog(_Name, PlayerID, _Dialog);
end

---
-- Prüft ob für den Spieler gerade ein Dialog aktiv ist.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=boolean] Dialog ist aktiv
-- @within Anwenderfunktionen
--
function API.IsDialogActive(_PlayerID)
    if API.GetScriptEnvironment() == QSB.Environment.GLOBAL then
        return ModuleDialogSystem.Global:GetCurrentDialog(_PlayerID) ~= nil;
    end
    return ModuleDialogSystem.Local:GetCurrentDialog(_PlayerID) ~= nil;
end

---
-- Erzeugt die Funktionen zur Erstellung von Seiten in einem Dialog und bindet
-- sie an selbigen. Diese Funktion muss vor dem Start eines Dialog aufgerufen
-- werden um Seiten hinzuzufügen.
--
-- @param[type=table] _Dialog Dialog Definition
-- @return[type=function] <a href="#AP">AP</a>
-- @return[type=function] <a href="#ASP">ASP</a>
-- @within Anwenderfunktionen
--
-- @usage
-- -- Wenn nur AP benötigt wird.
-- local AP = API.AddPages(Dialog);
-- -- Wenn zusätzlich ASP benötigt wird.
-- local AP, ASP = API.AddPages(Dialog);
--
function API.AddDialogPages(_Dialog)
    ModuleDialogSystem.Global:CreateDialogGetPage(_Dialog);
    ModuleDialogSystem.Global:CreateDialogAddPage(_Dialog);
    ModuleDialogSystem.Global:CreateDialogAddMCPage(_Dialog);
    ModuleDialogSystem.Global:CreateDialogAddRedirect(_Dialog);

    local AP = function(_Page)
        local Page;
        if type(_Page) == "table" then
            if _Page.MC then
                Page = _Dialog:AddMCPage(_Page);
            else
                Page = _Dialog:AddPage(_Page);
            end
        else
            Page = _Dialog:AddRedirect(_Page);
        end
        return Page;
    end

    local ASP = function(...)
        if type(arg[1]) ~= "number" then
            Name = table.remove(arg, 1);
        end
        local Sender   = table.remove(arg, 1);
        local Position = table.remove(arg, 1);
        local Title    = table.remove(arg, 1);
        local Text     = table.remove(arg, 1);
        local Dialog   = table.remove(arg, 1);
        local Action;
        if type(arg[1]) == "function" then
            Action = table.remove(arg, 1);
        end
        return _Dialog:AddPage{
            Name         = Name,
            Title        = Title,
            Text         = Text,
            Actor        = Sender,
            Target       = Position,
            DialogCamera = Dialog == true,
            Action       = Action,
        };
    end
    return AP, ASP;
end

---
-- Erstellt eine Seite für einen Dialog.
--
-- <b>Achtung</b>: Diese Funktion wird von
-- <a href="#API.AddPages">API.AddDialogPages</a> erzeugt und an
-- den Dialog gebunden.
--
-- <h5>Dialog Page</h5>
-- Eine Dialog Page stellt den gesprochenen Text mit und ohne Akteur dar.
--
-- <p>(→ Beispiel #1)</p>
-- 
-- Mögliche Felder:
-- <table border="1">
-- <tr>
-- <td><b>Einstellung</b></td>
-- <td><b>Typ</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>Actor</td>
-- <td>number</td>
-- <td>(optional) Spieler-ID des Akteur</td>
-- </tr>
-- <tr>
-- <td>Titel</td>
-- <td>string</td>
-- <td>(optional) Zeigt den Namen des Sprechers an. (Nur mit Akteur)</td>
-- </tr>
-- <tr>
-- <td>Text</td>
-- <td>string</td>
-- <td>(optional) Zeigt Text auf der Dialogseite an.</td>
-- </tr>
-- <tr>
-- <td>Action</td>
-- <td>function</td>
-- <td>(optional) Führt eine Funktion aus, wenn die aktuelle Dialogseite angezeigt wird.</td>
-- </tr>
-- <tr>
-- <td>Position</td>
-- <td>any (string|number|table)</td>
-- <td>Legt die Kameraposition der Seite fest.</td>
-- </tr>
-- <tr>
-- <td>Target</td>
-- <td>any (string|number)</td>
-- <td>Legt das Entity fest, dem die Kamera folgt.</td>
-- </tr>
-- <tr>
-- <td>Distance</td>
-- <td>number</td>
-- <td>(optional) Bestimmt die Entfernung der Kamera zur Position.</td>
-- </tr>
-- <tr>
-- <td>Rotation</td>
-- <td>number</td>
-- <td>(optional) Rotationswinkel der Kamera. Werte zwischen 0 und 360 sind möglich.</td>
-- </tr>
-- <tr>
-- <td>MC</td>
-- <td>table</td>
-- <td>(optional) Table mit möglichen Dialogoptionen. (Multiple Choice)</td>
-- </tr>
-- <tr>
-- <td>FadeIn</td>
-- <td>number</td>
-- <td>(Optional) Dauer des Einblendens von Schwarz zu Beginn der Page.<br>
-- Die Page benötigt eine Anzeigedauer!</td>
-- </tr>
-- <tr>
-- <td>FadeOut</td>
-- <td>number</td>
-- <td>(Optional) Dauer des Abblendens zu Schwarz am Ende der Page.<br>
-- Die Page benötigt eine Anzeigedauer!</td>
-- </tr>
-- <tr>
-- <td>FaderAlpha</td>
-- <td>number</td>
-- <td>(Optional) Zeigt entweder die Blende an (1) oder nicht (0). Per Default
-- wird die Blende nicht angezeigt. <br><b>Zwischen einer Seite mit FadeOut und
-- der nächsten mit FadeIn muss immer eine Seite mit FaderAlpha sein!</b></td>
-- </tr>
-- </table>
--
-- <br><h5>Multiple Choice</h5>
-- In einem Dialog kann der Spieler auch zur Auswahl einer Option gebeten
-- werden. Dies wird als Multiple Choice bezeichnet. Schreibe die Optionen
-- in eine Untertabelle MC.
--
-- <p>(→ Beispiel #2)</p>
--
-- Es kann der Name der Zielseite angegeben werden, oder eine Funktion, die
-- den Namen des Ziels zurück gibt. In der Funktion können vorher beliebige
-- Dinge getan werden, wie z.B. Variablen setzen.
--
-- Eine Antwort kann markiert werden, dass sie auch bei einem Rücksprung,
-- nicht mehrfach gewählt werden kann. In diesem Fall ist sie bei erneutem
-- Aufsuchen der Seite nicht mehr gelistet.
-- 
-- <p>(→ Beispiel #3)</p>
--
-- Eine Option kann auch bedingt ausgeblendet werden. Dazu wird eine Funktion
-- angegeben, welche über die Sichtbarkeit entscheidet.
-- 
-- <p>(→ Beispiel #4)</p>
--
-- Nachdem der Spieler eine Antwort gewählt hat, wird er auf die Seite mit
-- dem angegebenen Namen geleitet.
--
-- Um den Dialog zu beenden, nachdem ein Pfad beendet ist, wird eine leere
-- AP-Seite genutzt. Auf diese Weise weiß der Dialog, das er an dieser
-- Stelle zuende ist.
--
-- <p>(→ Beispiel #5)</p>
--
-- Soll stattdessen zu einer anderen Seite gesprungen werden, kann bei AP der
-- Name der Seite angeben werden, zu der gesprungen werden soll.
--
-- <p>(→ Beispiel #6)</p>
--
-- Um später zu einem beliebigen Zeitpunkt die gewählte Antwort einer Seite zu
-- erfahren, muss der Name der Seite genutzt werden.
-- 
-- <p>(→ Beispiel #7)</p>
--
-- Die zurückgegebene Zahl ist die ID der Antwort, angefangen von oben. Wird 0
-- zurückgegeben, wurde noch nicht geantwortet.
--
-- @param[type=table] _Page Spezifikation der Seite
-- @return[type=table] Refernez auf die angelegte Seite
-- @within Dialog
--
-- @usage
-- -- Beispiel #1: Eine einfache Seite erstellen
-- AP {
--     Title        = "Hero",
--     Text         = "This page has an actor and a choice.",
--     Actor        = 1,
--     Duration     = 2,
--     FadeIn       = 2,
--     Position     = "npc1",
--     DialogCamera = true,
-- };
--
-- @usage
-- -- Beispiel #2: Verwendung von Multiple Choice
-- AP {
--     Title        = "Hero",
--     Text         = "This page has an actor and a choice.",
--     Actor        = 1,
--     Duration     = 2,
--     FadeIn       = 2,
--     Position     = "npc1",
--     DialogCamera = true,
--    -- MC ist das Table mit den auswählbaren Antworten
--    MC = {
--        -- Zielseite ist der Name der Page, zu der gesprungen wird.
--        {"Antwort 1", "Zielseite"},
--        -- Option2Clicked ist eine Funktion, die etwas macht und
--        -- danach die Page zurückgibt, zu der gesprungen wird.
--        {"Antwort 2", Option2Clicked},
--    },
-- };
--
-- @usage
-- -- Beispiel #3: Antwort, die nur einmal gewählt werden kann
-- MC = {
--     {"Antwort 3", "AnotherPage", Remove = true},
-- }
--
-- @usage
-- -- Beispiel #4: Antwort mit gesteuerter Sichtbarkeit
-- MC = {
--     {"Antwort 3", "AnotherPage", Disable = OptionIsDisabled},
-- }
--
-- @usage
-- -- Beispiel #5: Abbruch des Dialog
-- AP()
--
-- @usage
-- -- Beispiel #6: Sprung zu anderer Seite
-- AP("SomePageName")
--
-- @usage
-- -- Beispiel #7: Erfragen der gewählten Antwort
-- Dialog.Finished = function(_Data)
--     local Choosen = _Data:GetPage("Choice"):GetSelected();
--     -- In Choosen steht der Index der Antwort
-- end
-- 
--
function AP(_Data)
    assert(false);
end

---
-- Erstellt eine Seite in vereinfachter Syntax. Es wird davon ausgegangen, dass
-- das Entity ein Siedler ist. Die Kamera schaut den Siedler an.
--
-- <b>Achtung</b>: Diese Funktion wird von
-- <a href="#API.AddPages">API.AddDialogPages</a> erzeugt und an
-- den Dialog gebunden.
--
-- @param[type=string]   _Name         (Optional) Name der Seite
-- @param[type=number]   _Sender       Spieler-ID des Akteur
-- @param[type=string]   _Target       Entity auf die die Kamera schaut
-- @param[type=string]   _Title        Name des Sprechers
-- @param[type=string]   _Text         Text der Seite
-- @param[type=boolean]  _DialogCamera Nahsicht an/aus
-- @param[type=function] _Action       (Optional) Callback-Funktion
-- @return[type=table] Referenz auf die Seite
-- @within Dialog
--
-- @usage
-- -- Beispiel ohne Page Name
-- ASP(1, "hans", "Hans", "Ich gehe in die weitel Welt hinein.", true);
-- -- Beispiel mit Page Name
-- ASP("Page1", 1, "hans", "Hans", "Ich gehe in die weitel Welt hinein.", true);
--
function ASP(...)
    assert(false);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Fügt Behavior zur Steuerung von Dialogs hinzu.
--
-- @set sort=true
--

-- -------------------------------------------------------------------------- --

---
-- Ruft die Funktion auf und startet das enthaltene Dialog.
--
-- Jedes Dialog braucht einen eindeutigen Namen!
--
-- @param[type=string] _Name   Bezeichner des Dialog
-- @param[type=string] _Dialog Funktionsname als String
-- @within Reprisal
--
function Reprisal_Dialog(...)
    return B_Reprisal_Dialog:new(...);
end

B_Reprisal_Dialog = {
    Name = "Reprisal_Dialog",
    Description = {
        en = "Reprisal: Calls a function to start an new dialog.",
        de = "Vergeltung: Ruft die Funktion auf und startet das enthaltene Dialog.",
        fr = "Rétribution: Appelle la fonction et démarre le dialogue contenu.",
    },
    Parameter = {
        { ParameterType.Default, en = "Dialog name",     de = "Name des Dialog",     fr = "Nom du dialogue" },
        { ParameterType.Default, en = "Dialog function", de = "Funktion mit Dialog", fr = "Fonction du dialogue" },
    },
}

function B_Reprisal_Dialog:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_Dialog:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.DialogName = _Parameter;
    elseif (_Index == 1) then
        self.Function = _Parameter;
    end
end

function B_Reprisal_Dialog:CustomFunction(_Quest)
    _G[self.Function](self.DialogName, _Quest.ReceivingPlayer);
end

function B_Reprisal_Dialog:Debug(_Quest)
    if self.DialogName == nil or self.DialogName == "" then
        error(string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    if not type(_G[self.Function]) == "function" then
        error(_Quest.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_Dialog);

-- -------------------------------------------------------------------------- --

---
-- Ruft die Funktion auf und startet das enthaltene Dialog.
--
-- Jedes Dialog braucht einen eindeutigen Namen!
--
-- @param[type=string] _Name   Bezeichner des Dialog
-- @param[type=string] _Dialog Funktionsname als String
-- @within Reward
--
function Reward_Dialog(...)
    return B_Reward_Dialog:new(...);
end

B_Reward_Dialog = Swift.LuaBase:CopyTable(B_Reprisal_Dialog);
B_Reward_Dialog.Name = "Reward_Dialog";
B_Reward_Dialog.Description.en = "Reward: Calls a function to start an new dialog.";
B_Reward_Dialog.Description.de = "Lohn: Ruft die Funktion auf und startet das enthaltene Dialog.";
B_Reward_Dialog.Description.fr = "Récompense: Appelle la fonction et lance le dialogue qu'elle contient.";
B_Reward_Dialog.GetReprisalTable = nil;

B_Reward_Dialog.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Swift:RegisterBehavior(B_Reward_Dialog);

-- -------------------------------------------------------------------------- --

---
-- Prüft, ob ein Dialog beendet ist und startet dann den Quest.
--
-- @param[type=string] _Name     Bezeichner des Dialog
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Waittime (optional) Wartezeit in Sekunden
-- @within Trigger
--
function Trigger_Dialog(...)
    return B_Trigger_Dialog:new(...);
end

B_Trigger_Dialog = {
    Name = "Trigger_Dialog",
    Description = {
        en = "Trigger: Checks if an dialog has concluded and starts the quest if so.",
        de = "Auslöser: Prüft, ob ein Dialog beendet ist und startet dann den Quest.",
        fr = "Déclencheur: Vérifie si un dialogue est terminé et démarre alors la quête.",
    },
    Parameter = {
        { ParameterType.Default,  en = "Dialog name", de = "Name des Dialog", fr = "Nom du dialogue" },
        { ParameterType.PlayerID, en = "Player ID",   de = "Player ID",       fr = "Player ID" },
        { ParameterType.Number,   en = "Wait time",   de = "Wartezeit",       fr = "Temps d'attente" },
    },
}

function B_Trigger_Dialog:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_Dialog:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.DialogName = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or 0;
        self.WaitTime = _Parameter * 1;
    end
end

function B_Trigger_Dialog:CustomFunction(_Quest)
    if API.GetCinematicEvent(self.DialogName, self.PlayerID) == CinematicEvent.Concluded then
        if self.WaitTime and self.WaitTime > 0 then
            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
            if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                return true;
            end
        else
            return true;
        end
    end
    return false;
end

function B_Trigger_Dialog:Debug(_Quest)
    if self.WaitTime < 0 then
        error(string.format("%s: %s: Wait time must be 0 or greater!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.PlayerID < 1 or self.PlayerID > 8 then
        error(string.format("%s: %s: Player-ID must be between 1 and 8!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.DialogName == nil or self.DialogName == "" then
        error(string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Trigger_Dialog);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleLifestockBreeding = {
    Properties = {
        Name = "ModuleLifestockBreeding",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        AnimalChildren = {},
        PastureRegister = {},

        Cattle = {
            RequiredAmount = 2,
            QuantityBoost = 9,
            AreaSize = 4500,
            GrothTimer = 15,
            FeedingTimer = 20,
            BreedingTimer = 150,
            BabySize = 0.45,
            UseCalves = true,

            Breeding = true,
            MoneyCost = 300,
        },
        Sheep = {
            RequiredAmount = 2,
            QuantityBoost = 9,
            AreaSize = 4500,
            GrothTimer = 15,
            FeedingTimer = 30,
            BreedingTimer = 210,
            BabySize = 0.45,
            UseCalves = true,

            Breeding = true,
            MoneyCost = 450,
        },
    },
    Local = {
        Cattle = {
            Breeding = true,
            MoneyCost = 300,
        },
        Sheep = {
            Breeding = true,
            MoneyCost = 450,
        },
    },
    Shared = {
        Text = {
            BreedingActive = {
                Title = {
                    de = "Zucht aktiv",
                    en = "Breeding active",
                    fr = "Élevage actif",
                },
                Text = {
                    de = "- Klicken um Zucht zu stoppen",
                    en = "- Click to stop breeding",
                    fr = "- Cliquez pour arrêter l'élevage",
                },
                Disabled = {
                    de = "Zucht ist gesperrt!",
                    en = "Breeding is locked!",
                    fr = "L'élevage est bloqué!",
                },
            },
            BreedingInactive = {
                Title = {
                    de = "Zucht gestoppt",
                    en = "Breeding stopped",
                    fr = "Élevage stoppé",
                },
                Text = {
                    de = "- Klicken um Zucht zu starten {cr}- Benötigt Platz {cr}- Benötigt Getreide",
                    en = "- Click to allow breeding {cr}- Requires space {cr}- Requires grain",
                    fr = "- Cliquez pour démarrer l'élevage {cr}- Nécessite de l'espace {cr}- Nécessite des céréales",
                },
                Disabled = {
                    de = "Zucht ist gesperrt!",
                    en = "Breeding is locked!",
                    fr = "L'élevage est bloqué!",
                },
            },
        },
    }
}

-- Global ------------------------------------------------------------------- --

function ModuleLifestockBreeding.Global:OnGameStart()
    MerchantSystem.BasePricesOrigModuleLifestockBreeding                = {};
    MerchantSystem.BasePricesOrigModuleLifestockBreeding[Goods.G_Sheep] = MerchantSystem.BasePrices[Goods.G_Sheep];
    MerchantSystem.BasePricesOrigModuleLifestockBreeding[Goods.G_Cow]   = MerchantSystem.BasePrices[Goods.G_Cow];

    MerchantSystem.BasePrices[Goods.G_Sheep] = ModuleLifestockBreeding.Global.Sheep.MoneyCost;
    MerchantSystem.BasePrices[Goods.G_Cow]   = ModuleLifestockBreeding.Global.Cattle.MoneyCost;

    QSB.ScriptEvents.AnimalBreed = API.RegisterScriptEvent("Event_AnimalBreed");

    for i= 1, 8 do
        self.PastureRegister[i] = {};
    end

    API.StartJob(function()
        ModuleLifestockBreeding.Global:AnimalBreedController();
    end);
    API.StartJob(function()
        ModuleLifestockBreeding.Global:AnimalGrouthController();
    end);
end

function ModuleLifestockBreeding.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

function ModuleLifestockBreeding.Global:SpawnCattle(_X, _Y, _PlayerID, _Shrink)
    local ID = Logic.CreateEntity(Entities.A_X_Cow01, _X, _Y, 0, _PlayerID);
    if _Shrink == true then
        API.SetFloat(ID, QSB.ScriptingValue.Size, self.Cattle.BabySize);
        table.insert(self.AnimalChildren, {ID, self.Cattle.GrothTimer});
    end
    API.SendScriptEvent(QSB.ScriptEvents.AnimalBreed, _PlayerID, ID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.AnimalBreed, %d, %d)]],
        _PlayerID, ID
    ));
end

function ModuleLifestockBreeding.Global:SpawnSheep(_X, _Y, _PlayerID, _Shrink)
    local Type = Entities.A_X_Sheep01;
    if not Framework.IsNetworkGame() then
        Type = Entities["A_X_Sheep0" ..math.random(1, 2)];
    end
    local ID = Logic.CreateEntity(Type, _X, _Y, 0, _PlayerID);
    if _Shrink == true then
        API.SetFloat(ID, QSB.ScriptingValue.Size, self.Sheep.BabySize);
        table.insert(self.AnimalChildren, {ID, self.Sheep.GrothTimer});
    end
    API.SendScriptEvent(QSB.ScriptEvents.AnimalBreed, _PlayerID, ID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.AnimalBreed, %d, %d)]],
        _PlayerID, ID
    ));
end

function ModuleLifestockBreeding.Global:CalculateCattleBreedingTimer(_Animals)
    if self.Cattle.RequiredAmount <= _Animals then
        local Time = self.Cattle.BreedingTimer - (_Animals * self.Cattle.QuantityBoost);
        return (Time < 30 and 30) or Time;
    end
    return -1;
end

function ModuleLifestockBreeding.Global:CalculateSheepBreedingTimer(_Animals)
    if self.Sheep.RequiredAmount <= _Animals then
        local Time = self.Sheep.BreedingTimer - (_Animals * self.Sheep.QuantityBoost);
        return (Time < 30 and 30) or Time;
    end
    return -1;
end

function ModuleLifestockBreeding.Global:IsCattleNeeded(_PastureID, _PlayerID)
    if self:GetCattlePastureDelta(_PlayerID) < 1 then
        local x,y,z = Logic.EntityGetPos(_PastureID);
        local n1, ID1 = Logic.GetPlayerEntitiesInArea(_PlayerID, Entities.A_X_Cow01, x, y, 900, 16);
        return n1 < 5;
    end
    return false;
end

function ModuleLifestockBreeding.Global:IsSheepNeeded(_PastureID, _PlayerID)
    if self:GetSheepPastureDelta(_PlayerID) < 1 then
        local x,y,z = Logic.EntityGetPos(_PastureID);
        local n1, ID1 = Logic.GetPlayerEntitiesInArea(_PlayerID, Entities.A_X_Sheep01, x, y, 900, 16);
        local n2, ID2 = Logic.GetPlayerEntitiesInArea(_PlayerID, Entities.A_X_Sheep02, x, y, 900, 16);
        return n1+n2 < 5;
    end
    return false;
end

function ModuleLifestockBreeding.Global:GetCattlePastureDelta(_PlayerID)
    local AmountOfCattle = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CattlePasture)};
    local AmountOfPasture = Logic.GetNumberOfEntitiesOfTypeOfPlayer(_PlayerID, Entities.B_CattlePasture);
    return #AmountOfCattle / (AmountOfPasture * 5);
end

function ModuleLifestockBreeding.Global:GetSheepPastureDelta(_PlayerID)
    local AmountOfSheep = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.SheepPasture)};
    local AmountOfPasture = Logic.GetNumberOfEntitiesOfTypeOfPlayer(_PlayerID, Entities.B_SheepPasture);
    return #AmountOfSheep / (AmountOfPasture * 5);
end

function ModuleLifestockBreeding.Global:CountCattleNearby(_Pasture)
    local PastureID = GetID(_Pasture)
    local PlayerID  = Logic.EntityGetPlayer(PastureID);
    local x, y, z   = Logic.EntityGetPos(PastureID);
    local AreaSize  = self.Cattle.AreaSize;
    local Cattle    = {Logic.GetPlayerEntitiesInArea(PlayerID, Entities.A_X_Cow01, x, y, AreaSize, 16)};
    table.remove(Cattle, 1);
    return #Cattle;
end

function ModuleLifestockBreeding.Global:CountSheepsNearby(_Pasture)
    local PastureID = GetID(_Pasture)
    local PlayerID  = Logic.EntityGetPlayer(PastureID);
    local x, y, z   = Logic.EntityGetPos(PastureID);
    local AreaSize  = self.Sheep.AreaSize;
    local Sheeps1   = {Logic.GetPlayerEntitiesInArea(PlayerID, Entities.A_X_Sheep01, x, y, AreaSize, 16)};
    local Sheeps2   = {Logic.GetPlayerEntitiesInArea(PlayerID, Entities.A_X_Sheep02, x, y, AreaSize, 16)};
    table.remove(Sheeps1, 1);
    table.remove(Sheeps2, 1);
    return #Sheeps1 + #Sheeps2;
end

function ModuleLifestockBreeding.Global:AnimalGrouthController()
    for k, v in pairs(self.AnimalChildren) do
        if not IsExisting(v[1]) then
            self.AnimalChildren[k] = nil;
        else
            self.AnimalChildren[k][2] = v[2] -1;
            if v[2] < 0 then
                local IsCow = Logic.GetEntityType(v[1]) == Entities.A_X_Cow01;
                local GrothTimer = (IsCow and self.Cattle.GrothTimer) or self.Sheep.GrothTimer;
                self.AnimalChildren[k][2] = GrothTimer;
                local Scale = API.GetFloat(v[1], QSB.ScriptingValue.Size);
                API.SetFloat(v[1], QSB.ScriptingValue.Size, math.min(1, Scale + 0.05))
                if Scale + 0.05 >= 1 then
                    self.AnimalChildren[k] = nil;
                end
            end
        end
    end
end

function ModuleLifestockBreeding.Global:AnimalBreedController()
    if self.Cattle.Breeding then
        local CattlePasture = Logic.GetEntitiesOfType(Entities.B_CattlePasture);
        for k, v in pairs(CattlePasture) do
            local PlayerID = Logic.EntityGetPlayer(v);
            if not self.PastureRegister[PlayerID][v] then
                self.PastureRegister[PlayerID][v] = {0, 0};
            end
            self:CalculateCattlePastureFeeding(PlayerID, v);
            self:CattlePastureSpawnAnimal(PlayerID, v);
        end
    end

    if self.Sheep.Breeding then
        local SheepPasture = Logic.GetEntitiesOfType(Entities.B_SheepPasture);
        for k, v in pairs(SheepPasture) do
            local PlayerID = Logic.EntityGetPlayer(v);
            if not self.PastureRegister[PlayerID][v] then
                self.PastureRegister[PlayerID][v] = {0, 0};
            end
            self:CalculateSheepPastureFeeding(PlayerID, v);
            self:SheepPastureSpawnAnimal(PlayerID, v);
        end
    end
end

function ModuleLifestockBreeding.Global:CalculateCattlePastureFeeding(_PlayerID, _PastureID)
    if self:IsCattleNeeded(_PastureID, _PlayerID) and Logic.IsBuildingStopped(_PastureID) == false then
        self.PastureRegister[_PlayerID][_PastureID][1] = self.PastureRegister[_PlayerID][_PastureID][1] +1;
        if self.PastureRegister[_PlayerID][_PastureID][1] > 0 then
            self.PastureRegister[_PlayerID][_PastureID][2] = self.PastureRegister[_PlayerID][_PastureID][2] +1;
            if self.PastureRegister[_PlayerID][_PastureID][2] >= self.Cattle.FeedingTimer then
                self.PastureRegister[_PlayerID][_PastureID][2] = 0;
                if GetPlayerResources(Goods.G_Grain, _PlayerID) > 0 then
                    AddGood(Goods.G_Grain, -1, _PlayerID);
                else
                    self.PastureRegister[_PlayerID][_PastureID][1] = math.max(
                        self.PastureRegister[_PlayerID][_PastureID][1] - self.Cattle.FeedingTimer,
                        0
                    );
                end
            end
        else
            self.PastureRegister[_PlayerID][_PastureID][2] = 0;
        end
    end
end

function ModuleLifestockBreeding.Global:CalculateSheepPastureFeeding(_PlayerID, _PastureID)
    if self:IsSheepNeeded(_PastureID, _PlayerID) and Logic.IsBuildingStopped(_PastureID) == false then
        self.PastureRegister[_PlayerID][_PastureID][1] = self.PastureRegister[_PlayerID][_PastureID][1] +1;
        if self.PastureRegister[_PlayerID][_PastureID][1] > 0 then
            self.PastureRegister[_PlayerID][_PastureID][2] = self.PastureRegister[_PlayerID][_PastureID][2] +1;
            if self.PastureRegister[_PlayerID][_PastureID][2] >= self.Sheep.FeedingTimer then
                self.PastureRegister[_PlayerID][_PastureID][2] = 0;
                if GetPlayerResources(Goods.G_Grain, _PlayerID) > 0 then
                    AddGood(Goods.G_Grain, -1, _PlayerID);
                else
                    self.PastureRegister[_PlayerID][_PastureID][1] = math.max(
                        self.PastureRegister[_PlayerID][_PastureID][1] - self.Sheep.FeedingTimer,
                        0
                    );
                end
            end
        else
            self.PastureRegister[_PlayerID][_PastureID][2] = 0;
        end
    end
end

function ModuleLifestockBreeding.Global:CattlePastureSpawnAnimal(_PlayerID, _PastureID)
    local CattleNearby = self:CountCattleNearby(_PastureID);
    local TimeTillNext = self:CalculateCattleBreedingTimer(CattleNearby);
    if TimeTillNext > -1 and self.PastureRegister[_PlayerID][_PastureID][1] >= TimeTillNext then
        if self:IsCattleNeeded(_PastureID, _PlayerID) then
            local x, y = Logic.GetBuildingApproachPosition(_PastureID);
            self:SpawnCattle(x, y, _PlayerID, self.Cattle.UseCalves);
            self.PastureRegister[_PlayerID][_PastureID] = nil;
        end
    end
end

function ModuleLifestockBreeding.Global:SheepPastureSpawnAnimal(_PlayerID, _PastureID)
    local SheepNearby = self:CountSheepsNearby(_PastureID);
    local TimeTillNext = self:CalculateSheepBreedingTimer(SheepNearby);
    if TimeTillNext > -1 and self.PastureRegister[_PlayerID][_PastureID][1] >= TimeTillNext then
        if self:IsSheepNeeded(_PastureID, _PlayerID) then
            local x, y = Logic.GetBuildingApproachPosition(_PastureID);
            self:SpawnSheep(x, y, _PlayerID, self.Sheep.UseCalves);
            self.PastureRegister[_PlayerID][_PastureID] = nil;
        end
    end
end

-- Local -------------------------------------------------------------------- --

function ModuleLifestockBreeding.Local:OnGameStart()
    MerchantSystem.BasePricesOrigModuleLifestockBreeding                = {};
    MerchantSystem.BasePricesOrigModuleLifestockBreeding[Goods.G_Sheep] = MerchantSystem.BasePrices[Goods.G_Sheep];
    MerchantSystem.BasePricesOrigModuleLifestockBreeding[Goods.G_Cow]   = MerchantSystem.BasePrices[Goods.G_Cow];

    MerchantSystem.BasePrices[Goods.G_Sheep] = ModuleLifestockBreeding.Local.Sheep.MoneyCost;
    MerchantSystem.BasePrices[Goods.G_Cow]   = ModuleLifestockBreeding.Local.Cattle.MoneyCost;

    QSB.ScriptEvents.AnimalBreed = API.RegisterScriptEvent("Event_AnimalBreed");

    self:OverrideHouseMenuProductionButton();
    self:InitBuyCattleButton();
    self:InitBuySheepButton();
end

function ModuleLifestockBreeding.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

function ModuleLifestockBreeding.Local:ToggleBreedingState(_BarrackID)
    local BuildingEntityType = Logic.GetEntityType(_BarrackID);
    if BuildingEntityType == Entities.B_CattlePasture then
        GUI.SetStoppedState(_BarrackID, not Logic.IsBuildingStopped(_BarrackID));
    elseif BuildingEntityType == Entities.B_SheepPasture then
        GUI.SetStoppedState(_BarrackID, not Logic.IsBuildingStopped(_BarrackID));
    end
end

function ModuleLifestockBreeding.Local:OverrideHouseMenuProductionButton()
    HouseMenuStopProductionClicked_Orig_Stockbreeding = HouseMenuStopProductionClicked;
    HouseMenuStopProductionClicked = function()
        HouseMenuStopProductionClicked_Orig_Stockbreeding();
        local WidgetName = HouseMenu.Widget.CurrentBuilding;
        local EntityType = Entities[WidgetName];
        local PlayerID = GUI.GetPlayerID();
        local Bool = HouseMenu.StopProductionBool;

        if EntityType == Entities.B_CattleFarm then
            local Buildings = GetPlayerEntities(PlayerID, Entities.B_CattlePasture);
            for i=1, #Buildings, 1 do
                GUI.SetStoppedState(Buildings[i], Bool);
            end
        elseif EntityType == Entities.B_SheepFarm then
            local Buildings = GetPlayerEntities(PlayerID, Entities.B_SheepPasture);
            for i=1, #Buildings, 1 do
                GUI.SetStoppedState(Buildings[i], Bool);
            end
        end
    end
end

function ModuleLifestockBreeding.Local:InitBuyCattleButton()
    local Position = {XGUIEng.GetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/BuyCatapultCart")};
    API.AddBuildingButtonByTypeAtPosition(
        Entities.B_CattlePasture,
        Position[1], Position[2],
        function(_WidgetID, _EntityID)
            ModuleLifestockBreeding.Local:ToggleBreedingState(_EntityID);
        end,
        function(_WidgetID, _EntityID)
            local Description = API.Localize(ModuleLifestockBreeding.Shared.Text.BreedingActive);
            if Logic.IsBuildingStopped(_EntityID) then
                Description = API.Localize(ModuleLifestockBreeding.Shared.Text.BreedingInactive);
            end
            API.SetTooltipCosts(Description.Title, Description.Text, Description.Disabled, {Goods.G_Grain, 1}, false);
        end,
        function(_WidgetID, _EntityID)
            local Icon = {4, 13};
            if Logic.IsBuildingStopped(_EntityID) then
                Icon = {4, 12};
            end
            SetIcon(_WidgetID, Icon);
            local DisableState = (ModuleLifestockBreeding.Local.Cattle.Breeding and 0) or 1;
            XGUIEng.DisableButton(_WidgetID, DisableState);
        end
    );
end

function ModuleLifestockBreeding.Local:InitBuySheepButton()
    local Position = {XGUIEng.GetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/BuyCatapultCart")};
    API.AddBuildingButtonByTypeAtPosition(
        Entities.B_SheepPasture,
        Position[1], Position[2],
        function(_WidgetID, _EntityID)
            ModuleLifestockBreeding.Local:ToggleBreedingState(_EntityID);
        end,
        function(_WidgetID, _EntityID)
            local Description = API.Localize(ModuleLifestockBreeding.Shared.Text.BreedingActive);
            if Logic.IsBuildingStopped(_EntityID) then
                Description = API.Localize(ModuleLifestockBreeding.Shared.Text.BreedingInactive);
            end
            API.SetTooltipCosts(Description.Title, Description.Text, Description.Disabled, {Goods.G_Grain, 1}, false);
        end,
        function(_WidgetID, _EntityID)
            local Icon = {4, 13};
            if Logic.IsBuildingStopped(_EntityID) then
                Icon = {4, 12};
            end
            SetIcon(_WidgetID, Icon);
            local DisableState = (ModuleLifestockBreeding.Local.Sheep.Breeding and 0) or 1;
            XGUIEng.DisableButton(_WidgetID, DisableState);
        end
    );
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleLifestockBreeding);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Schafe und Kühe können vom Spieler gezüchtet werden.
-- 
-- Verschiedene Kenngrößen können angepasst werden.
--
-- Es wird ein Button an Kuh- und Schafställe angebracht. Damit kann die
-- Zucht individuell angehalten oder fortgesetzt werden. Dieser Button
-- belegt einen der 6 möglichen zusätzlichen Buttons bei den Ställen.
--
-- Wird im Produktionsmenü die Produktion von Kuh- oder Schaffarmen gestoppt,
-- werden jeweils alle Kuh- oder Schafställe ebenfalls gestoppt. Wird die
-- Produktion fortgeführt, wird auch die Zucht fortgeführt.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Ankeigekontrolle</a></li>
-- <li><a href="modules.QSB_2_BuildingUI.QSB_2_BuildingUI.html">(2) Gebäudeschalter</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field AnimalBreed Ein Nutztier wurde erzeugt. (Parameter: PlayerID, EntityID)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Erlaube oder verbiete dem Spieler Kühe zu züchten.
--
-- Die Zucht wird immer synchron für alle Spieler erlaubt oder verboten.
--
-- @param[type=boolean] _Flag Kuhzucht aktiv/inaktiv
-- @within Anwenderfunktionen
--
-- @usage
-- -- Es können keine Kühe gezüchtet werden
-- API.UseBreedCattle(false);
--
function API.ActivateCattleBreeding(_Flag)
    if GUI then
        return;
    end

    ModuleLifestockBreeding.Global.Sheep.Breeding = _Flag == true;
    Logic.ExecuteInLuaLocalState("ModuleLifestockBreeding.Local.Sheep.Breeding = " ..tostring(_Flag == true));
    if _Flag ~= true then
        local Price = MerchantSystem.BasePricesOrigModuleLifestockBreeding[Goods.G_Sheep];
        MerchantSystem.BasePrices[Goods.G_Sheep] = Price;
        Logic.ExecuteInLuaLocalState("MerchantSystem.BasePrices[Goods.G_Sheep] = " ..Price);
    else
        local Price = ModuleLifestockBreeding.Global.Sheep.MoneyCost;
        MerchantSystem.BasePrices[Goods.G_Sheep] = Price;
        Logic.ExecuteInLuaLocalState("MerchantSystem.BasePrices[Goods.G_Sheep] = " ..Price);
    end
end

---
-- Erlaube oder verbiete dem Spieler Schafe zu züchten.
--
-- Die Zucht wird immer synchron für alle Spieler erlaubt oder verboten.
--
-- @param[type=boolean] _Flag Schafzucht aktiv/inaktiv
-- @within Anwenderfunktionen
--
-- @usage
-- -- Schafsaufzucht ist erlaubt
-- API.UseBreedSheeps(true);
--
function API.ActivateSheepBreeding(_Flag)
    if GUI then
        return;
    end

    ModuleLifestockBreeding.Global.Cattle.Breeding = _Flag == true;
    Logic.ExecuteInLuaLocalState("ModuleLifestockBreeding.Local.Cattle.Breeding = " ..tostring(_Flag == true));
    if _Flag ~= true then
        local Price = MerchantSystem.BasePricesOrigModuleLifestockBreeding[Goods.G_Cow];
        MerchantSystem.BasePrices[Goods.G_Cow] = Price;
        Logic.ExecuteInLuaLocalState("MerchantSystem.BasePrices[Goods.G_Cow] = " ..Price);
    else
        local Price = ModuleLifestockBreeding.Global.Cattle.MoneyCost;
        MerchantSystem.BasePrices[Goods.G_Cow] = Price;
        Logic.ExecuteInLuaLocalState("MerchantSystem.BasePrices[Goods.G_Cow] = " ..Price);
    end
end

---
-- Konfiguriert die Zucht von Kühen.
--
-- Die Konfiguration erfolgt immer synchron für alle Spieler.
--
-- Mögliche Optionen:
-- <table border="1">
-- <tr>
-- <td><b>Option</b></td>
-- <td><b>Datentyp</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>RequiredAmount</td>
-- <td>number</td>
-- <td>Mindestanzahl an Tieren, die sich im Gebiet befinden müssen.
-- (Default: 2)</td>
-- </tr>
-- <tr>
-- <td>QuantityBoost</td>
-- <td>number</td>
-- <td>Menge an Sekunden, die jedes Tier im Gebiet die Zuchtauer verkürzt.
-- (Default: 9)</td>
-- </tr>
-- <tr>
-- <td>AreaSize</td>
-- <td>number</td>
-- <td>Größe des Gebietes, in dem Tiere für die Zucht vorhanden sein müssen.
-- (Default: 4500)</td>
-- </tr>
-- <tr>
-- <td>UseCalves</td>
-- <td>boolean</td>
-- <td>Gezüchtete Tiere erscheinen zuerst als Kälber und wachsen. Dies ist rein
-- kosmetisch und hat keinen Einfluss auf die Produktion. (Default: true)</td>
-- </tr>
-- <tr>
-- <td>CalvesSize</td>
-- <td>number</td>
-- <td>Bestimmt die initiale Größe der Kälber. Werden Kälber nicht benutzt, wird
-- diese Option ignoriert. (Default: 0.45)</td>
-- </tr>
-- <tr>
-- <td>FeedingTimer</td>
-- <td>number</td>
-- <td>Bestimmt die Zeit in Sekunden zwischen den Fütterungsperioden. Am Ende
-- jeder Periode wird pro züchtendem Gatter 1 Getreide abgezogen, wenn das
-- Gebäude nicht pausiert ist. (Default: 25)</td>
-- </tr>
-- <tr>
-- <td>BreedingTimer</td>
-- <td>number</td>
-- <td>Bestimmt die Zeit in Sekunden, bis ein neues Tier erscheint. Wenn für
-- eine Fütterung kein Getreide da ist, wird der Zähler zur letzten Fütterung
-- zurückgesetzt. (Default: 150)</td>
-- </tr>
-- <tr>
-- <td>GrothTimer</td>
-- <td>number</td>
-- <td>Bestimmt die Zeit in Sekunden zwischen den Wachstumsschüben eines
-- Kalbs. Jeder Wachstumsschub ist +0.05 Gößenänderung. (Default: 15)</td>
-- </tr>
-- </table>
-- 
-- @param[type=table] _Data Konfiguration der Zucht
-- @within Anwenderfunktionen
--
-- @usage
-- API.ConfigureCattleBreeding{
--     -- Es werden keine Tiere benötigt
--     RequiredAmount = 0,
--     -- Mindestzeit sind 3 Minuten
--     BreedingTimer = 3*60
-- }
--
function API.ConfigureCattleBreeding(_Data)
    if _Data.CalvesSize ~= nil then
        ModuleLifestockBreeding.Global.Cattle.CalvesSize = _Data.CalvesSize;
    end
    if _Data.RequiredAmount ~= nil then
        ModuleLifestockBreeding.Global.Cattle.RequiredAmount = _Data.RequiredAmount;
    end
    if _Data.QuantityBoost ~= nil then
        ModuleLifestockBreeding.Global.Cattle.QuantityBoost = _Data.QuantityBoost;
    end
    if _Data.AreaSize ~= nil then
        ModuleLifestockBreeding.Global.Cattle.AreaSize = _Data.AreaSize;
    end
    if _Data.UseCalves ~= nil then
        ModuleLifestockBreeding.Global.Cattle.UseCalves = _Data.UseCalves;
    end
    if _Data.FeedingTimer ~= nil then
        ModuleLifestockBreeding.Global.Cattle.FeedingTimer = _Data.FeedingTimer;
    end
    if _Data.BreedingTimer ~= nil then
        ModuleLifestockBreeding.Global.Cattle.BreedingTimer = _Data.BreedingTimer;
    end
    if _Data.GrothTimer ~= nil then
        ModuleLifestockBreeding.Global.Cattle.GrothTimer = _Data.GrothTimer;
    end
end

---
-- Konfiguriert die Zucht von Schafen.
--
-- Die Konfiguration erfolgt immer synchron für alle Spieler.
--
-- Mögliche Optionen:
-- <table border="1">
-- <tr>
-- <td><b>Option</b></td>
-- <td><b>Datentyp</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>RequiredAmount</td>
-- <td>number</td>
-- <td>Mindestanzahl an Tieren, die sich im Gebiet befinden müssen.
-- (Default: 2)</td>
-- </tr>
-- <tr>
-- <td>QuantityBoost</td>
-- <td>number</td>
-- <td>Menge an Sekunden, die jedes Tier im Gebiet die Zuchtauer verkürzt.
-- (Default: 9)</td>
-- </tr>
-- <tr>
-- <td>AreaSize</td>
-- <td>number</td>
-- <td>Größe des Gebietes, in dem Tiere für die Zucht vorhanden sein müssen.
-- (Default: 4500)</td>
-- </tr>
-- <tr>
-- <td>UseCalves</td>
-- <td>boolean</td>
-- <td>Gezüchtete Tiere erscheinen zuerst als Kälber und wachsen. Dies ist rein
-- kosmetisch und hat keinen Einfluss auf die Produktion. (Default: true)</td>
-- </tr>
-- <tr>
-- <td>CalvesSize</td>
-- <td>number</td>
-- <td>Bestimmt die initiale Größe der Kälber. Werden Kälber nicht benutzt, wird
-- diese Option ignoriert. (Default: 0.45)</td>
-- </tr>
-- <tr>
-- <td>FeedingTimer</td>
-- <td>number</td>
-- <td>Bestimmt die Zeit in Sekunden zwischen den Fütterungsperioden. Am Ende
-- jeder Periode wird pro züchtendem Gatter 1 Getreide abgezogen, wenn das
-- Gebäude nicht pausiert ist. (Default: 30)</td>
-- </tr>
-- <tr>
-- <td>BreedingTimer</td>
-- <td>number</td>
-- <td>Bestimmt die Zeit in Sekunden, bis ein neues Tier erscheint. Wenn für
-- eine Fütterung kein Getreide da ist, wird der Zähler zur letzten Fütterung
-- zurückgesetzt. (Default: 120)</td>
-- </tr>
-- <tr>
-- <td>GrothTimer</td>
-- <td>number</td>
-- <td>Bestimmt die Zeit in Sekunden zwischen den Wachstumsschüben eines
-- Kalbs. Jeder Wachstumsschub ist +0.05 Gößenänderung. (Default: 15)</td>
-- </tr>
-- </table>
-- 
-- @param[type=table] _Data Konfiguration der Zucht
-- @within Anwenderfunktionen
--
-- @usage
-- API.ConfigureSheepBreeding{
--     -- Es werden keine Tiere benötigt
--     RequiredAmount = 0,
--     -- Mindestzeit sind 3 Minuten
--     BreedingTimer = 3*60
-- }
--
function API.ConfigureSheepBreeding(_Data)
    if _Data.CalvesSize ~= nil then
        ModuleLifestockBreeding.Global.Sheep.CalvesSize = _Data.CalvesSize;
    end
    if _Data.RequiredAmount ~= nil then
        ModuleLifestockBreeding.Global.Sheep.RequiredAmount = _Data.RequiredAmount;
    end
    if _Data.QuantityBoost ~= nil then
        ModuleLifestockBreeding.Global.Sheep.QuantityBoost = _Data.QuantityBoost;
    end
    if _Data.AreaSize ~= nil then
        ModuleLifestockBreeding.Global.Sheep.AreaSize = _Data.AreaSize;
    end
    if _Data.UseCalves ~= nil then
        ModuleLifestockBreeding.Global.Sheep.UseCalves = _Data.UseCalves;
    end
    if _Data.FeedingTimer ~= nil then
        ModuleLifestockBreeding.Global.Sheep.FeedingTimer = _Data.FeedingTimer;
    end
    if _Data.BreedingTimer ~= nil then
        ModuleLifestockBreeding.Global.Cattle.BreedingTimer = _Data.BreedingTimer;
    end
    if _Data.GrothTimer ~= nil then
        ModuleLifestockBreeding.Global.Sheep.GrothTimer = _Data.GrothTimer;
    end
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleShipSalesment = {
    Properties = {
        Name = "ModuleShipSalesment",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        Harbors = {},
    },
    Local = {},
    Shared = {},
};

QSB.ShipTraderState = {
    Waiting = 1,
    MovingIn = 2,
    Anchored = 3,
    MovingOut = 4,
}

-- Global ------------------------------------------------------------------- --

function ModuleShipSalesment.Global:OnGameStart()
    QSB.ScriptEvents.TradeShipSpawned = API.RegisterScriptEvent("Event_TradeShipSpawned");
    QSB.ScriptEvents.TradeShipArrived = API.RegisterScriptEvent("Event_TradeShipArrived");
    QSB.ScriptEvents.TradeShipLeft = API.RegisterScriptEvent("Event_TradeShipLeft");
    QSB.ScriptEvents.TradeShipDespawned = API.RegisterScriptEvent("Event_TradeShipDespawned");

    API.StartJob(function()
        ModuleShipSalesment.Global:ControlHarbors();
    end);
end

function ModuleShipSalesment.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

function ModuleShipSalesment.Global:CreateHarbor(_PlayerID)
    if self.Harbors[_PlayerID] then
        self:DisposeHarbor(_PlayerID);
    end
    self.Harbors[_PlayerID] = {
        AddedOffers  = {},
        Routes = {}
    };
end

function ModuleShipSalesment.Global:DisposeHarbor(_PlayerID)
    local StoreHouseID = Logic.GetStoreHouse(_PlayerID)
    for k, v in pairs(self.Harbors[_PlayerID].Routes) do
        self:PurgeTradeRoute(_PlayerID, v.Name);
    end
    if IsExisting(StoreHouseID) then
        Logic.RemoveAllOffers(StoreHouseID);
    end
end

function ModuleShipSalesment.Global:AddTradeRoute(_PlayerID, _Data)
    if not self.Harbors[_PlayerID] then
        return;
    end
    for i= #self.Harbors[_PlayerID].Routes, 1, -1 do
        if self.Harbors[_PlayerID].Routes[i].Name == _Data.Name then
            return;
        end
    end
    _Data.Interval = _Data.Interval or 300;
    _Data.Duration = _Data.Duration or 120;
    _Data.Timer = _Data.Interval -1;
    _Data.State = QSB.ShipTraderState.Waiting;
    table.insert(self.Harbors[_PlayerID].Routes, _Data);
end

function ModuleShipSalesment.Global:AlterTradeRouteOffers(_PlayerID, _Name, _Offers)
    if not self.Harbors[_PlayerID] then
        return;
    end
    for i= #self.Harbors[_PlayerID].Routes, 1, -1 do
        if self.Harbors[_PlayerID].Routes[i].Name == _Name then
            self.Harbors[_PlayerID].Routes[i].Offers = _Offers;
            return;
        end
    end
end

function ModuleShipSalesment.Global:PurgeAllTradeRoutes(_PlayerID)
    if not self.Harbors[_PlayerID] then
        return;
    end
    for i= #self.Harbors[_PlayerID].Routes, 1, -1 do
        local Data = table.remove(self.Harbors[_PlayerID].Routes, i);
        if IsExisting(Data.ShipID) then
            DestroyEntity(Data.ShipID);
        end
        if JobIsRunning(Data.ShipID) then
            EndJob(Data.ShipJob);
        end
    end
end

function ModuleShipSalesment.Global:PurgeTradeRoute(_PlayerID, _Name)
    if not self.Harbors[_PlayerID] then
        return;
    end
    for i= #self.Harbors[_PlayerID].Routes, 1, -1 do
        if self.Harbors[_PlayerID].Routes[i].Name == _Name then
            local Data = table.remove(self.Harbors[_PlayerID].Routes, i);
            if IsExisting(Data.ShipID) then
                DestroyEntity(Data.ShipID);
            end
            if JobIsRunning(Data.ShipID) then
                EndJob(Data.ShipJob);
            end
            break;
        end
    end
end

function ModuleShipSalesment.Global:ShutdownTradeRoute(_PlayerID, _Name)
    if not self.Harbors[_PlayerID] then
        return;
    end
    for i= #self.Harbors[_PlayerID].Routes, 1, -1 do
        if self.Harbors[_PlayerID].Routes[i].Name == _Name then
            return API.StartJob(function (_PlayerID, _Index)
                if self.Harbors[_PlayerID].Routes[_Index].State == QSB.ShipTraderState.Waiting then
                    local Name = self.Harbors[_PlayerID].Routes[_Index].Name;
                    ModuleShipSalesment.Global:PurgeTradeRoute(_PlayerID, Name);
                    return true;
                end
            end, _PlayerID, i);
        end
    end
    return 0;
end

function ModuleShipSalesment.Global:SpawnShip(_PlayerID, _Index)
    local Route = self.Harbors[_PlayerID].Routes[_Index];
    local SpawnPointID = GetID(Route.Path[1]);
    local x, y, z = Logic.EntityGetPos(SpawnPointID);
    local Orientation = Logic.GetEntityOrientation(SpawnPointID);
    local ID = Logic.CreateEntity(Entities.D_X_TradeShip, x, y, Orientation, 0);
    self.Harbors[_PlayerID].Routes[_Index].ShipID = ID;
    self:SendShipSpawnedEvent(_PlayerID, Route, ID);
    Logic.SetSpeedFactor(ID, 3.0);
    return ID;
end

function ModuleShipSalesment.Global:DespawnShip(_PlayerID, _Index)
    local ID = self.Harbors[_PlayerID].Routes[_Index].ShipID;
    local Route = self.Harbors[_PlayerID].Routes[_Index];
    self:SendShipDespawnedEvent(_PlayerID, Route, ID);
    DestroyEntity(ID);
end

function ModuleShipSalesment.Global:MoveShipIn(_PlayerID, _Index)
    local Route = self.Harbors[_PlayerID].Routes[_Index];
    local ID = self.Harbors[_PlayerID].Routes[_Index].ShipID;
    local Waypoints = {};
    for i= 1, #Route.Path do
        table.insert(Waypoints, GetID(Route.Path[i]));
    end
    local Instance = Path:new(ID, Waypoints, nil, nil, nil, nil, true, nil, nil, 300);
    self.Harbors[_PlayerID].Routes[_Index].ShipJob = Instance.Job;
    return ID;
end

function ModuleShipSalesment.Global:MoveShipOut(_PlayerID, _Index)
    local Route = self.Harbors[_PlayerID].Routes[_Index];
    local ID = self.Harbors[_PlayerID].Routes[_Index].ShipID;
    local Waypoints = {};
    for i= 1, #Route.Path do
        table.insert(Waypoints, GetID(Route.Path[i]));
    end
    local Instance = Path:new(ID, table.invert(Waypoints), nil, nil, nil, nil, true, nil, nil, 300);
    self.Harbors[_PlayerID].Routes[_Index].ShipJob = Instance.Job;
    return ID;
end

function ModuleShipSalesment.Global:SendShipSpawnedEvent(_PlayerID, _Route, _ShipID)
    API.SendScriptEvent(QSB.ScriptEvents.TradeShipSpawned, _PlayerID, _Route.Name, _ShipID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.TradeShipSpawned, %d, "%s", %d)]],
        _PlayerID,
        _Route.Name,
        _ShipID
    ));
end

function ModuleShipSalesment.Global:SendShipDespawnedEvent(_PlayerID, _Route, _ShipID)
    API.SendScriptEvent(QSB.ScriptEvents.TradeShipDespawned, _PlayerID, _Route.Name, _ShipID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.TradeShipDespawned, %d, "%s", %d)]],
        _PlayerID,
        _Route.Name,
        _ShipID
    ));
end

function ModuleShipSalesment.Global:SendShipArrivedEvent(_PlayerID, _Route, _ShipID)
    API.SendScriptEvent(QSB.ScriptEvents.TradeShipArrived, _PlayerID, _Route.Name, _ShipID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.TradeShipArrived, %d, "%s", %d)]],
        _PlayerID,
        _Route.Name,
        _ShipID
    ));
end

function ModuleShipSalesment.Global:SendShipLeftEvent(_PlayerID, _Route, _ShipID)
    API.SendScriptEvent(QSB.ScriptEvents.TradeShipLeft, _PlayerID, _Route.Name, _ShipID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[API.SendScriptEvent(QSB.ScriptEvents.TradeShipLeft, %d, "%s", %d)]],
        _PlayerID,
        _Route.Name,
        _ShipID
    ));
end

function ModuleShipSalesment.Global:AddTradeOffers(_PlayerID, _Index)
    local Harbor = self.Harbors[_PlayerID];
    local Route = Harbor.Routes[_Index];

    -- select offers
    local Offers = {};
    if Route.Amount == #Route.Offers then
        Offers = table.copy(Route.Offers);
    else
        local Indices = {};
        while (#Indices < Route.Amount) do
            local Index = math.random(1, #Route.Offers);
            if not table.contains(Indices, Index) then
                table.insert(Indices, Index);
            end
        end
        for i= 1, #Indices do
            table.insert(Offers, table.copy(Route.Offers[Indices[i]]));
        end
    end

    -- add selected offers
    local StoreData;
    for i= 1, #Offers do
        -- set offer type
        local IsGoodType = true;
        local IsMilitary = false;
        local OfferType = Goods[Offers[i][1]];
        if not OfferType then
            IsGoodType = false;
            OfferType = Entities[Offers[i][1]];
            if Logic.IsEntityTypeInCategory(Entities[Offers[i][1]], EntityCategories.Military) == 1 then
                IsMilitary = true;
            end
        end
        -- remove oldest offer if needed
        StoreData = ModuleTrade.Global:GetStorehouseInformation(_PlayerID);
        if StoreData.OfferCount >= 4 then
            local LastOffer = table.remove(self.Harbors[_PlayerID].AddedOffers, 1);
            API.RemoveTradeOffer(_PlayerID, LastOffer);
            StoreData = ModuleTrade.Global:GetStorehouseInformation(_PlayerID);
        end
        -- add new offer
        API.RemoveTradeOffer(_PlayerID, OfferType);
        if IsGoodType then
            AddOffer(StoreData.Storehouse, Offers[i][2], OfferType, 9999);
        else
            if not IsMilitary then
                AddEntertainerOffer(StoreData.Storehouse, OfferType);
            else
                AddMercenaryOffer(StoreData.Storehouse, Offers[i][2], OfferType, 9999);
            end
        end
        table.insert(self.Harbors[_PlayerID].AddedOffers, OfferType);
        StoreData = ModuleTrade.Global:GetStorehouseInformation(_PlayerID);
    end

    -- update visuals
    Logic.ExecuteInLuaLocalState(string.format(
        [[GameCallback_CloseNPCInteraction(GUI.GetPlayerID(), %d)]],
        StoreData.Storehouse
    ));
end

function ModuleShipSalesment.Global:ControlHarbors()
    for k,v in pairs(self.Harbors) do
        if Logic.GetStoreHouse(k) == 0 then
            self:DisposeHarbor(k);
        else
            if #v.Routes > 0 then
                -- remove sold out offers
                local StoreData = ModuleTrade.Global:GetStorehouseInformation(k);
                for i= 1, #StoreData[1] do
                    if StoreData[1][i][5] == 0 then
                        ModuleTrade.Global:RemoveTradeOfferByData(StoreData, i);
                        for j= #v.AddedOffers, 1, -1 do
                            if v.AddedOffers[j] == StoreData[1][i][3] then
                                table.remove(self.Harbors[k].AddedOffers, j);
                            end
                        end
                    end
                end

                -- control trade routes
                for i= 1, #v.Routes do
                    if v.Routes[i].State == QSB.ShipTraderState.Waiting then
                        self.Harbors[k].Routes[i].Timer = v.Routes[i].Timer +1;
                        if v.Routes[i].Timer >= v.Routes[i].Interval then
                            self.Harbors[k].Routes[i].State = QSB.ShipTraderState.MovingIn;
                            self.Harbors[k].Routes[i].Timer = 0;
                            self:SpawnShip(k, i);
                            self:MoveShipIn(k, i);
                        end

                    elseif v.Routes[i].State == QSB.ShipTraderState.MovingIn then
                        local AnchorPoint = v.Routes[i].Path[#v.Routes[i].Path];
                        local ShipID = v.Routes[i].ShipID;
                        if IsNear(ShipID, AnchorPoint, 300) then
                            self.Harbors[k].Routes[i].State = QSB.ShipTraderState.Anchored;
                            self:SendShipArrivedEvent(k, v.Routes[i], ShipID);
                            self:AddTradeOffers(k, i);
                        end

                    elseif v.Routes[i].State == QSB.ShipTraderState.Anchored then
                        local ShipID = v.Routes[i].ShipID;
                        self.Harbors[k].Routes[i].Timer = v.Routes[i].Timer +1;
                        if v.Routes[i].Timer >= v.Routes[i].Duration then
                            self.Harbors[k].Routes[i].State = QSB.ShipTraderState.MovingOut;
                            self.Harbors[k].Routes[i].Timer = 0;
                            self:SendShipLeftEvent(k, v.Routes[i], ShipID);
                            self:MoveShipOut(k, i);
                        end

                    elseif v.Routes[i].State == QSB.ShipTraderState.MovingOut then
                        local SpawnPoint = v.Routes[i].Path[1];
                        local ShipID = v.Routes[i].ShipID;
                        if IsNear(ShipID, SpawnPoint, 300) then
                            self.Harbors[k].Routes[i].State = QSB.ShipTraderState.Waiting;
                            self:DespawnShip(k, i);
                        end
                    end
                end
            end
        end
    end
end

-- Local -------------------------------------------------------------------- --

function ModuleShipSalesment.Local:OnGameStart()
    QSB.ScriptEvents.TradeShipSpawned = API.RegisterScriptEvent("Event_TradeShipSpawned");
    QSB.ScriptEvents.TradeShipArrived = API.RegisterScriptEvent("Event_TradeShipArrived");
    QSB.ScriptEvents.TradeShipLeft = API.RegisterScriptEvent("Event_TradeShipLeft");
    QSB.ScriptEvents.TradeShipDespawned = API.RegisterScriptEvent("Event_TradeShipDespawned");
end

function ModuleShipSalesment.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleShipSalesment);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Ermöglicht einen KI-Spieler als Hafen einzurichten.
--
-- <h5>Was ein Hafen macht</h5>
-- Häfen werden zyklisch von Schiffen über Handelsrouten angesteuert. Ein Hafen
-- kann prinzipiell ungebegrenzt viele Handelsrouten haben. Wenn ein Schiff im
-- Hafen anlegt, werden die Waren den Angeboten hinzugefügt. Ist kein Platz
-- mehr für ein weiteres Angebot, wird das jeweils älteste entfernt.
--
-- Die Angebote in einem Hafen werden nicht erneuert. Wenn alle Einheiten eines
-- Angebotes gekauft wurden, wird das Angebot automatisch entfernt.
--
-- Handelsschiffe einer Handelsroute haben einen Geschwindigkeitsbonus erhalten,
-- damit man bei langen Wegen nicht ewig auf die Ankunft warten muss.
--
-- Sollte ein KI-Spieler, welcher als Hafen eingerichtet ist, vernichtet werden,
-- werden automatisch alle aktiven Routen gelöscht. Schiffe, welche sich auf
-- dem Weg vom oder zum Hafen befinden, verschwinden ebenfalls.
--
-- <h5>Was ein Hafen NICHT macht</h5>
-- Die Einrichtung eines KI-Spielers als Hafen bringt keine automatischen
-- Änderungen des Diplomatiestatus mit sich. Des weiteren wird keine Nachricht
-- versendet, wenn ein Schiff im Hafen anlegt oder diesen wieder verlässt. Bei
-- vielen Handelsrouten würde sonst der Spieler in Nachrichten ersticken.
-- 
-- <p><b>Vorausgesetzte Module:</b></p>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_Trade.QSB_1_Trade.html">(1) Handelserweiterung</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field TradeShipSpawned   Ein Schiff wurde erzeugt (Parameter: _PlayerID, _RouteName, _ShipID)
-- @field TradeShipArrived   Ein Schiff hat den Hafen erreicht (Parameter: _PlayerID, _RouteName, _ShipID)
-- @field TradeShipLeft      Ein Schiff hat den Hafen verlassen (Parameter: _PlayerID, _RouteName, _ShipID)
-- @field TradeShipDespawned Ein Schiff wurde gelöscht (Parameter: _PlayerID, _RouteName, _ShipID)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Fügt einen Schiffshändler im Lagerhaus des Spielers hinzu.
--
-- Optional kann eine Liste von Handelsrouten übergeben werden.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=table] ...        Liste an Handelsrouten
-- @see API.AddTradeRoute
-- @within Anwenderfunktionen
--
-- @usage
-- API.InitHarbor(2);
--
function API.InitHarbor(_PlayerID, ...)
    if Logic.GetStoreHouse(_PlayerID) == 0 then
        error("API.InitHarbor: player " .._PlayerID.. " is dead! :(");
        return;
    end
    ModuleShipSalesment.Global:CreateHarbor(_PlayerID);
    for i= 1, #arg do
        API.AddTradeRoute(_PlayerID, arg[i]);
    end
end

---
-- Entfernt den Schiffshändler vom Lagerhaus des Spielers.
--
-- <b>Hinweis</b>: Die Routen werden sofort gelöscht. Schiffe, die sich mitten
-- in ihrem Zyklus befinden, werden ebenfalls gelöscht und alle aktiven Angebote
-- im Lagerhaus des KI-Spielers werden sofort entfernt. Nutze dies, wenn z.B.
-- der KI-Spieler feindlich wird.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @within Anwenderfunktionen
--
-- @usage
-- API.DisposeHarbor(2);
--
function API.DisposeHarbor(_PlayerID)
    if Logic.GetStoreHouse(_PlayerID) == 0 then
        error("API.AddTradeRoute: player " .._PlayerID.. " is dead! :(");
        return;
    end
    ModuleShipSalesment.Global:DisposeHarbor(_PlayerID);
end

---
-- Fügt eine Handelsroute zu einem Hafen hinzu.
--
-- Für jede Handelsroute eines Hafens erscheint ein Handelsschiff, das den Hafen
-- zyklisch mit neuen Waren versorgt.
--
-- Eine Handelsroute hat folgende Felder:
-- <table border="1">
-- <tr>
-- <td><b>Feld</b></td>
-- <td><b>Typ</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>Name</td>
-- <td>string</td>
-- <td>Name der Handelsroute (Muss für die Partei eindeutig sein)</td>
-- </tr>
-- <tr>
-- <td>Path</td>
-- <td>table</td>
-- <td>Liste der Wegpunkte des Handelsschiffs (mindestens 2)</td>
-- </tr>
-- <tr>
-- <td>Offers</td>
-- <td>table</td>
-- <td>Liste mit Angeboten (Format: {_Angebot, _Menge})</td>
-- </tr>
-- <tr>
-- <td>Amount</td>
-- <td>number</td>
-- <td>(Optional) Menge an ausgewählten Angeboten.</td>
-- </tr>
-- <tr>
-- <td>Duration</td>
-- <td>number</td>
-- <td>(Option) Verweildauer im Hafen in Sekunden</td>
-- </tr>
-- <tr>
-- <td>Interval</td>
-- <td>number</td>
-- <td>(Optional) Zeit bis zur Widerkehr in Sekunden</td>
-- </tr>
-- <tr>
-- <td></td>
-- <td></td>
-- <td></td>
-- </tr>
-- </table>
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=table]  _Route    Daten der Handelsroute
-- @see API.InitHarbor
-- @see API.ChangeTradeRouteGoods
-- @see API.RemoveTradeRoute
-- @within Anwenderfunktionen
--
-- @usage
-- API.AddTradeRoute(
--     2,
--     {
--         Name       = "Route3",
--         -- Wegpunkte - Der letzte sollte beim Hafen sein ;)
--         Path       = {"Spawn3", "Arrived3"},
--         -- Schiff kommt alle 10 Minuten
--         Interval   = 10*60,
--         -- Schiff bleibt 2 Minunten im Hafen
--         Duration   = 2*60,
--         -- Menge pro Anfahrt
--         Amount     = 2,
--         -- Liste an Angeboten
--         Offers     = {
--             {"G_Wool", 5},
--             {"U_CatapultCart", 1},
--             {"G_Beer", 2},
--             {"G_Herb", 5},
--             {"U_Entertainer_NA_StiltWalker", 1},
--         }
--     }
-- );
--
function API.AddTradeRoute(_PlayerID, _Route)
    if Logic.GetStoreHouse(_PlayerID) == 0 then
        error("API.AddTradeRoute: player " .._PlayerID.. " is dead! :(");
        return;
    end
    if type(_Route) ~= "table" then
        error("API.AddTradeRoute: _Route must be a table!");
        return;
    end
    if not _Route.Name then
        error("API.AddTradeRoute: trade route needs a name!");
        return;
    end
    if not _Route.Path or #_Route.Path < 2 then
        error("API.AddTradeRoute: path of route " .._Route.Name.. " is invalid!");
        return;
    end
    if not _Route.Offers or #_Route.Offers < 1 then
        error("API.AddTradeRoute: route " .._Route.Name.. " has to few offers!");
        return;
    end
    _Route.Amount = _Route.Amount or ((#_Route.Offers > 4 and 4) or #_Route.Offers);
    if _Route.Amount < 1 or _Route.Amount > 4 then
        error("API.AddTradeRoute: offer amount of route " .._Route.Name.. " is invalid!");
        return;
    end
    if _Route.Amount > #_Route.Offers then
        error("API.AddTradeRoute: route " .._Route.Name.. " has not enough offers!");
        return;
    end
    for i= 1, #_Route.Offers, 1 do
        if Goods[_Route.Offers[i][1]] == nil and Entities[_Route.Offers[i][1]] == nil then
            error("API.AddTradeRoute: Offers[" ..i.. "][1] is invalid good type!");
            return;
        end
        if type(_Route.Offers[i][2]) ~= "number" or _Route.Offers[i][2] < 1 then
            error("API.AddTradeRoute: Offers[" ..i.. "][2] amount must be at least 1!");
            return;
        end
    end
    ModuleShipSalesment.Global:AddTradeRoute(_PlayerID, _Route);
end

---
-- Andert das Warenangebot einer Handelsroute.
--
-- Es können nur bestehende Handelsrouten geändert werden. Die Änderung wird
-- erst im nächsten Zyklus wirksam.
--
-- @param[type=number] _PlayerID    ID des Spielers
-- @param[type=string] _RouteName   Daten der Handelsroute
-- @param[type=table]  _RouteOffers Daten der Handelsroute
-- @see API.InitHarbor
-- @see API.RemoveTradeRoute
-- @see API.AddTradeRoute
-- @within Anwenderfunktionen
--
-- @usage
-- API.ChangeTradeRouteGoods(
--     2,
--     "Route3",
--     {{"G_Wool", 3},
--      {"U_CatapultCart", 5},
--      {"G_Beer", 2},
--      {"G_Herb", 3},
--      {"U_Entertainer_NA_StiltWalker", 1}}
-- );
--
function API.ChangeTradeRouteGoods(_PlayerID, _RouteName, _RouteOffers)
    if Logic.GetStoreHouse(_PlayerID) == 0 then
        error("API.ChangeTradeRouteGoods: player " .._PlayerID.. " is dead! :(");
        return;
    end
    if type(_RouteOffers) ~= "table" and #_RouteOffers < 1 then
        error("API.ChangeTradeRouteGoods: _RouteOffers must be a table with entries!");
        return;
    end
    for i= 1, #_RouteOffers, 1 do
        if Goods[_RouteOffers[i][1]] == nil and Entities[_RouteOffers[i][1]] == nil then
            error("API.ChangeTradeRouteGoods: Offers[" ..i.. "][1] is invalid good type!");
            return;
        end
        if type(_RouteOffers[i][2]) ~= "number" or _RouteOffers[i][2] < 1 then
            error("API.ChangeTradeRouteGoods: Offers[" ..i.. "][2] amount must be at least 1!");
            return;
        end
    end
    ModuleShipSalesment.Global:AlterTradeRouteOffers(_PlayerID, _RouteName, _RouteOffers);
end

---
-- Löscht eine Handelsroute, wenn ihr Zyklus beendet ist.
--
-- Der Befehl erzeugt einen Job, welcher auf das Ende des Zyklus wartet und
-- erst dann die Route löscht. Über die ID kann der Job abgebrochen werden.
--
-- @param[type=number] _PlayerID  ID des Spielers
-- @param[type=string] _RouteName Name der Route
-- @return[type=number] Job ID
-- @see API.InitHarbor
-- @see API.AddTradeRoute
-- @see API.ChangeTradeRouteGoods
-- @within Anwenderfunktionen
--
-- @usage
-- API.RemoveTradeRoute(2, "Route1");
--
function API.RemoveTradeRoute(_PlayerID, _RouteName)
    if Logic.GetStoreHouse(_PlayerID) == 0 then
        error("API.RemoveTradeRoute: player " .._PlayerID.. " is dead! :(");
        return 0;
    end
    return ModuleShipSalesment.Global:ShutdownTradeRoute(_PlayerID, _RouteName);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleInteractiveMines = {
    Properties = {
        Name = "ModuleInteractiveMines",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        Mines = {},
        Lambda = {
            MineCondition = {},
            MineConstructed = {},
            InteractiveMineDepleted = {},
        }
    },
    Local = {},
    -- This is a shared structure but the values are asynchronous!
    Shared = {
        Text = {
            Title = {
                de = "Rohstoffquelle erschließen",
                en = "Construct mine",
                fr = "Exploiter la source de ressources",
            },
            Text = {
                de = "An diesem Ort könnt Ihr eine Rohstoffquelle erschließen!",
                en = "You're able to create a pit at this location!",
                fr = "À cet endroit, vous pouvez exploiter une source de ressources!",
            },
        },
    },
};

-- Global ------------------------------------------------------------------- --

function ModuleInteractiveMines.Global:OnGameStart()
    QSB.ScriptEvents.InteractiveMineDepleted = API.RegisterScriptEvent("Event_InteractiveMineDepleted");

    API.StartHiResJob(function()
        ModuleInteractiveMines.Global:ControlIOMines();
    end);
end

function ModuleInteractiveMines.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.ObjectReset then
        if IO[arg[1]] and IO[arg[1]].IsInteractiveMine then
            self:ResetIOMine(arg[1], IO[arg[1]].Type);
        end
    elseif _ID == QSB.ScriptEvents.ObjectDelete then
        if IO[arg[1]].IsInteractiveMine and IO[arg[1]].Type then
            ReplaceEntity(arg[1], IO[arg[1]].Type);
        end
    end
end

function ModuleInteractiveMines.Global:CreateIOMine(
    _Position, _Type, _Title, _Text, _Costs, _ResourceAmount,
    _RefillAmount, _Condition, _ConditionInfo, _Action
)
    local BlockerID = self:ResetIOMine(_Position, _Type);
    local Icon = {14, 10};
    if g_GameExtraNo >= 1 then
        if _Type == Entities.R_IronMine then
            Icon = {14, 10};
        end
        if _Type == Entities.R_StoneMine then
            Icon = {14, 10};
        end
    end

    API.SetupObject {
        Name                 = _Position,
        IsInteractiveMine    = true,
        Title                = _Title or ModuleInteractiveMines.Shared.Text.Title,
        Text                 = _Text or ModuleInteractiveMines.Shared.Text.Text,
        Texture              = Icon,
        Type                 = _Type,
        ResourceAmount       = _ResourceAmount or 250,
        RefillAmount         = _RefillAmount or 75,
        Costs                = _Costs,
        InvisibleBlocker     = BlockerID,
        Distance             = 1200,
        ConditionInfo        = _ConditionInfo,
        AdditionalCondition  = _Condition,
        AdditionalAction     = _Action,
        Condition            = function(_Data)
            if _Data.AdditionalCondition then
                return _Data:AdditionalCondition(_Data);
            end
            return true;
        end,
        Action               = function(_Data, _KnightID, _PlayerID)
            local ID = ReplaceEntity(_Data.Name, _Data.Type);
            API.SetResourceAmount(ID, _Data.ResourceAmount, _Data.RefillAmount);
            DestroyEntity(_Data.InvisibleBlocker);
            if _Data.AdditionalAction then
                _Data.AdditionalAction(_Data, _KnightID, _PlayerID);
            end
        end
    };
end

function ModuleInteractiveMines.Global:ResetIOMine(_ScriptName, _Type)
    if IO[_ScriptName] then
        DestroyEntity(IO[_ScriptName].InvisibleBlocker);
    end
    local EntityID = ReplaceEntity(_ScriptName, Entities.XD_ScriptEntity);
    local Model = Models.Doodads_D_SE_ResourceIron_Wrecked;
    if _Type == Entities.R_StoneMine then
        Model = Models.R_SE_ResorceStone_10;
    end
    Logic.SetVisible(EntityID, true);
    Logic.SetModel(EntityID, Model);
    local x, y, z = Logic.EntityGetPos(EntityID);
    local BlockerID = Logic.CreateEntity(Entities.D_ME_Rock_Set01_B_07, x, y, 0, 0);
    Logic.SetVisible(BlockerID, false);
    if IO[_ScriptName] then
        IO[_ScriptName].InvisibleBlocker = BlockerID;
    end
    return BlockerID;
end

function ModuleInteractiveMines.Global:ControlIOMines()
    for k, v in pairs(IO) do
        local EntityID = GetID(k);
        if v.IsInteractiveMine and Logic.GetResourceDoodadGoodType(EntityID) ~= 0 then
            if Logic.GetResourceDoodadGoodAmount(EntityID) == 0 then
                if v.RefillAmount == 0 then
                    local Model = Models.Doodads_D_SE_ResourceIron_Wrecked;
                    if v.Type == Entities.R_StoneMine then
                        Model = Models.R_ResorceStone_Scaffold_Destroyed;
                    end
                    API.InteractiveObjectDeactivate(EntityID);
                    Logic.SetModel(EntityID, Model);
                end

                API.SendScriptEvent(QSB.ScriptEvents.InteractiveMineDepleted, k);
                Logic.ExecuteInLuaLocalState(string.format(
                    [[API.SendScriptEvent(QSB.ScriptEvents.InteractiveMineDepleted, "%s")]],
                    k
                ));
            end
        end
    end
end

-- Local -------------------------------------------------------------------- --

function ModuleInteractiveMines.Local:OnGameStart()
    QSB.ScriptEvents.InteractiveMineDepleted = API.RegisterScriptEvent("Event_InteractiveMineDepleted");
end

function ModuleInteractiveMines.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleInteractiveMines);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Stellt Minen bereit, die wie Ruinen aktiviert werden können.
-- 
-- Der Spieler kann eine Stein- oder Eisenmine restaurieren, die zuerst durch
-- Begleichen der Kosten aufgebaut werden muss, bevor sie genutzt werden kann.
-- <br>Optional kann die Mine einstürzen, wenn sie ausgebeutet wurde.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- <li><a href="modules.QSB_2_Objects.QSB_2_Objects.html">(2) Interaktive Objekte</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field InteractiveMineDepleted  Eine ehemals interaktive Mine wurde ausgebeutet (Parameter: ScriptName)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Erstelle eine verschüttete Eisenmine.
--
-- Werden keine Materialkosten bestimmt, benötigt der Bau der Mine 500 Gold und
-- 20 Holz.
--
-- Die Parameter der interaktiven Mine werden durch ihre Beschreibung
-- festgelegt. Die Beschreibung ist eine Table, die bestimmte Werte für das
-- Objekt beinhaltet. Dabei müssen nicht immer alle Werte angegeben werden.
--
-- Mögliche Angaben:
-- <table border="1">
-- <tr>
-- <td><b>Feldname</b></td>
-- <td><b>Typ</b></td>
-- <td><b>Beschreibung</b></td>
-- <td><b>Optional</b></td>
-- </tr>
-- <tr>
-- <td>Position</td>
-- <td>string</td>
-- <td>Der Skriptname des Entity, das zum interaktiven Objekt wird.</td>
-- <td>nein</td>
-- </tr>
-- <tr>
-- <td>Title</td>
-- <td>string</td>
-- <td>Angezeigter Titel der Beschreibung für die Mine</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Text</td>
-- <td>string</td>
-- <td>Angezeigte Text der Beschreibung für die Mine</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Costs</td>
-- <td>table</td>
-- <td>Eine Table mit dem Typ und der Menge der Kosten. (Format: {Typ, Menge, Typ, Menge})</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>ResourceAmount</td>
-- <td>number</td>
-- <td>Menge an Rohstoffen nach der Aktivierung</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>RefillAmount</td>
-- <td>number</td>
-- <td>Menge an Rohstoffen, die ein Geologe auffüllt (0 == nicht nachfüllbar)</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>ConstructionCondition</td>
-- <td>function</td>
-- <td>Eine zusätzliche Aktivierungsbedinung als Funktion.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>ConstructionAction</td>
-- <td>function</td>
-- <td>Eine zusätzliche Aktion nach der Aktivierung.</td>
-- <td>ja</td>
-- </tr>
-- </table>
--
-- @param[type=table] _Data Datentabelle der Mine
-- @within Anwenderfunktionen
-- @see API.CreateIOStoneMine
--
-- @usage
-- -- Beispiel #1: Eine einfache Mine
-- API.CreateIOIronMine{
--     Position = "mine"
-- };
--
-- @usage
-- -- Beispiel #2: Mine mit geänderten Kosten
-- API.CreateIOIronMine{
--     Position = "mine",
--     Costs    = {Goods.G_Wood, 15}
-- };
--
-- @usage
-- -- Beispiel #3: Mine mit Aktivierungsbedingung
-- API.CreateIOIronMine{
--     Position              = "mine",
--     Costs                 = {Goods.G_Wood, 15},
--     ConstructionCondition = function(_Data)
--         return HeroHasShovel == true;
--     end
-- };
--
function API.CreateIOIronMine(_Data)
    if GUI then
        return;
    end
    if not IsExisting(_Data.Position) then
        error("API.CreateIOIronMine: Position (" ..tostring(_Data.Position).. ") does not exist!");
        return;
    end

    local Costs = {Goods.G_Gold, 500, Goods.G_Wood, 20};
    if _Data.Costs then
        if _Data.Costs[1] then
            if GetNameOfKeyInTable(Goods, _Data.Costs[1]) == nil then
                error("API.CreateIOIronMine: First cost type (" ..tostring(_Data.Costs[1]).. ") is wrong!");
                return;
            end
            if _Data.Costs[2] and (type(_Data.Costs[2]) ~= "number" or _Data.Costs[2] < 1) then
                error("API.CreateIOIronMine: First cost amount must be above 0!");
                return;
            end
        end
        if _Data.Costs[3] then
            if GetNameOfKeyInTable(Goods, _Data.Costs[3]) == nil then
                error("API.CreateIOIronMine: Second cost type (" ..tostring(_Data.Costs[3]).. ") is wrong!");
                return;
            end
            if _Data.Costs[4] and (type(_Data.Costs[4]) ~= "number" or _Data.Costs[4] < 1) then
                error("API.CreateIOIronMine: Second cost amount must be above 0!");
                return;
            end
        end
        Costs = _Data.Costs;
    end

    ModuleInteractiveMines.Global:CreateIOMine(
        _Data.Position,
        Entities.R_IronMine,
        _Data.Title,
        _Data.Text,
        Costs,
        _Data.ResourceAmount,
        _Data.RefillAmount,
        _Data.ConstructionCondition,
        _Data.ConditionInfo,
        _Data.ConstructionAction
    );
end

---
-- Erstelle eine verschüttete Steinmine.
--
-- Werden keine Materialkosten bestimmt, benötigt der Bau der Mine 500 Gold und
-- 20 Holz.
--
-- Die Parameter der interaktiven Mine werden durch ihre Beschreibung
-- festgelegt. Die Beschreibung ist eine Table, die bestimmte Werte für das
-- Objekt beinhaltet. Dabei müssen nicht immer alle Werte angegeben werden.
--
-- Mögliche Angaben:
-- <table border="1">
-- <tr>
-- <td><b>Feldname</b></td>
-- <td><b>Typ</b></td>
-- <td><b>Beschreibung</b></td>
-- <td><b>Optional</b></td>
-- </tr>
-- <tr>
-- <td>Position</td>
-- <td>string</td>
-- <td>Der Skriptname des Entity, das zum interaktiven Objekt wird.</td>
-- <td>nein</td>
-- </tr>
-- <tr>
-- <td>Title</td>
-- <td>string</td>
-- <td>Angezeigter Titel der Beschreibung für die Mine</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Text</td>
-- <td>string</td>
-- <td>Angezeigte Text der Beschreibung für die Mine</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Costs</td>
-- <td>table</td>
-- <td>Eine Table mit dem Typ und der Menge der Kosten. (Format: {Typ, Menge, Typ, Menge})</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <tr>
-- <td>ResourceAmount</td>
-- <td>number</td>
-- <td>Menge an Rohstoffen nach der Aktivierung</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>RefillAmount</td>
-- <td>number</td>
-- <td>Menge an Rohstoffen, die ein Geologe auffüllt (0 == nicht nachfüllbar)</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>ConstructionCondition</td>
-- <td>function</td>
-- <td>Eine zusätzliche Aktivierungsbedinung als Funktion.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>ConstructionAction</td>
-- <td>function</td>
-- <td>Eine zusätzliche Aktion nach der Aktivierung.</td>
-- <td>ja</td>
-- </tr>
-- </table>
--
-- @param[type=table] _Data Datentabelle der Mine
-- @within Anwenderfunktionen
-- @see API.CreateIOIronMine
--
-- @usage
-- -- Beispiel #1: Eine einfache Mine
-- API.CreateIOStoneMine{
--     Position = "mine"
-- };
--
-- @usage
-- -- Beispiel #2: Mine mit geänderten Kosten
-- API.CreateIOStoneMine{
--     Position = "mine",
--     Costs    = {Goods.G_Wood, 15}
-- };
--
-- @usage
-- -- Beispiel #3: Mine mit Aktivierungsbedingung
-- API.CreateIOStoneMine{
--     Position              = "mine",
--     Costs                 = {Goods.G_Wood, 15},
--     ConstructionCondition = function(_Data)
--         return HeroHasPickaxe == true;
--     end
-- };
--
function API.CreateIOStoneMine(_Data)
    if GUI then
        return;
    end
    if not IsExisting(_Data.Position) then
        error("API.CreateIOStoneMine: Position (" ..tostring(_Data.Position).. ") does not exist!");
        return;
    end

    local Costs = {Goods.G_Gold, 500, Goods.G_Wood, 20};
    if _Data.Costs then
        if _Data.Costs[1] then
            if GetNameOfKeyInTable(Goods, _Data.Costs[1]) == nil then
                error("API.CreateIOStoneMine: First cost type (" ..tostring(_Data.Costs[1]).. ") is wrong!");
                return;
            end
            if _Data.Costs[2] and (type(_Data.Costs[2]) ~= "number" or _Data.Costs[2] < 1) then
                error("API.CreateIOStoneMine: First cost amount must be above 0!");
                return;
            end
        end
        if _Data.Costs[3] then
            if GetNameOfKeyInTable(Goods, _Data.Costs[3]) == nil then
                error("API.CreateIOStoneMine: Second cost type (" ..tostring(_Data.Costs[3]).. ") is wrong!");
                return;
            end
            if _Data.Costs[4] and (type(_Data.Costs[4]) ~= "number" or _Data.Costs[4] < 1) then
                error("API.CreateIOStoneMine: Second cost amount must be above 0!");
                return;
            end
        end
        Costs = _Data.Costs;
    end

    ModuleInteractiveMines.Global:CreateIOMine(
        _Data.Position,
        Entities.R_StoneMine,
        _Data.Title,
        _Data.Text,
        Costs,
        _Data.ResourceAmount,
        _Data.RefillAmount,
        _Data.ConstructionCondition,
        _Data.ConditionInfo,
        _Data.ConstructionAction
    );
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleQuestJournal = {
    Properties = {
        Name = "ModuleQuestJournal",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        Journal = {ID = 0},
        CustomInputAllowed = {},
        InputShown = {},
        TextColor  = "{tooltip}",
    };
    Local = {
        NextButton = "/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/TutorialNextButton",
        NextButtonIcon = {16, 10},
    };

    Shared = {
        Text = {
            Next  = {de = "Tagebuch anzeigen", en = "Show Journal", fr = "Afficher le journal"},
            Title = {de = "Tagebuch",          en = "Journal",      fr = "Journal"},
            Note  = {de = "Notiz",             en = "Note",         fr = "Note"},
        },
    };
};

-- -------------------------------------------------------------------------- --
-- Global Script

function ModuleQuestJournal.Global:OnGameStart()
    QSB.ScriptEvents.QuestJournalDisplayed = API.RegisterScriptEvent("Event_QuestJournalDisplayed");
    QSB.ScriptEvents.QuestJournalPlayerNote = API.RegisterScriptEvent("Event_QuestJournalPlayerNote");

    API.RegisterScriptCommand("Cmd_TutorialNextClicked", function(_QuestName, _PlayerID)
        local CustomInput = self.CustomInputAllowed[_QuestName] == true;
        local FullText = self:FormatJournalEntry(_QuestName, _PlayerID);
        API.SendScriptEvent(
            QSB.ScriptEvents.QuestJournalDisplayed,
            _PlayerID, _QuestName, FullText, CustomInput
        );
    end);
end

function ModuleQuestJournal.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.ChatClosed then
        self:ProcessChatInput(arg[1], arg[2]);
    elseif _ID == QSB.ScriptEvents.QuestJournalPlayerNote then
        self.InputShown[arg[1]] = arg[2];
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.QuestJournalPlayerNote, %d, "%s", %s)]],
            arg[1], arg[2], tostring(arg[3] == true)
        ));
    elseif _ID == QSB.ScriptEvents.QuestJournalDisplayed then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.SendScriptEvent(QSB.ScriptEvents.QuestJournalDisplayed, %d, "%s", "%s", %s)]],
            arg[1], arg[2], arg[3], tostring(arg[4])
        ));
    end
end

function ModuleQuestJournal.Global:CreateJournalEntry(_Text, _Rank, _AlwaysVisible)
    self.Journal.ID = self.Journal.ID +1;
    table.insert(self.Journal, {
        ID            = self.Journal.ID,
        AlwaysVisible = _AlwaysVisible == true,
        Quests        = {},
        Rank          = _Rank,
        _Text
    });
    return self.Journal.ID;
end

function ModuleQuestJournal.Global:GetJournalEntry(_ID)
    for i= 1, #self.Journal do
        if self.Journal[i].ID == _ID then
            return self.Journal[i];
        end
    end
end

function ModuleQuestJournal.Global:UpdateJournalEntry(_ID, _Text, _Rank, _AlwaysVisible, _Deleted)
    for i= 1, #self.Journal do
        if self.Journal[i].ID == _ID then
            self.Journal[i].AlwaysVisible = _AlwaysVisible == true;
            self.Journal[i].Deleted       = _Deleted == true;
            self.Journal[i].Rank          = _Rank;

            self.Journal[i][1] = self.Journal[i][1] or _Text;
        end
    end
end

function ModuleQuestJournal.Global:AssociateJournalEntryWithQuest(_ID, _Quest, _Flag)
    for i= 1, #self.Journal do
        if self.Journal[i].ID == _ID then
            self.Journal[i].Quests[_Quest] = _Flag == true;
        end
    end
end

function ModuleQuestJournal.Global:FormatJournalEntry(_QuestName, _PlayerID)
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest and Quest.QuestNotes and Quest.ReceivingPlayer == _PlayerID then
        local Journal = self:GetJournalEntriesSorted();
        local SeperateImportant = false;
        local SeperateNormal = false;
        local Info = "";
        for i= 1, #Journal, 1 do
            if Journal[i].AlwaysVisible or Journal[i].Quests[_QuestName] then
                if not Journal[i].Deleted then
                    local Text = API.ConvertPlaceholders(API.Localize(Journal[i][1]));

                    if Journal[i].Rank == 1 then
                        Text = "{scarlet}" .. Text .. self.TextColor;
                        SeperateImportant = true;
                    end
                    if Journal[i].Rank == 0 then
                        if SeperateImportant then
                            SeperateImportant = false;
                            Text = "{cr}----------{cr}{cr}" .. Text;
                        end
                        SeperateNormal = true;
                    end
                    if Journal[i].Rank == -1 then
                        local Color = "";
                        if SeperateNormal then
                            SeperateNormal = false;
                            Color = "{violet}";
                            Text = "{cr}----------{cr}{cr}" .. Text;
                        end
                        Text = Color .. Text .. self.TextColor;
                    end

                    Info = Info .. ((Info ~= "" and "{cr}") or "") .. Text;
                end
            end
        end
        return Info;
    end
end

function ModuleQuestJournal.Global:GetJournalEntriesSorted()
    local Journal = {};
    for i= 1, #self.Journal, 1 do
        table.insert(Journal, self.Journal[i]);
    end
    table.sort(Journal, function(a, b)
        return a.Rank > b.Rank;
    end)
    return Journal;
end

function ModuleQuestJournal.Global:ProcessChatInput(_Text, _PlayerID)
    if self.InputShown[_PlayerID] then
        if _Text and _Text ~= "" then
            local QuestName = self.InputShown[_PlayerID];
            local CustomInput = self.CustomInputAllowed[QuestName] == true;
            local ID = self:CreateJournalEntry(_Text, -1, false)
            self:AssociateJournalEntryWithQuest(ID, QuestName, true);
            local FullText = self:FormatJournalEntry(QuestName, _PlayerID);

            API.SendScriptEvent(
            QSB.ScriptEvents.QuestJournalDisplayed,
                _PlayerID, QuestName, FullText, CustomInput
            );
        end
        self.InputShown[_PlayerID] = nil;
    end
end

-- -------------------------------------------------------------------------- --
-- Local Script

function ModuleQuestJournal.Local:OnGameStart()
    QSB.ScriptEvents.QuestJournalDisplayed = API.RegisterScriptEvent("Event_QuestJournalDisplayed");
    QSB.ScriptEvents.QuestJournalPlayerNote = API.RegisterScriptEvent("Event_QuestJournalPlayerNote");

    self:OverrideUpdateVoiceMessage();
    self:OverrideTutorialNext();
    self:OverrideStringKeys();
    self:OverrideTimerButtons();
end

function ModuleQuestJournal.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.QuestJournalPlayerNote then
        if arg[1] == GUI.GetPlayerID() and arg[3] then
            API.ShowTextInput(arg[1], false);
        end
    elseif _ID == QSB.ScriptEvents.QuestJournalDisplayed then
        if arg[1] == GUI.GetPlayerID() then
            self:DisplayQuestJournal(arg[2], arg[1], arg[3], arg[4]);
        end
    end
end

function ModuleQuestJournal.Local:DisplayQuestJournal(_QuestName, _PlayerID, _Info, _Input)
    if _Info and GUI.GetPlayerID() == _PlayerID then
        local Title = API.Localize(ModuleQuestJournal.Shared.Text.Title);
        local Data = {
            PlayerID  = _PlayerID,
            Caption   = Title,
            Content   = API.ConvertPlaceholders(_Info),
            QuestName = _QuestName
        }
        if _Input then
            Data.Button = {
                Text   = API.Localize{de = "Notiz", en = "Note", fr = "Note"},
                Action = function(_Data)
                    API.BroadcastScriptEventToGlobal("QuestJournalPlayerNote", _Data.PlayerID, _Data.QuestName, _Input);
                end
            }
        end
        ModuleRequester.Local:ShowTextWindow(Data);
    end
end

function ModuleQuestJournal.Local:OverrideUpdateVoiceMessage()
    GUI_Interaction.UpdateVoiceMessage_Orig_ModuleQuestJournal = GUI_Interaction.UpdateVoiceMessage;
    GUI_Interaction.UpdateVoiceMessage = function()
        GUI_Interaction.UpdateVoiceMessage_Orig_ModuleQuestJournal();
        if not QuestLog.IsQuestLogShown() then
            if ModuleQuestJournal.Local:IsShowingJournalButton(g_Interaction.CurrentMessageQuestIndex) then
                XGUIEng.ShowWidget(ModuleQuestJournal.Local.NextButton, 1);
                SetIcon(
                    ModuleQuestJournal.Local.NextButton,
                    ModuleQuestJournal.Local.NextButtonIcon
                );
            else
                XGUIEng.ShowWidget(ModuleQuestJournal.Local.NextButton, 0);
            end
        end
    end
end

function ModuleQuestJournal.Local:IsShowingJournalButton(_ID)
    if not g_Interaction.CurrentMessageQuestIndex then
        return false;
    end
    local Quest = Quests[_ID];
    if type(Quest) == "table" and Quest.QuestNotes then
        return true;
    end
    return false;
end

function ModuleQuestJournal.Local:OverrideTimerButtons()
    GUI_Interaction.TimerButtonClicked_Orig_ModuleQuestJournal = GUI_Interaction.TimerButtonClicked;
    GUI_Interaction.TimerButtonClicked = function()
        if  XGUIEng.IsWidgetShown("/InGame/Root/Normal/ChatOptions") == 1
        and XGUIEng.IsWidgetShown("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget") == 1 then
            return;
        end
        GUI_Interaction.TimerButtonClicked_Orig_ModuleQuestJournal();
    end
end

function ModuleQuestJournal.Local:OverrideTutorialNext()
    GUI_Interaction.TutorialNext_Orig_ModuleQuestJournal = GUI_Interaction.TutorialNext;
    GUI_Interaction.TutorialNext = function()
        if g_Interaction.CurrentMessageQuestIndex then
            local QuestID = g_Interaction.CurrentMessageQuestIndex;
            local Quest = Quests[QuestID];
            API.BroadcastScriptCommand(
                QSB.ScriptCommands.TutorialNextClicked,
                Quest.Identifier,
                GUI.GetPlayerID()
            );
        end
    end
end

function ModuleQuestJournal.Local:OverrideStringKeys()
    GetStringTableText_Orig_ModuleQuestJournal = XGUIEng.GetStringTableText;
    XGUIEng.GetStringTableText = function(_key)
        if _key == "UI_ObjectNames/TutorialNextButton" then
            return API.Localize(ModuleQuestJournal.Shared.Text.Next);
        end
        return GetStringTableText_Orig_ModuleQuestJournal(_key);
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleQuestJournal);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Erlaubt es Notizen zu einem Quest hinzuzufügen.
-- 
-- <p><b>Vorausgesetzte Module:</b></p>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- <li><a href="modules.QSB_1_Requester.QSB_1_Requester.html">(1) Requester</a></li>
-- <li><a href="modules.QSB_2_Quest.QSB_2_Quest.html">(2) Aufträge</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field QuestJournalDisplayed   (Parameter: PlayerID, QuestName, Text, NotizenErlaubt)
-- @field QuestJournalPlayerNote  (Parameter: PlayerID, QuestName, NotizenErlaubt)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Aktiviert oder Deaktiviert die Verfügbarkeit der Zusatzinformationen für den
-- übergebenen Quest.
--
-- <b>Hinweis</b>: Die Sichtbarkeit der Zusatzinformationen für einzelne Quests
-- ist generell deaktiviert und muss explizit aktiviert werden.
--
-- <b>Hinweis</b>: Der Button wird auch dann angezeigt, wenn es noch keine
-- Zusatzinformationen für den Quest gibt.
--
-- @param[type=string]  _Quest Name des Quest
-- @param[type=boolean] _Flag  Zusatzinfos aktivieren
-- @within Anwenderfunktionen
--
-- @usage
-- -- Deaktivieren
-- API.ShowJournalForQuest("MyQuest", false);
-- -- Aktivieren
-- API.ShowJournalForQuest("MyQuest", true);
--
function API.ShowJournalForQuest(_Quest, _Flag)
    if GUI then
        return;
    end
    local Quest = Quests[GetQuestID(_Quest)];
    if Quest then
        Quest.QuestNotes = _Flag == true;
    end
end

---
-- Aktiviert die Möglichkeit, selbst Notizen zu schreiben.
--
-- <b>Hinweis</b>: Die Zusatzinformationen müssen für den Quest aktiv sein.
--
-- @param[type=string]  _Quest Name des Quest
-- @param[type=boolean] _Flag  Notizen aktivieren
-- @within Anwenderfunktionen
--
-- @usage
-- -- Deaktivieren
-- API.AllowNotesForQuest("MyQuest", false);
-- -- Aktivieren
-- API.AllowNotesForQuest("MyQuest", true);
--
function API.AllowNotesForQuest(_Quest, _Flag)
    if GUI then
        return;
    end
    local Quest = Quests[GetQuestID(_Quest)];
    if Quest then
        ModuleQuestJournal.Global.CustomInputAllowed[_Quest] = _Flag == true;
    end
end

---
-- Fugt eine Zusatzinformation für diesen Quests hinzu.
--
-- <b>Hinweis</b>: Die erzeugte ID ist immer eindeutig für alle Einträge,
-- ungeachtet ob sie einem Quest zugeordnet sind oder nicht.
--
-- <b>Hinweis</b>: Der Questname kann durch nil ersetzt werden. In diesem Fall
-- erscheint der Eintrag bei <i>allen</i> Quests (für die das Feature aktiviert
-- ist). Und das so lange, bis er wieder gelöscht wird.
--
-- <b>Hinweis</b>: Formatierungsbefehle sind deaktiviert.
--
-- @param[type=string] _Text  Text der Zusatzinfo
-- @return[type=number] ID des neuen Eintrags
-- @within Anwenderfunktionen
--
-- @usage
-- local NewEntryID = API.CreateJournalEntry("Wichtige Information zum Anzeigen");
--
function API.CreateJournalEntry(_Text)
    _Text = _Text:gsub("{@[A-Za-z0-9:,]+}", "");
    _Text = _Text:gsub("{[A-Za-z0-9_]+}", "");
    return ModuleQuestJournal.Global:CreateJournalEntry(_Text, 0, false);
end

---
-- Ändert den Text einer Zusatzinformation.
--
-- <b>Hinweis</b>: Der neue Text bezieht sich auf den Eintrag mit der ID. Ist
-- der Eintrag für alle Quests sichtbar, wird er in allen Quests geändert.
-- Kopien eines Eintrags werden nicht berücksichtigt.
--
-- <b>Hinweis</b>: Formatierungsbefehle sind deaktiviert.
--
-- @param[type=number] _ID   ID des Eintrag
-- @param              _Text Neuer Text
-- @within Anwenderfunktionen
--
-- @usage
-- API.AlterJournalEntry(SomeEntryID, "Das ist der neue Text.");
--
function API.AlterJournalEntry(_ID, _Text)
    _Text = _Text:gsub("{@[A-Za-z0-9:,]+}", "");
    _Text = _Text:gsub("{[A-Za-z0-9_]+}", "");
    local Entry = ModuleQuestJournal.Global:GetJournalEntry(_ID);
    if Entry then
        ModuleQuestJournal.Global:UpdateJournalEntry(
            _ID,
            _Text,
            Entry.Rank,
            Entry.AlwaysVisible,
            Entry.Deleted
        );
    end
end

---
-- Hebt einen Eintrag aus den Zusatzinformationen als wichtig hervor oder
-- setzt ihn zurück.
--
-- <b>Hinweis</b>: Wichtige Einträge erscheinen immer als erstes und sind durch
-- rote Färbung hervorgehoben. Eigene Farben in einer Nachricht beeinträchtigen
-- die rote hervorhebung.
--
-- @param[type=number]  _ID        ID des Eintrag
-- @param[type=boolean] _Important Wichtig Markierung
-- @within Anwenderfunktionen
--
-- @usage
-- API.HighlightJournalEntry(SomeEntryID, true);
--
function API.HighlightJournalEntry(_ID, _Important)
    local Entry = ModuleQuestJournal.Global:GetJournalEntry(_ID);
    if Entry then
        ModuleQuestJournal.Global:UpdateJournalEntry(
            _ID,
            Entry[1],
            (_Important == true and 1) or 0,
            Entry.AlwaysVisible,
            Entry.Deleted
        );
    end
end

---
-- Entfernt einen Eintrag aus den Zusatzinformationen.
--
-- <b>Hinweis</b>: Ein Eintrag wird niemals wirklich gelöscht, sondern nur
-- unsichtbar geschaltet.
--
-- @param[type=number] _ID ID des Eintrag
-- @within Anwenderfunktionen
--
-- @usage
-- API.DeleteJournalEntry(SomeEntryID);
--
function API.DeleteJournalEntry(_ID)
    local Entry = ModuleQuestJournal.Global:GetJournalEntry(_ID);
    if Entry then
        ModuleQuestJournal.Global:UpdateJournalEntry(
            _ID,
            Entry[1],
            Entry.Rank,
            Entry.AlwaysVisible,
            true
        );
    end
end

---
-- Stellt einen gelöschten Eintrag in den Zusatzinformationen wieder her.
--
-- @param[type=number] _ID ID des Eintrag
-- @within Anwenderfunktionen
--
-- @usage
-- API.RestoreJournalEntry(SomeEntryID);
--
function API.RestoreJournalEntry(_ID)
    local Entry = ModuleQuestJournal.Global:GetJournalEntry(_ID);
    if Entry then
        ModuleQuestJournal.Global:UpdateJournalEntry(
            _ID,
            Entry[1],
            Entry.Rank,
            Entry.AlwaysVisible,
            false
        );
    end
end

---
-- Fügt einen Tagebucheintrag zu einem Quest hinzu.
--
-- @param[type=number]  _ID    ID des Eintrag
-- @param[type=boolean] _Quest Name des Quest
-- @within Anwenderfunktionen
--
-- @usage
-- API.AddJournalEntryToQuest(_ID, _Quest);
--
function API.AddJournalEntryToQuest(_ID, _Quest)
    local Entry = ModuleQuestJournal.Global:GetJournalEntry(_ID);
    if Entry then
        ModuleQuestJournal.Global:AssociateJournalEntryWithQuest(_ID, _Quest, true);
    end
end

---
-- Entfernt einen Tagebucheintrag von einem Quest.
--
-- @param[type=number]  _ID    ID des Eintrag
-- @param[type=boolean] _Quest Name des Quest
-- @within Anwenderfunktionen
--
-- @usage
-- API.RemoveJournalEntryFromQuest(_ID, _Quest);
--
function API.RemoveJournalEntryFromQuest(_ID, _Quest)
    local Entry = ModuleQuestJournal.Global:GetJournalEntry(_ID);
    if Entry then
        ModuleQuestJournal.Global:AssociateJournalEntryWithQuest(_ID, _Quest, false);
    end
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Stellt Behavior bereit um die Tagebuchfunktion über den Assistenten nutzbar
-- zu machen.
--
-- @set sort=true
--

QSB.JournalEntryNameToQuestName = {};
QSB.JournalEntryNameToID = {};

-- -------------------------------------------------------------------------- --

---
-- Zeigt das Tagebuch für einen Quest an oder versteckt es.
--
-- @param[type=string] _QuestName Name des Quest
-- @param[type=string] _Active    Tagebuch ist aktiv
-- @within Reprisal
--
function Reprisal_JournalEnable(...)
    return B_Reprisal_JournalEnable:new(...);
end

B_Reprisal_JournalEnable = {
    Name = "Reprisal_JournalEnable",
    Description = {
        en = "Reprisal: Displays the journal for a quest or hides it.",
        de = "Vergeltung: Zeigt das Tagebuch für einen Quest an oder versteckt es.",
        fr = "Rétribution: Affiche ou cache le journal pour une quête.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name",     de = "Name Quest",     fr = "Nom de la quête" },
        { ParameterType.Custom,    en = "Journal active", de = "Tagebuch aktiv", fr = "Journal actif" },
    },
}

function B_Reprisal_JournalEnable:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} };
end

function B_Reprisal_JournalEnable:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
    elseif (_Index == 1) then
        self.ActiveFlag = API.ToBoolean(_Parameter);
    end
end

function B_Reprisal_JournalEnable:CustomFunction(_Quest)
    API.ShowJournalForQuest(self.QuestName, self.ActiveFlag == true);
end

function B_Reprisal_JournalEnable:Debug(_Quest)
    if not API.IsValidQuest(GetQuestID(self.QuestName)) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": quest '" ..tostring(self.QuestName).."' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_JournalEnable);

-- -------------------------------------------------------------------------- --

---
-- Zeigt das Tagebuch für einen Quest an oder versteckt es.
--
-- @param[type=string] _QuestName Name des Quest
-- @param[type=string] _Active    Tagebuch ist aktiv
-- @within Reward
--
function Reward_JournalEnable(...)
    return B_Reward_JournalEnable:new(...);
end

B_Reward_JournalEnable = Swift.LuaBase:CopyTable(B_Reprisal_JournalEnable);
B_Reward_JournalEnable.Name = "Reward_JournalEnable";
B_Reward_JournalEnable.Description.en = "Reward: Displays the journal for a quest or hides it.";
B_Reward_JournalEnable.Description.de = "Lohn: Zeigt das Tagebuch für einen Quest an oder versteckt es.";
B_Reward_JournalEnable.Description.fr = "Récompense: Affiche ou cache le journal d'une quête.";
B_Reward_JournalEnable.GetReprisalTable = nil;

B_Reward_JournalEnable.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Swift:RegisterBehavior(B_Reward_JournalEnable);

-- -------------------------------------------------------------------------- --

---
-- Schreibt einen Tagebucheintrag zu dem angegebenen Quest.
--
-- @param[type=string] _QuestName Name des Quest
-- @param[type=string] _EntryName Name des Eintrag
-- @param[type=string] _EntryText Text des Eintrag
-- @within Reprisal
--
function Reprisal_JournalWrite(...)
    return B_Reprisal_JournalWrite:new(...);
end

B_Reprisal_JournalWrite = {
    Name = "Reprisal_JournalWrite",
    Description = {
        en = "Reprisal: Adds or alters a journal entry to a quest.",
        de = "Vergeltung: Schreibt oder ändert einen Tagebucheintrag.",
        fr = "Rétribution: Écrit ou modifie une entrée de journal.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Name Quest",   fr = "Nom de la quête" },
        { ParameterType.Default,   en = "Entry name", de = "Name Eintrag", fr = "Nom de l'entrée" },
        { ParameterType.Default,   en = "Entry text", de = "Text Eintrag", fr = "Texte de l'entrée" },
    },
}

function B_Reprisal_JournalWrite:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} };
end

function B_Reprisal_JournalWrite:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
    elseif (_Index == 1) then
        self.EntryName = _Parameter;
    elseif (_Index == 2) then
        self.EntryText = _Parameter;
    end
end

function B_Reprisal_JournalWrite:CustomFunction(_Quest)
    if QSB.JournalEntryNameToQuestName[self.EntryName] then
        local EntryID = QSB.JournalEntryNameToID[self.EntryName];
        API.AlterJournalEntry(EntryID, self.EntryText);
    else
        local EntryID = API.CreateJournalEntry(self.EntryText);
        API.AddJournalEntryToQuest(EntryID, self.QuestName);
        QSB.JournalEntryNameToQuestName[self.EntryName] = self.QuestName;
        QSB.JournalEntryNameToID[self.EntryName] = EntryID;
    end
end

function B_Reprisal_JournalWrite:Debug(_Quest)
    if not API.IsValidQuest(GetQuestID(self.QuestName)) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": quest '" ..tostring(self.QuestName).."' does not exist!");
        return true;
    end
    if QSB.JournalEntryNameToQuestName[self.EntryName] ~= self.QuestName then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entry name '" ..tostring(self.EntryName).."' is already in use in another quest!");
        return true;
    end
    if not QSB.JournalEntryNameToID[self.EntryName] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entry '" ..tostring(self.EntryName).."' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_JournalWrite);

-- -------------------------------------------------------------------------- --

---
-- Schreibt einen Tagebucheintrag zu dem angegebenen Quest.
--
-- @param[type=string] _QuestName Name des Quest
-- @param[type=string] _EntryName Name des Eintrag
-- @param[type=string] _EntryText Text des Eintrag
-- @within Reward
--
function Reward_JournalWrite(...)
    return B_Reward_JournalWrite:new(...);
end

B_Reward_JournalWrite = Swift.LuaBase:CopyTable(B_Reprisal_JournalWrite);
B_Reward_JournalWrite.Name = "Reward_JournalWrite";
B_Reward_JournalWrite.Description.en = "Reward: Adds or alters a journal entry to a quest.";
B_Reward_JournalWrite.Description.de = "Lohn: Schreibt oder ändert einen Tagebucheintrag.";
B_Reward_JournalWrite.Description.de = "Récompense: Écrit ou modifie une entrée de journal.";
B_Reward_JournalWrite.GetReprisalTable = nil;

B_Reward_JournalWrite.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Swift:RegisterBehavior(B_Reward_JournalWrite);

-- -------------------------------------------------------------------------- --

---
-- Entfernt einen Tagebucheintrag von einem Quest.
--
-- @param[type=string] _QuestName Name des Quest
-- @param[type=string] _EntryName Name des Entry
-- @within Reprisal
--
function Reprisal_JournalRemove(...)
    return B_Reprisal_JournalRemove:new(...);
end

B_Reprisal_JournalRemove = {
    Name = "Reprisal_JournalRemove",
    Description = {
        en = "Reprisal: Remove a journal entry from a quest.",
        de = "Vergeltung: Entfernt einen Tagebucheintrag vom Quest.",
        fr = "Rétribution: Supprime une entrée de journal de la quête.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Name Quest",   fr = "Nom de la quête" },
        { ParameterType.Default,   en = "Entry name", de = "Name Eintrag", fr = "Nom de l'entrée" },
    },
}

function B_Reprisal_JournalRemove:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} };
end

function B_Reprisal_JournalRemove:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
    elseif (_Index == 1) then
        self.EntryName = _Parameter;
    end
end

function B_Reprisal_JournalRemove:CustomFunction(_Quest)
    if QSB.JournalEntryNameToQuestName[self.EntryName] then
        local EntryID = QSB.JournalEntryNameToID[self.EntryName];
        API.RemoveJournalEntryFromQuest(EntryID, self.QuestName);
        API.DeleteJournalEntry(EntryID);
        QSB.JournalEntryNameToQuestName[self.EntryName] = nil;
        QSB.JournalEntryNameToID[self.EntryName] = nil;
    end
end

function B_Reprisal_JournalRemove:Debug(_Quest)
    if not API.IsValidQuest(GetQuestID(self.QuestName)) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": quest '" ..tostring(self.QuestName).."' does not exist!");
        return true;
    end
    if QSB.JournalEntryNameToQuestName[self.EntryName] ~= self.QuestName then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entry name '" ..tostring(self.EntryName).."' is already in use in another quest!");
        return true;
    end
    if not QSB.JournalEntryNameToID[self.EntryName] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entry '" ..tostring(self.EntryName).."' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_JournalRemove);

-- -------------------------------------------------------------------------- --

---
-- Entfernt einen Tagebucheintrag von einem Quest.
--
-- @param[type=string] _QuestName Name des Quest
-- @param[type=string] _EntryName Name des Entry
-- @within Reward
--
function Reward_JournalRemove(...)
    return B_Reward_JournalRemove:new(...);
end

B_Reward_JournalRemove = Swift.LuaBase:CopyTable(B_Reprisal_JournalRemove);
B_Reward_JournalRemove.Name = "Reward_JournalRemove";
B_Reward_JournalRemove.Description.en = "Reward: Remove a journal entry from a quest.";
B_Reward_JournalRemove.Description.de = "Lohn: Entfernt einen Tagebucheintrag vom Quest.";
B_Reward_JournalRemove.Description.fr = "Récompense: Supprime une entrée de journal de la quête.";
B_Reward_JournalRemove.GetReprisalTable = nil;

B_Reward_JournalRemove.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Swift:RegisterBehavior(B_Reward_JournalRemove);

-- -------------------------------------------------------------------------- --

---
-- Hebt einen Eintrag im Tagebuch hervor oder setzt ihn auf normal zurück.
--
-- @param[type=string] _QuestName Name des Quest
-- @param[type=string]  _EntryName   Name des Eintrag
-- @param[type=boolean] _Highlighted Eintrag ist hervorgehoben
-- @within Reprisal
--
function Reprisal_JournaHighlight(...)
    return B_Reprisal_JournaHighlight:new(...);
end

B_Reprisal_JournaHighlight = {
    Name = "Reprisal_JournaHighlight",
    Description = {
        en = "Reprisal: Highlights or unhighlights a journal entry of a quest.",
        de = "Vergeltung: Hebt einen Tagebucheintrag hevor oder hebt die Hervorhebung auf.",
        fr = "Rétribution: met en valeur ou annule la mise en valeur d'une entrée de journal.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name",      de = "Name Quest",   fr= "Nom de la quête" },
        { ParameterType.Default,   en = "Name of entry",   de = "Name Eintrag", fr= "Nom de l'entrée" },
        { ParameterType.Custom,    en = "Highlight entry", de = "Hebe hervor",  fr= "Mettre en valeur" },
    },
}

function B_Reprisal_JournaHighlight:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} };
end

function B_Reprisal_JournaHighlight:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
    elseif (_Index == 1) then
        self.EntryName = _Parameter;
    elseif (_Index == 2) then
        self.IsImportant = API.ToBoolean(_Parameter);
    end
end

function B_Reprisal_JournaHighlight:GetCustomData(_Index)
    return {"true","false"};
end

function B_Reprisal_JournaHighlight:CustomFunction(_Quest)
    if QSB.JournalEntryNameToQuestName[self.EntryName] then
        local EntryID = QSB.JournalEntryNameToID[self.EntryName];
        API.HighlightJournalEntry(EntryID, self.IsImportant == true);
    end
end

function B_Reprisal_JournaHighlight:Debug(_Quest)
    if not API.IsValidQuest(GetQuestID(self.QuestName)) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": quest '" ..tostring(self.QuestName).."' does not exist!");
        return true;
    end
    if QSB.JournalEntryNameToQuestName[self.EntryName] ~= self.QuestName then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entry name '" ..tostring(self.EntryName).."' is not mapped to the quest!");
        return true;
    end
    if not QSB.JournalEntryNameToID[self.EntryName] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entry '" ..tostring(self.EntryName).."' does not exist!");
        return true;
    end
    return false;
end

Swift:RegisterBehavior(B_Reprisal_JournaHighlight);

-- -------------------------------------------------------------------------- --

---
-- Hebt einen Eintrag im Tagebuch hervor oder setzt ihn auf normal zurück.
--
-- @param[type=string] _QuestName Name des Quest
-- @param[type=string]  _EntryName   Name des Eintrag
-- @param[type=boolean] _Highlighted Eintrag ist hervorgehoben
-- @within Reward
--
function Reward_JournaHighlight(...)
    return B_Reward_JournaHighlight:new(...);
end

B_Reward_JournaHighlight = Swift.LuaBase:CopyTable(B_Reprisal_JournaHighlight);
B_Reward_JournaHighlight.Name = "Reward_JournaHighlight";
B_Reward_JournaHighlight.Description.en = "Reward: Highlights or unhighlights a journal entry of a quest.";
B_Reward_JournaHighlight.Description.de = "Lohn: Hebt einen Tagebucheintrag hevor oder hebt die Hervorhebung auf.";
B_Reward_JournaHighlight.Description.fr = "Récompense: met en valeur ou annule la mise en valeur d'une entrée de journal.";
B_Reward_JournaHighlight.GetReprisalTable = nil;

B_Reward_JournaHighlight.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Swift:RegisterBehavior(B_Reward_JournaHighlight);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleInteractiveSites = {
    Properties = {
        Name = "ModuleInteractiveSites",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        CreatedSites = {},
    };
    Local  = {};

    Shared = {
        Text = {
            Description = {
                Title = {
                    de = "Gebäude bauen",
                    en = "Create building",
                    fr = "Construire le bâtiment",
                },
                Text = {
                    de = "Beauftragt den Bau eines Gebäudes. Ein Siedler wird aus"..
                        " dem Lagerhaus kommen und mit dem Bau beginnen.",
                    en = "Order a building. A worker will come out of the"..
                        " storehouse and erect it.",
                    fr = "Commande la construction d'un bâtiment. Un Settler sortira de"..
                        " l'entrepôt et commencera la construction.",
                },
            }
        }
    };
};

QSB.NonPlayerCharacterObjects = {};

-- Global Script ------------------------------------------------------------ --

function ModuleInteractiveSites.Global:OnGameStart()
    QSB.ScriptEvents.InteractiveSiteBuilt = API.RegisterScriptEvent("Event_InteractiveSiteBuilt");

    self:OverrideConstructionCompleteCallback();
end

function ModuleInteractiveSites.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.ObjectReset then
        if IO[arg[1]] and IO[arg[1]].IsInteractiveSite then
            -- Nothing to do?
        end
    elseif _ID == QSB.ScriptEvents.ObjectDelete then
        if IO[arg[1]] and IO[arg[1]].IsInteractiveSite then
            -- Nothing to do?
        end
    end
end

function ModuleInteractiveSites.Global:OverrideConstructionCompleteCallback()
    GameCallback_OnBuildingConstructionComplete_Orig_QSB_InteractiveSites = GameCallback_OnBuildingConstructionComplete;
    GameCallback_OnBuildingConstructionComplete = function(_PlayerID, _EntityID)
        GameCallback_OnBuildingConstructionComplete_Orig_QSB_InteractiveSites(_PlayerID, _EntityID);

        if ModuleInteractiveSites.Global.CreatedSites[_EntityID] then
            local Object = ModuleInteractiveSites.Global.CreatedSites[_EntityID];
            if Object then
                API.SendScriptEvent(QSB.ScriptEvents.InteractiveSiteBuilt, Object.Name, _PlayerID, _EntityID);
                Logic.ExecuteInLuaLocalState(string.format(
                    [[API.SendScriptEvent(QSB.ScriptEvents.InteractiveSiteBuilt, "%s", %d, %d)]],
                    Object.Name,
                    _PlayerID,
                    _EntityID
                ));
            end
        end
    end
end

function ModuleInteractiveSites.Global:CreateIOBuildingSite(_Data)
    local Costs = _Data.Costs or {Logic.GetEntityTypeFullCost(_Data.Type)};
    local Title = _Data.Title or ModuleInteractiveSites.Shared.Text.Description.Title;
    local Text = _Data.Text or ModuleInteractiveSites.Shared.Text.Description.Text;

    local EntityID = GetID(_Data.Name);
    Logic.SetModel(EntityID, Models.Buildings_B_BuildingPlot_10x10);
    Logic.SetVisible(EntityID, true);

    _Data.Title = Title;
    _Data.Text = Text;
    _Data.Costs = Costs;
    _Data.ConditionOrigSite = _Data.Condition;
    _Data.ActionOrigSite = _Data.Action;
    API.SetupObject(_Data);

    IO[_Data.Name].Condition = function(_Data)
        if _Data.ConditionOrigSite then
            _Data.ConditionOrigSite(_Data);
        end
        return self:ConditionIOConstructionSite(_Data);
    end
    IO[_Data.Name].Action = function(_Data, _KnightID, _PlayerID)
        self:CallbackIOConstructionSite(_Data, _KnightID, _PlayerID);
        if _Data.ActionOrigSite then
            _Data.ActionOrigSite(_Data, _KnightID, _PlayerID);
        end
    end
end

function ModuleInteractiveSites.Global:CallbackIOConstructionSite(_Data, _KnightID, _PlayerID)
    local Position = GetPosition(_Data.Name);
    local EntityID = GetID(_Data.Name);
    local Orientation = Logic.GetEntityOrientation(EntityID);
    local SiteID = Logic.CreateConstructionSite(Position.X, Position.Y, Orientation, _Data.Type, _Data.PlayerID);
    Logic.SetVisible(EntityID, false);

    if (SiteID == nil) then
        warn("For object '" .._Data.Name.. "' building placement failed! Building created instead");
        SiteID = Logic.CreateEntity(_Data.Type, Position.X, Position.Y, Orientation, _Data.PlayerID);
    end
    self.CreatedSites[SiteID] = _Data;
end

function ModuleInteractiveSites.Global:ConditionIOConstructionSite(_Data)
    local EntityID = GetID(_Data.Name);
    local TerritoryID = GetTerritoryUnderEntity(EntityID);
    local PlayerID = Logic.GetTerritoryPlayerID(TerritoryID);

    if Logic.GetStoreHouse(_Data.PlayerID) == 0 then
        return false;
    end
    if _Data.PlayerID ~= PlayerID then
        return false;
    end
    return true;
end

-- Local Script ------------------------------------------------------------- --

function ModuleInteractiveSites.Local:OnGameStart()
end

function ModuleInteractiveSites.Local:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleInteractiveSites);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Ermöglicht mit interaktiven Objekten Baustellen zu setzen.
--
-- Die Baustelle muss durch den Helden aktiviert werden. Ein Siedler wird aus
-- dem Lagerhaus kommen und das Gebäude bauen.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- <li><a href="modules.QSB_2_Objects.QSB_2_Objects.html">(2) Interaktive Objekte</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Events, auf die reagiert werden kann.
--
-- @field InteractiveSiteBuilt (Parameter: ScriptName, PlayerID, BuildingID)
--
-- @within Event
--
QSB.ScriptEvents = QSB.ScriptEvents or {};

---
-- Erzeugt eine Baustelle eines beliebigen Gebäudetyps an der Position.
--
-- Diese Baustelle kann durch einen Helden aktiviert werden. Dann wird ein
-- Siedler zur Baustelle eilen und das Gebäude aufbauen. Es ist egal, ob es
-- sich um ein Territorium des Spielers oder einer KI handelt.
--
-- Es ist dabei zu beachten, dass der Spieler, dem die Baustelle zugeordnet
-- wird, das Territorium besitzt, auf dem er bauen soll. Des weiteren muss
-- er über ein Lagerhaus/Hauptzelt verfügen.
--
-- <p><b>Hinweis:</b> Es kann vorkommen, dass das Model der Baustelle nicht
-- geladen wird. Dann ist der Boden der Baustelle schwarz. Sobald wenigstens
-- ein reguläres Gebäude gebaut wurde, sollte die Textur jedoch vorhanden sein.
-- </p>
--
-- Mögliche Angaben für die Konfiguration:
-- <table border="1">
-- <tr><td><b>Feldname</b></td><td><b>Typ</b></td><td><b>Beschreibung</b></td></tr>
-- <tr><td>Name</td><td>string</td><td>Position für die Baustelle</td></tr>
-- <tr><td>PlayerID</td><td>number</td><td>Besitzer des Gebäudes</td></tr>
-- <tr><td>Type</td><td>number</td><td>Typ des Gebäudes</td></tr>
-- <tr><td>Costs</td><td>table</td><td>(optional) Eigene Gebäudekosten</td></tr>
-- <tr><td>Distance</td><td>number</td><td>(optional) Aktivierungsentfernung</td></tr>
-- <tr><td>Icon</td><td>table</td><td>(optional) Icon des Schalters</td></tr>
-- <tr><td>Title</td><td>string</td><td>(optional) Titel der Beschreibung</td></tr>
-- <tr><td>Text</td><td>string</td><td>(optional) Text der Beschreibung</td></tr>
-- <tr><td>Condition</td><td>function</td><td>(optional) Optionale Aktivierungsbedingung</td></tr>
-- <tr><td>Action</td><td>function</td><td>(optional) Optionale Funktion bei Aktivierung</td></tr>
-- </table>
--
-- @param[type=table] _Data Konfiguration des Objektes
-- @within Anwenderfunktionen
--
-- @usage
-- -- Beispiel #1: Eine einfache Baustelle erzeugen
-- API.CreateIOBuildingSite {
--     Name     = "haus",
--     PlayerID = 1,
--     Type     = Entities.B_Bakery
-- };
--
-- @usage
-- -- Beispiel #2: Baustelle mit Kosten erzeugen
-- API.CreateIOBuildingSite {
--     Name     = "haus",
--     PlayerID = 1,
--     Type     = Entities.B_Bakery,
--     Costs    = {Goods.G_Wood, 4},
--     Distance = 1000
-- };
--
function API.CreateIOBuildingSite(_Data)
    if GUI then
        return;
    end
    if not IsExisting(_Data.Name) then
        error("API.CreateIOBuildingSite: Position (" ..tostring(_Data.Name).. ") does not exist!");
        return;
    end
    if type(_Data.PlayerID) ~= "number" or _Data.PlayerID < 1 or _Data.PlayerID > 8 then
        error("API.CreateIOBuildingSite: PlayerID is wrong!");
        return;
    end
    if GetNameOfKeyInTable(Entities, _Data.Type) == nil then
        error("API.CreateIOBuildingSite: Type (" ..tostring(_Data.Type).. ") is wrong!");
        return;
    end
    if _Data.Costs and (type(_Data.Costs) ~= "table" or #_Data.Costs %2 ~= 0) then
        error("API.CreateIOBuildingSite: Costs has the wrong format!");
        return;
    end
    if _Data.Distance and (type(_Data.Distance) ~= "number" or _Data.Distance < 100) then
        error("API.CreateIOBuildingSite: Distance (" ..tostring(_Data.Distance).. ") is wrong or too small!");
        return;
    end
    if _Data.Condition and type(_Data.Condition) ~= "function" then
        error("API.CreateIOBuildingSite: Condition must be a function!");
        return;
    end
    if _Data.Action and type(_Data.Action) ~= "function" then
        error("API.CreateIOBuildingSite: Action must be a function!");
        return;
    end
    ModuleInteractiveSites.Global:CreateIOBuildingSite(_Data);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

ModuleTreasure = {
    Properties = {
        Name = "ModuleTreasure",
        Version = "3.0.0 (BETA 2.0.0)",
    },

    Global = {
        Chests = {},
    };
    Local  = {};

    Shared = {
        Text = {
            Chest = {
                Title = {
                    de = "Schatztruhe",
                    en = "Treasure Chest",
                    fr = "Coffre au trésor",
                },
                Text = {
                    de = "Diese Truhe enthält einen geheimen Schatz. Öffnet sie, um den Schatz zu bergen.",
                    en = "This chest contains a secred treasure. Open it to salvage the treasure.",
                    fr = "Ce coffre contient un trésor secret. Ouvrez-le pour récupérer le trésor.",
                },
            },
            Treasure = {
                Title = {
                    de = "Versteckter Schatz",
                    en = "Hidden treasure",
                    fr = "Trésor caché",
                },
                Text = {
                    de = "Ihr habt einen geheimen Schatz entdeckt. Beeilt Euch und beansprucht ihn für Euch!",
                    en = "You have discovered a secred treasure. Be quick to claim it before it is to late!",
                    fr = "Vous avez découvert un trésor secret. Dépêchez-vous de le revendiquer!",
                },
            }
        }
    };
};

QSB.NonPlayerCharacterObjects = {};

-- Global Script ------------------------------------------------------------ --

function ModuleTreasure.Global:OnGameStart()
end

function ModuleTreasure.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == QSB.ScriptEvents.ObjectReset then
        if IO[arg[1]] and IO[arg[1]].IsInteractiveChest then
            self:ResetIOChest(arg[1]);
        end
    elseif _ID == QSB.ScriptEvents.ObjectDelete then
        if IO[arg[1]] and IO[arg[1]].IsInteractiveChest then
            -- Nothing to do?
        end
    end
end

function ModuleTreasure.Global:CreateRandomChest(_Name, _Good, _Min, _Max, _DirectPay, _NoModelChange, _Condition, _Action)
    _Min = math.floor((_Min ~= nil and _Min > 0 and _Min) or 1);
    _Max = math.floor((_Max ~= nil and _Max > 1 and _Max) or 2);
    assert(_Good ~= nil, "CreateRandomChest: Good does not exist!");
    assert(_Min <= _Max, "CreateRandomChest: min amount must be smaller or equal than max amount!");

    -- Debug Informationen schreiben
    debug(string.format(
        "ModuleTreasure: Creating chest (%s, %s, %d, %d, %s, %s)",
        _Name,
        Logic.GetGoodTypeName(_Good),
        _Min,
        _Max,
        tostring(_DirectPay == true),
        tostring(_NoModelChange == true)
    ))

    -- Texte und Model setzen
    local Title = ModuleTreasure.Shared.Text.Treasure.Title;
    local Text  = ModuleTreasure.Shared.Text.Treasure.Text;
    if not _NoModelChange then
        Title = ModuleTreasure.Shared.Text.Chest.Title;
        Text  = ModuleTreasure.Shared.Text.Chest.Text;

        local eID = ReplaceEntity(_Name, Entities.XD_ScriptEntity, 0);
        Logic.SetModel(eID, Models.Doodads_D_X_ChestClose);
        Logic.SetVisible(eID, true);
    end

    -- Menge an Gütern ermitteln
    local GoodAmount = _Min;
    if _Min < _Max then
        GoodAmount = math.random(_Min, _Max);
    end

    -- Rewards
    local DirectReward;
    local IOReward;
    if not _DirectPay then
        IOReward = {_Good, GoodAmount};
    else
        DirectReward = {_Good, GoodAmount};
    end

    API.SetupObject {
        Name                    = _Name,
        IsInteractiveChest      = true,
        Title                   = Title,
        Text                    = Text,
        Reward                  = IOReward,
        DirectReward            = DirectReward,
        Texture                 = {1, 6},
        Distance                = (_NoModelChange and 1200) or 650,
        Waittime                = 0,
        State                   = 0,
        DoNotChangeModel        = _NoModelChange == true,
        ActivationCondition     = _Condition,
        ActivationAction        = _Action,
        Condition               = function(_Data)
            if _Data.ActivationCondition then
                return _Data.ActivationCondition(_Data);
            end
            return true;
        end,
        Action                  = function(_Data, _KnightID, _PlayerID)
            if not _Data.DoNotChangeModel then
                Logic.SetModel(GetID(_Data.Name), Models.Doodads_D_X_ChestOpenEmpty);
            end
            if _Data.DirectReward then
                AddGood(_Data.DirectReward[1], _Data.DirectReward[2], _PlayerID);
            end
            if _Data.ActivationAction then
                _Data.ActivationAction(_Data, _KnightID, _PlayerID);
            end
        end,
    };
end

function ModuleTreasure.Global:ResetIOChest(_ScriptName)
    if not IO[_ScriptName].DoNotChangeModel then
        local EntityID = ReplaceEntity(_ScriptName, Entities.XD_ScriptEntity, 0);
        Logic.SetModel(EntityID, Models.Doodads_D_X_ChestClose);
        Logic.SetVisible(EntityID, true);
    end
end

function ModuleTreasure.Global:CreateRandomGoldChest(_Name)
    self:CreateRandomChest(_Name, Goods.G_Gold, 300, 600, false);
end

function ModuleTreasure.Global:CreateRandomResourceChest(_Name)
    local PossibleGoods = {
        Goods.G_Iron, Goods.G_Stone, Goods.G_Wood, Goods.G_Wool,
        Goods.G_Carcass, Goods.G_Herb, Goods.G_Honeycomb,
        Goods.G_Milk, Goods.G_RawFish, Goods.G_Grain
    };
    local Good = PossibleGoods[math.random(1, #PossibleGoods)];
    self:CreateRandomChest(_Name, Good, 30, 60, false);
end

function ModuleTreasure.Global:CreateRandomLuxuryChest(_Name)
    local Luxury = {Goods.G_Salt, Goods.G_Dye};
    if g_GameExtraNo >= 1 then
        table.insert(Luxury, Goods.G_Gems);
        table.insert(Luxury, Goods.G_MusicalInstrument);
        table.insert(Luxury, Goods.G_Olibanum);
    end
    local Good = Luxury[math.random(1, #Luxury)];
    self:CreateRandomChest(_Name, Good, 50, 100, false);
end

-- Local Script ------------------------------------------------------------- --

function ModuleTreasure.Local:OnGameStart()
end

function ModuleTreasure.Global:OnEvent(_ID, ...)
    if _ID == QSB.ScriptEvents.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

Swift:RegisterModule(ModuleTreasure);

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

---
-- Es können Schatztruhen und Ruinen mit Inhalten bestückt werden.
-- 
-- Der Schatz einer Kiste oder Ruine wird nach Aktivierung in einem Karren
-- abtransportiert.
--
-- Die erzeugten Truhen und Ruinen verhalten sich wie Interaktive Objekte.
-- Werden ihnen Aktionen und Bedingungen mitgegeben, gelten für diese Funktionen
-- die gleichen Regeln wie bei Interaktiven Objekten.
--
-- <b>Vorausgesetzte Module:</b>
-- <ul>
-- <li><a href="qsb.html">(0) Basismodul</a></li>
-- <li><a href="modules.QSB_1_GuiControl.QSB_1_GuiControl.html">(1) Anzeigekontrolle</a></li>
-- <li><a href="modules.QSB_2_Objects.QSB_2_Objects.html">(2) Interaktive Objekte</a></li>
-- </ul>
--
-- @within Beschreibung
-- @set sort=true
--

---
-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Waren
-- des angegebenen Typs.
--
-- Die Menge der Ware ist dabei zufällig und liegt zwischen dem Minimalwert
-- und dem Maximalwert.
--
-- @param[type=string] _Name      Name der zu ersetzenden Script Entity
-- @param[type=number] _Good      Warentyp
-- @param[type=number] _Min       Mindestmenge
-- @param[type=number] _Max       (Optional) Maximalmenge
-- @param[type=number] _Condition (Optional) Bedingung zur Aktivierung
-- @param[type=number] _Action    (Optional) Aktion nach Aktivierung
-- @within Anwenderfunktionen
--
-- @usage
-- -- Bepspiel #1: Normale Truhe
-- API.CreateRandomChest("well1", Goods.G_Gems, 100, 300);
--
-- @usage
-- -- Bepspiel #2: Truhe mit Aktion
-- -- Wird die Bedingung weggelassen, tritt die Aktion an ihre Stelle
-- API.CreateRandomChest("well1", Goods.G_Gems, 100, 300, MyActionFunction);
--
-- @usage
-- -- Bepspiel #3: Truhe mit Bedingung
-- -- Wenn eine Bedingung gebraucht wird, muss eine Aktion angegeben werden.
-- API.CreateRandomChest("well1", Goods.G_Gems, 100, 300, MyConditionFunction, MyActionFunction);
--
function API.CreateRandomChest(_Name, _Good, _Min, _Max, _Condition, _Action)
    if GUI then
        return;
    end
    if not _Action then
        _Action = _Condition;
        _Condition = nil;
    end

    if not IsExisting(_Name) then
        error("API.CreateRandomChest: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    if GetNameOfKeyInTable(Goods, _Good) == nil then
        error("API.CreateRandomChest: _Good (" ..tostring(_Good).. ") is wrong!");
        return;
    end
    if type(_Min) ~= "number" or _Min < 1 then
        error("API.CreateRandomChest: _Min (" ..tostring(_Min).. ") is wrong!");
        return;
    end

    if type(_Max) ~= "number" then
        _Max = _Min;
    else
        if type(_Max) ~= "number" or _Max < 1 then
            error("API.CreateRandomChest: _Max (" ..tostring(_Max).. ") is wrong!");
            return;
        end
        if _Max < _Min then
            error("API.CreateRandomChest: _Max (" ..tostring(_Max).. ") must be greather then _Min (" ..tostring(_Min).. ")!");
            return;
        end
    end
    ModuleTreasure.Global:CreateRandomChest(_Name, _Good, _Min, _Max, false, false, _Condition, _Action);
end

---
-- Erstellt ein beliebiges IO mit einer zufälligen Menge an Waren
-- des angegebenen Typs.
--
-- Die Menge der Ware ist dabei zufällig und liegt zwischen dem Minimalwert
-- und dem Maximalwert.
--
-- @param[type=string] _Name      Name des Script Entity
-- @param[type=number] _Good      Warentyp
-- @param[type=number] _Min       Mindestmenge
-- @param[type=number] _Max       (Optional) Maximalmenge
-- @param[type=number] _Condition (Optional) Bedingung zur Aktivierung
-- @param[type=number] _Action    (Optional) Aktion nach Aktivierung
-- @within Anwenderfunktionen
--
-- @usage
-- -- Bepspiel #1: Normale Ruine
-- API.CreateRandomTreasure("well1", Goods.G_Gems, 100, 300);
--
-- @usage
-- -- Bepspiel #2: Ruine mit Aktion
-- -- Wird die Bedingung weggelassen, tritt die Aktion an ihre Stelle
-- API.CreateRandomTreasure("well1", Goods.G_Gems, 100, 300, MyActionFunction);
--
-- @usage
-- -- Bepspiel #3: Ruine mit Bedingung
-- -- Wenn eine Bedingung gebraucht wird, muss eine Action angegeben werden.
-- API.CreateRandomTreasure("well1", Goods.G_Gems, 100, 300, MyConditionFunction, MyActionFunction);
--
function API.CreateRandomTreasure(_Name, _Good, _Min, _Max, _Condition, _Action)
    if GUI then
        return;
    end
    if not _Action then
        _Action = _Condition;
        _Condition = nil;
    end

    if not IsExisting(_Name) then
        error("API.CreateRandomTreasure: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    if GetNameOfKeyInTable(Goods, _Good) == nil then
        error("API.CreateRandomTreasure: _Good (" ..tostring(_Good).. ") is wrong!");
        return;
    end
    if type(_Min) ~= "number" or _Min < 1 then
        error("API.CreateRandomTreasure: _Min (" ..tostring(_Min).. ") is wrong!");
        return;
    end

    if type(_Max) ~= "number" then
        _Max = _Min;
    else
        if type(_Max) ~= "number" or _Max < 1 then
            error("API.CreateRandomTreasure: _Max (" ..tostring(_Max).. ") is wrong!");
            return;
        end
        if _Max < _Min then
            error("API.CreateRandomTreasure: _Max (" ..tostring(_Max).. ") must be greather then _Min (" ..tostring(_Min).. ")!");
            return;
        end
    end
    ModuleTreasure.Global:CreateRandomChest(_Name, _Good, _Min, _Max, false, true, _Condition, _Action);
end

---
-- Erstellt eine Schatztruhe mit einer zufälligen Menge Gold.
--
-- @param[type=string] _Name Name der zu ersetzenden Script Entity
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateRandomGoldChest("chest")
--
function API.CreateRandomGoldChest(_Name)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateRandomGoldChest: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    ModuleTreasure.Global:CreateRandomGoldChest(_Name);
end

---
-- Erstellt eine Schatztruhe mit zufälligen Gütern.
--
-- Güter können seien: Eisen, Fisch, Fleisch, Getreide, Holz,
-- Honig, Kräuter, Milch, Stein, Wolle.
--
-- @param[type=string] _Name Name der zu ersetzenden Script Entity
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateRandomResourceChest("chest")
--
function API.CreateRandomResourceChest(_Name)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateRandomResourceChest: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    ModuleTreasure.Global:CreateRandomResourceChest(_Name);
end

---
-- Erstellt eine Schatztruhe mit zufälligen Luxusgütern.
--
-- Luxusgüter können seien: Salz, Farben (, Edelsteine, Musikinstrumente
-- Weihrauch)
--
-- @param[type=string] _Name Name der zu ersetzenden Script Entity
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateRandomLuxuryChest("chest")
--
function API.CreateRandomLuxuryChest(_Name)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateRandomLuxuryChest: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    ModuleTreasure.Global:CreateRandomLuxuryChest(_Name);
end

--[[
Copyright (C) 2023 totalwarANGEL - All Rights Reserved.

This file is part of the QSB-R. QSB-R is created by totalwarANGEL.
You may use and modify this file unter the terms of the MIT licence.
(See https://en.wikipedia.org/wiki/MIT_License)
]]

-- -------------------------------------------------------------------------- --

if not MapEditor and not GUI then
    local MapTypeFolder = "externalmap";
    local MapType, Campaign = Framework.GetCurrentMapTypeAndCampaignName();
    if MapType ~= 3 then
        MapTypeFolder = "development";
    end

    gvMission = gvMission or {};
    gvMission.ContentPath      = "maps/" ..MapTypeFolder.. "/" ..Framework.GetCurrentMapName() .. "/";
    gvMission.MusicRootPath    = gvMission.ContentPath.. "music/";
    gvMission.PlaylistRootPath = "config/sound/";

    Logic.ExecuteInLuaLocalState([[
        gvMission = gvMission or {};
        gvMission.GlobalVariables = Logic.CreateReferenceToTableInGlobaLuaState("gvMission");
        gvMission.ContentPath      = "maps/]] ..MapTypeFolder.. [[/" ..Framework.GetCurrentMapName() .. "/";
        gvMission.MusicRootPath    = gvMission.ContentPath.. "music/";
        gvMission.PlaylistRootPath = "config/sound/";

        Script.Load(gvMission.ContentPath.. "questsystembehavior.lua");
        API.Install();
        if ModuleKnightTitleRequirements then
            InitKnightTitleTables();
        end
        
        -- Call directly for singleplayer
        if not Framework.IsNetworkGame() then
            Swift:CreateRandomSeed();
            if Mission_LocalOnQsbLoaded then
                Mission_LocalOnQsbLoaded();
            end

        -- Send asynchron command to player in multiplayer
        else
            function Swift_Selfload_ReadyTrigger()
                if table.getn(API.GetDelayedPlayers()) == 0 then
                    Swift:CreateRandomSeed();
                    Swift.Event:DispatchScriptCommand(QSB.ScriptCommands.GlobalQsbLoaded, 0);
                    return true;
                end
            end
            StartSimpleHiResJob("Swift_Selfload_ReadyTrigger")
        end        
    ]]);
    API.Install();
    if ModuleKnightTitleRequirements then
        InitKnightTitleTables();
    end
end

