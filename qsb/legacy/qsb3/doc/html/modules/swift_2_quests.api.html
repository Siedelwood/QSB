<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<button onclick="topFunction()" id="back2top" title="Nach oben scrollen">&#11014</button>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>ldoc</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Fields">Fields</a></li>
<li><a href="#Anwenderfunktionen">Anwenderfunktionen</a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/swift_0_core.api.html">swift_0_core.api</a></li>
  <li><a href="../modules/swift_0_core.behavior.html">swift_0_core.behavior</a></li>
  <li><a href="../modules/swift_0_core.debug.html">swift_0_core.debug</a></li>
  <li><a href="../modules/swift_1_displaycore.api.html">swift_1_displaycore.api</a></li>
  <li><a href="../modules/swift_1_entityeventcore.api.html">swift_1_entityeventcore.api</a></li>
  <li><a href="../modules/swift_1_inputoutputcore.api.html">swift_1_inputoutputcore.api</a></li>
  <li><a href="../modules/swift_1_inputoutputcore.behavior.html">swift_1_inputoutputcore.behavior</a></li>
  <li><a href="../modules/swift_1_interfacecore.api.html">swift_1_interfacecore.api</a></li>
  <li><a href="../modules/swift_1_jobscore.api.html">swift_1_jobscore.api</a></li>
  <li><a href="../modules/swift_1_scriptingvaluecore.api.html">swift_1_scriptingvaluecore.api</a></li>
  <li><a href="../modules/swift_1_soundcore.api.html">swift_1_soundcore.api</a></li>
  <li><a href="../modules/swift_1_tradingcore.api.html">swift_1_tradingcore.api</a></li>
  <li><a href="../modules/swift_2_castlestore.api.html">swift_2_castlestore.api</a></li>
  <li><a href="../modules/swift_2_entitymovement.api.html">swift_2_entitymovement.api</a></li>
  <li><a href="../modules/swift_2_knighttitlerequirements.api.html">swift_2_knighttitlerequirements.api</a></li>
  <li><a href="../modules/swift_2_knighttitlerequirements.requirements.html">swift_2_knighttitlerequirements.requirements</a></li>
  <li><a href="../modules/swift_2_npcinteraction.api.html">swift_2_npcinteraction.api</a></li>
  <li><a href="../modules/swift_2_npcinteraction.behavior.html">swift_2_npcinteraction.behavior</a></li>
  <li><a href="../modules/swift_2_objectinteraction.api.html">swift_2_objectinteraction.api</a></li>
  <li><a href="../modules/swift_2_objectinteraction.behavior.html">swift_2_objectinteraction.behavior</a></li>
  <li><strong>swift_2_quests.api</strong></li>
  <li><a href="../modules/swift_2_typewriter.api.html">swift_2_typewriter.api</a></li>
  <li><a href="../modules/swift_3_behaviorcollection.behavior.html">swift_3_behaviorcollection.behavior</a></li>
  <li><a href="../modules/swift_3_briefingsystem.api.html">swift_3_briefingsystem.api</a></li>
  <li><a href="../modules/swift_3_briefingsystem.behavior.html">swift_3_briefingsystem.behavior</a></li>
  <li><a href="../modules/swift_3_cutscenesystem.api.html">swift_3_cutscenesystem.api</a></li>
  <li><a href="../modules/swift_3_cutscenesystem.behavior.html">swift_3_cutscenesystem.behavior</a></li>
  <li><a href="../modules/swift_3_dialogsystem.api.html">swift_3_dialogsystem.api</a></li>
  <li><a href="../modules/swift_3_dialogsystem.behavior.html">swift_3_dialogsystem.behavior</a></li>
  <li><a href="../modules/swift_3_weathermanipulation.api.html">swift_3_weathermanipulation.api</a></li>
  <li><a href="../modules/swift_4_constructionandknockdown.api.html">swift_4_constructionandknockdown.api</a></li>
  <li><a href="../modules/swift_4_lifestockbreeding.api.html">swift_4_lifestockbreeding.api</a></li>
  <li><a href="../modules/swift_4_questjournal.api.html">swift_4_questjournal.api</a></li>
  <li><a href="../modules/swift_4_questjournal.behavior.html">swift_4_questjournal.behavior</a></li>
  <li><a href="../modules/swift_4_selection.api.html">swift_4_selection.api</a></li>
  <li><a href="../modules/swift_4_shipsalesman.api.html">swift_4_shipsalesman.api</a></li>
  <li><a href="../modules/swift_5_extendedcamera.api.html">swift_5_extendedcamera.api</a></li>
  <li><a href="../modules/swift_5_graphvizexport.api.html">swift_5_graphvizexport.api</a></li>
  <li><a href="../modules/swift_5_interactivechests.api.html">swift_5_interactivechests.api</a></li>
  <li><a href="../modules/swift_5_interactivemines.api.html">swift_5_interactivemines.api</a></li>
  <li><a href="../modules/swift_5_interactivesites.api.html">swift_5_interactivesites.api</a></li>
  <li><a href="../modules/swift_5_minimap.api.html">swift_5_minimap.api</a></li>
  <li><a href="../modules/swift_5_minimap.behavior.html">swift_5_minimap.behavior</a></li>
  <li><a href="../modules/swift_5_speedlimitation.api.html">swift_5_speedlimitation.api</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>swift_2_quests.api</code></h1>
<p>Dieses Modul ermöglicht es einen Quest, bzw.</p>
<p> Auftrag, per Skript zu
 erstellen.
<p> Normaler Weise werden Aufträge im Questassistenten erzeugt. Dies ist aber
 statisch und das Kopieren von Aufträgen ist nicht möglich. Wenn Aufträge
 im Skript erzeugt werden, verschwinden alle diese Nachteile. Aufträge
 können im Skript kopiert und angepasst werden. Es ist ebenfalls machbar,
 die Aufträge in Sequenzen zu erzeugen.
<p> <b>Befehle:</b><br>
 <i>Diese Befehle können über die Konsole (SHIFT + ^) eingegeben werden, wenn
 der Debug Mode aktiviert ist.</i><br>
 <table border="1">
 <tr>
 <td><b>Befehl</b></td>
 <td><b>Parameter</b></td>
 <td><b>Beschreibung</b></td>
 </tr>
 <tr>
 <td>stop</td>
 <td>QuestName</td>
 <td>Unterbricht den angegebenen Quest.</td>
 </tr>
 <tr>
 <td>start</td>
 <td>QuestName</td>
 <td>Startet den angegebenen Quest.</td>
 </tr>
 <tr>
 <td>win</td>
 <td>QuestName</td>
 <td>Schließt den angegebenen Quest erfolgreich ab.</td>
 </tr>
 <tr>
 <td>fail</td>
 <td>QuestName</td>
 <td>Lässt den angegebenen Quest fehlschlagen</td>
 </tr>
 <tr>
 <td>restart</td>
 <td>QuestName</td>
 <td>Startet den angegebenen Quest neu.</td>
 </tr>
 </table>
<p> <h4>Bekannte Probleme</h4>
 Jede Voice Message - <b>Quests sind ebenfalls Voice Messages</b> - hat die
 Chance, dass die Message Queue des Spiels hängen bleibt und dann ein leeres
 Fenster mit dem Titel "Rhian over the Sea Chapell" angezeigt wird, welches
 das Portrait Window dauerhaft blockiert und verhindert, dass weitere Voice
 Messages - <b>auch Quests</b> - angezeigt werden können.
<p> Es wird dringend geraten, Quests <b>ausschließlich</b> zur Darstellung von
 Aufgaben für den Spieler und für <b>nichts anderes</b> zu benutzen.
<p> <b>Vorausgesetzte Module:</b>
 <ul>
 <li><a href="Swift_1_DisplayCore.api.html">(1) Display Core</a></li>
 <li><a href="Swift_1_InputOutputCore.api.html">(1) Input/Output Core</a></li>
 </ul>
</p>


<h2><a href="#Fields">Fields</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#QSB.SegmentResult">QSB.SegmentResult</a></td>
	<td class="summary">Die Abschlussarten eines Quest Segment.</td>
	</tr>
</table>
<h2><a href="#Anwenderfunktionen">Anwenderfunktionen</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#API.CreateNestedQuest">API.CreateNestedQuest (_Data)</a></td>
	<td class="summary">Erstellt einen verschachtelten Auftrag.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#API.CreateQuest">API.CreateQuest (_Data)</a></td>
	<td class="summary">Erstellt einen Quest.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#API.CreateQuestMessage">API.CreateQuestMessage (_Text, _Sender, _Receiver, _AncestorWt, _Callback, _Ancestor)</a></td>
	<td class="summary">Erzeugt eine Nachricht im Questfenster.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Fields"></a>Fields</h2>

    <dl class="function">
    <dt>
    <a name = "QSB.SegmentResult"></a>
    <strong>QSB.SegmentResult</strong>
    </dt>
    <dd>
    Die Abschlussarten eines Quest Segment.


    <ul>
        <li><span class="parameter">Success</span>
         Phase muss erfolgreich abgeschlossen werden.
        </li>
        <li><span class="parameter">Failure</span>
         Phase muss fehlschlagen.
        </li>
        <li><span class="parameter">Ignore</span>
          Erfolg und Misserfolg werden geleichermaßen akzeptiert.
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header "><a name="Anwenderfunktionen"></a>Anwenderfunktionen</h2>

    <dl class="function">
    <dt>
    <a name = "API.CreateNestedQuest"></a>
    <strong>API.CreateNestedQuest (_Data)</strong>
    </dt>
    <dd>
    Erstellt einen verschachtelten Auftrag.
<p> Verschachtelte Aufträge (Nested Quests) vereinfachen aufschreiben und
 zuordnen der zugeordneten Aufträge. Ein Nested Quest ist selbst unsichtbar
 und hat mindestens ein ihm untergeordnetes Segment. Die Segmente eines
 Nested Quest sind wiederum eigenständige Quests.
<p> Du kannst für Segmente die gleichen Einträge setzen, wie bei gewöhnlichen
 Quests. Zudem kannst du auch ihnen einen Namen geben. Wenn du das nicht tust,
 werden sie automatisch benannt. Der Name setzt sich zusammen aus dem Namen
 des Nested Quest und ihrem Index (z.B. "UnimaginativeQuestname@Segment1").
<p> Segmente haben ein erwartetes Ergebnis. Für gewöhnlich ist dies auf Erfolg
 festgelegt. Du kanns es aber auch auf Fehlschlag ändern oder ganz ignorieren.
 Ein Nested Quest ist abgeschlossen, wenn alle Segmente mit ihrem erwarteten
 Ergebnis abgeschlossen wurden (Erfolg) oder mindestens einer ein anderes
 Ergebnis als erwartet hatte (Fehlschlag).
<p> Werden Status oder Resultat eines Quest über Funktionen verändert (zb.
 API.StopQuest bzw "stop" Konsolenbefehl), dann werden automatisch die
 Segmente ausgelöst oder abgebrochen.
<p> Es ist nicht zwingend notwendig, einen Trigger für die Segmente zu setzen.
 Alle Segmente starten automatisch sobald der Nested Quest startet. Du kannst
 weitere Trigger zu Segmenten hinzufügen, um dieses Verhalten nach deinen
 Bedürfnissen abzuändern (z.B. auf ein vorangegangenes Segment triggern).
<p> Nested Quests können auch ineinander verschachtelt werden. Man kann also
 innerhalb eines Hauptauftrag eine untergeordneten Hauptauftrag anlegen.



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">_Data</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         Daten des Quest
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        Name des Nested Quest oder nil bei Fehler
    </ol>


    <h3>Verwandte Themen:</h3>
    <ul>
         <li><a href="../modules/swift_2_quests.api.html#QSB.SegmentResult">QSB.SegmentResult</a></li>
         <li><a href="../modules/swift_2_quests.api.html#API.CreateQuest">API.CreateQuest</a></li>
    </ul>

    <h3>Beispiel:</h3>
    <ul>
        <pre class="example">API.CreateNestedQuest {
    Name        = <span class="string">"UnimaginativeQuestname"</span>,
    Segments    = {
        {
            Suggestion  = <span class="string">"Wir benötigen einen höheren Titel!"</span>,

            Goal_KnightTitle(<span class="string">"Mayor"</span>),
        },
        {
            <span class="comment">-- Mit dem Typ Ignore wird Fehlschlag ignoriert.
</span>            Result      = QSB.SegmentResult.Ignore,

            Suggestion  = <span class="string">"Wir benötigen außerdem mehr Asche! Und das sofort..."</span>,
            Success     = <span class="string">"Geschafft!"</span>,
            Failure     = <span class="string">"Versagt!"</span>,
            Time        = <span class="number">3</span> * <span class="number">60</span>,

            Goal_Produce(<span class="string">"G_Gold"</span>, <span class="number">5000</span>),

            Trigger_OnQuestSuccess(<span class="string">"UnimaginativeQuestname@Segment1"</span>, <span class="number">1</span>),
            <span class="comment">-- Segmented Quest wird gewonnen.
</span>            Reward_QuestSuccess(<span class="string">"UnimaginativeQuestname"</span>),
        },
        {
            Suggestion  = <span class="string">"Dann versuchen wir es mit Eisen..."</span>,
            Success     = <span class="string">"Geschafft!"</span>,
            Failure     = <span class="string">"Versagt!"</span>,
            Time        = <span class="number">3</span> * <span class="number">60</span>,

            Trigger_OnQuestFailure(<span class="string">"UnimaginativeQuestname@Segment2"</span>),
            Goal_Produce(<span class="string">"G_Iron"</span>, <span class="number">50</span>),
        }
    },

    <span class="comment">-- Wenn ein Quest nicht das erwartete Ergebnis hat, Fehlschlag.
</span>    Reprisal_Defeat(),
    <span class="comment">-- Wenn alles erfüllt wird, ist das Spiel gewonnen.
</span>    Reward_VictoryWithParty(),
};</pre>
    </ul>

</dd>
    <dt>
    <a name = "API.CreateQuest"></a>
    <strong>API.CreateQuest (_Data)</strong>
    </dt>
    <dd>
    Erstellt einen Quest.
<p> Ein Auftrag braucht immer wenigstens ein Goal und einen Trigger um ihn
 erstellen zu können. Hat ein Quest keinen Namen, erhält er automatisch
 einen mit fortlaufender Nummerierung.
<p> Ein Quest besteht aus verschiedenen Eigenschaften und Behavior, die nicht
 alle zwingend gesetzt werden müssen. Behavior werden einfach nach den
 Eigenschaften nacheinander angegeben.
 <p><u>Eigenschaften:</u></p>
 <ul>
 <li>Name: Der eindeutige Name des Quests</li>
 <li>Sender: PlayerID des Auftraggeber (Default 1)</li>
 <li>Receiver: PlayerID des Auftragnehmer (Default 1)</li>
 <li>Suggestion: Vorschlagnachricht des Quests</li>
 <li>Success: Erfolgsnachricht des Quest</li>
 <li>Failure: Fehlschlagnachricht des Quest</li>
 <li>Description: Aufgabenbeschreibung (Nur bei Custom)</li>
 <li>Time: Zeit bis zu, Fehlschlag/Abschluss</li>
 <li>Loop: Funktion, die während der Laufzeit des Quests aufgerufen wird</li>
 <li>Callback: Funktion, die nach Abschluss aufgerufen wird</li>
 </ul>



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">_Data</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         Questdefinition
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        Name des Quests</li>
        <li>
           <span class="types"><span class="type">number</span></span>
        Gesamtzahl Quests</li>
    </ol>


    <h3>Verwandte Themen:</h3>
    <ul>
         <a href="../modules/swift_2_quests.api.html#API.CreateNestedQuest">API.CreateNestedQuest</a>
    </ul>

    <h3>Beispiel:</h3>
    <ul>
        <pre class="example">API.CreateQuest {
    Name        = <span class="string">"UnimaginativeQuestname"</span>,
    Suggestion  = <span class="string">"Wir müssen das Kloster finden."</span>,
    Success     = <span class="string">"Dies sind die berümten Heilermönche."</span>,

    Goal_DiscoverPlayer(<span class="number">4</span>),
    Reward_Diplomacy(<span class="number">1</span>, <span class="number">4</span>, <span class="string">"EstablishedContact"</span>),
    Trigger_Time(<span class="number">0</span>),
}</pre>
    </ul>

</dd>
    <dt>
    <a name = "API.CreateQuestMessage"></a>
    <strong>API.CreateQuestMessage (_Text, _Sender, _Receiver, _AncestorWt, _Callback, _Ancestor)</strong>
    </dt>
    <dd>
    Erzeugt eine Nachricht im Questfenster.
<p> Der Quest wird immer nach Ablauf der Wartezeit nach
 Abschluss des Ancestor Quest gestartet bzw. unmittelbar, wenn es keinen
 Ancestor Quest gibt. Das Callback ist eine Funktion, die zur Anzeigezeit
 des Quests ausgeführt wird.
<p> Alle Paramater sind optional und können von rechts nach links weggelassen
 oder mit nil aufgefüllt werden.



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">_Text</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
                Anzeigetext der Nachricht
        </li>
        <li><span class="parameter">_Sender</span>
            <span class="types"><span class="type">number</span></span>
              Sender der Nachricht
        </li>
        <li><span class="parameter">_Receiver</span>
            <span class="types"><span class="type">number</span></span>
            Receiver der Nachricht
        </li>
        <li><span class="parameter">_AncestorWt</span>
            <span class="types"><span class="type">number</span></span>
          Wartezeit
        </li>
        <li><span class="parameter">_Callback</span>
            <span class="types"><span class="type">function</span></span>
            Callback
        </li>
        <li><span class="parameter">_Ancestor</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
            Vorgänger-Quest
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        QuestName
    </ol>



    <h3>Beispiel:</h3>
    <ul>
        <pre class="example">API.CreateQuestMessage(<span class="string">"Das ist ein Text"</span>, <span class="number">4</span>, <span class="number">1</span>);</pre>
    </ul>

</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2022-12-02 22:01:47 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->

<script>
    window.onscroll = function() {scrollFunction()};

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            document.getElementById("back2top").style.display = "block";
        } else {
            document.getElementById("back2top").style.display = "none";
        }
    }

    function topFunction() {
        document.body.scrollTop = 0; // For Safari
        document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    }
</script>

</body>
</html>
